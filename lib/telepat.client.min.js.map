{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///telepat.client.min.js","webpack:///webpack/bootstrap 64ca6c30c6b0c6b4d262","webpack:///./src/telepat.js","webpack:///./~/process/browser.js","webpack:///./~/fs/index.js","webpack:///./~/pouchdb/lib/index-browser.js","webpack:///./~/uuid/index.js","webpack:///./~/uuid/v1.js","webpack:///./~/uuid/lib/rng-browser.js","webpack:///./~/uuid/lib/bytesToUuid.js","webpack:///./~/uuid/v4.js","webpack:///./~/lie/lib/browser.js","webpack:///./~/immediate/lib/browser.js","webpack:///./~/argsarray/index.js","webpack:///./~/events/events.js","webpack:///./~/inherits/inherits_browser.js","webpack:///./~/debug/src/browser.js","webpack:///./~/debug/src/debug.js","webpack:///./~/ms/index.js","webpack:///./~/spark-md5/spark-md5.js","webpack:///./~/vuvuzela/index.js","webpack:///./src/api.js","webpack:///./~/superagent/lib/client.js","webpack:///./~/component-emitter/index.js","webpack:///./~/superagent/lib/request-base.js","webpack:///./~/superagent/lib/is-object.js","webpack:///./~/superagent/lib/request.js","webpack:///./~/crypto-js/sha256.js","webpack:///./~/crypto-js/core.js","webpack:///./src/logger.js","webpack:///./~/loglevel/lib/loglevel.js","webpack:///./src/error.js","webpack:///./src/event.js","webpack:///./src/monitor.js","webpack:///./~/buffer/index.js","webpack:///./~/base64-js/index.js","webpack:///./~/ieee754/index.js","webpack:///./~/isarray/index.js","webpack:///./~/jsondiffpatch/src/main.js","webpack:///./~/jsondiffpatch/src/environment.js","webpack:///./~/jsondiffpatch/src/diffpatcher.js","webpack:///./~/jsondiffpatch/src/processor.js","webpack:///./~/jsondiffpatch/src/pipe.js","webpack:///./~/jsondiffpatch/src/contexts/diff.js","webpack:///./~/jsondiffpatch/src/contexts/context.js","webpack:///./~/jsondiffpatch/src/clone.js","webpack:///./~/jsondiffpatch/src/contexts/patch.js","webpack:///./~/jsondiffpatch/src/contexts/reverse.js","webpack:///./~/jsondiffpatch/src/filters/trivial.js","webpack:///./~/jsondiffpatch/src/filters/nested.js","webpack:///./~/jsondiffpatch/src/filters/arrays.js","webpack:///./~/jsondiffpatch/src/filters/lcs.js","webpack:///./~/jsondiffpatch/src/filters/dates.js","webpack:///./~/jsondiffpatch/src/filters/texts.js","webpack:///./~/jsondiffpatch ^\\.\\/.*$","webpack:///./~/jsondiffpatch/package.json","webpack:///./~/jsondiffpatch/src/formatters/console.js","webpack:///./~/chalk/index.js","webpack:///./~/escape-string-regexp/index.js","webpack:///./~/ansi-styles/index.js","webpack:///./~/strip-ansi/index.js","webpack:///./~/ansi-regex/index.js","webpack:///./~/has-ansi/index.js","webpack:///./~/supports-color/index.js","webpack:///./~/jsondiffpatch/src/formatters/base.js","webpack:///./~/jsondiffpatch/src/formatters/index.js","webpack:///./~/jsondiffpatch/src/formatters/html.js","webpack:///./~/jsondiffpatch/src/formatters/annotated.js","webpack:///./~/jsondiffpatch/src/formatters/jsonpatch.js","webpack:///./~/jsondiffpatch/src/date-reviver.js","webpack:///./src/channel.js","webpack:///./src/user.js","webpack:///./src/admin.js","webpack:///./~/socket.io-client/lib/index.js","webpack:///./~/socket.io-client/lib/url.js","webpack:///./~/parseuri/index.js","webpack:///./~/socket.io-client/~/debug/browser.js","webpack:///./~/socket.io-client/~/debug/debug.js","webpack:///./~/socket.io-client/~/ms/index.js","webpack:///./~/socket.io-parser/index.js","webpack:///./~/socket.io-parser/~/debug/browser.js","webpack:///./~/socket.io-parser/~/debug/debug.js","webpack:///./~/socket.io-parser/~/ms/index.js","webpack:///./~/json3/lib/json3.js","webpack:///(webpack)/buildin/module.js","webpack:///(webpack)/buildin/amd-options.js","webpack:///./~/socket.io-parser/~/component-emitter/index.js","webpack:///./~/socket.io-parser/binary.js","webpack:///./~/socket.io-parser/~/isarray/index.js","webpack:///./~/socket.io-parser/is-buffer.js","webpack:///./~/socket.io-client/lib/manager.js","webpack:///./~/engine.io-client/index.js","webpack:///./~/engine.io-client/lib/index.js","webpack:///./~/engine.io-client/lib/socket.js","webpack:///./~/engine.io-client/lib/transports/index.js","webpack:///./~/engine.io-client/lib/xmlhttprequest.js","webpack:///./~/has-cors/index.js","webpack:///./~/engine.io-client/lib/transports/polling-xhr.js","webpack:///./~/engine.io-client/lib/transports/polling.js","webpack:///./~/engine.io-client/lib/transport.js","webpack:///./~/engine.io-parser/lib/browser.js","webpack:///./~/engine.io-parser/lib/keys.js","webpack:///./~/has-binary/index.js","webpack:///./~/has-binary/~/isarray/index.js","webpack:///./~/arraybuffer.slice/index.js","webpack:///./~/after/index.js","webpack:///./~/wtf-8/wtf-8.js","webpack:///./~/base64-arraybuffer/lib/base64-arraybuffer.js","webpack:///./~/blob/index.js","webpack:///./~/parseqs/index.js","webpack:///./~/component-inherit/index.js","webpack:///./~/yeast/index.js","webpack:///./~/engine.io-client/~/debug/browser.js","webpack:///./~/engine.io-client/~/debug/debug.js","webpack:///./~/engine.io-client/~/ms/index.js","webpack:///./~/engine.io-client/lib/transports/polling-jsonp.js","webpack:///./~/engine.io-client/lib/transports/websocket.js","webpack:///./~/indexof/index.js","webpack:///./~/parsejson/index.js","webpack:///./~/socket.io-client/lib/socket.js","webpack:///./~/to-array/index.js","webpack:///./~/socket.io-client/lib/on.js","webpack:///./~/component-bind/index.js","webpack:///./~/backo2/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","process","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_fs","_fs2","_pouchdb","_pouchdb2","_api","_api2","_logger","_logger2","_error","_error2","_event","_event2","_monitor","_monitor2","_channel","_channel2","_user","_user2","UDID_DB_KEY","Telepat","getUserHome","env","platform","getTelepatDir","dir","existsSync","mkdirSync","options","arguments","undefined","name","_db","window","console","log","_socketEndpoint","_socket","_persistentConnectionOptions","connected","connecting","configured","currentAppId","collections","subscriptions","admin","user","collectionEvent","connect","callback","on","_this","get","err","res","resultingError","remove","channel","model","index","body","content","add","_addCollection","bind","_deleteCollection","_updateCollection","operation","parentId","parentObject","delta","emit","collection","addCollection","warn","patches","updateCollection","deleteCollection","_this2","reauth","newAdmin","then","doc","appId","Error","udid","_this3","put","info","newObject","_id","UDID","_this4","watchdog","setTimeout","device_id","application_id","removeAllListeners","clearTimeout","subscribe","_this5","apiEndpoint","socketEndpoint","_updateUser","_this6","finalizeRequest","identifier","_saveUDID","request","os","userAgent","navigator","volatile","type","active","persistent","res2","_this7","ioOptions","disconnectVolatileTransport","_rebindVolatileTransport","message","processMessage","getCollections","close","_this8","apiKey","timerInterval","signalConnectFailed","signalConnectSucceded","populateData","postRegister","connectVolatileTransport","disconnect","apps","app","persistentConnection","updateUDID","registerDevice","_getSavedUDID","_this9","unsubscribe","isAdmin","logout","unhook","level","setLevel","removeCallback","onSubscribe","_this10","subscriptionKeyForOptions","from","fromName","to","subject","recipients","from_name","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","e","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","timeout","len","run","Item","array","noop","nextTick","args","Array","push","apply","title","browser","argv","version","versions","addListener","once","off","removeListener","prependListener","prependOnceListener","listeners","binding","cwd","chdir","umask","global","_interopDefault","ex","isBinaryObject","object","ArrayBuffer","Blob","cloneArrayBuffer","buff","slice","byteLength","targetArray","Uint8Array","sourceArray","set","cloneBinaryObject","size","webkitSlice","isPlainObject","proto","getPrototypeOf","Ctor","constructor","funcToString","objectCtorString","clone","isArray","Date","toISOString","hasOwnProperty","called","getArguments","toPromise","func","self","usedCB","pop","promise","PouchPromise$1","fulfill","reject","resp","mesg","result","logApiCall","logArgs","origCallback","responseArgs","adapterFun","_closed","_destroyed","taskqueue","isReady","addTask","failed","mangle","unmangle","substring","Map$1","_store","Set$1","supportsMapAndSet","Symbol","Map","Set","prop","getOwnPropertyDescriptor","species","pick","arr","identityFunction","x","formatResultForOpenRevsGet","ok","bulkGet","db","opts","collapseResultsAndFinish","results","perDocResults","forEach","docs","checkDone","numDone","numDocs","gotResult","docIndex","nextBatch","allRequests","upTo","Math","min","MAX_NUM_CONCURRENT_REQUESTS","batch","processBatch","offset","docId","j","docIdx","docRequests","requestsById","docOpts","open_revs","map","rev","filter","formatResult","param","error","requests","ExportedMap","has","isChromeApp","chrome","storage","local","hasLocalStorage","hasLocal","attachBrowserEvents","onChanged","db_name","dbName","newValue","addEventListener","attachEvent","Changes","events","EventEmitter","_listeners","guardedConsole","method","randomNumber","max","maxTimeout","parseInt","ratio","random","range","defaultBackOff","explainError","status","str","PouchError","reason","createError","CustomPouchError","generateErrorFromResponse","data","UNKNOWN_ERROR","tryFilter","req","msg","toString","BAD_REQUEST","filterChange","hasFilter","query","query_params","change","filterReturn","include_docs","attachments","att","_attachments","stub","flatten","arrs","f","invalidIdError","INVALID_ID","test","RESERVED_ID","MISSING_ID","isRemote","_remote","listenerCount","ee","parseDesignDocFunctionName","s","parts","split","normalizeDesignDocFunctionName","normalized","join","parseUri","parser","exec","uri","keys","encoded","indexOf","decodeURIComponent","qName","replace","qParser","$0","$1","$2","scopeEval","source","scope","values","Function","upsert","diffFun","docRev","_rev","newDoc","tryAndPut","updated","uuidV4","v4","toLowerCase","winningRev","metadata","winningId","winningPos","winningDeleted","node","toVisit","rev_tree","tree","ids","branches","pos","deleted","traverseRevTree","revs","newCtx","ctx","sortByPos","a","b","collectLeaves","leaves","isLeaf","acc","sort","reverse","collectConflicts","win","conflicts","leaf","compactTree","revHash","rootToLeaf","paths","history","sortByPos$1","binarySearch","item","comparator","mid","low","high","insertSorted","idx","splice","pathToTree","path","numStemmed","currentLeaf","compareTree","mergeTree","in_tree1","in_tree2","tree1","tree2","merged","doMerge","dontExpand","restree","branch","t1","t2","diff","candidateParents","trees","parent","parentIdx","elements","elementsLen","el","stem","depth","stemmedRevs","stemmed","merge","newTree","revExists","splitRev","targetPos","targetId","getTrees","isDeleted","isLocalId","latest","historyNode","historyRev","l","tryCatchInChangeListener","Changes$2","onDestroy","cancel","complete","onChange","isCancelled","validateChanges","processChange","changeList","style","changes","_conflicts","compare","left","right","yankError","cleanDocs","_deleted","atts","compareByIdThenRev","idCompare","aStart","_revisions","start","bStart","computeHeight","height","edges","prnt","rev$$1","edge","allDocsKeysQuery","api","skip","limit","descending","_allDocs","finalResults","all","subOpts","$inject_Object_assign","optKey","resolve","total_rows","rows","doNextCompaction","task","_compactionQueue","last_seq","_compact","shift","attachmentNameError","charAt","AbstractPouchDB","TaskQueue$1","parseAdapter","match","adapter","adapters","PouchDB$5","preferredAdapters","prefix","adapterName","localStorage","usePrefix","use_prefix","prepareForDestruction","onDestroyed","from_constructor","onClosed","__opts","auto_compaction","prefixedName","backend","_adapter","valid","fail","ready","setUpEventEmitter","Pouch","eventEmitter","destructListeners","_destructionListeners","dbList","debugPouch","PouchDB","debug","logs","logId","getFieldFromDoc","parsedField","compare$1","parseField","fieldName","fields","current","ch","isCombinationalField","field","combinationFields","getKey","getValue","mergeAndedSelectors","selectors","selector","matcher","$eq","fieldMatchers","operator","mergeGtGte","mergeLtLte","mergeNe","mergeEq","$gte","$gt","$lte","$lt","$ne","massageSelector","input","wasAnded","orOrNor","subSelector","pad","padWith","upToLength","padding","targetLength","padLeft","collate","normalizeKey","ai","collationIndex","bi","stringCollate","arrayCollate","objectCollate","Infinity","isNaN","origKey","toJSON","k","val","indexify","numToIndexableString","toIndexableString","objKey","zero","SEP","parseNumber","num","originalIdx","neg","numAsString","magAsString","MAGNITUDE_DIGITS","magnitude","MIN_MAGNITUDE","parseFloat","stack","metaStack","lastMetaElement","element","lastElementIndex","parseIndexableString","parsedNum","parsedStr","arrayElement","objElement","ak","bk","expFormat","toExponential","magForComparison","magString","factor","abs","factorStr","toFixed","createFieldSorter","getFieldValuesAsArray","sorting","docFieldValue","aRow","bRow","aFieldValues","bFieldValues","collation","filterInMemoryFields","requestDef","inMemoryFields","row","rowFilter","fieldSorter","every","matchCominationalSelector","matchSelector","userOperator","userValue","some","orMatchers","find","matchers","fieldExists","fieldIsNotUndefined","modField","divisor","mod","arrayContainsValue","arrayContainsAllValues","arraySize","regexMatch","re","RegExp","typeMatch","matchesSelector","rowsMatched","evalFilter","evalView","code","validate","filterName","normalize","view","shouldFilter","changesHandler","doc_ids","viewName","ddoc","mapFun","views","doChanges","MISSING_DOC","filterFun","filters","applyChangesFilterPlugin","_changesFilterPlugin","toObject","reduce","parseRevisionInfo","INVALID_REV","makeRevTreeFromRevisions","revisions","revisionIds","parseDoc","newEdits","nRevNum","newRevId","revInfo","uuid","_rev_tree","specialKey","reservedWords","DOC_VALIDATION","dataWords","createBlob","properties","Builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","builder","append","getBlob","binaryStringToArrayBuffer","bin","buf","charCodeAt","binStringToBluffer","binString","b64ToBluffer","b64","thisAtob","arrayBufferToBinaryString","buffer","binary","bytes","String","fromCharCode","readAsBinaryString","blob","FileReader","FileReaderSync","readAsArrayBuffer","reader","hasBinaryString","onloadend","blobToBinaryString","blobOrBuffer","blobToBase64","base64","thisBtoa","rawToBase64","raw","sliceBlob","end","appendBlob","arrayBuffer","appendString","string","appendBinary","binaryMd5","next","setImmediateShim","loadNextChunk","done","destroy","currentChunk","chunkSize","chunks","inputIsString","MD5_CHUNK_SIZE","ceil","Md5","stringMd5","hash","parseBase64","BAD_ARG","preprocessString","blobType","asBinary","content_type","digest","preprocessBlob","md5","preprocessAttachment","preprocessAttachments","docInfos","docv","overallErr","docInfo","processedAttachment","recv","updateDoc","revLimit","prev","cb","writeDoc","previousWinningRev","previouslyDeleted","isRoot","inConflict","REV_CONFLICT","newRev","rev_map","newRevIsDeleted","winningRev$$1","winningRevIsDeleted","rootIsMissing","processDocs","fetchedDocs","tx","overallCallback","insertDoc","resultsIdx","checkAllDocsDone","docsDone","docsToDo","new_edits","idsToDocs","currentDoc","docWritten","nextDoc","safeJsonParse","JSON","parse","vuvuzela","safeJsonStringify","json","stringify","idbError","evt","IDB_ERROR","encodeMetadata","deletedOrLocal","seq","decodeMetadata","storedObject","decodeDoc","_doc_id_rev","lastIndexOf","readBlobData","asBlob","fetchAttachmentsIfNecessary","txn","fetchAttachment","attObj","objectStore","ATTACH_STORE","onsuccess","postProcessAttachments","attNames","compactRevs","count","deleteOrphanedAttachments","possiblyOrphanedDigests","countReq","attAndSeqStore","IDBKeyRange","bound","attStore","seqStore","BY_SEQ_STORE","ATTACH_AND_SEQ_STORE","cursor","openCursor","only","event","digestSeq","primaryKey","openTransactionSafely","idb","stores","mode","transaction","idbBulkDocs","dbOpts","startTransaction","DOC_STORE","LOCAL_STORE","META_STORE","txnResult","onabort","ontimeout","oncomplete","docStore","bySeqStore","attachStore","attachAndSeqStore","metaStore","metaDoc","updateDocCountIfReady","verifyAttachments","preconditionErrored","fetchExistingDocs","onAllDocsProcessed","allDocsProcessed","idbProcessDocs","revs_limit","docCount","docCountDelta","numFetched","readMetadata","notify","_meta","verifyAttachment","MISSING_STUB","finish","digests","filename","attErr","isUpdate","hasAttachments","writeAttachments","finishDoc","afterPutDoc","revsToDelete","metadataToStore","metaDataReq","afterPutMetadata","afterPutDocError","preventDefault","stopPropagation","getKeyReq","putReq","insertAttachmentMappings","onerror","collectResults","attachmentSaved","revpos","saveAttachment","attsAdded","attsToAdd","newAtt","docInfoError","blobSupport","runBatchedCursor","keyRange","batchSize","onBatch","onGetAll","valuesBatch","keysBatch","pseudoCursor","onGetAllKeys","continuePseudoCursor","newKeyRange","lastKey","upper","upperOpen","lowerBound","getAll","getAllKeys","onCursor","useGetAll","continue","onSuccess","createKeyRange","inclusiveEnd","upperBound","idbAllDocs","fetchDocAsynchronously","docIdRevIndex","allDocsInner","batchValues","batchValue","batchKeys","onResultsReady","onTxnComplete","startkey","endkey","inclusive_end","keyRangeError","checkBlobSupport","DETECT_BLOB_SUPPORT_STORE","matchedChrome","matchedEdge","countDocs","tryCode","applyNext","running","enqueueTask","action","processMetadataAndWinningDoc","winningDoc","lastSeq","filtered","numResults","returnDocs","onBatchDone","winningDocs","metadatas","fetchWinningDocAndMetadata","onGetMetadata","docIdRev","docIds","docIdsToMetadata","continuous","ExportedSet","since","return_docs","objectStores","IdbPouch","thisCallback","init","createSchema","createObjectStore","keyPath","autoIncrement","createIndex","unique","addDeletedOrLocalIndex","createLocalStoreSchema","migrateLocalStore","localStore","seqCursor","addAttachAndSeqStore","migrateAttsAndSeqs","digestMap","migrateMetadata","decodeMetadataCompat","fetchMetadataSeq","metadataSeq","onGetMetadataSeq","instanceId","_bulkDocs","reqOpts","_get","_getAttachment","attachId","attachment","blobData","_info","updateSeq","doc_count","update_seq","idb_attachment_format","_changes","_close","cachedDBs","_getRevisionTree","_doCompaction","_getLocal","_putLocal","oldRev","ret","oStore","oldDoc","_removeLocal","_destroy","openReq","openReqList","indexedDB","deleteDatabase","cached","tryStorageOption","open","ADAPTER_VERSION","onupgradeneeded","migration","migrations","oldVersion","currentTarget","completeSetup","storedMetaDoc","storeMetaDocIfReady","instanceKey","onversionchange","blobSupportPromise","decodeUtf8","escape","hexToInt","charCode","parseHexUtf8","parseHexUtf16","parseHexString","encoding","quote","escapeBlob","unescapeBlob","stringifyDoc","unstringifyDoc","qMarks","select","table","joiner","where","orderBy","compactRevs$1","deleteOrphans","seqs","sql","ATTACH_AND_SEQ_STORE$1","executeSql","digestsToCheck","nonOrphanedDigests","ATTACH_STORE$1","BY_SEQ_STORE$1","websqlError","errorNameMatch","errorName","errorReason","WSQ_ERROR","getSize","isAndroid","websqlBulkDocs","websqlChanges","_name","cnt","sqlArgs","deletedInt","insertId","dataWritten","fetchSql","attachmentErr","revsToCompact","DOC_STORE$1","metadataStr","params","websqlProcessDocs","userDocs","docInfoErrors","openDatabaseWithOpts","websql","description","openDBSafely","openDB$1","cachedResult","cachedDatabases","fetchAttachmentsIfNecessary$1","attOpts","_","WebSqlPouch$1","dbCreated","runMigration2","DOC_STORE_WINNINGSEQ_INDEX_SQL","BY_SEQ_STORE_DELETED_INDEX_SQL","runMigration3","LOCAL_STORE$1","doNext","runMigration4","updateRows","doc_id_rev","hex","doc_id","BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL","runMigration5","nextPage","SELECT_DOCS","DOC_STORE_AND_BY_SEQ_JOINER","pageSize","addDigestSeq","digestSeqs","digestSeqPairs","pair","attachAndRev","ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL","ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL","runMigration6","runMigration7","checkEncoding","onGetInstanceId","idRequests","idCallback","onGetVersion","dbVersion","meta","META_STORE$1","attach","initSeq","initSeqArgs","ADAPTER_VERSION$1","setupDone","migrated","dbid","tasks","nextMigration","setup","fetchVersion","db_version","getMaxSeq","latest$$1","websqlOpts","POUCH_VERSION","openDBResult","readTransaction","theSeq","theDocCount","websql_encoding","latestRev","missingErr","deletedErr","totalRows","criteria","fetchChanges","selectStmt","reportChange","maxSeq","escaped","putLocal","rowsAffected","removeLocal","store","canOpenTestDB","openDatabase","isValidWebSQL","hasLS","localStorageKey","openedTestDB","openDB","WebSQLPouch","_opts","wrappedFetch","wrappedPromise","fetch","response","fetchRequest","timer","headers","Headers","fetchOptions","credentials","processData","url","fetchResponse","statusCode","text","abort","xhRequest","xhr","timedout","abortReq","cleanUp","timeoutReq","onprogress","upload","onreadystatechange","XMLHttpRequest","exception","withCredentials","Accept","responseType","setRequestHeader","readyState","getResponseHeader","responseText","send","testXhr","ajax$1","hasXhr","defaultBody","ajaxCore$1","v","missing","res$2","defaultOptions","cache","ajax","ua","isSafari","isIE","isEdge","shouldCacheBust","isBlobUrl","hasArgs","now","pool","promiseFactories","runNext","onError","runNextBatch","thisErr","readAttachmentsAsBlobOrBuffer","encodeDocId","encodeURIComponent","preprocessAttachments$2","hasUrlPrefix","protocol","getHost","substr","password","auth","username","genDBUrl","genUrl","pathDel","host","port","paramsToStr","HttpPouch","ajax$$1","userOpts","reqAjax","ajaxOpts","defaultHeaders","_ajax","ajaxPromise","adapterFun$$1","skipSetup","skip_setup","setupPromise","checkExists","dbUrl","encodeAttachmentId","attachmentId","nAuth","token","unescape","Authorization","uuid$$1","compact","ping","compact_running","interval","doBulkGet","doBulkGetShim","onResult","batchNum","numBatches","MAX_SIMULTANEOUS_REVS","supportsBulkGet","supportsBulkGetMap","fetchAttachments","filenames","fetchAllAttachments","docOrDocs","revs_info","docOrId","optsOrRev","getAttachment","removeAttachment","putAttachment","Content-Type","_put","allDocs","start_key","end_key","paramStr","batch_size","CHANGES_BATCH_SIZE","heartbeat","DEFAULT_HEARTBEAT","requestTimeout","CHANGES_TIMEOUT_BUFFER","leftToFetch","feed","param_name","lastFetchedSeq","aborted","xhrOpts","fetched","raw_results_length","finished","revsDiff","QueryParseError","captureStackTrace","NotFoundError","BuiltInError","promisedCallback","callbackify","fin","finalPromiseFactory","sequentialize","promiseFactory","that","uniq","theSet","mapToKeysArray","createBuiltInError","sum","jLen","jNum","evalFunctionWithEval","TaskQueue$2","createViewSignature","reduceFun","createView","sourceDB","temporary","localDocName","cachedViews","viewSignature","_cachedViews","promiseForView","diffFunction","fullViewName","depDbs","depDbName","registerDependentDatabase","lastSeqDoc","parseViewName","isGenOne","emitError","createAbstractMapReduce","mapper","reducer","ddocValidator","tryMap","tryReduce","rereduce","output","sortByKeyThenValue","y","keyCompare","sliceResults","rowToDocId","postprocessAttachments","addHttpParam","paramName","asJson","coerceInteger","integerCandidate","asNumber","Number","coerceOptions","group_level","checkPositiveInteger","number","checkQueryParseError","startkeyName","endkeyName","group","optionName","httpQuery","MAX_URL_LENGTH","keysAsString","customQuery","_query","customViewCleanup","_viewCleanup","defaultsTo","getDocsToPersist","docIdsToChangesAndEmits","getMetaDoc","defaultMetaDoc","metaDocId","getKeyValueDocs","processKeyValueDocs","kvDocsRes","kvDocs","oldKeys","indexableKeysToKeyValues","keyValue","newKeys","kvDoc","docData","saveKeyValues","seqDocId","listOfDocsToPersist","docsToPersist","bulkDocs","getQueue","persistentQueues","updateView","updateViewInQueue","mapResults","processNextBatch","currentSeq","CHANGES_BATCH_SIZE$1","createDocIdsToChangesAndEmits","createIndexableKeysToKeyValues","emittedKeyValue","complexKey","reduceView","shouldGroup","groups","lvl","POSITIVE_INFINITY","last","groupKey","reduceTry","queryView","queryViewInQueue","fetchFromView","viewOpts","expectedKeys","parsedKeyAndDocId","onMapResultsReady","shouldReduce","allDocsRes","docIdsToDocs","fetchPromises","keyStart","keyEnd","httpViewCleanup","localViewCleanup","docsToViews","designDocName","viewsToStatus","ddocName","viewDBNames","statusIsGood","viewDBName","dbsToDelete","destroyPromises","queryPromised","tempViewQueue","createViewPromise","stale","abstractQuery","abstractViewCleanup","viewCleanup","getBuiltIn","reduceFunString","builtInReduce","_sum","_count","_stats","origMap","builtIn","abstract","isGenOne$1","fileHasChanged","localDoc","remoteDoc","getDocAttachments","getDocAttachmentsFromTargetOrSource","src","doCheckForLocalAttachments","createBulkGetOpts","diffs","missingRevs","missingRev","getDocs","state","getAllDocs","bulkGetOpts","bulkGetResponse","cancelled","bulkGetInfo","resultDocs","Boolean","hasConflicts","fetchRevisionOneDocs","getRevisionOneDocs","returnResult","updateCheckpoint","checkpoint","session","returnValue","session_id","replicator","REPLICATOR","CHECKPOINT_VERSION","unshift","CHECKPOINT_HISTORY_SIZE","Checkpointer","compareReplicationLogs","srcDoc","tgtDoc","compareReplicationHistory","sourceHistory","targetHistory","S","sourceRest","T","targetRest","LOWEST_SEQ","sourceId","hasSessionId","sessionId","rest","isForbiddenError","floor","backOff","retry","back_off_function","backOffSet","current_back_off","STARTING_BACK_OFF","removeBackOffSetter","sortObjectPropertiesByKey","queryParams","generateReplicationId","filterViewName","queryData","md5sum","replicate","initCheckpointer","checkpointer","repId","checkpointOpts","writeSourceCheckpoint","writeTargetCheckpoint","writeDocs","changedDocs","currentBatch","bulkOpts","completeReplication","errorsById","create","errorsNo","doc_write_failures","docs_written","errors","finishBatch","outResult","writingCheckpoint","writeCheckpoint","getChanges","onCheckpointError","getDiffs","getBatchDocs","got","docs_read","startNextBatch","batches","processPendingBatch","abortReplication","immediate","pendingBatch","changesOpts","live","changesCompleted","replicationCompleted","fatalError","end_time","onChangesComplete","changesPending","onChangesError","abortChanges","batches_limit","_abortChanges","startChanges","getCheckpoint","start_time","_addedListeners","Replication","toPouch","PouchConstructor","replicateWrapper","replicateRet","srcPouch","targetPouch","sync$1","Sync","pullChange","direction","pushChange","pushDenied","pullDenied","pushPaused","pullPaused","pushActive","pullActive","removeAll","isChange","isDenied","isPaused","isActive","removed","addOneListener","listener","canceled","optsPush","optsPull","pull","out","success","replication","sync","other","lie","inherits","Promise","mangled","setItem","getItem","eventFunction","inprogress","notifyLocalWindows","assign","nextSource","nextKey","MISSING_BULK_DOCS","QUERY_PARSE_ERROR","NOT_AN_OBJECT","hasName","newPromise","post","transformForceOptionToNewEditsOption","oldRevId","oldRevNum","newRevNum","putDoc","force","createAttachment","prevrevpos","was_delete","addToMissing","revId","processDoc","missingForId","missingObj","compactDocument","maxHeight","revTree","candidates","promises","onComplete","finishOpenRevs","existing","splittedRev","revNo","currentPath","hashIndex","hashFoundAtRevPos","indexOfRev","howMany","_revs_info","incompatibleOpt","_type","attachmentError","dependentDb","dependentDbs","depDB","destroyDb","deletedMap","trueName","execute","addToPreferredAdapters","plugin","__defaults","defaults","defaultOpts","PouchAlt","$elemMatch","$allMatch","$exists","$mod","neValue","$in","$nin","$size","$all","$regex","$type","atob","btoa","setImmediate","IDBPouch","WebSqlPouch","HttpPouch$1","sumsqr","_sumsqr","mapreduce","updateTarget","updateSource","readOnlySource","comparisons","targetDoc","sourceDoc","1","cleanup","_readyCalled","v1","clockseq","_clockseq","msecs","getTime","nsecs","_lastNSecs","dt","_lastMSecs","tl","tmh","_nodeId","n","bytesToUuid","rng","_seedBytes","crypto","msCrypto","getRandomValues","rnds8","rnds","r","bth","byteToHex","ii","INTERNAL","resolver","PENDING","outcome","safelyResolveThenable","QueueItem","onFulfilled","onRejected","callFulfilled","otherCallFulfilled","callRejected","otherCallRejected","unwrap","handlers","getThen","thenable","tryToUnwrap","tryCatch","iterable","allResolver","resolveFromAll","outValue","resolved","race","REJECTED","FULFILLED","oldQueue","scheduleDrain","Mutation","MutationObserver","WebKitMutationObserver","observer","document","createTextNode","observe","characterData","MessageChannel","createElement","scriptEl","parentNode","removeChild","documentElement","appendChild","port1","onmessage","port2","postMessage","argsArray","_events","_maxListeners","isFunction","arg","isNumber","isObject","isUndefined","defaultMaxListeners","setMaxListeners","er","handler","context","newListener","warned","trace","g","fired","list","position","evlistener","emitter","ctor","superCtor","super_","TempCtor","useColors","firebug","formatArgs","namespace","humanize","color","lastC","save","namespaces","removeItem","load","DEBUG","localstorage","colors","formatters","enable","selectColor","createDebug","enabled","curr","ms","prevTime","coerce","format","formatter","logFn","names","skips","disable","d","h","fmtShort","round","fmtLong","plural","md5cycle","md5blk","md5blks","md5blk_array","md51","tail","tmp","lo","hi","md51_array","subarray","rhex","hex_chr","toUtf8","utf8Str2ArrayBuffer","returnUInt8Array","arrayBuffer2Utf8Str","concatenateArrayBuffers","first","second","hexToBinaryString","SparkMD5","reset","add32","lsw","msw","clamp","begin","contents","_buff","_length","_hash","_finish","getState","setState","hashBinary","arrayPrefix","objPrefix","numChar","parsedString","lastCh","numConsecutiveSlashes","_superagent","_superagent2","_sha","_sha2","API","authenticationToken","tokenUpdateCallback","newToken","endpoint","del","needsTokenUpdate","updateToken","serialize","pairs","pushEncodedKeyValuePair","subkey","parseString","parseHeader","line","lines","trim","isJSON","mime","Response","statusText","_setStatusProperties","header","getAllResponseHeaders","_setHeaderProperties","_parseBody","Request","_header","original","rawResponse","new_err","fn","Emitter","requestBase","getXHR","location","ActiveXObject","serializeObject","types","html","xml","urlencoded","form","form-data","application/x-www-form-urlencoded","application/json","ct","statusType","clientError","serverError","toError","accepted","noContent","badRequest","unauthorized","notAcceptable","notFound","forbidden","_responseType","accept","pass","file","_getFormData","_formData","FormData","_callback","crossDomainError","crossDomain","_timeoutError","_timeout","_appendQueryString","_data","_aborted","handleProgress","total","percent","hasListeners","_timer","_withCredentials","_isHost","contentType","_serializer","head","patch","mixin","_callbacks","removeEventListener","callbacks","_parser","_fullfilledPromise","innerResolve","innerReject","use","getHeader","unset","redirects","_maxRedirects","RequestConstructor","CryptoJS","C","C_lib","lib","WordArray","Hasher","C_algo","algo","H","K","isPrime","sqrtN","sqrt","getFractionalBits","nPrime","pow","W","SHA256","extend","_doReset","_doProcessBlock","M","words","gamma0x","gamma0","gamma1x","gamma1","maj","sigma0","sigma1","_doFinalize","nBitsTotal","_nDataBytes","nBitsLeft","sigBytes","_process","_createHelper","HmacSHA256","_createHmacHelper","F","subtype","Base","overrides","mixIn","$super","propertyName","encoder","Hex","wordArray","thisWords","thatWords","thisSigBytes","thatSigBytes","thatByte","nBytes","rcache","m_w","m_z","mask","_r","C_enc","enc","hexChars","bite","hexStr","hexStrLength","Latin1","latin1Chars","latin1Str","latin1StrLength","Utf8","utf8Str","BufferedBlockAlgorithm","_append","doFlush","dataSigBytes","blockSize","blockSizeBytes","nBlocksReady","_minBufferSize","nWordsReady","nBytesReady","processedWords","cfg","update","messageUpdate","finalize","hasher","HMAC","_loglevel","_loglevel2","originalFactory","methodFactory","methodName","logLevel","rawMethod","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","definition","realMethod","undefinedType","bindMethod","enableLoggingWhenConsoleArrives","loggerName","replaceLoggingMethods","logMethods","defaultMethodFactory","Logger","defaultLevel","persistLevelIfPossible","levelNum","levelName","toUpperCase","storageKey","ignore","cookie","getPersistedLevel","storedLevel","levels","currentLevel","TRACE","INFO","WARN","ERROR","SILENT","getLevel","persist","setDefaultLevel","enableAll","disableAll","initialLevel","defaultLogger","_loggersByName","getLogger","logger","_log","noConflict","_typeof","iterator","Event","eventFunctions","Buffer","_jsondiffpatch","_jsondiffpatch2","jsondiffpatch","objectHash","textDiff","minLength","Monitor","objectPropertyTrimFilter","trimObject","trimmedObject","leftIsArray","leftType","rightIsArray","rightType","processor","pipes","before","_updateRunning","_processingPatch","_lastObjects","objects","subscriptionOptions","subscriptionKey","addCallback","updateCallback","processDeltaObject","timerFunction","totalDiff","subKey","diffKeys","objKeys","publicKey","op","setInterval","subscription","subscriptionComponents","lastRoot","$$event","pathComponents","objectId","changedProperty","oldValue","typedArraySupport","__proto__","foo","kMaxLength","TYPED_ARRAY_SUPPORT","createBuffer","RangeError","encodingOrOffset","allocUnsafe","fromArrayBuffer","fromString","fromObject","assertSize","alloc","fill","checked","isEncoding","actual","write","fromArrayLike","byteOffset","isBuffer","copy","isnan","SlowBuffer","isView","loweredCase","utf8ToBytes","base64ToBytes","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","bidirectionalIndexOf","arrayIndexOf","read","indexSize","readUInt16BE","arrLength","valLength","foundIndex","found","hexWrite","remaining","strLen","parsed","utf8Write","blitBuffer","asciiWrite","asciiToBytes","latin1Write","base64Write","ucs2Write","utf16leToBytes","fromByteArray","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","codePoints","MAX_ARGUMENTS_LENGTH","toHex","checkOffset","ext","checkInt","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","ieee754","writeDouble","base64clean","stringtrim","INVALID_BASE64_RE","units","leadSurrogate","byteArray","toByteArray","dst","INSPECT_MAX_BYTES","poolSize","_augment","allocUnsafeSlow","_isBuffer","swap16","swap32","swap64","equals","inspect","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","_arr","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","maxBytes","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","placeHoldersCount","placeHolders","Arr","L","revLookup","tripletToBase64","lookup","encodeChunk","uint8","extraBytes","maxChunkLength","len2","isLE","mLen","eLen","eMax","eBias","nBits","NaN","rt","LN2","environment","DiffPatcher","dateReviver","defaultInstance","unpatch","isBrowser","homepage","packageInfoModuleName","packageInfo","formatterModuleName","Processor","Pipe","DiffContext","PatchContext","ReverseContext","trivial","nested","arrays","dates","texts","pipe","collectChildrenDiffFilter","diffFilter","objectsDiffFilter","shouldHaveResult","collectChildrenPatchFilter","patchFilter","collectChildrenReverseFilter","reverseFilter","selfOptions","lastPipe","lastContext","nextPipe","nextAfterChildren","hasResult","exiting","resultCheck","prepend","after","clear","should","noResult","Context","defaultClone","setResult","cloneDiffValues","exit","switchTo","child","childName","children","cloneRegExp","cloned","regexArgs","_t","propertyFilter","arraysHaveMatchByRef","array1","array2","len1","index1","val1","index2","val2","matchItems","value1","value2","matchByPosition","hash1","hash2","hashCache1","hashCache2","lcs","ARRAY_MOVE","matchContext","commonHead","commonTail","trimmed1","trimmed2","removedItems","indices1","detectMove","includeValueOnMove","removedItemsLength","indexOnArray2","indices2","isMove","removeItemIndex1","numerically","numericallyBy","toRemove","toInsert","toModify","indexDiff","removedValue","toInsertLength","insertion","toModifyLength","modification","newName","reverseArrayDeltaIndex","itemDelta","reverseIndex","deltaIndex","deltaItem","moveFromIndex","moveToIndex","deleteIndex","defaultMatch","lengthMatrix","matrix","backtrack","sequence","subsequence","TEXT_DIFF","DEFAULT_MIN_LENGTH","cachedDiffPatch","getDiffMatchPatch","required","diff_match_patch","dmpModuleName","dmp","diff_match_patch_not_found","txt1","txt2","patch_toText","patch_make","patch_apply","patch_fromText","textPatchFailed","diffMatchPatch","textDeltaReverse","lineTmp","lineHeader","lineAdd","lineRemove","headerRegex","lineStart","webpackContext","webpackContextResolve","../package.json","./console","./formatters","_args","_from","_inBundle","_integrity","_location","_phantomChildren","_requested","registry","escapedName","rawSpec","saveSpec","fetchSpec","_requiredBy","_resolved","_spec","_where","author","email","bugs","bundleDependencies","contributors","dependencies","chalk","devDependencies","bulk-require","codeclimate-test-reporter","expect.js","fiberglass","gulp","istanbul","mocha","engine","engines","keywords","license","main","repository","scripts","bump","cover","cover-publish","cover-report","testling","harness","files","browsers","base","BaseFormatter","added","green","red","movedestination","gray","moved","yellow","unchanged","white","bgRed","textDiffLine","ConsoleFormatter","includeMoveDestinations","prepareContext","indent","indentLevel","indentPad","outLine","pushColor","popColor","typeFormattterErrorFormatter","formatValue","formatTextDiffString","parseTextDiff","chr","pieces","pieceIndex","piecesLength","piece","rootBegin","nodeType","rootEnd","nodeBegin","leftKey","nodeEnd","isLast","format_unchanged","format_movedestination","format_node","formatDeltaChildren","format_added","format_modified","format_deleted","format_moved","format_textdiff","build","_styles","applyStyle","argsLen","nestedStyles","ansiStyles","closeRe","styles","escapeStringRegexp","stripAnsi","hasAnsi","supportsColor","defineProps","grey","hasColor","stripColor","matchOperatorsRe","codes","bold","dim","italic","underline","inverse","hidden","strikethrough","black","blue","magenta","cyan","bgBlack","bgGreen","bgYellow","bgBlue","bgMagenta","bgCyan","bgWhite","ansiRegex","stdout","isTTY","TERM","getObjectKeys","property","trimUnderscore","arrayKeyToSortNumber","arrayKeyComparer","key1","key2","recurse","typeFormattterNotFound","deltaType","movedFrom","useMoveOriginHere","leftValue","getDeltaType","typeFormattter","forEachDeltaKey","arrayKeys","moveDestinations","lineOutput","pieceOutput","annotated","jsonpatch","consoleModuleName","htmlEscape","replacements","HtmlFormatter","adjustArrows","getElementText","textContent","innerText","eachByQuery","elems","querySelectorAll","eachChildren","arrow","arrowParent","svg","display","destinationElem","destination","querySelector","container","getAttribute","distance","offsetTop","setAttribute","top","curve","nodeClass","hasArrows","showUnchanged","show","delay","classes","showing","hiding","visible","classList","intervalId","clearInterval","hideUnchanged","AnnotatedFormatter","htmlNote","wrapPropertyName","deltaAnnotations","formatLegend","modified","textdiff","formatAnyChange","annotator","JSONFormatter","sortBy","pred","opsByDescendingOrder","removeOps","splitA","splitB","compareByIndexDesc","partition","coll","reorderOps","jsonFormattedDiff","removeOpsOtherOps","otherOps","removeOpsReverse","named","pushCurrentOp","indexA","indexB","lastA","lastB","UTC","Channel","monitor","_options","_addCallback","_updateCallback","_removeCallback","_subscribed","objectsArray","objectsCount","_sortObjectArray","order","objectKeys","context_id","_admin","_admin2","User","setAdmin","_setAdmin","_customProperties","_userChannel","canReauth","isLoggedIn","_saveToken","userContainer","callbackURL","callbackUrl","newPassword","user_id","facebookToken","_login","access_token","userId","Admin","userChannel","users","updateApp","new","model_name","addUser","deleteUser","updateUser","register","io","sameNamespace","nsps","newConnection","forceNew","multiplex","Manager","encodeQueryString","socket","managers","Socket","loc","parseuri","ipv6","href","authority","ipv6uri","prevColor","disabled","Encoder","encodeAsString","nsp","BINARY_EVENT","BINARY_ACK","encodeAsBinary","writeEncoding","bloblessData","deconstruction","deconstructPacket","pack","packet","buffers","removeBlobs","Decoder","reconstructor","decodeString","tryParse","BinaryReconstructor","reconPack","isBuf","CONNECT","DISCONNECT","EVENT","ACK","encode","takeBinaryData","finishedReconstruction","binData","reconstructPacket","short","long","runInContext","undef","isSupported","serialized","stringifySupported","isExtended","getClass","parseSupported","SyntaxError","nativeJSON","isProperty","objectProto","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","functionClass","dateClass","numberClass","stringClass","arrayClass","booleanClass","charIndexBuggy","Months","getDay","year","month","members","Properties","valueOf","isConstructor","hasProperty","objectTypes","Escapes","92","34","8","12","10","13","9","leadingZeroes","toPaddedString","width","unicodePrefix","useCharIndex","symbols","whitespace","indentation","className","date","time","hours","minutes","seconds","milliseconds","Index","Source","Unescapes","47","98","116","110","102","114","lex","isSigned","hasMembers","walk","isLoader","function","freeExports","freeGlobal","previousJSON","isRestored","JSON3","webpackPolyfill","deprecate","__webpack_amd_options__","_deconstructPacket","placeholder","_placeholder","newData","packetData","_reconstructPacket","_removeBlobs","curKey","containingObject","File","pendingBlobs","fileReader","onload","subs","reconnection","reconnectionAttempts","reconnectionDelay","reconnectionDelayMax","randomizationFactor","backoff","Backoff","jitter","lastPing","packetBuffer","decoder","autoConnect","eio","emitAll","updateSocketIds","_reconnection","_reconnectionAttempts","_reconnectionDelay","setMin","_randomizationFactor","setJitter","_reconnectionDelayMax","setMax","maybeReconnectOnOpen","reconnecting","attempts","reconnect","skipReconnect","openSub","onopen","errorSub","onping","onpong","ondata","ondecoded","onConnecting","encodedPackets","processPacketQueue","subsLength","onclose","duration","onreconnect","attempt","hostname","secure","agent","parseqs","decode","upgrade","forceJSONP","jsonp","forceBase64","enablesXDR","timestampParam","timestampRequests","transports","writeBuffer","prevBufferLen","policyPort","rememberUpgrade","binaryType","onlyBinaryUpgrades","perMessageDeflate","threshold","pfx","passphrase","cert","ca","ciphers","rejectUnauthorized","forceNode","extraHeaders","localAddress","upgrades","pingInterval","pingTimeout","pingIntervalTimer","pingTimeoutTimer","o","parsejson","priorWebsocketSuccess","Transport","createTransport","EIO","transport","sid","setTransport","onDrain","onPacket","onClose","probe","onTransportOpen","upgradeLosesBinary","supportsBinary","upgrading","pause","flush","freezeTransport","onTransportClose","onupgrade","onOpen","onHandshake","setPing","filterUpgrades","onHeartbeat","sendPacket","compress","cleanupAndClose","waitForUpgrade","desc","filteredUpgrades","polling","xd","xs","isSSL","xdomain","xscheme","XHR","JSONP","websocket","hasCORS","XDomainRequest","empty","Polling","async","isBinary","unloadHandler","inherit","doWrite","sendXhr","doPoll","onData","pollXhr","setDisableHeaderCheck","hasXDR","onLoad","requestsCount","fromError","ui8Arr","dataArray","hasXHR2","yeast","doOpen","poll","onPause","decodePayload","doClose","packets","callbackfn","encodePayload","schema","decodePacket","encodeBase64Object","encodeArrayBuffer","encodeBase64Packet","contentArray","resultBuffer","encodeBlobAsArrayBuffer","fr","encodePacket","encodeBlob","dontSendBlobs","tryDecode","utf8","ary","each","eachWithIndex","base64encoder","hasBinary","sliceBuffer","isPhantomJS","pong","packetslist","utf8encode","readAsDataURL","b64data","typed","basic","utf8decode","decodeBase64Packet","asArray","setLengthHeader","encodeOne","doneCallback","encodePayloadAsBlob","encodePayloadAsArrayBuffer","decodePayloadAsBinary","totalLength","resultArray","bufferIndex","isString","ab","lenStr","binaryIdentifier","lengthAry","bufferTail","numberTooLong","tailArray","msgLength","_hasBinary","arraybuffer","abv","err_cb","proxy","bail","ucs2decode","extra","counter","ucs2encode","stringFromCharCode","createByte","encodeCodePoint","symbol","wtf8encode","byteString","readContinuationByte","byteIndex","byteCount","continuationByte","decodeSymbol","byte1","byte2","byte3","byte4","wtf8decode","wtf8","chars","encoded1","encoded2","encoded3","encoded4","bufferLength","mapArrayBufferViews","chunk","BlobBuilderConstructor","bb","BlobConstructor","blobSupported","blobSupportsArrayBufferView","blobBuilderSupported","qs","qry","alphabet","decoded","seed","JSONPPolling","___eio","script","rNewline","rEscapedNewline","iframe","insertAt","getElementsByTagName","insertBefore","isUAgecko","initIframe","iframeId","area","submit","WS","usingBrowserWebSocket","BrowserWebSocket","WebSocket","NodeWebSocket","MozWebSocket","check","protocols","ws","supports","addEventListeners","ev","rvalidchars","rvalidescape","rvalidtokens","rvalidbraces","rtrimLeft","rtrimRight","acks","receiveBuffer","sendBuffer","disconnected","toArray","hasBin","connect_error","connect_timeout","reconnect_attempt","reconnect_failed","reconnect_error","subEvents","parserType","flags","onpacket","onconnect","onevent","onack","ondisconnect","ack","sent","emitBuffered","rand","deviation"],"mappings":"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","file":"telepat.client.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Telepat\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Telepat\"] = factory();\n\telse\n\t\troot[\"Telepat\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Telepat\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Telepat\"] = factory();\n\telse\n\t\troot[\"Telepat\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _fs = __webpack_require__(2);\n\t\n\tvar _fs2 = _interopRequireDefault(_fs);\n\t\n\tvar _pouchdb = __webpack_require__(3);\n\t\n\tvar _pouchdb2 = _interopRequireDefault(_pouchdb);\n\t\n\tvar _api = __webpack_require__(19);\n\t\n\tvar _api2 = _interopRequireDefault(_api);\n\t\n\tvar _logger = __webpack_require__(27);\n\t\n\tvar _logger2 = _interopRequireDefault(_logger);\n\t\n\tvar _error = __webpack_require__(29);\n\t\n\tvar _error2 = _interopRequireDefault(_error);\n\t\n\tvar _event = __webpack_require__(30);\n\t\n\tvar _event2 = _interopRequireDefault(_event);\n\t\n\tvar _monitor = __webpack_require__(31);\n\t\n\tvar _monitor2 = _interopRequireDefault(_monitor);\n\t\n\tvar _channel = __webpack_require__(68);\n\t\n\tvar _channel2 = _interopRequireDefault(_channel);\n\t\n\tvar _user = __webpack_require__(69);\n\t\n\tvar _user2 = _interopRequireDefault(_user);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar UDID_DB_KEY = ':deviceId';\n\t\n\t/**\n\t * The `Telepat` object is the first object you want to instantiate while working with the Telepat SDK.\n\t * It exposes methods and properties that enable you to register, login, subscribe to objects and to users.\n\t *\n\t * @class Telepat\n\t *\n\t * @example\n\t * let telepat = new Telepat();\n\t * telepat.connect({\n\t *  apiEndpoint: 'TELEPAT-API-ENDPOINT',\n\t *  socketEndpoint: 'TELEPAT-SOCKET-ENDPOINT',\n\t *  apiKey: 'APP-API-KEY',\n\t *  appId: 'APP-ID'\n\t * }, (err, res) => {\n\t *  if (err) {\n\t *    // Treat connection error\n\t *    console.log(err);\n\t *    return;\n\t *  }\n\t *\n\t *  // Display all collections\n\t *  console.log(telepat.collections);\n\t *\n\t *  // Login, display and update user data\n\t *  telepat.on('login', () => {\n\t *    console.log(telepat.user.data);\n\t *    telepat.user.data.change = true;\n\t *  });\n\t *  telepat.user.login('user', 'pass');\n\t *\n\t *  // Subscribe to data\n\t *  let articleChannel = telepat.subscribe({\n\t *    channel: {\n\t *      context: 'collection-identifier',\n\t *      model: 'article'\n\t *    }\n\t *  }, () => {\n\t *    console.log(articleChannel.objectsArray);\n\t *    articleChannel.objects['object-identifier'].title = 'new title';\n\t *\n\t *    articleChannel.on('update', (operationType, objectId, object, oldObject) => {\n\t *      // Update interface on data updates\n\t *    });\n\t *  });\n\t * });\n\t */\n\t\n\tvar Telepat = function () {\n\t  function Telepat() {\n\t    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\n\t    _classCallCheck(this, Telepat);\n\t\n\t    function getUserHome() {\n\t      return process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];\n\t    }\n\t\n\t    function getTelepatDir() {\n\t      var dir = getUserHome() + '/.telepat-cli';\n\t\n\t      if (!_fs2.default.existsSync(dir)) {\n\t        _fs2.default.mkdirSync(dir, 744);\n\t      }\n\t      return dir;\n\t    }\n\t    this.name = options && options.name ? options.name : '';\n\t    UDID_DB_KEY += this.name;\n\t    this._db = new _pouchdb2.default(typeof window !== 'undefined' ? '/_telepat' : getTelepatDir());\n\t    console.log(UDID_DB_KEY);\n\t    this._event = new _event2.default(_logger2.default);\n\t    this._monitor = new _monitor2.default();\n\t    this._socketEndpoint = null;\n\t    this._socket = null;\n\t    this._persistentConnectionOptions = null;\n\t    /**\n\t     * Indicates whether the current instance is connected to the backend\n\t     * @type {boolean}\n\t     * @memberof Telepat\n\t     * @instance\n\t     */\n\t    this.connected = false;\n\t    /**\n\t     * Indicates whether the current instance is in the process of connecting to the backend.\n\t     * If true, the `connect` event will be fired as soon as connection is established.\n\t     * @type {boolean}\n\t     * @memberof Telepat\n\t     * @instance\n\t     */\n\t    this.connecting = false;\n\t    /**\n\t     * Indicates whether the current instance is properly configured and ready for connection.\n\t     * @type {boolean}\n\t     * @memberof Telepat\n\t     * @instance\n\t     */\n\t    this.configured = false;\n\t    /**\n\t     * If connected, this property reflects the current app id.\n\t     * @type {string}\n\t     * @memberof Telepat\n\t     * @instance\n\t     */\n\t    this.currentAppId = null;\n\t    /**\n\t     * This object contains details about all the collections available for the currently connected application.\n\t     * You can read this after the `connect` event is emitted, or if the `connected` property is true.\n\t     * Each available collection is stored as an Object, using a key whose name is equal to the collection's id.\n\t     * Modifications to collection objects stored within will be automatically synchronized with the Telepat backend.\n\t     * @type {Object}\n\t     * @memberof Telepat\n\t     * @instance\n\t     */\n\t    this.collections = {};\n\t    /**\n\t     * This object contains references to all of the {@link Channel}s that are actively subscribed.\n\t     * Each channel is stored using a key equal to the channel's unique identifier.\n\t     * @type {Object}\n\t     * @memberof Telepat\n\t     * @instance\n\t     */\n\t    this.subscriptions = {};\n\t    /**\n\t     * This property becomes available after successfully logging in as an administrator.\n\t     * It gives you access to a instance of the {@link Admin} class, allowing you access to administrator functionality.\n\t     * @type {Admin}\n\t     * @memberof Telepat\n\t     * @instance\n\t     *\n\t     * @example\n\t     * telepat.user.loginAdmin('admin@email.com', 'password', (err) => {\n\t     *  if (err) {\n\t     *    // Treat login error\n\t     *  } else {\n\t     *    telepat.admin.getAppUsers((err) => {\n\t     *      if (err) {\n\t     *        // Treat error\n\t     *      } else {\n\t     *        // Treat success\n\t     *        console.log(telepat.admin.users);\n\t     *      }\n\t     *    })\n\t     *  }\n\t     * });\n\t     */\n\t    this.admin = null;\n\t    /**\n\t     * An instance of the {@link User} class, this allows you to access user functionality like logging in,\n\t     * accessing and modifying current user data or registering new user accounts.\n\t     * @type {User}\n\t     * @memberof Telepat\n\t     * @instance\n\t     *\n\t     * @example\n\t     * telepat.user.login('email', 'password', (err) => {\n\t     *  if (err) {\n\t     *    // Treat login error\n\t     *  } else {\n\t     *    // Treat successful login\n\t     *    console.log(telepat.user.data);\n\t     *  }\n\t     * });\n\t     */\n\t    this.user = null;\n\t    this.collectionEvent = new _event2.default(_logger2.default);\n\t\n\t    if (options) {\n\t      this.connect(options);\n\t    }\n\t  }\n\t\n\t  _createClass(Telepat, [{\n\t    key: 'onReady',\n\t    value: function onReady(callback) {\n\t      return this.on('ready', callback);\n\t    }\n\t  }, {\n\t    key: 'getCollections',\n\t    value: function getCollections() {\n\t      var _this = this;\n\t\n\t      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n\t\n\t      _api2.default.get('context/all', '', function (err, res) {\n\t        if (err) {\n\t          var resultingError = (0, _error2.default)('Error retrieving collections ' + err);\n\t\n\t          _this.callback(resultingError, null);\n\t        } else {\n\t          _this._monitor.remove({ channel: { model: 'context' } });\n\t          _this.collections = {};\n\t          for (var index in res.body.content) {\n\t            _this.collections[res.body.content[index].id] = res.body.content[index];\n\t          }\n\t\n\t          _this._monitor.add({ channel: { model: 'context' } }, _this.collections, _this.collectionEvent, _this._addCollection.bind(_this), _this._deleteCollection.bind(_this), _this._updateCollection.bind(_this));\n\t          _this.collectionEvent.on('update', function (operation, parentId, parentObject, delta) {\n\t            _this._event.emit('collections_update');\n\t          });\n\t          callback(null, _this.collections);\n\t          _this._event.emit('collections_update');\n\t        }\n\t      });\n\t    }\n\t  }, {\n\t    key: '_addCollection',\n\t    value: function _addCollection(collection) {\n\t      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\t\n\t      if (this.admin) {\n\t        this.admin.addCollection(collection, callback);\n\t      } else {\n\t        _logger2.default.warn('Editing collection data as non-admin user. Changes will not be remotely persisted.');\n\t      }\n\t    }\n\t  }, {\n\t    key: '_updateCollection',\n\t    value: function _updateCollection(id, patches) {\n\t      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n\t\n\t      if (this.admin) {\n\t        this.admin.updateCollection(id, patches, callback);\n\t      } else {\n\t        _logger2.default.warn('Editing collection data as non-admin user. Changes will not be remotely persisted.');\n\t      }\n\t    }\n\t  }, {\n\t    key: '_deleteCollection',\n\t    value: function _deleteCollection(id) {\n\t      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\t\n\t      if (this.admin) {\n\t        this.admin.deleteCollection(id, callback);\n\t      } else {\n\t        _logger2.default.warn('Editing collection data as non-admin user. Changes will not be remotely persisted.');\n\t      }\n\t    }\n\t  }, {\n\t    key: '_updateUser',\n\t    value: function _updateUser() {\n\t      var _this2 = this;\n\t\n\t      var reauth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\t\n\t      if (!this.user) {\n\t        this.user = new _user2.default(this._db, this._event, this._monitor, function (newAdmin) {\n\t          _this2.admin = newAdmin;\n\t        }, function () {\n\t          if (reauth) {\n\t            _this2.user.reauth(callback);\n\t          } else {\n\t            callback(null);\n\t          }\n\t        });\n\t      } else {\n\t        callback(null);\n\t      }\n\t    }\n\t  }, {\n\t    key: '_getSavedUDID',\n\t    value: function _getSavedUDID(callback) {\n\t      this._db.get(UDID_DB_KEY).then(function (doc) {\n\t        if (doc[_api2.default.appId]) {\n\t          callback(null, doc[_api2.default.appId]);\n\t        } else {\n\t          _logger2.default.warn('Could not retrieve saved UDID');\n\t          callback(new Error('Could not retrieve saved UDID'));\n\t        }\n\t      }).catch(function (err) {\n\t        _logger2.default.warn('Could not retrieve saved UDID', err);\n\t        callback(err);\n\t      });\n\t    }\n\t  }, {\n\t    key: '_saveUDID',\n\t    value: function _saveUDID(udid, callback) {\n\t      var _this3 = this;\n\t\n\t      this._db.get(UDID_DB_KEY).then(function (doc) {\n\t        doc[_api2.default.appId] = udid;\n\t        _this3._db.put(doc).then(function () {\n\t          _logger2.default.info('Replaced existing UDID');\n\t          callback(null);\n\t        }).catch(function (err) {\n\t          _logger2.default.warn('Could not persist UDID. Error: ' + err);\n\t          callback(err);\n\t        });\n\t      }).catch(function () {\n\t        var newObject = {\n\t          _id: UDID_DB_KEY\n\t        };\n\t\n\t        newObject[_api2.default.appId] = _api2.default.UDID;\n\t        _this3._db.put(newObject).then(function () {\n\t          _logger2.default.info('Saved new UDID');\n\t          callback(null);\n\t        }).catch(function (err) {\n\t          _logger2.default.warn('Could not persist UDID. Error: ' + err);\n\t          callback(err);\n\t        });\n\t      });\n\t    }\n\t  }, {\n\t    key: '_rebindVolatileTransport',\n\t    value: function _rebindVolatileTransport(callback) {\n\t      var _this4 = this;\n\t\n\t      if (this._socket) {\n\t        var watchdog = setTimeout(function () {\n\t          callback((0, _error2.default)('Socket transport connection timeout'));\n\t        }, 5000);\n\t\n\t        this._socket.emit('bind_device', {\n\t          'device_id': _api2.default.UDID,\n\t          'application_id': _api2.default.appId\n\t        });\n\t        this._socket.on('ready', function () {\n\t          _this4._socket.removeAllListeners('ready');\n\t          clearTimeout(watchdog);\n\t          watchdog = null;\n\t\n\t          // Update all subscription data on transport reconnect\n\t          for (var key in _this4.subscriptions) {\n\t            _this4.subscriptions[key].subscribe();\n\t          }\n\t\n\t          callback(null);\n\t        });\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Call this to configure Telepat server endpoints without connecting to a specific app.\n\t     *\n\t     * @param {Object} options Object containing all configuration options for connection\n\t     * @param {string} options.apiEndpoint The Telepat API endpoint URL\n\t     * @param {string} options.socketEndpoint The Telepat socket endpoint URL\n\t     * @param {boolean} [options.reauth=false] Should reauth previously logged in user on connection\n\t     * @param {TelepatCallback} callback Callback invoked after configuration is finished\n\t     *\n\t     * @fires Telepat.event:configure\n\t     *\n\t     * @example\n\t     * let telepat = new Telepat();\n\t     * telepat.configure({\n\t     *  apiEndpoint: 'TELEPAT-API-ENDPOINT',\n\t     *  socketEndpoint: 'TELEPAT-SOCKET-ENDPOINT'\n\t     * }, (err, res) => {\n\t     *  // Handle configuration\n\t     * });\n\t     */\n\t\n\t  }, {\n\t    key: 'configure',\n\t    value: function configure() {\n\t      var _this5 = this;\n\t\n\t      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\t\n\t      if (typeof options.apiEndpoint !== 'undefined') {\n\t        _api2.default.apiEndpoint = options.apiEndpoint + '/';\n\t      } else {\n\t        callback((0, _error2.default)('Configure options must provide an apiEndpoint property'));\n\t      }\n\t      // - `socketEndpoint`: the host and port number for the socket service\n\t      if (typeof options.socketEndpoint !== 'undefined') {\n\t        this._socketEndpoint = options.socketEndpoint;\n\t      } else {\n\t        callback((0, _error2.default)('Configure options must provide an socketEndpoint property'));\n\t      }\n\t\n\t      this._updateUser(options.reauth, function () {\n\t        _this5._event.emit('configure');\n\t        _this5.configured = true;\n\t        callback(null, _this5);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Call this to register a device with the Telepat backend. This will be automatically invoked\n\t     * during the initial connection.\n\t     *\n\t     * @param {TelepatCallback} callback Callback invoked after device is registered\n\t     */\n\t\n\t  }, {\n\t    key: 'registerDevice',\n\t    value: function registerDevice() {\n\t      var _this6 = this;\n\t\n\t      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n\t\n\t      var finalizeRequest = function finalizeRequest(err, res) {\n\t        if (err) {\n\t          callback(err);\n\t        } else {\n\t          if (res.body.content.identifier) {\n\t            _api2.default.UDID = res.body.content.identifier + _this6.name;\n\t            _logger2.default.info('Received new UDID: ' + _api2.default.UDID);\n\t            _this6._saveUDID(_api2.default.UDID, function () {});\n\t          }\n\t          callback(null, res);\n\t        }\n\t      };\n\t\n\t      var request = {\n\t        'info': {\n\t          'os': 'web',\n\t          'userAgent': typeof navigator !== 'undefined' ? navigator.userAgent : 'node'\n\t        },\n\t        'volatile': {\n\t          'type': 'sockets',\n\t          'active': 1\n\t        }\n\t      };\n\t\n\t      if (this._persistentConnectionOptions) {\n\t        request.persistent = this._persistentConnectionOptions;\n\t        if (request.persistent.active === 1) {\n\t          request.volatile.active = 0;\n\t        }\n\t      }\n\t\n\t      _api2.default.call('device/register', request, function (err, res) {\n\t        if (err && _api2.default.UDID) {\n\t          // Maybe our UDID got out of sync with the server. Let's try to get a new one\n\t          _api2.default.UDID = null;\n\t          _api2.default.call('device/register', request, function (err, res2) {\n\t            finalizeRequest(err, res2);\n\t          });\n\t        } else {\n\t          finalizeRequest(null, res);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Call this to register the device with the Telepat volatile transport service. This will be automatically invoked\n\t     * during the initial connection.\n\t     *\n\t     * @param {Object} options Socket.io connection options. See http://socket.io/docs/client-api/#manager(url:string,-opts:object).\n\t     * @param {TelepatCallback} callback Callback invoked after transport is registered\n\t     */\n\t\n\t  }, {\n\t    key: 'connectVolatileTransport',\n\t    value: function connectVolatileTransport() {\n\t      var _this7 = this;\n\t\n\t      var ioOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\t\n\t      this.disconnectVolatileTransport();\n\t\n\t      this._socket = __webpack_require__(71)(this._socketEndpoint, ioOptions);\n\t      _logger2.default.info('Connecting to socket service ' + this._socketEndpoint);\n\t\n\t      this._socket.on('error', function (err) {\n\t        callback(err);\n\t      });\n\t\n\t      this._socket.on('connect', function () {\n\t        _this7._rebindVolatileTransport(function (err) {\n\t          callback(err);\n\t        });\n\t      });\n\t\n\t      this._socket.on('message', function (message) {\n\t        _this7.processMessage(message);\n\t      });\n\t\n\t      this._socket.on('context-update', function () {\n\t        _this7.getCollections();\n\t      });\n\t\n\t      this._socket.on('disconnect', function () {\n\t        _logger2.default.warn('Sockets disconnected');\n\t        _this7._event.emit('volatile_disconnect');\n\t      });\n\t\n\t      this._socket.on('reconnect', function () {\n\t        _this7._rebindVolatileTransport(function (err) {\n\t          if (err) {\n\t            _this7._event.emit('reconnect_failed');\n\t          } else {\n\t            _this7._event.emit('reconnect');\n\t          }\n\t        });\n\t      });\n\t\n\t      this._socket.on('reconnect_failed', function () {\n\t        _logger2.default.warn('Sockets reconnect failed');\n\t        _this7._event.emit('reconnect_failed');\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Call this to unregister the device with the Telepat volatile transport service. This will be automatically invoked\n\t     * during disconnection.\n\t     *\n\t     * @fires Telepat.event:volatile_disconnect\n\t     */\n\t\n\t  }, {\n\t    key: 'disconnectVolatileTransport',\n\t    value: function disconnectVolatileTransport() {\n\t      if (this._socket) {\n\t        this._socket.removeAllListeners();\n\t        this._socket.close();\n\t        this._socket = null;\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Call this to connect to a specific Telepat app.\n\t     * This is usually the first thing you need to do after instantiating the Telepat object.\n\t     *\n\t     * @param {Object} options Object containing all configuration options for connection\n\t     * @param {string} options.apiKey Your app API key\n\t     * @param {string} options.appId Your app id\n\t     * @param {string} [options.apiEndpoint] The Telepat API endpoint URL. If this is absent from the connect options, it must have been previously set by calling {@link #Telepat#configure configure}.\n\t     * @param {string} [options.socketEndpoint] The Telepat socket endpoint URL.\n\t     *  If this is absent from the connect options, it must have been previously set by calling {@link #Telepat#configure configure}.\n\t     * @param {boolean} [options.reauth=false] Should reauth previously logged in user on connection\n\t     * @param {Object} [options.persistentConnection=null] Set this to configure receiving updates via persistent channels, like push notifications.\n\t     * @param {Object} [options.ioOptions={}] Configuration options for socket.io\n\t     * @param {boolean} [options.updateUDID=false] Set this to true to force the client to update the saved device identifier.\n\t     * @param {number} [options.timerInterval=150] Frequency of running diff (in miliseconds) to check for object updates.\n\t     * @param {TelepatCallback} callback Callback invoked after configuration is finished\n\t     *\n\t     * @fires Telepat.event:connect\n\t     * @fires Telepat.event:ready\n\t     * @fires Telepat.event:connect_error\n\t     * @fires Telepat.event:disconnect\n\t     *\n\t     * @example\n\t     * // Simple connection to backend\n\t     *\n\t     * let telepat = new Telepat();\n\t     * telepat.connect({\n\t     *  apiEndpoint: 'TELEPAT-API-ENDPOINT',\n\t     *  socketEndpoint: 'TELEPAT-SOCKET-ENDPOINT',\n\t     *  apiKey: 'APP-API-KEY',\n\t     *  appId: 'APP-ID'\n\t     * }, (err, res) => {\n\t     *  // Handle connection\n\t     * });\n\t     *\n\t     * @example\n\t     * // Using connection event\n\t     *\n\t     * let telepat = new Telepat();\n\t     * telepat.connect({\n\t     *  apiEndpoint: 'TELEPAT-API-ENDPOINT',\n\t     *  socketEndpoint: 'TELEPAT-SOCKET-ENDPOINT',\n\t     *  apiKey: 'APP-API-KEY',\n\t     *  appId: 'APP-ID'\n\t     * });\n\t     * let connectCallbackId = telepat.on('connect', {\n\t     *  telepat.removeCallback(connectCallbackId);\n\t     *  // Handle connection\n\t     * });\n\t     *\n\t     * @example\n\t     * // Activating the push notifications transport.\n\t     * // Do this when running inside a mobile OS, for example.\n\t     * telepat.connect({\n\t     *  apiEndpoint: 'TELEPAT-API-ENDPOINT',\n\t     *  socketEndpoint: 'TELEPAT-SOCKET-ENDPOINT',\n\t     *  apiKey: 'APP-API-KEY',\n\t     *  appId: 'APP-ID',\n\t     *  persistentConnection: {\n\t     *    type: 'ios',\n\t     *    token: 'DEVICE-NOTIFICATION-TOKEN',\n\t     *    active: 1\n\t     *  }\n\t     * });\n\t     */\n\t\n\t  }, {\n\t    key: 'connect',\n\t    value: function connect() {\n\t      var _this8 = this;\n\t\n\t      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\t\n\t      if (typeof options !== 'undefined') {\n\t        if (typeof options.apiKey === 'undefined') {\n\t          return callback((0, _error2.default)('Connect options must provide an apiKey property'));\n\t        }\n\t        if (typeof options.appId === 'undefined') {\n\t          return callback((0, _error2.default)('Connect options must provide an appId property'));\n\t        }\n\t        if (typeof options.apiEndpoint !== 'undefined') {\n\t          _api2.default.apiEndpoint = options.apiEndpoint + '/';\n\t        } else if (!_api2.default.apiEndpoint) {\n\t          return callback((0, _error2.default)('Connect options must provide an apiEndpoint property, or you must run `configure` first'));\n\t        }\n\t        if (typeof options.socketEndpoint !== 'undefined') {\n\t          this._socketEndpoint = options.socketEndpoint;\n\t        } else if (!this._socketEndpoint) {\n\t          return callback((0, _error2.default)('Connect options must provide an socketEndpoint property, or you must run `configure` first'));\n\t        }\n\t        if (typeof options.timerInterval !== 'undefined') {\n\t          this._monitor.timerInterval = options.timerInterval;\n\t        }\n\t      } else {\n\t        return callback((0, _error2.default)('Options object not provided to the connect function'));\n\t      }\n\t\n\t      var signalConnectFailed = function signalConnectFailed(err) {\n\t        _this8.connected = false;\n\t        _this8.connecting = false;\n\t        _this8.currentAppId = null;\n\t        callback((0, _error2.default)('Device registration failed with error: ' + err));\n\t        _this8._event.emit('connect_error', err);\n\t      };\n\t\n\t      var signalConnectSucceded = function signalConnectSucceded() {\n\t        _this8.connected = true;\n\t        _this8.connecting = false;\n\t        _this8.currentAppId = _api2.default.appId;\n\t        callback(null);\n\t        _this8._event.emit('connect');\n\t        _this8._event.emit('ready');\n\t      };\n\t\n\t      var populateData = function populateData() {\n\t        _this8.getCollections(function (err) {\n\t          if (err) {\n\t            signalConnectFailed(err);\n\t          } else {\n\t            _this8._updateUser(options.reauth, function () {\n\t              signalConnectSucceded();\n\t            });\n\t          }\n\t        });\n\t      };\n\t\n\t      var postRegister = function postRegister(err, res) {\n\t        if (err) {\n\t          signalConnectFailed(err);\n\t        } else {\n\t          if (!_this8._persistentConnectionOptions || _this8._persistentConnectionOptions.active !== 1) {\n\t            _this8.connectVolatileTransport({}, function (err) {\n\t              if (err) {\n\t                signalConnectFailed(err);\n\t              } else {\n\t                populateData();\n\t              }\n\t            });\n\t          } else {\n\t            populateData();\n\t          }\n\t        }\n\t      };\n\t\n\t      // START CONNECTION PROCESS\n\t\n\t      if (this.connected) {\n\t        this.connected = false;\n\t        this.disconnect();\n\t      }\n\t      this.connecting = true;\n\t\n\t      _api2.default.apiKey = options.apiKey;\n\t      _api2.default.appId = options.appId;\n\t\n\t      if (this.admin && this.admin.apps) {\n\t        this.admin.app = this.admin.apps[_api2.default.appId];\n\t      }\n\t\n\t      this._persistentConnectionOptions = options.persistentConnection || this._persistentConnectionOptions;\n\t\n\t      if (options.updateUDID) {\n\t        this.registerDevice(postRegister);\n\t      } else {\n\t        this._getSavedUDID(function (err, udid) {\n\t          if (!err) {\n\t            _api2.default.UDID = udid;\n\t          }\n\t          _this8.registerDevice(postRegister);\n\t        });\n\t      }\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Call this function to disconnect the client from the Telepat backend.\n\t     * @fires Telepat.event:disconnect\n\t     * @fires Telepat.event:volatile_disconnect\n\t     */\n\t\n\t  }, {\n\t    key: 'disconnect',\n\t    value: function disconnect() {\n\t      var _this9 = this;\n\t\n\t      this.disconnectVolatileTransport();\n\t      this.collections = null;\n\t      this._monitor.remove({ channel: { model: 'context' } });\n\t\n\t      for (var key in this.subscriptions) {\n\t        this.subscriptions[key].unsubscribe();\n\t      }\n\t      this.subscriptions = {};\n\t\n\t      if (!this.user.isAdmin) {\n\t        this.user.logout(function () {\n\t          _this9.admin.unhook();\n\t          _this9.admin = null;\n\t          _this9.user = null;\n\t        });\n\t      }\n\t\n\t      _api2.default.apiKey = null;\n\t      _api2.default.appId = null;\n\t      _api2.default.UDID = null;\n\t\n\t      this._event.emit('disconnect');\n\t      this.currentAppId = null;\n\t      this.connected = false;\n\t    }\n\t  }, {\n\t    key: 'processMessage',\n\t\n\t\n\t    /**\n\t     * Forwards messages reveived via external channels to the processing unit.\n\t     * Use this if you've configured external transports (like push notifications), and you need to pass received payloads\n\t     * to the processing engine.\n\t     *\n\t     * @param {string} message The delta update notification received from Telepat\n\t     */\n\t    value: function processMessage(message) {\n\t      this._monitor.processMessage(message);\n\t    }\n\t\n\t    /**\n\t     * You can tweak the logger verbosity using this function.\n\t     *\n\t     * @param {string} level One of `'debug'`, `'info'`, `'warn'` or `'error'`\n\t     */\n\t\n\t  }, {\n\t    key: 'setLogLevel',\n\t    value: function setLogLevel(level) {\n\t      _logger2.default.setLevel(level);\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Invoked when client has connected to the backend.\n\t     *\n\t     * @event connect\n\t     */\n\t    /**\n\t     * Invoked when client has connected to the backend. Alias for the `connect` event.\n\t     *\n\t     * @event ready\n\t     */\n\t    /**\n\t     * Invoked when client has disconnected from the backend.\n\t     *\n\t     * @event disconnect\n\t     * @type {Error}\n\t     */\n\t    /**\n\t     * Invoked when volatile transport has been (temporarily) disconnected.\n\t     *\n\t     * @event volatile_disconnect\n\t     * @type {Error}\n\t     */\n\t    /**\n\t     * Invoked when volatile transport has reconnected.\n\t     *\n\t     * @event reconnect\n\t     * @type {Error}\n\t     */\n\t    /**\n\t     * Invoked when volatile transport has failed to reconnect.\n\t     *\n\t     * @event reconnect_failed\n\t     * @type {Error}\n\t     */\n\t    /**\n\t     * Invoked when client configuration has completed.\n\t     *\n\t     * @event configure\n\t     */\n\t    /**\n\t     * Invoked on connection error.\n\t     *\n\t     * @event connect_error\n\t     * @type {Error}\n\t     */\n\t    /**\n\t     * Invoked when the available collections have updated.\n\t     *\n\t     * @event collections_update\n\t     */\n\t    /**\n\t     * Invoked when client has successfully logged in.\n\t     *\n\t     * @event login\n\t     */\n\t    /**\n\t     * Invoked when there was an error with logging in.\n\t     *\n\t     * @event login_error\n\t     * @type {Error}\n\t     */\n\t    /**\n\t     * Invoked when client has successfully logged out.\n\t     *\n\t     * @event logout\n\t     */\n\t    /**\n\t     * Invoked when there was an error with logging out.\n\t     *\n\t     * @event logout_error\n\t     * @type {Error}\n\t     */\n\t\n\t    /**\n\t     * Call this function to add callbacks to be invoked on event triggers.\n\t     * Available callbacks:\n\t     *\n\t     * | Name                                                          | Description           |\n\t     * | ------------------------------------------------------------- | --------------------- |\n\t     * | {@link #Telepat.event:connect connect}                        | Invoked when client has connected to the backend |\n\t     * | {@link #Telepat.event:ready ready}                            | Alias for the connect event |\n\t     * | {@link #Telepat.event:disconnect disconnect}                  | Invoked when client has disconnected from the backend |\n\t     * | {@link #Telepat.event:reconnect reconnect}                    | Invoked when volatile transport has reconnected |\n\t     * | {@link #Telepat.event:reconnect_failed reconnect_failed}      | Invoked when volatile transport reconnection failed |\n\t     * | {@link #Telepat.event:volatile_disconnect volatile_disconnect}| Invoked when volatile transport has been disconnected |\n\t     * | {@link #Telepat.event:configure configure}                    | Invoked when client configuration has completed |\n\t     * | {@link #Telepat.event:connect_error connect_error}            | Invoked on connection errors |\n\t     * | {@link #Telepat.event:collections_update collections_update}  | Invoked when the available collections have updated |\n\t     * | {@link #Telepat.event:login login}                            | Invoked when client has successfully logged in |\n\t     * | {@link #Telepat.event:login_error login_error}                | Invoked when there was an error with logging in |\n\t     * | {@link #Telepat.event:logout logout}                          | Invoked when client has successfully logged out |\n\t     * | {@link #Telepat.event:logout_error logout_error}              | Invoked when there was an error with logging out |\n\t     *\n\t     * @param {string} name The name of the event to associate the callback with\n\t     * @param {function} callback The callback to be executed\n\t     * @return {number} A callback id. Save this in order to later remove the callback from the event (using {@link #Telepat#removeCallback removeCallback})\n\t     *\n\t     * @example\n\t     * telepat.on('connect', () => {\n\t     *  console.log('connected');\n\t     * });\n\t     */\n\t\n\t  }, {\n\t    key: 'on',\n\t    value: function on(name, callback) {\n\t      if ((name === 'connect' || name === 'ready') && this.connected) {\n\t        setTimeout(callback, 0);\n\t      }\n\t      return this._event.on(name, callback);\n\t    }\n\t  }, {\n\t    key: 'removeCallback',\n\t\n\t\n\t    /**\n\t     * Call this function to remove callbacks that have been set using {@link #Telepat#on on}.\n\t     *\n\t     * @param {string} name The name of the event the callback was associated with\n\t     * @param {number} callbackId The callback id returned by calling {@link #Telepat#on on}\n\t     *\n\t     * @example\n\t     * let connectCallbackId = telepat.on('connect', () => {\n\t     *  // Remove the callback after the first connection event\n\t     *  telepat.removeCallback(connectCallbackId);\n\t     * });\n\t     */\n\t    value: function removeCallback(name, index) {\n\t      return this._event.removeCallback(name, index);\n\t    }\n\t  }, {\n\t    key: 'subscribe',\n\t\n\t\n\t    /**\n\t     * Use this function to create a new {@link Channel} object and retrieve its objects.\n\t     *\n\t     * @param {Object} options The object describing the required subscription\n\t     * @param {function} onSubscribe Callback invoked when subscription is ready\n\t     * @param {Object} [options.channel] Describes the basic properties of the objects requested\n\t     * @param {string} [options.channel.context] The id of the collection in which you're searching for objects\n\t     * @param {string} [options.channel.model] The model of the objects you're searching for (needs to be defined in the schema first)\n\t     * @param {string} [options.channel.id] If set, specifies the id of the unique object that you're querying for\n\t     * @param {Object} [options.channel.parent] If set, specifies the parent id and parent model of the objects you're querying for.\n\t     * @param {string} [options.channel.parent.model] The model of the parent object\n\t     * @param {string} [options.channel.parent.id] The id of the parent object\n\t     * @param {string} [options.channel.user] If set, specifies the user id of the creator of the objects you're querying for.\n\t     * @param {Object} [options.sort] An object that defines how returned objects should be sorted. Each object key is a property name, and each value can be either `asc` or `desc`.\n\t     * @param {Object} [options.filters] An object describing how returned objects should be filtered.\n\t     * @param {number} [options.offset] The offset that should be applied for the returned objects (for pagination)\n\t     * @param {number} [options.limit] The maximum number of objects to be returned in this batch (for pagination)\n\t     * @return {Channel} The new {@link Channel} object\n\t     *\n\t     * @example\n\t     * // A simple subscription to all objects of type `article`\n\t     * // in a specific collection\n\t     *\n\t     * let articleChannel = telepat.subscribe({\n\t     *  channel: {\n\t     *    context: 'context-unique-identifier',\n\t     *    model: 'article'\n\t     *  }\n\t     * }, () => {\n\t     *  console.log(articleChannel.objectsArray);\n\t     * });\n\t     *\n\t     * @example\n\t     * // A filtered subscription to all objects of type `article`\n\t     * // in a specific collection, that have one of two specific tag values\n\t     *\n\t     * let articleChannel = telepat.subscribe({\n\t     *  channel: {\n\t     *    context: 'context-unique-identifier',\n\t     *    model: 'article'\n\t     *  },\n\t     *  filters: {\n\t     *    or: [\n\t     *      {\n\t     *        is: {\n\t     *          tag: 'specific-tag-value'\n\t     *        }\n\t     *      },\n\t     *      {\n\t     *        is: {\n\t     *          tag: 'another-tag-value'\n\t     *        }\n\t     *      }\n\t     *    ]\n\t     *  }\n\t     * }, () => {\n\t     *  console.log(articleChannel.objectsArray);\n\t     * });\n\t     *\n\t     * @example\n\t     * // A simple subscription to all objects of type `article`\n\t     * // in a specific collection, sorted by created date descending\n\t     *\n\t     * let articleChannel = telepat.subscribe({\n\t     *  channel: {\n\t     *    context: 'context-unique-identifier',\n\t     *    model: 'article'\n\t     *  },\n\t     *  sort: {\n\t     *    created: 'desc'\n\t     *  }\n\t     * }, () => {\n\t     *  console.log(articleChannel.objectsArray);\n\t     * });\n\t     *\n\t     * @example\n\t     * // A simple subscription to all objects of type `comment`\n\t     * // in a specific collection, that belong to a specific article parent\n\t     *\n\t     * let articleChannel = telepat.subscribe({\n\t     *  channel: {\n\t     *    context: 'context-unique-identifier',\n\t     *    model: 'comment',\n\t     *    parent: {\n\t     *      model: 'article',\n\t     *      id: 'article-parent-unique-identifier'\n\t     *    }\n\t     *  }\n\t     * }, () => {\n\t     *  console.log(articleChannel.objectsArray);\n\t     * });\n\t     */\n\t    value: function subscribe(options, onSubscribe) {\n\t      var _this10 = this;\n\t\n\t      var channel = new _channel2.default(this._monitor, options);\n\t      var key = _monitor2.default.subscriptionKeyForOptions(options);\n\t\n\t      this.subscriptions[key] = channel;\n\t      channel.subscribe();\n\t      if (onSubscribe !== undefined) {\n\t        channel.on('subscribe', onSubscribe);\n\t      }\n\t      channel.on('_unsubscribe', function () {\n\t        delete _this10.subscriptions[key];\n\t      });\n\t      return channel;\n\t    }\n\t  }, {\n\t    key: 'getChannel',\n\t\n\t\n\t    /**\n\t     * Same as {@link #Telepat#subscribe subscribe} method, but returns the new {@link Channel} object without calling subscribe on it.\n\t     *\n\t     * @param  {Object} options Same as {@link #Telepat#subscribe subscribe} Options\n\t     * @return {Channel} The new {@link Channel} object\n\t     */\n\t    value: function getChannel(options) {\n\t      var key = _monitor2.default.subscriptionKeyForOptions(options);\n\t\n\t      if (this.subscriptions[key]) {\n\t        return this.subscriptions[key];\n\t      }\n\t      return new _channel2.default(this._monitor, options);\n\t    }\n\t  }, {\n\t    key: 'sendEmail',\n\t    value: function sendEmail(from, fromName, to, subject, body, callback) {\n\t      _api2.default.call('/email', {\n\t        'recipients': to,\n\t        'from': from,\n\t        'from_name': fromName,\n\t        'subject': subject,\n\t        'body': body\n\t      }, function (err, res) {\n\t        if (err) {\n\t          callback((0, _error2.default)('Send email failed with error: ' + err), null);\n\t        } else {\n\t          callback(null, res.body.content);\n\t        }\n\t      });\n\t    }\n\t  }, {\n\t    key: 'get',\n\t    value: function get(options, callback) {\n\t      options['no_subscribe'] = true;\n\t      _api2.default.call('object/subscribe', options, function (err, res) {\n\t        if (err) {\n\t          callback((0, _error2.default)('Get objects failed with error: ' + err), null);\n\t        } else {\n\t          callback(null, res.body.content);\n\t        }\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return Telepat;\n\t}();\n\t\n\texports.default = Telepat;\n\t;\n\t\n\t/**\n\t * This callback is displayed as part of the Requester class.\n\t * @callback TelepatCallback\n\t * @param {Error} err If there was an error processing the requested operation, this will reference the error object resulted\n\t * @param {*} res The operation response\n\t */\n\n\tmodule.exports = exports['default'];\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\tprocess.prependListener = noop;\n\tprocess.prependOnceListener = noop;\n\t\n\tprocess.listeners = function (name) { return [] }\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tconsole.log(\"I'm `fs` modules\");\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\t\n\tvar uuidV4 = _interopDefault(__webpack_require__(4));\n\tvar lie = _interopDefault(__webpack_require__(9));\n\tvar getArguments = _interopDefault(__webpack_require__(11));\n\tvar events = __webpack_require__(12);\n\tvar inherits = _interopDefault(__webpack_require__(13));\n\tvar nextTick = _interopDefault(__webpack_require__(10));\n\tvar debug = _interopDefault(__webpack_require__(14));\n\tvar Md5 = _interopDefault(__webpack_require__(17));\n\tvar vuvuzela = _interopDefault(__webpack_require__(18));\n\t\n\t/* istanbul ignore next */\n\tvar PouchPromise$1 = typeof Promise === 'function' ? Promise : lie;\n\t\n\tfunction isBinaryObject(object) {\n\t  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||\n\t    (typeof Blob !== 'undefined' && object instanceof Blob);\n\t}\n\t\n\tfunction cloneArrayBuffer(buff) {\n\t  if (typeof buff.slice === 'function') {\n\t    return buff.slice(0);\n\t  }\n\t  // IE10-11 slice() polyfill\n\t  var target = new ArrayBuffer(buff.byteLength);\n\t  var targetArray = new Uint8Array(target);\n\t  var sourceArray = new Uint8Array(buff);\n\t  targetArray.set(sourceArray);\n\t  return target;\n\t}\n\t\n\tfunction cloneBinaryObject(object) {\n\t  if (object instanceof ArrayBuffer) {\n\t    return cloneArrayBuffer(object);\n\t  }\n\t  var size = object.size;\n\t  var type = object.type;\n\t  // Blob\n\t  if (typeof object.slice === 'function') {\n\t    return object.slice(0, size, type);\n\t  }\n\t  // PhantomJS slice() replacement\n\t  return object.webkitSlice(0, size, type);\n\t}\n\t\n\t// most of this is borrowed from lodash.isPlainObject:\n\t// https://github.com/fis-components/lodash.isplainobject/\n\t// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js\n\t\n\tvar funcToString = Function.prototype.toString;\n\tvar objectCtorString = funcToString.call(Object);\n\t\n\tfunction isPlainObject(value) {\n\t  var proto = Object.getPrototypeOf(value);\n\t  /* istanbul ignore if */\n\t  if (proto === null) { // not sure when this happens, but I guess it can\n\t    return true;\n\t  }\n\t  var Ctor = proto.constructor;\n\t  return (typeof Ctor == 'function' &&\n\t    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n\t}\n\t\n\tfunction clone(object) {\n\t  var newObject;\n\t  var i;\n\t  var len;\n\t\n\t  if (!object || typeof object !== 'object') {\n\t    return object;\n\t  }\n\t\n\t  if (Array.isArray(object)) {\n\t    newObject = [];\n\t    for (i = 0, len = object.length; i < len; i++) {\n\t      newObject[i] = clone(object[i]);\n\t    }\n\t    return newObject;\n\t  }\n\t\n\t  // special case: to avoid inconsistencies between IndexedDB\n\t  // and other backends, we automatically stringify Dates\n\t  if (object instanceof Date) {\n\t    return object.toISOString();\n\t  }\n\t\n\t  if (isBinaryObject(object)) {\n\t    return cloneBinaryObject(object);\n\t  }\n\t\n\t  if (!isPlainObject(object)) {\n\t    return object; // don't clone objects like Workers\n\t  }\n\t\n\t  newObject = {};\n\t  for (i in object) {\n\t    /* istanbul ignore else */\n\t    if (Object.prototype.hasOwnProperty.call(object, i)) {\n\t      var value = clone(object[i]);\n\t      if (typeof value !== 'undefined') {\n\t        newObject[i] = value;\n\t      }\n\t    }\n\t  }\n\t  return newObject;\n\t}\n\t\n\tfunction once(fun) {\n\t  var called = false;\n\t  return getArguments(function (args) {\n\t    /* istanbul ignore if */\n\t    if (called) {\n\t      // this is a smoke test and should never actually happen\n\t      throw new Error('once called more than once');\n\t    } else {\n\t      called = true;\n\t      fun.apply(this, args);\n\t    }\n\t  });\n\t}\n\t\n\tfunction toPromise(func) {\n\t  //create the function we will be returning\n\t  return getArguments(function (args) {\n\t    // Clone arguments\n\t    args = clone(args);\n\t    var self = this;\n\t    // if the last argument is a function, assume its a callback\n\t    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n\t    var promise = new PouchPromise$1(function (fulfill, reject) {\n\t      var resp;\n\t      try {\n\t        var callback = once(function (err, mesg) {\n\t          if (err) {\n\t            reject(err);\n\t          } else {\n\t            fulfill(mesg);\n\t          }\n\t        });\n\t        // create a callback for this invocation\n\t        // apply the function in the orig context\n\t        args.push(callback);\n\t        resp = func.apply(self, args);\n\t        if (resp && typeof resp.then === 'function') {\n\t          fulfill(resp);\n\t        }\n\t      } catch (e) {\n\t        reject(e);\n\t      }\n\t    });\n\t    // if there is a callback, call it back\n\t    if (usedCB) {\n\t      promise.then(function (result) {\n\t        usedCB(null, result);\n\t      }, usedCB);\n\t    }\n\t    return promise;\n\t  });\n\t}\n\t\n\tfunction logApiCall(self, name, args) {\n\t  /* istanbul ignore if */\n\t  if (self.constructor.listeners('debug').length) {\n\t    var logArgs = ['api', self.name, name];\n\t    for (var i = 0; i < args.length - 1; i++) {\n\t      logArgs.push(args[i]);\n\t    }\n\t    self.constructor.emit('debug', logArgs);\n\t\n\t    // override the callback itself to log the response\n\t    var origCallback = args[args.length - 1];\n\t    args[args.length - 1] = function (err, res) {\n\t      var responseArgs = ['api', self.name, name];\n\t      responseArgs = responseArgs.concat(\n\t        err ? ['error', err] : ['success', res]\n\t      );\n\t      self.constructor.emit('debug', responseArgs);\n\t      origCallback(err, res);\n\t    };\n\t  }\n\t}\n\t\n\tfunction adapterFun(name, callback) {\n\t  return toPromise(getArguments(function (args) {\n\t    if (this._closed) {\n\t      return PouchPromise$1.reject(new Error('database is closed'));\n\t    }\n\t    if (this._destroyed) {\n\t      return PouchPromise$1.reject(new Error('database is destroyed'));\n\t    }\n\t    var self = this;\n\t    logApiCall(self, name, args);\n\t    if (!this.taskqueue.isReady) {\n\t      return new PouchPromise$1(function (fulfill, reject) {\n\t        self.taskqueue.addTask(function (failed) {\n\t          if (failed) {\n\t            reject(failed);\n\t          } else {\n\t            fulfill(self[name].apply(self, args));\n\t          }\n\t        });\n\t      });\n\t    }\n\t    return callback.apply(this, args);\n\t  }));\n\t}\n\t\n\tfunction mangle(key) {\n\t  return '$' + key;\n\t}\n\tfunction unmangle(key) {\n\t  return key.substring(1);\n\t}\n\tfunction Map$1() {\n\t  this._store = {};\n\t}\n\tMap$1.prototype.get = function (key) {\n\t  var mangled = mangle(key);\n\t  return this._store[mangled];\n\t};\n\tMap$1.prototype.set = function (key, value) {\n\t  var mangled = mangle(key);\n\t  this._store[mangled] = value;\n\t  return true;\n\t};\n\tMap$1.prototype.has = function (key) {\n\t  var mangled = mangle(key);\n\t  return mangled in this._store;\n\t};\n\tMap$1.prototype.delete = function (key) {\n\t  var mangled = mangle(key);\n\t  var res = mangled in this._store;\n\t  delete this._store[mangled];\n\t  return res;\n\t};\n\tMap$1.prototype.forEach = function (cb) {\n\t  var keys = Object.keys(this._store);\n\t  for (var i = 0, len = keys.length; i < len; i++) {\n\t    var key = keys[i];\n\t    var value = this._store[key];\n\t    key = unmangle(key);\n\t    cb(value, key);\n\t  }\n\t};\n\tObject.defineProperty(Map$1.prototype, 'size', {\n\t  get: function () {\n\t    return Object.keys(this._store).length;\n\t  }\n\t});\n\t\n\tfunction Set$1(array) {\n\t  this._store = new Map$1();\n\t\n\t  // init with an array\n\t  if (array && Array.isArray(array)) {\n\t    for (var i = 0, len = array.length; i < len; i++) {\n\t      this.add(array[i]);\n\t    }\n\t  }\n\t}\n\tSet$1.prototype.add = function (key) {\n\t  return this._store.set(key, true);\n\t};\n\tSet$1.prototype.has = function (key) {\n\t  return this._store.has(key);\n\t};\n\tSet$1.prototype.forEach = function (cb) {\n\t  this._store.forEach(function (value, key) {\n\t    cb(key);\n\t  });\n\t};\n\tObject.defineProperty(Set$1.prototype, 'size', {\n\t  get: function () {\n\t    return this._store.size;\n\t  }\n\t});\n\t\n\t/* global Map,Set,Symbol */\n\t// Based on https://kangax.github.io/compat-table/es6/ we can sniff out\n\t// incomplete Map/Set implementations which would otherwise cause our tests to fail.\n\t// Notably they fail in IE11 and iOS 8.4, which this prevents.\n\tfunction supportsMapAndSet() {\n\t  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {\n\t    return false;\n\t  }\n\t  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);\n\t  return prop && 'get' in prop && Map[Symbol.species] === Map;\n\t}\n\t\n\t// based on https://github.com/montagejs/collections\n\t/* global Map,Set */\n\t\n\tvar ExportedSet;\n\tvar ExportedMap;\n\t\n\t{\n\t  if (supportsMapAndSet()) { // prefer built-in Map/Set\n\t    ExportedSet = Set;\n\t    ExportedMap = Map;\n\t  } else { // fall back to our polyfill\n\t    ExportedSet = Set$1;\n\t    ExportedMap = Map$1;\n\t  }\n\t}\n\t\n\t// like underscore/lodash _.pick()\n\tfunction pick(obj, arr) {\n\t  var res = {};\n\t  for (var i = 0, len = arr.length; i < len; i++) {\n\t    var prop = arr[i];\n\t    if (prop in obj) {\n\t      res[prop] = obj[prop];\n\t    }\n\t  }\n\t  return res;\n\t}\n\t\n\t// Most browsers throttle concurrent requests at 6, so it's silly\n\t// to shim _bulk_get by trying to launch potentially hundreds of requests\n\t// and then letting the majority time out. We can handle this ourselves.\n\tvar MAX_NUM_CONCURRENT_REQUESTS = 6;\n\t\n\tfunction identityFunction(x) {\n\t  return x;\n\t}\n\t\n\tfunction formatResultForOpenRevsGet(result) {\n\t  return [{\n\t    ok: result\n\t  }];\n\t}\n\t\n\t// shim for P/CouchDB adapters that don't directly implement _bulk_get\n\tfunction bulkGet(db, opts, callback) {\n\t  var requests = opts.docs;\n\t\n\t  // consolidate into one request per doc if possible\n\t  var requestsById = new ExportedMap();\n\t  requests.forEach(function (request) {\n\t    if (requestsById.has(request.id)) {\n\t      requestsById.get(request.id).push(request);\n\t    } else {\n\t      requestsById.set(request.id, [request]);\n\t    }\n\t  });\n\t\n\t  var numDocs = requestsById.size;\n\t  var numDone = 0;\n\t  var perDocResults = new Array(numDocs);\n\t\n\t  function collapseResultsAndFinish() {\n\t    var results = [];\n\t    perDocResults.forEach(function (res) {\n\t      res.docs.forEach(function (info) {\n\t        results.push({\n\t          id: res.id,\n\t          docs: [info]\n\t        });\n\t      });\n\t    });\n\t    callback(null, {results: results});\n\t  }\n\t\n\t  function checkDone() {\n\t    if (++numDone === numDocs) {\n\t      collapseResultsAndFinish();\n\t    }\n\t  }\n\t\n\t  function gotResult(docIndex, id, docs) {\n\t    perDocResults[docIndex] = {id: id, docs: docs};\n\t    checkDone();\n\t  }\n\t\n\t  var allRequests = [];\n\t  requestsById.forEach(function (value, key) {\n\t    allRequests.push(key);\n\t  });\n\t\n\t  var i = 0;\n\t\n\t  function nextBatch() {\n\t\n\t    if (i >= allRequests.length) {\n\t      return;\n\t    }\n\t\n\t    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);\n\t    var batch = allRequests.slice(i, upTo);\n\t    processBatch(batch, i);\n\t    i += batch.length;\n\t  }\n\t\n\t  function processBatch(batch, offset) {\n\t    batch.forEach(function (docId, j) {\n\t      var docIdx = offset + j;\n\t      var docRequests = requestsById.get(docId);\n\t\n\t      // just use the first request as the \"template\"\n\t      // TODO: The _bulk_get API allows for more subtle use cases than this,\n\t      // but for now it is unlikely that there will be a mix of different\n\t      // \"atts_since\" or \"attachments\" in the same request, since it's just\n\t      // replicate.js that is using this for the moment.\n\t      // Also, atts_since is aspirational, since we don't support it yet.\n\t      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n\t      docOpts.open_revs = docRequests.map(function (request) {\n\t        // rev is optional, open_revs disallowed\n\t        return request.rev;\n\t      });\n\t\n\t      // remove falsey / undefined revisions\n\t      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);\n\t\n\t      var formatResult = identityFunction;\n\t\n\t      if (docOpts.open_revs.length === 0) {\n\t        delete docOpts.open_revs;\n\t\n\t        // when fetching only the \"winning\" leaf,\n\t        // transform the result so it looks like an open_revs\n\t        // request\n\t        formatResult = formatResultForOpenRevsGet;\n\t      }\n\t\n\t      // globally-supplied options\n\t      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {\n\t        if (param in opts) {\n\t          docOpts[param] = opts[param];\n\t        }\n\t      });\n\t      db.get(docId, docOpts, function (err, res) {\n\t        var result;\n\t        /* istanbul ignore if */\n\t        if (err) {\n\t          result = [{error: err}];\n\t        } else {\n\t          result = formatResult(res);\n\t        }\n\t        gotResult(docIdx, docId, result);\n\t        nextBatch();\n\t      });\n\t    });\n\t  }\n\t\n\t  nextBatch();\n\t\n\t}\n\t\n\tfunction isChromeApp() {\n\t  return (typeof chrome !== \"undefined\" &&\n\t    typeof chrome.storage !== \"undefined\" &&\n\t    typeof chrome.storage.local !== \"undefined\");\n\t}\n\t\n\tvar hasLocal;\n\t\n\tif (isChromeApp()) {\n\t  hasLocal = false;\n\t} else {\n\t  try {\n\t    localStorage.setItem('_pouch_check_localstorage', 1);\n\t    hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n\t  } catch (e) {\n\t    hasLocal = false;\n\t  }\n\t}\n\t\n\tfunction hasLocalStorage() {\n\t  return hasLocal;\n\t}\n\t\n\t// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We\n\t// avoid using process.nextTick() directly because the polyfill is very large and we don't\n\t// need all of it (see: https://github.com/defunctzombie/node-process).\n\t// \"immediate\" 3.0.8 is used by lie, and it's a smaller version of the latest \"immediate\"\n\t// package, so it's the one we use.\n\t// When we use nextTick() in our codebase, we only care about not releasing Zalgo\n\t// (see: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony).\n\t// Microtask vs macrotask doesn't matter to us. So we're free to use the fastest\n\t// (least latency) option, which is \"immediate\" due to use of microtasks.\n\t// All of our nextTicks are isolated to this one function so we can easily swap out one\n\t// implementation for another.\n\t\n\tinherits(Changes, events.EventEmitter);\n\t\n\t/* istanbul ignore next */\n\tfunction attachBrowserEvents(self) {\n\t  if (isChromeApp()) {\n\t    chrome.storage.onChanged.addListener(function (e) {\n\t      // make sure it's event addressed to us\n\t      if (e.db_name != null) {\n\t        //object only has oldValue, newValue members\n\t        self.emit(e.dbName.newValue);\n\t      }\n\t    });\n\t  } else if (hasLocalStorage()) {\n\t    if (typeof addEventListener !== 'undefined') {\n\t      addEventListener(\"storage\", function (e) {\n\t        self.emit(e.key);\n\t      });\n\t    } else { // old IE\n\t      window.attachEvent(\"storage\", function (e) {\n\t        self.emit(e.key);\n\t      });\n\t    }\n\t  }\n\t}\n\t\n\tfunction Changes() {\n\t  events.EventEmitter.call(this);\n\t  this._listeners = {};\n\t\n\t  attachBrowserEvents(this);\n\t}\n\tChanges.prototype.addListener = function (dbName, id, db, opts) {\n\t  /* istanbul ignore if */\n\t  if (this._listeners[id]) {\n\t    return;\n\t  }\n\t  var self = this;\n\t  var inprogress = false;\n\t  function eventFunction() {\n\t    /* istanbul ignore if */\n\t    if (!self._listeners[id]) {\n\t      return;\n\t    }\n\t    if (inprogress) {\n\t      inprogress = 'waiting';\n\t      return;\n\t    }\n\t    inprogress = true;\n\t    var changesOpts = pick(opts, [\n\t      'style', 'include_docs', 'attachments', 'conflicts', 'filter',\n\t      'doc_ids', 'view', 'since', 'query_params', 'binary'\n\t    ]);\n\t\n\t    /* istanbul ignore next */\n\t    function onError() {\n\t      inprogress = false;\n\t    }\n\t\n\t    db.changes(changesOpts).on('change', function (c) {\n\t      if (c.seq > opts.since && !opts.cancelled) {\n\t        opts.since = c.seq;\n\t        opts.onChange(c);\n\t      }\n\t    }).on('complete', function () {\n\t      if (inprogress === 'waiting') {\n\t        nextTick(eventFunction);\n\t      }\n\t      inprogress = false;\n\t    }).on('error', onError);\n\t  }\n\t  this._listeners[id] = eventFunction;\n\t  this.on(dbName, eventFunction);\n\t};\n\t\n\tChanges.prototype.removeListener = function (dbName, id) {\n\t  /* istanbul ignore if */\n\t  if (!(id in this._listeners)) {\n\t    return;\n\t  }\n\t  events.EventEmitter.prototype.removeListener.call(this, dbName,\n\t    this._listeners[id]);\n\t  delete this._listeners[id];\n\t};\n\t\n\t\n\t/* istanbul ignore next */\n\tChanges.prototype.notifyLocalWindows = function (dbName) {\n\t  //do a useless change on a storage thing\n\t  //in order to get other windows's listeners to activate\n\t  if (isChromeApp()) {\n\t    chrome.storage.local.set({dbName: dbName});\n\t  } else if (hasLocalStorage()) {\n\t    localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\n\t  }\n\t};\n\t\n\tChanges.prototype.notify = function (dbName) {\n\t  this.emit(dbName);\n\t  this.notifyLocalWindows(dbName);\n\t};\n\t\n\tfunction guardedConsole(method) {\n\t  /* istanbul ignore else */\n\t  if (console !== 'undefined' && method in console) {\n\t    var args = Array.prototype.slice.call(arguments, 1);\n\t    console[method].apply(console, args);\n\t  }\n\t}\n\t\n\tfunction randomNumber(min, max) {\n\t  var maxTimeout = 600000; // Hard-coded default of 10 minutes\n\t  min = parseInt(min, 10) || 0;\n\t  max = parseInt(max, 10);\n\t  if (max !== max || max <= min) {\n\t    max = (min || 1) << 1; //doubling\n\t  } else {\n\t    max = max + 1;\n\t  }\n\t  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout\n\t  if (max > maxTimeout) {\n\t    min = maxTimeout >> 1; // divide by two\n\t    max = maxTimeout;\n\t  }\n\t  var ratio = Math.random();\n\t  var range = max - min;\n\t\n\t  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n\t}\n\t\n\tfunction defaultBackOff(min) {\n\t  var max = 0;\n\t  if (!min) {\n\t    max = 2000;\n\t  }\n\t  return randomNumber(min, max);\n\t}\n\t\n\t// designed to give info to browser users, who are disturbed\n\t// when they see http errors in the console\n\tfunction explainError(status, str) {\n\t  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);\n\t}\n\t\n\tvar assign;\n\t{\n\t  if (typeof Object.assign === 'function') {\n\t    assign = Object.assign;\n\t  } else {\n\t    // lite Object.assign polyfill based on\n\t    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\t    assign = function (target) {\n\t      var to = Object(target);\n\t\n\t      for (var index = 1; index < arguments.length; index++) {\n\t        var nextSource = arguments[index];\n\t\n\t        if (nextSource != null) { // Skip over if undefined or null\n\t          for (var nextKey in nextSource) {\n\t            // Avoid bugs when hasOwnProperty is shadowed\n\t            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n\t              to[nextKey] = nextSource[nextKey];\n\t            }\n\t          }\n\t        }\n\t      }\n\t      return to;\n\t    };\n\t  }\n\t}\n\t\n\tvar $inject_Object_assign = assign;\n\t\n\tinherits(PouchError, Error);\n\t\n\tfunction PouchError(status, error, reason) {\n\t  Error.call(this, reason);\n\t  this.status = status;\n\t  this.name = error;\n\t  this.message = reason;\n\t  this.error = true;\n\t}\n\t\n\tPouchError.prototype.toString = function () {\n\t  return JSON.stringify({\n\t    status: this.status,\n\t    name: this.name,\n\t    message: this.message,\n\t    reason: this.reason\n\t  });\n\t};\n\t\n\tvar UNAUTHORIZED = new PouchError(401, 'unauthorized', \"Name or password is incorrect.\");\n\tvar MISSING_BULK_DOCS = new PouchError(400, 'bad_request', \"Missing JSON list of 'docs'\");\n\tvar MISSING_DOC = new PouchError(404, 'not_found', 'missing');\n\tvar REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');\n\tvar INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');\n\tvar MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');\n\tvar RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');\n\tvar NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');\n\tvar UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');\n\tvar BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');\n\tvar INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');\n\tvar QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');\n\tvar DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');\n\tvar BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');\n\tvar NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');\n\tvar DB_MISSING = new PouchError(404, 'not_found', 'Database not found');\n\tvar IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');\n\tvar WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');\n\tvar LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');\n\tvar FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');\n\tvar INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');\n\tvar FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');\n\tvar MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\\'t found');\n\tvar INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');\n\t\n\tfunction createError(error, reason) {\n\t  function CustomPouchError(reason) {\n\t    // inherit error properties from our parent error manually\n\t    // so as to allow proper JSON parsing.\n\t    /* jshint ignore:start */\n\t    for (var p in error) {\n\t      if (typeof error[p] !== 'function') {\n\t        this[p] = error[p];\n\t      }\n\t    }\n\t    /* jshint ignore:end */\n\t    if (reason !== undefined) {\n\t      this.reason = reason;\n\t    }\n\t  }\n\t  CustomPouchError.prototype = PouchError.prototype;\n\t  return new CustomPouchError(reason);\n\t}\n\t\n\tfunction generateErrorFromResponse(err) {\n\t\n\t  if (typeof err !== 'object') {\n\t    var data = err;\n\t    err = UNKNOWN_ERROR;\n\t    err.data = data;\n\t  }\n\t\n\t  if ('error' in err && err.error === 'conflict') {\n\t    err.name = 'conflict';\n\t    err.status = 409;\n\t  }\n\t\n\t  if (!('name' in err)) {\n\t    err.name = err.error || 'unknown';\n\t  }\n\t\n\t  if (!('status' in err)) {\n\t    err.status = 500;\n\t  }\n\t\n\t  if (!('message' in err)) {\n\t    err.message = err.message || err.reason;\n\t  }\n\t\n\t  return err;\n\t}\n\t\n\tfunction tryFilter(filter, doc, req) {\n\t  try {\n\t    return !filter(doc, req);\n\t  } catch (err) {\n\t    var msg = 'Filter function threw: ' + err.toString();\n\t    return createError(BAD_REQUEST, msg);\n\t  }\n\t}\n\t\n\tfunction filterChange(opts) {\n\t  var req = {};\n\t  var hasFilter = opts.filter && typeof opts.filter === 'function';\n\t  req.query = opts.query_params;\n\t\n\t  return function filter(change) {\n\t    if (!change.doc) {\n\t      // CSG sends events on the changes feed that don't have documents,\n\t      // this hack makes a whole lot of existing code robust.\n\t      change.doc = {};\n\t    }\n\t\n\t    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\t\n\t    if (typeof filterReturn === 'object') {\n\t      return filterReturn;\n\t    }\n\t\n\t    if (filterReturn) {\n\t      return false;\n\t    }\n\t\n\t    if (!opts.include_docs) {\n\t      delete change.doc;\n\t    } else if (!opts.attachments) {\n\t      for (var att in change.doc._attachments) {\n\t        /* istanbul ignore else */\n\t        if (change.doc._attachments.hasOwnProperty(att)) {\n\t          change.doc._attachments[att].stub = true;\n\t        }\n\t      }\n\t    }\n\t    return true;\n\t  };\n\t}\n\t\n\tfunction flatten(arrs) {\n\t  var res = [];\n\t  for (var i = 0, len = arrs.length; i < len; i++) {\n\t    res = res.concat(arrs[i]);\n\t  }\n\t  return res;\n\t}\n\t\n\t// shim for Function.prototype.name,\n\t// for browsers that don't support it like IE\n\t\n\t/* istanbul ignore next */\n\tfunction f() {}\n\t\n\tvar hasName = f.name;\n\tvar res;\n\t\n\t// We dont run coverage in IE\n\t/* istanbul ignore else */\n\tif (hasName) {\n\t  res = function (fun) {\n\t    return fun.name;\n\t  };\n\t} else {\n\t  res = function (fun) {\n\t    return fun.toString().match(/^\\s*function\\s*(\\S*)\\s*\\(/)[1];\n\t  };\n\t}\n\t\n\t// Determine id an ID is valid\n\t//   - invalid IDs begin with an underescore that does not begin '_design' or\n\t//     '_local'\n\t//   - any other string value is a valid id\n\t// Returns the specific error object for each case\n\tfunction invalidIdError(id) {\n\t  var err;\n\t  if (!id) {\n\t    err = createError(MISSING_ID);\n\t  } else if (typeof id !== 'string') {\n\t    err = createError(INVALID_ID);\n\t  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\n\t    err = createError(RESERVED_ID);\n\t  }\n\t  if (err) {\n\t    throw err;\n\t  }\n\t}\n\t\n\t// Checks if a PouchDB object is \"remote\" or not. This is\n\t// designed to opt-in to certain optimizations, such as\n\t// avoiding checks for \"dependentDbs\" and other things that\n\t// we know only apply to local databases. In general, \"remote\"\n\t// should be true for the http adapter, and for third-party\n\t// adapters with similar expensive boundaries to cross for\n\t// every API call, such as socket-pouch and worker-pouch.\n\t// Previously, this was handled via db.type() === 'http'\n\t// which is now deprecated.\n\t\n\tfunction isRemote(db) {\n\t  if (typeof db._remote === 'boolean') {\n\t    return db._remote;\n\t  }\n\t  /* istanbul ignore next */\n\t  if (typeof db.type === 'function') {\n\t    guardedConsole('warn',\n\t      'db.type() is deprecated and will be removed in ' +\n\t      'a future version of PouchDB');\n\t    return db.type() === 'http';\n\t  }\n\t  /* istanbul ignore next */\n\t  return false;\n\t}\n\t\n\tfunction listenerCount(ee, type) {\n\t  return 'listenerCount' in ee ? ee.listenerCount(type) :\n\t                                 events.EventEmitter.listenerCount(ee, type);\n\t}\n\t\n\tfunction parseDesignDocFunctionName(s) {\n\t  if (!s) {\n\t    return null;\n\t  }\n\t  var parts = s.split('/');\n\t  if (parts.length === 2) {\n\t    return parts;\n\t  }\n\t  if (parts.length === 1) {\n\t    return [s, s];\n\t  }\n\t  return null;\n\t}\n\t\n\tfunction normalizeDesignDocFunctionName(s) {\n\t  var normalized = parseDesignDocFunctionName(s);\n\t  return normalized ? normalized.join('/') : null;\n\t}\n\t\n\t// originally parseUri 1.2.2, now patched by us\n\t// (c) Steven Levithan <stevenlevithan.com>\n\t// MIT License\n\tvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\",\n\t    \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\n\tvar qName =\"queryKey\";\n\tvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\t\n\t// use the \"loose\" parser\n\t/* eslint maxlen: 0, no-useless-escape: 0 */\n\tvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\t\n\tfunction parseUri(str) {\n\t  var m = parser.exec(str);\n\t  var uri = {};\n\t  var i = 14;\n\t\n\t  while (i--) {\n\t    var key = keys[i];\n\t    var value = m[i] || \"\";\n\t    var encoded = ['user', 'password'].indexOf(key) !== -1;\n\t    uri[key] = encoded ? decodeURIComponent(value) : value;\n\t  }\n\t\n\t  uri[qName] = {};\n\t  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n\t    if ($1) {\n\t      uri[qName][$1] = $2;\n\t    }\n\t  });\n\t\n\t  return uri;\n\t}\n\t\n\t// Based on https://github.com/alexdavid/scope-eval v0.0.3\n\t// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)\n\t// This is basically just a wrapper around new Function()\n\t\n\tfunction scopeEval(source, scope) {\n\t  var keys = [];\n\t  var values = [];\n\t  for (var key in scope) {\n\t    if (scope.hasOwnProperty(key)) {\n\t      keys.push(key);\n\t      values.push(scope[key]);\n\t    }\n\t  }\n\t  keys.push(source);\n\t  return Function.apply(null, keys).apply(null, values);\n\t}\n\t\n\t// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n\t// the diffFun tells us what delta to apply to the doc.  it either returns\n\t// the doc, or false if it doesn't need to do an update after all\n\tfunction upsert(db, docId, diffFun) {\n\t  return new PouchPromise$1(function (fulfill, reject) {\n\t    db.get(docId, function (err, doc) {\n\t      if (err) {\n\t        /* istanbul ignore next */\n\t        if (err.status !== 404) {\n\t          return reject(err);\n\t        }\n\t        doc = {};\n\t      }\n\t\n\t      // the user might change the _rev, so save it for posterity\n\t      var docRev = doc._rev;\n\t      var newDoc = diffFun(doc);\n\t\n\t      if (!newDoc) {\n\t        // if the diffFun returns falsy, we short-circuit as\n\t        // an optimization\n\t        return fulfill({updated: false, rev: docRev});\n\t      }\n\t\n\t      // users aren't allowed to modify these values,\n\t      // so reset them here\n\t      newDoc._id = docId;\n\t      newDoc._rev = docRev;\n\t      fulfill(tryAndPut(db, newDoc, diffFun));\n\t    });\n\t  });\n\t}\n\t\n\tfunction tryAndPut(db, doc, diffFun) {\n\t  return db.put(doc).then(function (res) {\n\t    return {\n\t      updated: true,\n\t      rev: res.rev\n\t    };\n\t  }, function (err) {\n\t    /* istanbul ignore next */\n\t    if (err.status !== 409) {\n\t      throw err;\n\t    }\n\t    return upsert(db, doc._id, diffFun);\n\t  });\n\t}\n\t\n\tfunction rev() {\n\t  return uuidV4.v4().replace(/-/g, '').toLowerCase();\n\t}\n\t\n\tvar uuid = uuidV4.v4;\n\t\n\t// We fetch all leafs of the revision tree, and sort them based on tree length\n\t// and whether they were deleted, undeleted documents with the longest revision\n\t// tree (most edits) win\n\t// The final sort algorithm is slightly documented in a sidebar here:\n\t// http://guide.couchdb.org/draft/conflicts.html\n\tfunction winningRev(metadata) {\n\t  var winningId;\n\t  var winningPos;\n\t  var winningDeleted;\n\t  var toVisit = metadata.rev_tree.slice();\n\t  var node;\n\t  while ((node = toVisit.pop())) {\n\t    var tree = node.ids;\n\t    var branches = tree[2];\n\t    var pos = node.pos;\n\t    if (branches.length) { // non-leaf\n\t      for (var i = 0, len = branches.length; i < len; i++) {\n\t        toVisit.push({pos: pos + 1, ids: branches[i]});\n\t      }\n\t      continue;\n\t    }\n\t    var deleted = !!tree[1].deleted;\n\t    var id = tree[0];\n\t    // sort by deleted, then pos, then id\n\t    if (!winningId || (winningDeleted !== deleted ? winningDeleted :\n\t        winningPos !== pos ? winningPos < pos : winningId < id)) {\n\t      winningId = id;\n\t      winningPos = pos;\n\t      winningDeleted = deleted;\n\t    }\n\t  }\n\t\n\t  return winningPos + '-' + winningId;\n\t}\n\t\n\t// Pretty much all below can be combined into a higher order function to\n\t// traverse revisions\n\t// The return value from the callback will be passed as context to all\n\t// children of that node\n\tfunction traverseRevTree(revs, callback) {\n\t  var toVisit = revs.slice();\n\t\n\t  var node;\n\t  while ((node = toVisit.pop())) {\n\t    var pos = node.pos;\n\t    var tree = node.ids;\n\t    var branches = tree[2];\n\t    var newCtx =\n\t      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);\n\t    for (var i = 0, len = branches.length; i < len; i++) {\n\t      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});\n\t    }\n\t  }\n\t}\n\t\n\tfunction sortByPos(a, b) {\n\t  return a.pos - b.pos;\n\t}\n\t\n\tfunction collectLeaves(revs) {\n\t  var leaves = [];\n\t  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {\n\t    if (isLeaf) {\n\t      leaves.push({rev: pos + \"-\" + id, pos: pos, opts: opts});\n\t    }\n\t  });\n\t  leaves.sort(sortByPos).reverse();\n\t  for (var i = 0, len = leaves.length; i < len; i++) {\n\t    delete leaves[i].pos;\n\t  }\n\t  return leaves;\n\t}\n\t\n\t// returns revs of all conflicts that is leaves such that\n\t// 1. are not deleted and\n\t// 2. are different than winning revision\n\tfunction collectConflicts(metadata) {\n\t  var win = winningRev(metadata);\n\t  var leaves = collectLeaves(metadata.rev_tree);\n\t  var conflicts = [];\n\t  for (var i = 0, len = leaves.length; i < len; i++) {\n\t    var leaf = leaves[i];\n\t    if (leaf.rev !== win && !leaf.opts.deleted) {\n\t      conflicts.push(leaf.rev);\n\t    }\n\t  }\n\t  return conflicts;\n\t}\n\t\n\t// compact a tree by marking its non-leafs as missing,\n\t// and return a list of revs to delete\n\tfunction compactTree(metadata) {\n\t  var revs = [];\n\t  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n\t                                               revHash, ctx, opts) {\n\t    if (opts.status === 'available' && !isLeaf) {\n\t      revs.push(pos + '-' + revHash);\n\t      opts.status = 'missing';\n\t    }\n\t  });\n\t  return revs;\n\t}\n\t\n\t// build up a list of all the paths to the leafs in this revision tree\n\tfunction rootToLeaf(revs) {\n\t  var paths = [];\n\t  var toVisit = revs.slice();\n\t  var node;\n\t  while ((node = toVisit.pop())) {\n\t    var pos = node.pos;\n\t    var tree = node.ids;\n\t    var id = tree[0];\n\t    var opts = tree[1];\n\t    var branches = tree[2];\n\t    var isLeaf = branches.length === 0;\n\t\n\t    var history = node.history ? node.history.slice() : [];\n\t    history.push({id: id, opts: opts});\n\t    if (isLeaf) {\n\t      paths.push({pos: (pos + 1 - history.length), ids: history});\n\t    }\n\t    for (var i = 0, len = branches.length; i < len; i++) {\n\t      toVisit.push({pos: pos + 1, ids: branches[i], history: history});\n\t    }\n\t  }\n\t  return paths.reverse();\n\t}\n\t\n\t// for a better overview of what this is doing, read:\n\t// https://github.com/apache/couchdb-couch/blob/master/src/couch_key_tree.erl\n\t//\n\t// But for a quick intro, CouchDB uses a revision tree to store a documents\n\t// history, A -> B -> C, when a document has conflicts, that is a branch in the\n\t// tree, A -> (B1 | B2 -> C), We store these as a nested array in the format\n\t//\n\t// KeyTree = [Path ... ]\n\t// Path = {pos: position_from_root, ids: Tree}\n\t// Tree = [Key, Opts, [Tree, ...]], in particular single node: [Key, []]\n\t\n\tfunction sortByPos$1(a, b) {\n\t  return a.pos - b.pos;\n\t}\n\t\n\t// classic binary search\n\tfunction binarySearch(arr, item, comparator) {\n\t  var low = 0;\n\t  var high = arr.length;\n\t  var mid;\n\t  while (low < high) {\n\t    mid = (low + high) >>> 1;\n\t    if (comparator(arr[mid], item) < 0) {\n\t      low = mid + 1;\n\t    } else {\n\t      high = mid;\n\t    }\n\t  }\n\t  return low;\n\t}\n\t\n\t// assuming the arr is sorted, insert the item in the proper place\n\tfunction insertSorted(arr, item, comparator) {\n\t  var idx = binarySearch(arr, item, comparator);\n\t  arr.splice(idx, 0, item);\n\t}\n\t\n\t// Turn a path as a flat array into a tree with a single branch.\n\t// If any should be stemmed from the beginning of the array, that's passed\n\t// in as the second argument\n\tfunction pathToTree(path, numStemmed) {\n\t  var root;\n\t  var leaf;\n\t  for (var i = numStemmed, len = path.length; i < len; i++) {\n\t    var node = path[i];\n\t    var currentLeaf = [node.id, node.opts, []];\n\t    if (leaf) {\n\t      leaf[2].push(currentLeaf);\n\t      leaf = currentLeaf;\n\t    } else {\n\t      root = leaf = currentLeaf;\n\t    }\n\t  }\n\t  return root;\n\t}\n\t\n\t// compare the IDs of two trees\n\tfunction compareTree(a, b) {\n\t  return a[0] < b[0] ? -1 : 1;\n\t}\n\t\n\t// Merge two trees together\n\t// The roots of tree1 and tree2 must be the same revision\n\tfunction mergeTree(in_tree1, in_tree2) {\n\t  var queue = [{tree1: in_tree1, tree2: in_tree2}];\n\t  var conflicts = false;\n\t  while (queue.length > 0) {\n\t    var item = queue.pop();\n\t    var tree1 = item.tree1;\n\t    var tree2 = item.tree2;\n\t\n\t    if (tree1[1].status || tree2[1].status) {\n\t      tree1[1].status =\n\t        (tree1[1].status ===  'available' ||\n\t        tree2[1].status === 'available') ? 'available' : 'missing';\n\t    }\n\t\n\t    for (var i = 0; i < tree2[2].length; i++) {\n\t      if (!tree1[2][0]) {\n\t        conflicts = 'new_leaf';\n\t        tree1[2][0] = tree2[2][i];\n\t        continue;\n\t      }\n\t\n\t      var merged = false;\n\t      for (var j = 0; j < tree1[2].length; j++) {\n\t        if (tree1[2][j][0] === tree2[2][i][0]) {\n\t          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\n\t          merged = true;\n\t        }\n\t      }\n\t      if (!merged) {\n\t        conflicts = 'new_branch';\n\t        insertSorted(tree1[2], tree2[2][i], compareTree);\n\t      }\n\t    }\n\t  }\n\t  return {conflicts: conflicts, tree: in_tree1};\n\t}\n\t\n\tfunction doMerge(tree, path, dontExpand) {\n\t  var restree = [];\n\t  var conflicts = false;\n\t  var merged = false;\n\t  var res;\n\t\n\t  if (!tree.length) {\n\t    return {tree: [path], conflicts: 'new_leaf'};\n\t  }\n\t\n\t  for (var i = 0, len = tree.length; i < len; i++) {\n\t    var branch = tree[i];\n\t    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n\t      // Paths start at the same position and have the same root, so they need\n\t      // merged\n\t      res = mergeTree(branch.ids, path.ids);\n\t      restree.push({pos: branch.pos, ids: res.tree});\n\t      conflicts = conflicts || res.conflicts;\n\t      merged = true;\n\t    } else if (dontExpand !== true) {\n\t      // The paths start at a different position, take the earliest path and\n\t      // traverse up until it as at the same point from root as the path we\n\t      // want to merge.  If the keys match we return the longer path with the\n\t      // other merged After stemming we dont want to expand the trees\n\t\n\t      var t1 = branch.pos < path.pos ? branch : path;\n\t      var t2 = branch.pos < path.pos ? path : branch;\n\t      var diff = t2.pos - t1.pos;\n\t\n\t      var candidateParents = [];\n\t\n\t      var trees = [];\n\t      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\n\t      while (trees.length > 0) {\n\t        var item = trees.pop();\n\t        if (item.diff === 0) {\n\t          if (item.ids[0] === t2.ids[0]) {\n\t            candidateParents.push(item);\n\t          }\n\t          continue;\n\t        }\n\t        var elements = item.ids[2];\n\t        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {\n\t          trees.push({\n\t            ids: elements[j],\n\t            diff: item.diff - 1,\n\t            parent: item.ids,\n\t            parentIdx: j\n\t          });\n\t        }\n\t      }\n\t\n\t      var el = candidateParents[0];\n\t\n\t      if (!el) {\n\t        restree.push(branch);\n\t      } else {\n\t        res = mergeTree(el.ids, t2.ids);\n\t        el.parent[2][el.parentIdx] = res.tree;\n\t        restree.push({pos: t1.pos, ids: t1.ids});\n\t        conflicts = conflicts || res.conflicts;\n\t        merged = true;\n\t      }\n\t    } else {\n\t      restree.push(branch);\n\t    }\n\t  }\n\t\n\t  // We didnt find\n\t  if (!merged) {\n\t    restree.push(path);\n\t  }\n\t\n\t  restree.sort(sortByPos$1);\n\t\n\t  return {\n\t    tree: restree,\n\t    conflicts: conflicts || 'internal_node'\n\t  };\n\t}\n\t\n\t// To ensure we dont grow the revision tree infinitely, we stem old revisions\n\tfunction stem(tree, depth) {\n\t  // First we break out the tree into a complete list of root to leaf paths\n\t  var paths = rootToLeaf(tree);\n\t  var stemmedRevs;\n\t\n\t  var result;\n\t  for (var i = 0, len = paths.length; i < len; i++) {\n\t    // Then for each path, we cut off the start of the path based on the\n\t    // `depth` to stem to, and generate a new set of flat trees\n\t    var path = paths[i];\n\t    var stemmed = path.ids;\n\t    var node;\n\t    if (stemmed.length > depth) {\n\t      // only do the stemming work if we actually need to stem\n\t      if (!stemmedRevs) {\n\t        stemmedRevs = {}; // avoid allocating this object unnecessarily\n\t      }\n\t      var numStemmed = stemmed.length - depth;\n\t      node = {\n\t        pos: path.pos + numStemmed,\n\t        ids: pathToTree(stemmed, numStemmed)\n\t      };\n\t\n\t      for (var s = 0; s < numStemmed; s++) {\n\t        var rev = (path.pos + s) + '-' + stemmed[s].id;\n\t        stemmedRevs[rev] = true;\n\t      }\n\t    } else { // no need to actually stem\n\t      node = {\n\t        pos: path.pos,\n\t        ids: pathToTree(stemmed, 0)\n\t      };\n\t    }\n\t\n\t    // Then we remerge all those flat trees together, ensuring that we dont\n\t    // connect trees that would go beyond the depth limit\n\t    if (result) {\n\t      result = doMerge(result, node, true).tree;\n\t    } else {\n\t      result = [node];\n\t    }\n\t  }\n\t\n\t  // this is memory-heavy per Chrome profiler, avoid unless we actually stemmed\n\t  if (stemmedRevs) {\n\t    traverseRevTree(result, function (isLeaf, pos, revHash) {\n\t      // some revisions may have been removed in a branch but not in another\n\t      delete stemmedRevs[pos + '-' + revHash];\n\t    });\n\t  }\n\t\n\t  return {\n\t    tree: result,\n\t    revs: stemmedRevs ? Object.keys(stemmedRevs) : []\n\t  };\n\t}\n\t\n\tfunction merge(tree, path, depth) {\n\t  var newTree = doMerge(tree, path);\n\t  var stemmed = stem(newTree.tree, depth);\n\t  return {\n\t    tree: stemmed.tree,\n\t    stemmedRevs: stemmed.revs,\n\t    conflicts: newTree.conflicts\n\t  };\n\t}\n\t\n\t// return true if a rev exists in the rev tree, false otherwise\n\tfunction revExists(revs, rev) {\n\t  var toVisit = revs.slice();\n\t  var splitRev = rev.split('-');\n\t  var targetPos = parseInt(splitRev[0], 10);\n\t  var targetId = splitRev[1];\n\t\n\t  var node;\n\t  while ((node = toVisit.pop())) {\n\t    if (node.pos === targetPos && node.ids[0] === targetId) {\n\t      return true;\n\t    }\n\t    var branches = node.ids[2];\n\t    for (var i = 0, len = branches.length; i < len; i++) {\n\t      toVisit.push({pos: node.pos + 1, ids: branches[i]});\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\tfunction getTrees(node) {\n\t  return node.ids;\n\t}\n\t\n\t// check if a specific revision of a doc has been deleted\n\t//  - metadata: the metadata object from the doc store\n\t//  - rev: (optional) the revision to check. defaults to winning revision\n\tfunction isDeleted(metadata, rev) {\n\t  if (!rev) {\n\t    rev = winningRev(metadata);\n\t  }\n\t  var id = rev.substring(rev.indexOf('-') + 1);\n\t  var toVisit = metadata.rev_tree.map(getTrees);\n\t\n\t  var tree;\n\t  while ((tree = toVisit.pop())) {\n\t    if (tree[0] === id) {\n\t      return !!tree[1].deleted;\n\t    }\n\t    toVisit = toVisit.concat(tree[2]);\n\t  }\n\t}\n\t\n\tfunction isLocalId(id) {\n\t  return (/^_local/).test(id);\n\t}\n\t\n\t// returns the current leaf node for a given revision\n\tfunction latest(rev, metadata) {\n\t  var toVisit = metadata.rev_tree.slice();\n\t  var node;\n\t  while ((node = toVisit.pop())) {\n\t    var pos = node.pos;\n\t    var tree = node.ids;\n\t    var id = tree[0];\n\t    var opts = tree[1];\n\t    var branches = tree[2];\n\t    var isLeaf = branches.length === 0;\n\t\n\t    var history = node.history ? node.history.slice() : [];\n\t    history.push({id: id, pos: pos, opts: opts});\n\t\n\t    if (isLeaf) {\n\t      for (var i = 0, len = history.length; i < len; i++) {\n\t        var historyNode = history[i];\n\t        var historyRev = historyNode.pos + '-' + historyNode.id;\n\t\n\t        if (historyRev === rev) {\n\t          // return the rev of this leaf\n\t          return pos + '-' + id;\n\t        }\n\t      }\n\t    }\n\t\n\t    for (var j = 0, l = branches.length; j < l; j++) {\n\t      toVisit.push({pos: pos + 1, ids: branches[j], history: history});\n\t    }\n\t  }\n\t\n\t  /* istanbul ignore next */\n\t  throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);\n\t}\n\t\n\tinherits(Changes$2, events.EventEmitter);\n\t\n\tfunction tryCatchInChangeListener(self, change) {\n\t  // isolate try/catches to avoid V8 deoptimizations\n\t  try {\n\t    self.emit('change', change);\n\t  } catch (e) {\n\t    guardedConsole('error', 'Error in .on(\"change\", function):', e);\n\t  }\n\t}\n\t\n\tfunction Changes$2(db, opts, callback) {\n\t  events.EventEmitter.call(this);\n\t  var self = this;\n\t  this.db = db;\n\t  opts = opts ? clone(opts) : {};\n\t  var complete = opts.complete = once(function (err, resp) {\n\t    if (err) {\n\t      if (listenerCount(self, 'error') > 0) {\n\t        self.emit('error', err);\n\t      }\n\t    } else {\n\t      self.emit('complete', resp);\n\t    }\n\t    self.removeAllListeners();\n\t    db.removeListener('destroyed', onDestroy);\n\t  });\n\t  if (callback) {\n\t    self.on('complete', function (resp) {\n\t      callback(null, resp);\n\t    });\n\t    self.on('error', callback);\n\t  }\n\t  function onDestroy() {\n\t    self.cancel();\n\t  }\n\t  db.once('destroyed', onDestroy);\n\t\n\t  opts.onChange = function (change) {\n\t    /* istanbul ignore if */\n\t    if (self.isCancelled) {\n\t      return;\n\t    }\n\t    tryCatchInChangeListener(self, change);\n\t  };\n\t\n\t  var promise = new PouchPromise$1(function (fulfill, reject) {\n\t    opts.complete = function (err, res) {\n\t      if (err) {\n\t        reject(err);\n\t      } else {\n\t        fulfill(res);\n\t      }\n\t    };\n\t  });\n\t  self.once('cancel', function () {\n\t    db.removeListener('destroyed', onDestroy);\n\t    opts.complete(null, {status: 'cancelled'});\n\t  });\n\t  this.then = promise.then.bind(promise);\n\t  this['catch'] = promise['catch'].bind(promise);\n\t  this.then(function (result) {\n\t    complete(null, result);\n\t  }, complete);\n\t\n\t\n\t\n\t  if (!db.taskqueue.isReady) {\n\t    db.taskqueue.addTask(function (failed) {\n\t      if (failed) {\n\t        opts.complete(failed);\n\t      } else if (self.isCancelled) {\n\t        self.emit('cancel');\n\t      } else {\n\t        self.validateChanges(opts);\n\t      }\n\t    });\n\t  } else {\n\t    self.validateChanges(opts);\n\t  }\n\t}\n\tChanges$2.prototype.cancel = function () {\n\t  this.isCancelled = true;\n\t  if (this.db.taskqueue.isReady) {\n\t    this.emit('cancel');\n\t  }\n\t};\n\tfunction processChange(doc, metadata, opts) {\n\t  var changeList = [{rev: doc._rev}];\n\t  if (opts.style === 'all_docs') {\n\t    changeList = collectLeaves(metadata.rev_tree)\n\t    .map(function (x) { return {rev: x.rev}; });\n\t  }\n\t  var change = {\n\t    id: metadata.id,\n\t    changes: changeList,\n\t    doc: doc\n\t  };\n\t\n\t  if (isDeleted(metadata, doc._rev)) {\n\t    change.deleted = true;\n\t  }\n\t  if (opts.conflicts) {\n\t    change.doc._conflicts = collectConflicts(metadata);\n\t    if (!change.doc._conflicts.length) {\n\t      delete change.doc._conflicts;\n\t    }\n\t  }\n\t  return change;\n\t}\n\t\n\tChanges$2.prototype.validateChanges = function (opts) {\n\t  var callback = opts.complete;\n\t  var self = this;\n\t\n\t  /* istanbul ignore else */\n\t  if (PouchDB$5._changesFilterPlugin) {\n\t    PouchDB$5._changesFilterPlugin.validate(opts, function (err) {\n\t      if (err) {\n\t        return callback(err);\n\t      }\n\t      self.doChanges(opts);\n\t    });\n\t  } else {\n\t    self.doChanges(opts);\n\t  }\n\t};\n\t\n\tChanges$2.prototype.doChanges = function (opts) {\n\t  var self = this;\n\t  var callback = opts.complete;\n\t\n\t  opts = clone(opts);\n\t  if ('live' in opts && !('continuous' in opts)) {\n\t    opts.continuous = opts.live;\n\t  }\n\t  opts.processChange = processChange;\n\t\n\t  if (opts.since === 'latest') {\n\t    opts.since = 'now';\n\t  }\n\t  if (!opts.since) {\n\t    opts.since = 0;\n\t  }\n\t  if (opts.since === 'now') {\n\t    this.db.info().then(function (info) {\n\t      /* istanbul ignore if */\n\t      if (self.isCancelled) {\n\t        callback(null, {status: 'cancelled'});\n\t        return;\n\t      }\n\t      opts.since = info.update_seq;\n\t      self.doChanges(opts);\n\t    }, callback);\n\t    return;\n\t  }\n\t\n\t  /* istanbul ignore else */\n\t  if (PouchDB$5._changesFilterPlugin) {\n\t    PouchDB$5._changesFilterPlugin.normalize(opts);\n\t    if (PouchDB$5._changesFilterPlugin.shouldFilter(this, opts)) {\n\t      return PouchDB$5._changesFilterPlugin.filter(this, opts);\n\t    }\n\t  } else {\n\t    ['doc_ids', 'filter', 'selector', 'view'].forEach(function (key) {\n\t      if (key in opts) {\n\t        guardedConsole('warn',\n\t          'The \"' + key + '\" option was passed in to changes/replicate, ' +\n\t          'but pouchdb-changes-filter plugin is not installed, so it ' +\n\t          'was ignored. Please install the plugin to enable filtering.'\n\t        );\n\t      }\n\t    });\n\t  }\n\t\n\t  if (!('descending' in opts)) {\n\t    opts.descending = false;\n\t  }\n\t\n\t  // 0 and 1 should return 1 document\n\t  opts.limit = opts.limit === 0 ? 1 : opts.limit;\n\t  opts.complete = callback;\n\t  var newPromise = this.db._changes(opts);\n\t  /* istanbul ignore else */\n\t  if (newPromise && typeof newPromise.cancel === 'function') {\n\t    var cancel = self.cancel;\n\t    self.cancel = getArguments(function (args) {\n\t      newPromise.cancel();\n\t      cancel.apply(this, args);\n\t    });\n\t  }\n\t};\n\t\n\t/*\n\t * A generic pouch adapter\n\t */\n\t\n\tfunction compare(left, right) {\n\t  return left < right ? -1 : left > right ? 1 : 0;\n\t}\n\t\n\t// Wrapper for functions that call the bulkdocs api with a single doc,\n\t// if the first result is an error, return an error\n\tfunction yankError(callback, docId) {\n\t  return function (err, results) {\n\t    if (err || (results[0] && results[0].error)) {\n\t      err = err || results[0];\n\t      err.docId = docId;\n\t      callback(err);\n\t    } else {\n\t      callback(null, results.length ? results[0]  : results);\n\t    }\n\t  };\n\t}\n\t\n\t// clean docs given to us by the user\n\tfunction cleanDocs(docs) {\n\t  for (var i = 0; i < docs.length; i++) {\n\t    var doc = docs[i];\n\t    if (doc._deleted) {\n\t      delete doc._attachments; // ignore atts for deleted docs\n\t    } else if (doc._attachments) {\n\t      // filter out extraneous keys from _attachments\n\t      var atts = Object.keys(doc._attachments);\n\t      for (var j = 0; j < atts.length; j++) {\n\t        var att = atts[j];\n\t        doc._attachments[att] = pick(doc._attachments[att],\n\t          ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t// compare two docs, first by _id then by _rev\n\tfunction compareByIdThenRev(a, b) {\n\t  var idCompare = compare(a._id, b._id);\n\t  if (idCompare !== 0) {\n\t    return idCompare;\n\t  }\n\t  var aStart = a._revisions ? a._revisions.start : 0;\n\t  var bStart = b._revisions ? b._revisions.start : 0;\n\t  return compare(aStart, bStart);\n\t}\n\t\n\t// for every node in a revision tree computes its distance from the closest\n\t// leaf\n\tfunction computeHeight(revs) {\n\t  var height = {};\n\t  var edges = [];\n\t  traverseRevTree(revs, function (isLeaf, pos, id, prnt) {\n\t    var rev$$1 = pos + \"-\" + id;\n\t    if (isLeaf) {\n\t      height[rev$$1] = 0;\n\t    }\n\t    if (prnt !== undefined) {\n\t      edges.push({from: prnt, to: rev$$1});\n\t    }\n\t    return rev$$1;\n\t  });\n\t\n\t  edges.reverse();\n\t  edges.forEach(function (edge) {\n\t    if (height[edge.from] === undefined) {\n\t      height[edge.from] = 1 + height[edge.to];\n\t    } else {\n\t      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\n\t    }\n\t  });\n\t  return height;\n\t}\n\t\n\tfunction allDocsKeysQuery(api, opts, callback) {\n\t  var keys =  ('limit' in opts) ?\n\t      opts.keys.slice(opts.skip, opts.limit + opts.skip) :\n\t      (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;\n\t  if (opts.descending) {\n\t    keys.reverse();\n\t  }\n\t  if (!keys.length) {\n\t    return api._allDocs({limit: 0}, callback);\n\t  }\n\t  var finalResults = {\n\t    offset: opts.skip\n\t  };\n\t  return PouchPromise$1.all(keys.map(function (key) {\n\t    var subOpts = $inject_Object_assign({key: key, deleted: 'ok'}, opts);\n\t    ['limit', 'skip', 'keys'].forEach(function (optKey) {\n\t      delete subOpts[optKey];\n\t    });\n\t    return new PouchPromise$1(function (resolve, reject) {\n\t      api._allDocs(subOpts, function (err, res) {\n\t        /* istanbul ignore if */\n\t        if (err) {\n\t          return reject(err);\n\t        }\n\t        finalResults.total_rows = res.total_rows;\n\t        resolve(res.rows[0] || {key: key, error: 'not_found'});\n\t      });\n\t    });\n\t  })).then(function (results) {\n\t    finalResults.rows = results;\n\t    return finalResults;\n\t  });\n\t}\n\t\n\t// all compaction is done in a queue, to avoid attaching\n\t// too many listeners at once\n\tfunction doNextCompaction(self) {\n\t  var task = self._compactionQueue[0];\n\t  var opts = task.opts;\n\t  var callback = task.callback;\n\t  self.get('_local/compaction').catch(function () {\n\t    return false;\n\t  }).then(function (doc) {\n\t    if (doc && doc.last_seq) {\n\t      opts.last_seq = doc.last_seq;\n\t    }\n\t    self._compact(opts, function (err, res) {\n\t      /* istanbul ignore if */\n\t      if (err) {\n\t        callback(err);\n\t      } else {\n\t        callback(null, res);\n\t      }\n\t      nextTick(function () {\n\t        self._compactionQueue.shift();\n\t        if (self._compactionQueue.length) {\n\t          doNextCompaction(self);\n\t        }\n\t      });\n\t    });\n\t  });\n\t}\n\t\n\tfunction attachmentNameError(name) {\n\t  if (name.charAt(0) === '_') {\n\t    return name + ' is not a valid attachment name, attachment ' +\n\t      'names cannot start with \\'_\\'';\n\t  }\n\t  return false;\n\t}\n\t\n\tinherits(AbstractPouchDB, events.EventEmitter);\n\t\n\tfunction AbstractPouchDB() {\n\t  events.EventEmitter.call(this);\n\t}\n\t\n\tAbstractPouchDB.prototype.post =\n\t  adapterFun('post', function (doc, opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  if (typeof doc !== 'object' || Array.isArray(doc)) {\n\t    return callback(createError(NOT_AN_OBJECT));\n\t  }\n\t  this.bulkDocs({docs: [doc]}, opts, yankError(callback, doc._id));\n\t});\n\t\n\tAbstractPouchDB.prototype.put = adapterFun('put', function (doc, opts, cb) {\n\t  if (typeof opts === 'function') {\n\t    cb = opts;\n\t    opts = {};\n\t  }\n\t  if (typeof doc !== 'object' || Array.isArray(doc)) {\n\t    return cb(createError(NOT_AN_OBJECT));\n\t  }\n\t  invalidIdError(doc._id);\n\t  if (isLocalId(doc._id) && typeof this._putLocal === 'function') {\n\t    if (doc._deleted) {\n\t      return this._removeLocal(doc, cb);\n\t    } else {\n\t      return this._putLocal(doc, cb);\n\t    }\n\t  }\n\t  var self = this;\n\t  if (opts.force && doc._rev) {\n\t    transformForceOptionToNewEditsOption();\n\t    putDoc(function (err) {\n\t      var result = err ? null : {ok: true, id: doc._id, rev: doc._rev};\n\t      cb(err, result);\n\t    });\n\t  } else {\n\t    putDoc(cb);\n\t  }\n\t\n\t  function transformForceOptionToNewEditsOption() {\n\t    var parts = doc._rev.split('-');\n\t    var oldRevId = parts[1];\n\t    var oldRevNum = parseInt(parts[0], 10);\n\t\n\t    var newRevNum = oldRevNum + 1;\n\t    var newRevId = rev();\n\t\n\t    doc._revisions = {\n\t      start: newRevNum,\n\t      ids: [newRevId, oldRevId]\n\t    };\n\t    doc._rev = newRevNum + '-' + newRevId;\n\t    opts.new_edits = false;\n\t  }\n\t  function putDoc(next) {\n\t    if (typeof self._put === 'function' && opts.new_edits !== false) {\n\t      self._put(doc, opts, next);\n\t    } else {\n\t      self.bulkDocs({docs: [doc]}, opts, yankError(next, doc._id));\n\t    }\n\t  }\n\t});\n\t\n\tAbstractPouchDB.prototype.putAttachment =\n\t  adapterFun('putAttachment', function (docId, attachmentId, rev$$1,\n\t                                              blob, type) {\n\t  var api = this;\n\t  if (typeof type === 'function') {\n\t    type = blob;\n\t    blob = rev$$1;\n\t    rev$$1 = null;\n\t  }\n\t  // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267\n\t  /* istanbul ignore if */\n\t  if (typeof type === 'undefined') {\n\t    type = blob;\n\t    blob = rev$$1;\n\t    rev$$1 = null;\n\t  }\n\t  if (!type) {\n\t    guardedConsole('warn', 'Attachment', attachmentId, 'on document', docId, 'is missing content_type');\n\t  }\n\t\n\t  function createAttachment(doc) {\n\t    var prevrevpos = '_rev' in doc ? parseInt(doc._rev, 10) : 0;\n\t    doc._attachments = doc._attachments || {};\n\t    doc._attachments[attachmentId] = {\n\t      content_type: type,\n\t      data: blob,\n\t      revpos: ++prevrevpos\n\t    };\n\t    return api.put(doc);\n\t  }\n\t\n\t  return api.get(docId).then(function (doc) {\n\t    if (doc._rev !== rev$$1) {\n\t      throw createError(REV_CONFLICT);\n\t    }\n\t\n\t    return createAttachment(doc);\n\t  }, function (err) {\n\t     // create new doc\n\t    /* istanbul ignore else */\n\t    if (err.reason === MISSING_DOC.message) {\n\t      return createAttachment({_id: docId});\n\t    } else {\n\t      throw err;\n\t    }\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.removeAttachment =\n\t  adapterFun('removeAttachment', function (docId, attachmentId, rev$$1,\n\t                                                 callback) {\n\t  var self = this;\n\t  self.get(docId, function (err, obj) {\n\t    /* istanbul ignore if */\n\t    if (err) {\n\t      callback(err);\n\t      return;\n\t    }\n\t    if (obj._rev !== rev$$1) {\n\t      callback(createError(REV_CONFLICT));\n\t      return;\n\t    }\n\t    /* istanbul ignore if */\n\t    if (!obj._attachments) {\n\t      return callback();\n\t    }\n\t    delete obj._attachments[attachmentId];\n\t    if (Object.keys(obj._attachments).length === 0) {\n\t      delete obj._attachments;\n\t    }\n\t    self.put(obj, callback);\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.remove =\n\t  adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {\n\t  var doc;\n\t  if (typeof optsOrRev === 'string') {\n\t    // id, rev, opts, callback style\n\t    doc = {\n\t      _id: docOrId,\n\t      _rev: optsOrRev\n\t    };\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t  } else {\n\t    // doc, opts, callback style\n\t    doc = docOrId;\n\t    if (typeof optsOrRev === 'function') {\n\t      callback = optsOrRev;\n\t      opts = {};\n\t    } else {\n\t      callback = opts;\n\t      opts = optsOrRev;\n\t    }\n\t  }\n\t  opts = opts || {};\n\t  opts.was_delete = true;\n\t  var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};\n\t  newDoc._deleted = true;\n\t  if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {\n\t    return this._removeLocal(doc, callback);\n\t  }\n\t  this.bulkDocs({docs: [newDoc]}, opts, yankError(callback, newDoc._id));\n\t});\n\t\n\tAbstractPouchDB.prototype.revsDiff =\n\t  adapterFun('revsDiff', function (req, opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  var ids = Object.keys(req);\n\t\n\t  if (!ids.length) {\n\t    return callback(null, {});\n\t  }\n\t\n\t  var count = 0;\n\t  var missing = new ExportedMap();\n\t\n\t  function addToMissing(id, revId) {\n\t    if (!missing.has(id)) {\n\t      missing.set(id, {missing: []});\n\t    }\n\t    missing.get(id).missing.push(revId);\n\t  }\n\t\n\t  function processDoc(id, rev_tree) {\n\t    // Is this fast enough? Maybe we should switch to a set simulated by a map\n\t    var missingForId = req[id].slice(0);\n\t    traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,\n\t      opts) {\n\t        var rev$$1 = pos + '-' + revHash;\n\t        var idx = missingForId.indexOf(rev$$1);\n\t        if (idx === -1) {\n\t          return;\n\t        }\n\t\n\t        missingForId.splice(idx, 1);\n\t        /* istanbul ignore if */\n\t        if (opts.status !== 'available') {\n\t          addToMissing(id, rev$$1);\n\t        }\n\t      });\n\t\n\t    // Traversing the tree is synchronous, so now `missingForId` contains\n\t    // revisions that were not found in the tree\n\t    missingForId.forEach(function (rev$$1) {\n\t      addToMissing(id, rev$$1);\n\t    });\n\t  }\n\t\n\t  ids.map(function (id) {\n\t    this._getRevisionTree(id, function (err, rev_tree) {\n\t      if (err && err.status === 404 && err.message === 'missing') {\n\t        missing.set(id, {missing: req[id]});\n\t      } else if (err) {\n\t        /* istanbul ignore next */\n\t        return callback(err);\n\t      } else {\n\t        processDoc(id, rev_tree);\n\t      }\n\t\n\t      if (++count === ids.length) {\n\t        // convert LazyMap to object\n\t        var missingObj = {};\n\t        missing.forEach(function (value, key) {\n\t          missingObj[key] = value;\n\t        });\n\t        return callback(null, missingObj);\n\t      }\n\t    });\n\t  }, this);\n\t});\n\t\n\t// _bulk_get API for faster replication, as described in\n\t// https://github.com/apache/couchdb-chttpd/pull/33\n\t// At the \"abstract\" level, it will just run multiple get()s in\n\t// parallel, because this isn't much of a performance cost\n\t// for local databases (except the cost of multiple transactions, which is\n\t// small). The http adapter overrides this in order\n\t// to do a more efficient single HTTP request.\n\tAbstractPouchDB.prototype.bulkGet =\n\t  adapterFun('bulkGet', function (opts, callback) {\n\t  bulkGet(this, opts, callback);\n\t});\n\t\n\t// compact one document and fire callback\n\t// by compacting we mean removing all revisions which\n\t// are further from the leaf in revision tree than max_height\n\tAbstractPouchDB.prototype.compactDocument =\n\t  adapterFun('compactDocument', function (docId, maxHeight, callback) {\n\t  var self = this;\n\t  this._getRevisionTree(docId, function (err, revTree) {\n\t    /* istanbul ignore if */\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    var height = computeHeight(revTree);\n\t    var candidates = [];\n\t    var revs = [];\n\t    Object.keys(height).forEach(function (rev$$1) {\n\t      if (height[rev$$1] > maxHeight) {\n\t        candidates.push(rev$$1);\n\t      }\n\t    });\n\t\n\t    traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {\n\t      var rev$$1 = pos + '-' + revHash;\n\t      if (opts.status === 'available' && candidates.indexOf(rev$$1) !== -1) {\n\t        revs.push(rev$$1);\n\t      }\n\t    });\n\t    self._doCompaction(docId, revs, callback);\n\t  });\n\t});\n\t\n\t// compact the whole database using single document\n\t// compaction\n\tAbstractPouchDB.prototype.compact =\n\t  adapterFun('compact', function (opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t\n\t  var self = this;\n\t  opts = opts || {};\n\t\n\t  self._compactionQueue = self._compactionQueue || [];\n\t  self._compactionQueue.push({opts: opts, callback: callback});\n\t  if (self._compactionQueue.length === 1) {\n\t    doNextCompaction(self);\n\t  }\n\t});\n\tAbstractPouchDB.prototype._compact = function (opts, callback) {\n\t  var self = this;\n\t  var changesOpts = {\n\t    return_docs: false,\n\t    last_seq: opts.last_seq || 0\n\t  };\n\t  var promises = [];\n\t\n\t  function onChange(row) {\n\t    promises.push(self.compactDocument(row.id, 0));\n\t  }\n\t  function onComplete(resp) {\n\t    var lastSeq = resp.last_seq;\n\t    PouchPromise$1.all(promises).then(function () {\n\t      return upsert(self, '_local/compaction', function deltaFunc(doc) {\n\t        if (!doc.last_seq || doc.last_seq < lastSeq) {\n\t          doc.last_seq = lastSeq;\n\t          return doc;\n\t        }\n\t        return false; // somebody else got here first, don't update\n\t      });\n\t    }).then(function () {\n\t      callback(null, {ok: true});\n\t    }).catch(callback);\n\t  }\n\t  self.changes(changesOpts)\n\t    .on('change', onChange)\n\t    .on('complete', onComplete)\n\t    .on('error', callback);\n\t};\n\t\n\t/* Begin api wrappers. Specific functionality to storage belongs in the\n\t   _[method] */\n\tAbstractPouchDB.prototype.get = adapterFun('get', function (id, opts, cb) {\n\t  if (typeof opts === 'function') {\n\t    cb = opts;\n\t    opts = {};\n\t  }\n\t  if (typeof id !== 'string') {\n\t    return cb(createError(INVALID_ID));\n\t  }\n\t  if (isLocalId(id) && typeof this._getLocal === 'function') {\n\t    return this._getLocal(id, cb);\n\t  }\n\t  var leaves = [], self = this;\n\t\n\t  function finishOpenRevs() {\n\t    var result = [];\n\t    var count = leaves.length;\n\t    /* istanbul ignore if */\n\t    if (!count) {\n\t      return cb(null, result);\n\t    }\n\t\n\t    // order with open_revs is unspecified\n\t    leaves.forEach(function (leaf) {\n\t      self.get(id, {\n\t        rev: leaf,\n\t        revs: opts.revs,\n\t        latest: opts.latest,\n\t        attachments: opts.attachments\n\t      }, function (err, doc) {\n\t        if (!err) {\n\t          // using latest=true can produce duplicates\n\t          var existing;\n\t          for (var i = 0, l = result.length; i < l; i++) {\n\t            if (result[i].ok && result[i].ok._rev === doc._rev) {\n\t              existing = true;\n\t              break;\n\t            }\n\t          }\n\t          if (!existing) {\n\t            result.push({ok: doc});\n\t          }\n\t        } else {\n\t          result.push({missing: leaf});\n\t        }\n\t        count--;\n\t        if (!count) {\n\t          cb(null, result);\n\t        }\n\t      });\n\t    });\n\t  }\n\t\n\t  if (opts.open_revs) {\n\t    if (opts.open_revs === \"all\") {\n\t      this._getRevisionTree(id, function (err, rev_tree) {\n\t        if (err) {\n\t          return cb(err);\n\t        }\n\t        leaves = collectLeaves(rev_tree).map(function (leaf) {\n\t          return leaf.rev;\n\t        });\n\t        finishOpenRevs();\n\t      });\n\t    } else {\n\t      if (Array.isArray(opts.open_revs)) {\n\t        leaves = opts.open_revs;\n\t        for (var i = 0; i < leaves.length; i++) {\n\t          var l = leaves[i];\n\t          // looks like it's the only thing couchdb checks\n\t          if (!(typeof (l) === \"string\" && /^\\d+-/.test(l))) {\n\t            return cb(createError(INVALID_REV));\n\t          }\n\t        }\n\t        finishOpenRevs();\n\t      } else {\n\t        return cb(createError(UNKNOWN_ERROR, 'function_clause'));\n\t      }\n\t    }\n\t    return; // open_revs does not like other options\n\t  }\n\t\n\t  return this._get(id, opts, function (err, result) {\n\t    if (err) {\n\t      err.docId = id;\n\t      return cb(err);\n\t    }\n\t\n\t    var doc = result.doc;\n\t    var metadata = result.metadata;\n\t    var ctx = result.ctx;\n\t\n\t    if (opts.conflicts) {\n\t      var conflicts = collectConflicts(metadata);\n\t      if (conflicts.length) {\n\t        doc._conflicts = conflicts;\n\t      }\n\t    }\n\t\n\t    if (isDeleted(metadata, doc._rev)) {\n\t      doc._deleted = true;\n\t    }\n\t\n\t    if (opts.revs || opts.revs_info) {\n\t      var splittedRev = doc._rev.split('-');\n\t      var revNo       = parseInt(splittedRev[0], 10);\n\t      var revHash     = splittedRev[1];\n\t\n\t      var paths = rootToLeaf(metadata.rev_tree);\n\t      var path = null;\n\t\n\t      for (var i = 0; i < paths.length; i++) {\n\t        var currentPath = paths[i];\n\t        var hashIndex = currentPath.ids.map(function (x) { return x.id; })\n\t          .indexOf(revHash);\n\t        var hashFoundAtRevPos = hashIndex === (revNo - 1);\n\t\n\t        if (hashFoundAtRevPos || (!path && hashIndex !== -1)) {\n\t          path = currentPath;\n\t        }\n\t      }\n\t\n\t      var indexOfRev = path.ids.map(function (x) { return x.id; })\n\t        .indexOf(doc._rev.split('-')[1]) + 1;\n\t      var howMany = path.ids.length - indexOfRev;\n\t      path.ids.splice(indexOfRev, howMany);\n\t      path.ids.reverse();\n\t\n\t      if (opts.revs) {\n\t        doc._revisions = {\n\t          start: (path.pos + path.ids.length) - 1,\n\t          ids: path.ids.map(function (rev$$1) {\n\t            return rev$$1.id;\n\t          })\n\t        };\n\t      }\n\t      if (opts.revs_info) {\n\t        var pos =  path.pos + path.ids.length;\n\t        doc._revs_info = path.ids.map(function (rev$$1) {\n\t          pos--;\n\t          return {\n\t            rev: pos + '-' + rev$$1.id,\n\t            status: rev$$1.opts.status\n\t          };\n\t        });\n\t      }\n\t    }\n\t\n\t    if (opts.attachments && doc._attachments) {\n\t      var attachments = doc._attachments;\n\t      var count = Object.keys(attachments).length;\n\t      if (count === 0) {\n\t        return cb(null, doc);\n\t      }\n\t      Object.keys(attachments).forEach(function (key) {\n\t        this._getAttachment(doc._id, key, attachments[key], {\n\t          // Previously the revision handling was done in adapter.js\n\t          // getAttachment, however since idb-next doesnt we need to\n\t          // pass the rev through\n\t          rev: doc._rev,\n\t          binary: opts.binary,\n\t          ctx: ctx\n\t        }, function (err, data) {\n\t          var att = doc._attachments[key];\n\t          att.data = data;\n\t          delete att.stub;\n\t          delete att.length;\n\t          if (!--count) {\n\t            cb(null, doc);\n\t          }\n\t        });\n\t      }, self);\n\t    } else {\n\t      if (doc._attachments) {\n\t        for (var key in doc._attachments) {\n\t          /* istanbul ignore else */\n\t          if (doc._attachments.hasOwnProperty(key)) {\n\t            doc._attachments[key].stub = true;\n\t          }\n\t        }\n\t      }\n\t      cb(null, doc);\n\t    }\n\t  });\n\t});\n\t\n\t// TODO: I dont like this, it forces an extra read for every\n\t// attachment read and enforces a confusing api between\n\t// adapter.js and the adapter implementation\n\tAbstractPouchDB.prototype.getAttachment =\n\t  adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {\n\t  var self = this;\n\t  if (opts instanceof Function) {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  this._get(docId, opts, function (err, res) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    if (res.doc._attachments && res.doc._attachments[attachmentId]) {\n\t      opts.ctx = res.ctx;\n\t      opts.binary = true;\n\t      self._getAttachment(docId, attachmentId,\n\t                          res.doc._attachments[attachmentId], opts, callback);\n\t    } else {\n\t      return callback(createError(MISSING_DOC));\n\t    }\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.allDocs =\n\t  adapterFun('allDocs', function (opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;\n\t  if (opts.start_key) {\n\t    opts.startkey = opts.start_key;\n\t  }\n\t  if (opts.end_key) {\n\t    opts.endkey = opts.end_key;\n\t  }\n\t  if ('keys' in opts) {\n\t    if (!Array.isArray(opts.keys)) {\n\t      return callback(new TypeError('options.keys must be an array'));\n\t    }\n\t    var incompatibleOpt =\n\t      ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {\n\t      return incompatibleOpt in opts;\n\t    })[0];\n\t    if (incompatibleOpt) {\n\t      callback(createError(QUERY_PARSE_ERROR,\n\t        'Query parameter `' + incompatibleOpt +\n\t        '` is not compatible with multi-get'\n\t      ));\n\t      return;\n\t    }\n\t    if (!isRemote(this)) {\n\t      return allDocsKeysQuery(this, opts, callback);\n\t    }\n\t  }\n\t\n\t  return this._allDocs(opts, callback);\n\t});\n\t\n\tAbstractPouchDB.prototype.changes = function (opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  return new Changes$2(this, opts, callback);\n\t};\n\t\n\tAbstractPouchDB.prototype.close = adapterFun('close', function (callback) {\n\t  this._closed = true;\n\t  this.emit('closed');\n\t  return this._close(callback);\n\t});\n\t\n\tAbstractPouchDB.prototype.info = adapterFun('info', function (callback) {\n\t  var self = this;\n\t  this._info(function (err, info) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    // assume we know better than the adapter, unless it informs us\n\t    info.db_name = info.db_name || self.name;\n\t    info.auto_compaction = !!(self.auto_compaction && !isRemote(self));\n\t    info.adapter = self.adapter;\n\t    callback(null, info);\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.id = adapterFun('id', function (callback) {\n\t  return this._id(callback);\n\t});\n\t\n\t/* istanbul ignore next */\n\tAbstractPouchDB.prototype.type = function () {\n\t  return (typeof this._type === 'function') ? this._type() : this.adapter;\n\t};\n\t\n\tAbstractPouchDB.prototype.bulkDocs =\n\t  adapterFun('bulkDocs', function (req, opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t\n\t  opts = opts || {};\n\t\n\t  if (Array.isArray(req)) {\n\t    req = {\n\t      docs: req\n\t    };\n\t  }\n\t\n\t  if (!req || !req.docs || !Array.isArray(req.docs)) {\n\t    return callback(createError(MISSING_BULK_DOCS));\n\t  }\n\t\n\t  for (var i = 0; i < req.docs.length; ++i) {\n\t    if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {\n\t      return callback(createError(NOT_AN_OBJECT));\n\t    }\n\t  }\n\t\n\t  var attachmentError;\n\t  req.docs.forEach(function (doc) {\n\t    if (doc._attachments) {\n\t      Object.keys(doc._attachments).forEach(function (name) {\n\t        attachmentError = attachmentError || attachmentNameError(name);\n\t        if (!doc._attachments[name].content_type) {\n\t          guardedConsole('warn', 'Attachment', name, 'on document', doc._id, 'is missing content_type');\n\t        }\n\t      });\n\t    }\n\t  });\n\t\n\t  if (attachmentError) {\n\t    return callback(createError(BAD_REQUEST, attachmentError));\n\t  }\n\t\n\t  if (!('new_edits' in opts)) {\n\t    if ('new_edits' in req) {\n\t      opts.new_edits = req.new_edits;\n\t    } else {\n\t      opts.new_edits = true;\n\t    }\n\t  }\n\t\n\t  var adapter = this;\n\t  if (!opts.new_edits && !isRemote(adapter)) {\n\t    // ensure revisions of the same doc are sorted, so that\n\t    // the local adapter processes them correctly (#2935)\n\t    req.docs.sort(compareByIdThenRev);\n\t  }\n\t\n\t  cleanDocs(req.docs);\n\t\n\t  // in the case of conflicts, we want to return the _ids to the user\n\t  // however, the underlying adapter may destroy the docs array, so\n\t  // create a copy here\n\t  var ids = req.docs.map(function (doc) {\n\t    return doc._id;\n\t  });\n\t\n\t  return this._bulkDocs(req, opts, function (err, res) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    if (!opts.new_edits) {\n\t      // this is what couch does when new_edits is false\n\t      res = res.filter(function (x) {\n\t        return x.error;\n\t      });\n\t    }\n\t    // add ids for error/conflict responses (not required for CouchDB)\n\t    if (!isRemote(adapter)) {\n\t      for (var i = 0, l = res.length; i < l; i++) {\n\t        res[i].id = res[i].id || ids[i];\n\t      }\n\t    }\n\t\n\t    callback(null, res);\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.registerDependentDatabase =\n\t  adapterFun('registerDependentDatabase', function (dependentDb,\n\t                                                          callback) {\n\t  var depDB = new this.constructor(dependentDb, this.__opts);\n\t\n\t  function diffFun(doc) {\n\t    doc.dependentDbs = doc.dependentDbs || {};\n\t    if (doc.dependentDbs[dependentDb]) {\n\t      return false; // no update required\n\t    }\n\t    doc.dependentDbs[dependentDb] = true;\n\t    return doc;\n\t  }\n\t  upsert(this, '_local/_pouch_dependentDbs', diffFun)\n\t    .then(function () {\n\t      callback(null, {db: depDB});\n\t    }).catch(callback);\n\t});\n\t\n\tAbstractPouchDB.prototype.destroy =\n\t  adapterFun('destroy', function (opts, callback) {\n\t\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t\n\t  var self = this;\n\t  var usePrefix = 'use_prefix' in self ? self.use_prefix : true;\n\t\n\t  function destroyDb() {\n\t    // call destroy method of the particular adaptor\n\t    self._destroy(opts, function (err, resp) {\n\t      if (err) {\n\t        return callback(err);\n\t      }\n\t      self._destroyed = true;\n\t      self.emit('destroyed');\n\t      callback(null, resp || { 'ok': true });\n\t    });\n\t  }\n\t\n\t  if (isRemote(self)) {\n\t    // no need to check for dependent DBs if it's a remote DB\n\t    return destroyDb();\n\t  }\n\t\n\t  self.get('_local/_pouch_dependentDbs', function (err, localDoc) {\n\t    if (err) {\n\t      /* istanbul ignore if */\n\t      if (err.status !== 404) {\n\t        return callback(err);\n\t      } else { // no dependencies\n\t        return destroyDb();\n\t      }\n\t    }\n\t    var dependentDbs = localDoc.dependentDbs;\n\t    var PouchDB = self.constructor;\n\t    var deletedMap = Object.keys(dependentDbs).map(function (name) {\n\t      // use_prefix is only false in the browser\n\t      /* istanbul ignore next */\n\t      var trueName = usePrefix ?\n\t        name.replace(new RegExp('^' + PouchDB.prefix), '') : name;\n\t      return new PouchDB(trueName, self.__opts).destroy();\n\t    });\n\t    PouchPromise$1.all(deletedMap).then(destroyDb, callback);\n\t  });\n\t});\n\t\n\tfunction TaskQueue$1() {\n\t  this.isReady = false;\n\t  this.failed = false;\n\t  this.queue = [];\n\t}\n\t\n\tTaskQueue$1.prototype.execute = function () {\n\t  var fun;\n\t  if (this.failed) {\n\t    while ((fun = this.queue.shift())) {\n\t      fun(this.failed);\n\t    }\n\t  } else {\n\t    while ((fun = this.queue.shift())) {\n\t      fun();\n\t    }\n\t  }\n\t};\n\t\n\tTaskQueue$1.prototype.fail = function (err) {\n\t  this.failed = err;\n\t  this.execute();\n\t};\n\t\n\tTaskQueue$1.prototype.ready = function (db) {\n\t  this.isReady = true;\n\t  this.db = db;\n\t  this.execute();\n\t};\n\t\n\tTaskQueue$1.prototype.addTask = function (fun) {\n\t  this.queue.push(fun);\n\t  if (this.failed) {\n\t    this.execute();\n\t  }\n\t};\n\t\n\tfunction parseAdapter(name, opts) {\n\t  var match = name.match(/([a-z-]*):\\/\\/(.*)/);\n\t  if (match) {\n\t    // the http adapter expects the fully qualified name\n\t    return {\n\t      name: /https?/.test(match[1]) ? match[1] + '://' + match[2] : match[2],\n\t      adapter: match[1]\n\t    };\n\t  }\n\t\n\t  var adapters = PouchDB$5.adapters;\n\t  var preferredAdapters = PouchDB$5.preferredAdapters;\n\t  var prefix = PouchDB$5.prefix;\n\t  var adapterName = opts.adapter;\n\t\n\t  if (!adapterName) { // automatically determine adapter\n\t    for (var i = 0; i < preferredAdapters.length; ++i) {\n\t      adapterName = preferredAdapters[i];\n\t      // check for browsers that have been upgraded from websql-only to websql+idb\n\t      /* istanbul ignore if */\n\t      if (adapterName === 'idb' && 'websql' in adapters &&\n\t          hasLocalStorage() && localStorage['_pouch__websqldb_' + prefix + name]) {\n\t        // log it, because this can be confusing during development\n\t        guardedConsole('log', 'PouchDB is downgrading \"' + name + '\" to WebSQL to' +\n\t          ' avoid data loss, because it was already opened with WebSQL.');\n\t        continue; // keep using websql to avoid user data loss\n\t      }\n\t      break;\n\t    }\n\t  }\n\t\n\t  var adapter = adapters[adapterName];\n\t\n\t  // if adapter is invalid, then an error will be thrown later\n\t  var usePrefix = (adapter && 'use_prefix' in adapter) ?\n\t    adapter.use_prefix : true;\n\t\n\t  return {\n\t    name: usePrefix ? (prefix + name) : name,\n\t    adapter: adapterName\n\t  };\n\t}\n\t\n\t// OK, so here's the deal. Consider this code:\n\t//     var db1 = new PouchDB('foo');\n\t//     var db2 = new PouchDB('foo');\n\t//     db1.destroy();\n\t// ^ these two both need to emit 'destroyed' events,\n\t// as well as the PouchDB constructor itself.\n\t// So we have one db object (whichever one got destroy() called on it)\n\t// responsible for emitting the initial event, which then gets emitted\n\t// by the constructor, which then broadcasts it to any other dbs\n\t// that may have been created with the same name.\n\tfunction prepareForDestruction(self) {\n\t\n\t  function onDestroyed(from_constructor) {\n\t    self.removeListener('closed', onClosed);\n\t    if (!from_constructor) {\n\t      self.constructor.emit('destroyed', self.name);\n\t    }\n\t  }\n\t\n\t  function onClosed() {\n\t    self.removeListener('destroyed', onDestroyed);\n\t    self.constructor.emit('unref', self);\n\t  }\n\t\n\t  self.once('destroyed', onDestroyed);\n\t  self.once('closed', onClosed);\n\t  self.constructor.emit('ref', self);\n\t}\n\t\n\tinherits(PouchDB$5, AbstractPouchDB);\n\tfunction PouchDB$5(name, opts) {\n\t  // In Node our test suite only tests this for PouchAlt unfortunately\n\t  /* istanbul ignore if */\n\t  if (!(this instanceof PouchDB$5)) {\n\t    return new PouchDB$5(name, opts);\n\t  }\n\t\n\t  var self = this;\n\t  opts = opts || {};\n\t\n\t  if (name && typeof name === 'object') {\n\t    opts = name;\n\t    name = opts.name;\n\t    delete opts.name;\n\t  }\n\t\n\t  this.__opts = opts = clone(opts);\n\t\n\t  self.auto_compaction = opts.auto_compaction;\n\t  self.prefix = PouchDB$5.prefix;\n\t\n\t  if (typeof name !== 'string') {\n\t    throw new Error('Missing/invalid DB name');\n\t  }\n\t\n\t  var prefixedName = (opts.prefix || '') + name;\n\t  var backend = parseAdapter(prefixedName, opts);\n\t\n\t  opts.name = backend.name;\n\t  opts.adapter = opts.adapter || backend.adapter;\n\t\n\t  self.name = name;\n\t  self._adapter = opts.adapter;\n\t  PouchDB$5.emit('debug', ['adapter', 'Picked adapter: ', opts.adapter]);\n\t\n\t  if (!PouchDB$5.adapters[opts.adapter] ||\n\t      !PouchDB$5.adapters[opts.adapter].valid()) {\n\t    throw new Error('Invalid Adapter: ' + opts.adapter);\n\t  }\n\t\n\t  AbstractPouchDB.call(self);\n\t  self.taskqueue = new TaskQueue$1();\n\t\n\t  self.adapter = opts.adapter;\n\t\n\t  PouchDB$5.adapters[opts.adapter].call(self, opts, function (err) {\n\t    if (err) {\n\t      return self.taskqueue.fail(err);\n\t    }\n\t    prepareForDestruction(self);\n\t\n\t    self.emit('created', self);\n\t    PouchDB$5.emit('created', self.name);\n\t    self.taskqueue.ready(self);\n\t  });\n\t\n\t}\n\t\n\tPouchDB$5.adapters = {};\n\tPouchDB$5.preferredAdapters = [];\n\t\n\tPouchDB$5.prefix = '_pouch_';\n\t\n\tvar eventEmitter = new events.EventEmitter();\n\t\n\tfunction setUpEventEmitter(Pouch) {\n\t  Object.keys(events.EventEmitter.prototype).forEach(function (key) {\n\t    if (typeof events.EventEmitter.prototype[key] === 'function') {\n\t      Pouch[key] = eventEmitter[key].bind(eventEmitter);\n\t    }\n\t  });\n\t\n\t  // these are created in constructor.js, and allow us to notify each DB with\n\t  // the same name that it was destroyed, via the constructor object\n\t  var destructListeners = Pouch._destructionListeners = new ExportedMap();\n\t\n\t  Pouch.on('ref', function onConstructorRef(db) {\n\t    if (!destructListeners.has(db.name)) {\n\t      destructListeners.set(db.name, []);\n\t    }\n\t    destructListeners.get(db.name).push(db);\n\t  });\n\t\n\t  Pouch.on('unref', function onConstructorUnref(db) {\n\t    if (!destructListeners.has(db.name)) {\n\t      return;\n\t    }\n\t    var dbList = destructListeners.get(db.name);\n\t    var pos = dbList.indexOf(db);\n\t    if (pos < 0) {\n\t      /* istanbul ignore next */\n\t      return;\n\t    }\n\t    dbList.splice(pos, 1);\n\t    if (dbList.length > 1) {\n\t      /* istanbul ignore next */\n\t      destructListeners.set(db.name, dbList);\n\t    } else {\n\t      destructListeners.delete(db.name);\n\t    }\n\t  });\n\t\n\t  Pouch.on('destroyed', function onConstructorDestroyed(name) {\n\t    if (!destructListeners.has(name)) {\n\t      return;\n\t    }\n\t    var dbList = destructListeners.get(name);\n\t    destructListeners.delete(name);\n\t    dbList.forEach(function (db) {\n\t      db.emit('destroyed',true);\n\t    });\n\t  });\n\t}\n\t\n\tsetUpEventEmitter(PouchDB$5);\n\t\n\tPouchDB$5.adapter = function (id, obj, addToPreferredAdapters) {\n\t  /* istanbul ignore else */\n\t  if (obj.valid()) {\n\t    PouchDB$5.adapters[id] = obj;\n\t    if (addToPreferredAdapters) {\n\t      PouchDB$5.preferredAdapters.push(id);\n\t    }\n\t  }\n\t};\n\t\n\tPouchDB$5.plugin = function (obj) {\n\t  if (typeof obj === 'function') { // function style for plugins\n\t    obj(PouchDB$5);\n\t  } else if (typeof obj !== 'object' || Object.keys(obj).length === 0) {\n\t    throw new Error('Invalid plugin: got \"' + obj + '\", expected an object or a function');\n\t  } else {\n\t    Object.keys(obj).forEach(function (id) { // object style for plugins\n\t      PouchDB$5.prototype[id] = obj[id];\n\t    });\n\t  }\n\t  if (this.__defaults) {\n\t    PouchDB$5.__defaults = $inject_Object_assign({}, this.__defaults);\n\t  }\n\t  return PouchDB$5;\n\t};\n\t\n\tPouchDB$5.defaults = function (defaultOpts) {\n\t  function PouchAlt(name, opts) {\n\t    if (!(this instanceof PouchAlt)) {\n\t      return new PouchAlt(name, opts);\n\t    }\n\t\n\t    opts = opts || {};\n\t\n\t    if (name && typeof name === 'object') {\n\t      opts = name;\n\t      name = opts.name;\n\t      delete opts.name;\n\t    }\n\t\n\t    opts = $inject_Object_assign({}, PouchAlt.__defaults, opts);\n\t    PouchDB$5.call(this, name, opts);\n\t  }\n\t\n\t  inherits(PouchAlt, PouchDB$5);\n\t\n\t  PouchAlt.preferredAdapters = PouchDB$5.preferredAdapters.slice();\n\t  Object.keys(PouchDB$5).forEach(function (key) {\n\t    if (!(key in PouchAlt)) {\n\t      PouchAlt[key] = PouchDB$5[key];\n\t    }\n\t  });\n\t\n\t  // make default options transitive\n\t  // https://github.com/pouchdb/pouchdb/issues/5922\n\t  PouchAlt.__defaults = $inject_Object_assign({}, this.__defaults, defaultOpts);\n\t\n\t  return PouchAlt;\n\t};\n\t\n\t// managed automatically by set-version.js\n\tvar version = \"6.3.4\";\n\t\n\tfunction debugPouch(PouchDB) {\n\t  PouchDB.debug = debug;\n\t  var logs = {};\n\t  /* istanbul ignore next */\n\t  PouchDB.on('debug', function (args) {\n\t    // first argument is log identifier\n\t    var logId = args[0];\n\t    // rest should be passed verbatim to debug module\n\t    var logArgs = args.slice(1);\n\t    if (!logs[logId]) {\n\t      logs[logId] = debug('pouchdb:' + logId);\n\t    }\n\t    logs[logId].apply(null, logArgs);\n\t  });\n\t}\n\t\n\t// this would just be \"return doc[field]\", but fields\n\t// can be \"deep\" due to dot notation\n\tfunction getFieldFromDoc(doc, parsedField) {\n\t  var value = doc;\n\t  for (var i = 0, len = parsedField.length; i < len; i++) {\n\t    var key = parsedField[i];\n\t    value = value[key];\n\t    if (!value) {\n\t      break;\n\t    }\n\t  }\n\t  return value;\n\t}\n\t\n\tfunction compare$1(left, right) {\n\t  return left < right ? -1 : left > right ? 1 : 0;\n\t}\n\t\n\t// Converts a string in dot notation to an array of its components, with backslash escaping\n\tfunction parseField(fieldName) {\n\t  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n\t  var fields = [];\n\t  var current = '';\n\t  for (var i = 0, len = fieldName.length; i < len; i++) {\n\t    var ch = fieldName[i];\n\t    if (ch === '.') {\n\t      if (i > 0 && fieldName[i - 1] === '\\\\') { // escaped delimiter\n\t        current = current.substring(0, current.length - 1) + '.';\n\t      } else { // not escaped, so delimiter\n\t        fields.push(current);\n\t        current = '';\n\t      }\n\t    } else { // normal character\n\t      current += ch;\n\t    }\n\t  }\n\t  fields.push(current);\n\t  return fields;\n\t}\n\t\n\tvar combinationFields = ['$or', '$nor', '$not'];\n\tfunction isCombinationalField(field) {\n\t  return combinationFields.indexOf(field) > -1;\n\t}\n\t\n\tfunction getKey(obj) {\n\t  return Object.keys(obj)[0];\n\t}\n\t\n\tfunction getValue(obj) {\n\t  return obj[getKey(obj)];\n\t}\n\t\n\t\n\t// flatten an array of selectors joined by an $and operator\n\tfunction mergeAndedSelectors(selectors) {\n\t\n\t  // sort to ensure that e.g. if the user specified\n\t  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n\t  // just {$gt: 'b'}\n\t  var res = {};\n\t\n\t  selectors.forEach(function (selector) {\n\t    Object.keys(selector).forEach(function (field) {\n\t      var matcher = selector[field];\n\t      if (typeof matcher !== 'object') {\n\t        matcher = {$eq: matcher};\n\t      }\n\t\n\t      if (isCombinationalField(field)) {\n\t        if (matcher instanceof Array) {\n\t          res[field] = matcher.map(function (m) {\n\t            return mergeAndedSelectors([m]);\n\t          });\n\t        } else {\n\t          res[field] = mergeAndedSelectors([matcher]);\n\t        }\n\t      } else {\n\t        var fieldMatchers = res[field] = res[field] || {};\n\t        Object.keys(matcher).forEach(function (operator) {\n\t          var value = matcher[operator];\n\t\n\t          if (operator === '$gt' || operator === '$gte') {\n\t            return mergeGtGte(operator, value, fieldMatchers);\n\t          } else if (operator === '$lt' || operator === '$lte') {\n\t            return mergeLtLte(operator, value, fieldMatchers);\n\t          } else if (operator === '$ne') {\n\t            return mergeNe(value, fieldMatchers);\n\t          } else if (operator === '$eq') {\n\t            return mergeEq(value, fieldMatchers);\n\t          }\n\t          fieldMatchers[operator] = value;\n\t        });\n\t      }\n\t    });\n\t  });\n\t\n\t  return res;\n\t}\n\t\n\t\n\t\n\t// collapse logically equivalent gt/gte values\n\tfunction mergeGtGte(operator, value, fieldMatchers) {\n\t  if (typeof fieldMatchers.$eq !== 'undefined') {\n\t    return; // do nothing\n\t  }\n\t  if (typeof fieldMatchers.$gte !== 'undefined') {\n\t    if (operator === '$gte') {\n\t      if (value > fieldMatchers.$gte) { // more specificity\n\t        fieldMatchers.$gte = value;\n\t      }\n\t    } else { // operator === '$gt'\n\t      if (value >= fieldMatchers.$gte) { // more specificity\n\t        delete fieldMatchers.$gte;\n\t        fieldMatchers.$gt = value;\n\t      }\n\t    }\n\t  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n\t    if (operator === '$gte') {\n\t      if (value > fieldMatchers.$gt) { // more specificity\n\t        delete fieldMatchers.$gt;\n\t        fieldMatchers.$gte = value;\n\t      }\n\t    } else { // operator === '$gt'\n\t      if (value > fieldMatchers.$gt) { // more specificity\n\t        fieldMatchers.$gt = value;\n\t      }\n\t    }\n\t  } else {\n\t    fieldMatchers[operator] = value;\n\t  }\n\t}\n\t\n\t// collapse logically equivalent lt/lte values\n\tfunction mergeLtLte(operator, value, fieldMatchers) {\n\t  if (typeof fieldMatchers.$eq !== 'undefined') {\n\t    return; // do nothing\n\t  }\n\t  if (typeof fieldMatchers.$lte !== 'undefined') {\n\t    if (operator === '$lte') {\n\t      if (value < fieldMatchers.$lte) { // more specificity\n\t        fieldMatchers.$lte = value;\n\t      }\n\t    } else { // operator === '$gt'\n\t      if (value <= fieldMatchers.$lte) { // more specificity\n\t        delete fieldMatchers.$lte;\n\t        fieldMatchers.$lt = value;\n\t      }\n\t    }\n\t  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n\t    if (operator === '$lte') {\n\t      if (value < fieldMatchers.$lt) { // more specificity\n\t        delete fieldMatchers.$lt;\n\t        fieldMatchers.$lte = value;\n\t      }\n\t    } else { // operator === '$gt'\n\t      if (value < fieldMatchers.$lt) { // more specificity\n\t        fieldMatchers.$lt = value;\n\t      }\n\t    }\n\t  } else {\n\t    fieldMatchers[operator] = value;\n\t  }\n\t}\n\t\n\t// combine $ne values into one array\n\tfunction mergeNe(value, fieldMatchers) {\n\t  if ('$ne' in fieldMatchers) {\n\t    // there are many things this could \"not\" be\n\t    fieldMatchers.$ne.push(value);\n\t  } else { // doesn't exist yet\n\t    fieldMatchers.$ne = [value];\n\t  }\n\t}\n\t\n\t// add $eq into the mix\n\tfunction mergeEq(value, fieldMatchers) {\n\t  // these all have less specificity than the $eq\n\t  // TODO: check for user errors here\n\t  delete fieldMatchers.$gt;\n\t  delete fieldMatchers.$gte;\n\t  delete fieldMatchers.$lt;\n\t  delete fieldMatchers.$lte;\n\t  delete fieldMatchers.$ne;\n\t  fieldMatchers.$eq = value;\n\t}\n\t\n\t\n\t//\n\t// normalize the selector\n\t//\n\tfunction massageSelector(input) {\n\t  var result = clone(input);\n\t  var wasAnded = false;\n\t  if ('$and' in result) {\n\t    result = mergeAndedSelectors(result['$and']);\n\t    wasAnded = true;\n\t  }\n\t\n\t  ['$or', '$nor'].forEach(function (orOrNor) {\n\t    if (orOrNor in result) {\n\t      // message each individual selector\n\t      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}\n\t      result[orOrNor].forEach(function (subSelector) {\n\t        var fields = Object.keys(subSelector);\n\t        for (var i = 0; i < fields.length; i++) {\n\t          var field = fields[i];\n\t          var matcher = subSelector[field];\n\t          if (typeof matcher !== 'object' || matcher === null) {\n\t            subSelector[field] = {$eq: matcher};\n\t          }\n\t        }\n\t      });\n\t    }\n\t  });\n\t\n\t  if ('$not' in result) {\n\t    //This feels a little like forcing, but it will work for now,\n\t    //I would like to come back to this and make the merging of selectors a little more generic\n\t    result['$not'] = mergeAndedSelectors([result['$not']]);\n\t  }\n\t\n\t  var fields = Object.keys(result);\n\t\n\t  for (var i = 0; i < fields.length; i++) {\n\t    var field = fields[i];\n\t    var matcher = result[field];\n\t\n\t    if (typeof matcher !== 'object' || matcher === null) {\n\t      matcher = {$eq: matcher};\n\t    } else if ('$ne' in matcher && !wasAnded) {\n\t      // I put these in an array, since there may be more than one\n\t      // but in the \"mergeAnded\" operation, I already take care of that\n\t      matcher.$ne = [matcher.$ne];\n\t    }\n\t    result[field] = matcher;\n\t  }\n\t\n\t  return result;\n\t}\n\t\n\tfunction pad(str, padWith, upToLength) {\n\t  var padding = '';\n\t  var targetLength = upToLength - str.length;\n\t  /* istanbul ignore next */\n\t  while (padding.length < targetLength) {\n\t    padding += padWith;\n\t  }\n\t  return padding;\n\t}\n\t\n\tfunction padLeft(str, padWith, upToLength) {\n\t  var padding = pad(str, padWith, upToLength);\n\t  return padding + str;\n\t}\n\t\n\tvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\n\tvar MAGNITUDE_DIGITS = 3; // ditto\n\tvar SEP = ''; // set to '_' for easier debugging \n\t\n\tfunction collate(a, b) {\n\t\n\t  if (a === b) {\n\t    return 0;\n\t  }\n\t\n\t  a = normalizeKey(a);\n\t  b = normalizeKey(b);\n\t\n\t  var ai = collationIndex(a);\n\t  var bi = collationIndex(b);\n\t  if ((ai - bi) !== 0) {\n\t    return ai - bi;\n\t  }\n\t  switch (typeof a) {\n\t    case 'number':\n\t      return a - b;\n\t    case 'boolean':\n\t      return a < b ? -1 : 1;\n\t    case 'string':\n\t      return stringCollate(a, b);\n\t  }\n\t  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n\t}\n\t\n\t// couch considers null/NaN/Infinity/-Infinity === undefined,\n\t// for the purposes of mapreduce indexes. also, dates get stringified.\n\tfunction normalizeKey(key) {\n\t  switch (typeof key) {\n\t    case 'undefined':\n\t      return null;\n\t    case 'number':\n\t      if (key === Infinity || key === -Infinity || isNaN(key)) {\n\t        return null;\n\t      }\n\t      return key;\n\t    case 'object':\n\t      var origKey = key;\n\t      if (Array.isArray(key)) {\n\t        var len = key.length;\n\t        key = new Array(len);\n\t        for (var i = 0; i < len; i++) {\n\t          key[i] = normalizeKey(origKey[i]);\n\t        }\n\t      /* istanbul ignore next */\n\t      } else if (key instanceof Date) {\n\t        return key.toJSON();\n\t      } else if (key !== null) { // generic object\n\t        key = {};\n\t        for (var k in origKey) {\n\t          if (origKey.hasOwnProperty(k)) {\n\t            var val = origKey[k];\n\t            if (typeof val !== 'undefined') {\n\t              key[k] = normalizeKey(val);\n\t            }\n\t          }\n\t        }\n\t      }\n\t  }\n\t  return key;\n\t}\n\t\n\tfunction indexify(key) {\n\t  if (key !== null) {\n\t    switch (typeof key) {\n\t      case 'boolean':\n\t        return key ? 1 : 0;\n\t      case 'number':\n\t        return numToIndexableString(key);\n\t      case 'string':\n\t        // We've to be sure that key does not contain \\u0000\n\t        // Do order-preserving replacements:\n\t        // 0 -> 1, 1\n\t        // 1 -> 1, 2\n\t        // 2 -> 2, 2\n\t        return key\n\t          .replace(/\\u0002/g, '\\u0002\\u0002')\n\t          .replace(/\\u0001/g, '\\u0001\\u0002')\n\t          .replace(/\\u0000/g, '\\u0001\\u0001');\n\t      case 'object':\n\t        var isArray = Array.isArray(key);\n\t        var arr = isArray ? key : Object.keys(key);\n\t        var i = -1;\n\t        var len = arr.length;\n\t        var result = '';\n\t        if (isArray) {\n\t          while (++i < len) {\n\t            result += toIndexableString(arr[i]);\n\t          }\n\t        } else {\n\t          while (++i < len) {\n\t            var objKey = arr[i];\n\t            result += toIndexableString(objKey) +\n\t                toIndexableString(key[objKey]);\n\t          }\n\t        }\n\t        return result;\n\t    }\n\t  }\n\t  return '';\n\t}\n\t\n\t// convert the given key to a string that would be appropriate\n\t// for lexical sorting, e.g. within a database, where the\n\t// sorting is the same given by the collate() function.\n\tfunction toIndexableString(key) {\n\t  var zero = '\\u0000';\n\t  key = normalizeKey(key);\n\t  return collationIndex(key) + SEP + indexify(key) + zero;\n\t}\n\t\n\tfunction parseNumber(str, i) {\n\t  var originalIdx = i;\n\t  var num;\n\t  var zero = str[i] === '1';\n\t  if (zero) {\n\t    num = 0;\n\t    i++;\n\t  } else {\n\t    var neg = str[i] === '0';\n\t    i++;\n\t    var numAsString = '';\n\t    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n\t    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n\t    /* istanbul ignore next */\n\t    if (neg) {\n\t      magnitude = -magnitude;\n\t    }\n\t    i += MAGNITUDE_DIGITS;\n\t    while (true) {\n\t      var ch = str[i];\n\t      if (ch === '\\u0000') {\n\t        break;\n\t      } else {\n\t        numAsString += ch;\n\t      }\n\t      i++;\n\t    }\n\t    numAsString = numAsString.split('.');\n\t    if (numAsString.length === 1) {\n\t      num = parseInt(numAsString, 10);\n\t    } else {\n\t      /* istanbul ignore next */\n\t      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n\t    }\n\t    /* istanbul ignore next */\n\t    if (neg) {\n\t      num = num - 10;\n\t    }\n\t    /* istanbul ignore next */\n\t    if (magnitude !== 0) {\n\t      // parseFloat is more reliable than pow due to rounding errors\n\t      // e.g. Number.MAX_VALUE would return Infinity if we did\n\t      // num * Math.pow(10, magnitude);\n\t      num = parseFloat(num + 'e' + magnitude);\n\t    }\n\t  }\n\t  return {num: num, length : i - originalIdx};\n\t}\n\t\n\t// move up the stack while parsing\n\t// this function moved outside of parseIndexableString for performance\n\tfunction pop(stack, metaStack) {\n\t  var obj = stack.pop();\n\t\n\t  if (metaStack.length) {\n\t    var lastMetaElement = metaStack[metaStack.length - 1];\n\t    if (obj === lastMetaElement.element) {\n\t      // popping a meta-element, e.g. an object whose value is another object\n\t      metaStack.pop();\n\t      lastMetaElement = metaStack[metaStack.length - 1];\n\t    }\n\t    var element = lastMetaElement.element;\n\t    var lastElementIndex = lastMetaElement.index;\n\t    if (Array.isArray(element)) {\n\t      element.push(obj);\n\t    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n\t      var key = stack.pop();\n\t      element[key] = obj;\n\t    } else {\n\t      stack.push(obj); // obj with key only\n\t    }\n\t  }\n\t}\n\t\n\tfunction parseIndexableString(str) {\n\t  var stack = [];\n\t  var metaStack = []; // stack for arrays and objects\n\t  var i = 0;\n\t\n\t  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n\t  while (true) {\n\t    var collationIndex = str[i++];\n\t    if (collationIndex === '\\u0000') {\n\t      if (stack.length === 1) {\n\t        return stack.pop();\n\t      } else {\n\t        pop(stack, metaStack);\n\t        continue;\n\t      }\n\t    }\n\t    switch (collationIndex) {\n\t      case '1':\n\t        stack.push(null);\n\t        break;\n\t      case '2':\n\t        stack.push(str[i] === '1');\n\t        i++;\n\t        break;\n\t      case '3':\n\t        var parsedNum = parseNumber(str, i);\n\t        stack.push(parsedNum.num);\n\t        i += parsedNum.length;\n\t        break;\n\t      case '4':\n\t        var parsedStr = '';\n\t        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n\t        while (true) {\n\t          var ch = str[i];\n\t          if (ch === '\\u0000') {\n\t            break;\n\t          }\n\t          parsedStr += ch;\n\t          i++;\n\t        }\n\t        // perform the reverse of the order-preserving replacement\n\t        // algorithm (see above)\n\t        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n\t          .replace(/\\u0001\\u0002/g, '\\u0001')\n\t          .replace(/\\u0002\\u0002/g, '\\u0002');\n\t        stack.push(parsedStr);\n\t        break;\n\t      case '5':\n\t        var arrayElement = { element: [], index: stack.length };\n\t        stack.push(arrayElement.element);\n\t        metaStack.push(arrayElement);\n\t        break;\n\t      case '6':\n\t        var objElement = { element: {}, index: stack.length };\n\t        stack.push(objElement.element);\n\t        metaStack.push(objElement);\n\t        break;\n\t      /* istanbul ignore next */\n\t      default:\n\t        throw new Error(\n\t          'bad collationIndex or unexpectedly reached end of input: ' +\n\t            collationIndex);\n\t    }\n\t  }\n\t}\n\t\n\tfunction arrayCollate(a, b) {\n\t  var len = Math.min(a.length, b.length);\n\t  for (var i = 0; i < len; i++) {\n\t    var sort = collate(a[i], b[i]);\n\t    if (sort !== 0) {\n\t      return sort;\n\t    }\n\t  }\n\t  return (a.length === b.length) ? 0 :\n\t    (a.length > b.length) ? 1 : -1;\n\t}\n\tfunction stringCollate(a, b) {\n\t  // See: https://github.com/daleharvey/pouchdb/issues/40\n\t  // This is incompatible with the CouchDB implementation, but its the\n\t  // best we can do for now\n\t  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n\t}\n\tfunction objectCollate(a, b) {\n\t  var ak = Object.keys(a), bk = Object.keys(b);\n\t  var len = Math.min(ak.length, bk.length);\n\t  for (var i = 0; i < len; i++) {\n\t    // First sort the keys\n\t    var sort = collate(ak[i], bk[i]);\n\t    if (sort !== 0) {\n\t      return sort;\n\t    }\n\t    // if the keys are equal sort the values\n\t    sort = collate(a[ak[i]], b[bk[i]]);\n\t    if (sort !== 0) {\n\t      return sort;\n\t    }\n\t\n\t  }\n\t  return (ak.length === bk.length) ? 0 :\n\t    (ak.length > bk.length) ? 1 : -1;\n\t}\n\t// The collation is defined by erlangs ordered terms\n\t// the atoms null, true, false come first, then numbers, strings,\n\t// arrays, then objects\n\t// null/undefined/NaN/Infinity/-Infinity are all considered null\n\tfunction collationIndex(x) {\n\t  var id = ['boolean', 'number', 'string', 'object'];\n\t  var idx = id.indexOf(typeof x);\n\t  //false if -1 otherwise true, but fast!!!!1\n\t  if (~idx) {\n\t    if (x === null) {\n\t      return 1;\n\t    }\n\t    if (Array.isArray(x)) {\n\t      return 5;\n\t    }\n\t    return idx < 3 ? (idx + 2) : (idx + 3);\n\t  }\n\t  /* istanbul ignore next */\n\t  if (Array.isArray(x)) {\n\t    return 5;\n\t  }\n\t}\n\t\n\t// conversion:\n\t// x yyy zz...zz\n\t// x = 0 for negative, 1 for 0, 2 for positive\n\t// y = exponent (for negative numbers negated) moved so that it's >= 0\n\t// z = mantisse\n\tfunction numToIndexableString(num) {\n\t\n\t  if (num === 0) {\n\t    return '1';\n\t  }\n\t\n\t  // convert number to exponential format for easier and\n\t  // more succinct string sorting\n\t  var expFormat = num.toExponential().split(/e\\+?/);\n\t  var magnitude = parseInt(expFormat[1], 10);\n\t\n\t  var neg = num < 0;\n\t\n\t  var result = neg ? '0' : '2';\n\t\n\t  // first sort by magnitude\n\t  // it's easier if all magnitudes are positive\n\t  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n\t  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\t\n\t  result += SEP + magString;\n\t\n\t  // then sort by the factor\n\t  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n\t  /* istanbul ignore next */\n\t  if (neg) { // for negative reverse ordering\n\t    factor = 10 - factor;\n\t  }\n\t\n\t  var factorStr = factor.toFixed(20);\n\t\n\t  // strip zeros from the end\n\t  factorStr = factorStr.replace(/\\.?0+$/, '');\n\t\n\t  result += SEP + factorStr;\n\t\n\t  return result;\n\t}\n\t\n\t// create a comparator based on the sort object\n\tfunction createFieldSorter(sort) {\n\t\n\t  function getFieldValuesAsArray(doc) {\n\t    return sort.map(function (sorting) {\n\t      var fieldName = getKey(sorting);\n\t      var parsedField = parseField(fieldName);\n\t      var docFieldValue = getFieldFromDoc(doc, parsedField);\n\t      return docFieldValue;\n\t    });\n\t  }\n\t\n\t  return function (aRow, bRow) {\n\t    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n\t    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n\t    var collation = collate(aFieldValues, bFieldValues);\n\t    if (collation !== 0) {\n\t      return collation;\n\t    }\n\t    // this is what mango seems to do\n\t    return compare$1(aRow.doc._id, bRow.doc._id);\n\t  };\n\t}\n\t\n\tfunction filterInMemoryFields(rows, requestDef, inMemoryFields) {\n\t  rows = rows.filter(function (row) {\n\t    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n\t  });\n\t\n\t  if (requestDef.sort) {\n\t    // in-memory sort\n\t    var fieldSorter = createFieldSorter(requestDef.sort);\n\t    rows = rows.sort(fieldSorter);\n\t    if (typeof requestDef.sort[0] !== 'string' &&\n\t        getValue(requestDef.sort[0]) === 'desc') {\n\t      rows = rows.reverse();\n\t    }\n\t  }\n\t\n\t  if ('limit' in requestDef || 'skip' in requestDef) {\n\t    // have to do the limit in-memory\n\t    var skip = requestDef.skip || 0;\n\t    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n\t    rows = rows.slice(skip, limit);\n\t  }\n\t  return rows;\n\t}\n\t\n\tfunction rowFilter(doc, selector, inMemoryFields) {\n\t  return inMemoryFields.every(function (field) {\n\t    var matcher = selector[field];\n\t    var parsedField = parseField(field);\n\t    var docFieldValue = getFieldFromDoc(doc, parsedField);\n\t    if (isCombinationalField(field)) {\n\t      return matchCominationalSelector(field, matcher, doc);\n\t    }\n\t\n\t    return matchSelector(matcher, doc, parsedField, docFieldValue);\n\t  });\n\t}\n\t\n\tfunction matchSelector(matcher, doc, parsedField, docFieldValue) {\n\t  if (!matcher) {\n\t    // no filtering necessary; this field is just needed for sorting\n\t    return true;\n\t  }\n\t\n\t  return Object.keys(matcher).every(function (userOperator) {\n\t    var userValue = matcher[userOperator];\n\t    return match(userOperator, doc, userValue, parsedField, docFieldValue);\n\t  });\n\t}\n\t\n\tfunction matchCominationalSelector(field, matcher, doc) {\n\t\n\t  if (field === '$or') {\n\t    return matcher.some(function (orMatchers) {\n\t      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n\t    });\n\t  }\n\t\n\t  if (field === '$not') {\n\t    return !rowFilter(doc, matcher, Object.keys(matcher));\n\t  }\n\t\n\t  //`$nor`\n\t  return !matcher.find(function (orMatchers) {\n\t    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n\t  });\n\t\n\t}\n\t\n\tfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n\t  if (!matchers[userOperator]) {\n\t    throw new Error('unknown operator \"' + userOperator +\n\t      '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +\n\t      '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');\n\t  }\n\t  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n\t}\n\t\n\tfunction fieldExists(docFieldValue) {\n\t  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n\t}\n\t\n\tfunction fieldIsNotUndefined(docFieldValue) {\n\t  return typeof docFieldValue !== 'undefined';\n\t}\n\t\n\tfunction modField(docFieldValue, userValue) {\n\t  var divisor = userValue[0];\n\t  var mod = userValue[1];\n\t  if (divisor === 0) {\n\t    throw new Error('Bad divisor, cannot divide by zero');\n\t  }\n\t\n\t  if (parseInt(divisor, 10) !== divisor ) {\n\t    throw new Error('Divisor is not an integer');\n\t  }\n\t\n\t  if (parseInt(mod, 10) !== mod ) {\n\t    throw new Error('Modulus is not an integer');\n\t  }\n\t\n\t  if (parseInt(docFieldValue, 10) !== docFieldValue) {\n\t    return false;\n\t  }\n\t\n\t  return docFieldValue % divisor === mod;\n\t}\n\t\n\tfunction arrayContainsValue(docFieldValue, userValue) {\n\t  return userValue.some(function (val) {\n\t    if (docFieldValue instanceof Array) {\n\t      return docFieldValue.indexOf(val) > -1;\n\t    }\n\t\n\t    return docFieldValue === val;\n\t  });\n\t}\n\t\n\tfunction arrayContainsAllValues(docFieldValue, userValue) {\n\t  return userValue.every(function (val) {\n\t    return docFieldValue.indexOf(val) > -1;\n\t  });\n\t}\n\t\n\tfunction arraySize(docFieldValue, userValue) {\n\t  return docFieldValue.length === userValue;\n\t}\n\t\n\tfunction regexMatch(docFieldValue, userValue) {\n\t  var re = new RegExp(userValue);\n\t\n\t  return re.test(docFieldValue);\n\t}\n\t\n\tfunction typeMatch(docFieldValue, userValue) {\n\t\n\t  switch (userValue) {\n\t    case 'null':\n\t      return docFieldValue === null;\n\t    case 'boolean':\n\t      return typeof (docFieldValue) === 'boolean';\n\t    case 'number':\n\t      return typeof (docFieldValue) === 'number';\n\t    case 'string':\n\t      return typeof (docFieldValue) === 'string';\n\t    case 'array':\n\t      return docFieldValue instanceof Array;\n\t    case 'object':\n\t      return ({}).toString.call(docFieldValue) === '[object Object]';\n\t  }\n\t\n\t  throw new Error(userValue + ' not supported as a type.' +\n\t                  'Please use one of object, string, array, number, boolean or null.');\n\t\n\t}\n\t\n\tvar matchers = {\n\t\n\t  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n\t    if (!Array.isArray(docFieldValue)) {\n\t      return false;\n\t    }\n\t\n\t    if (docFieldValue.length === 0) {\n\t      return false;\n\t    }\n\t\n\t    if (typeof docFieldValue[0] === 'object') {\n\t      return docFieldValue.some(function (val) {\n\t        return rowFilter(val, userValue, Object.keys(userValue));\n\t      });\n\t    }\n\t\n\t    return docFieldValue.some(function (val) {\n\t      return matchSelector(userValue, doc, parsedField, val);\n\t    });\n\t  },\n\t\n\t  '$allMatch': function (doc, userValue, parsedField, docFieldValue) {\n\t    if (!Array.isArray(docFieldValue)) {\n\t      return false;\n\t    }\n\t\n\t    /* istanbul ignore next */\n\t    if (docFieldValue.length === 0) {\n\t      return false;\n\t    }\n\t\n\t    if (typeof docFieldValue[0] === 'object') {\n\t      return docFieldValue.every(function (val) {\n\t        return rowFilter(val, userValue, Object.keys(userValue));\n\t      });\n\t    }\n\t\n\t    return docFieldValue.every(function (val) {\n\t      return matchSelector(userValue, doc, parsedField, val);\n\t    });\n\t  },\n\t\n\t  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n\t  },\n\t\n\t  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n\t  },\n\t\n\t  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n\t  },\n\t\n\t  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n\t  },\n\t\n\t  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n\t  },\n\t\n\t  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n\t    //a field that is null is still considered to exist\n\t    if (userValue) {\n\t      return fieldIsNotUndefined(docFieldValue);\n\t    }\n\t\n\t    return !fieldIsNotUndefined(docFieldValue);\n\t  },\n\t\n\t  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n\t  },\n\t\n\t  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n\t    return userValue.every(function (neValue) {\n\t      return collate(docFieldValue, neValue) !== 0;\n\t    });\n\t  },\n\t  '$in': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n\t  },\n\t\n\t  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n\t  },\n\t\n\t  '$size': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);\n\t  },\n\t\n\t  '$all': function (doc, userValue, parsedField, docFieldValue) {\n\t    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n\t  },\n\t\n\t  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);\n\t  },\n\t\n\t  '$type': function (doc, userValue, parsedField, docFieldValue) {\n\t    return typeMatch(docFieldValue, userValue);\n\t  }\n\t};\n\t\n\t// return true if the given doc matches the supplied selector\n\tfunction matchesSelector(doc, selector) {\n\t  /* istanbul ignore if */\n\t  if (typeof selector !== 'object') {\n\t    // match the CouchDB error message\n\t    throw new Error('Selector error: expected a JSON object');\n\t  }\n\t\n\t  selector = massageSelector(selector);\n\t  var row = {\n\t    'doc': doc\n\t  };\n\t\n\t  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));\n\t  return rowsMatched && rowsMatched.length === 1;\n\t}\n\t\n\tfunction evalFilter(input) {\n\t  return scopeEval('\"use strict\";\\nreturn ' + input + ';', {});\n\t}\n\t\n\tfunction evalView(input) {\n\t  var code = [\n\t    'return function(doc) {',\n\t    '  \"use strict\";',\n\t    '  var emitted = false;',\n\t    '  var emit = function (a, b) {',\n\t    '    emitted = true;',\n\t    '  };',\n\t    '  var view = ' + input + ';',\n\t    '  view(doc);',\n\t    '  if (emitted) {',\n\t    '    return true;',\n\t    '  }',\n\t    '};'\n\t  ].join('\\n');\n\t\n\t  return scopeEval(code, {});\n\t}\n\t\n\tfunction validate(opts, callback) {\n\t  if (opts.selector) {\n\t    if (opts.filter && opts.filter !== '_selector') {\n\t      var filterName = typeof opts.filter === 'string' ?\n\t        opts.filter : 'function';\n\t      return callback(new Error('selector invalid for filter \"' + filterName + '\"'));\n\t    }\n\t  }\n\t  callback();\n\t}\n\t\n\tfunction normalize(opts) {\n\t  if (opts.view && !opts.filter) {\n\t    opts.filter = '_view';\n\t  }\n\t\n\t  if (opts.selector && !opts.filter) {\n\t    opts.filter = '_selector';\n\t  }\n\t\n\t  if (opts.filter && typeof opts.filter === 'string') {\n\t    if (opts.filter === '_view') {\n\t      opts.view = normalizeDesignDocFunctionName(opts.view);\n\t    } else {\n\t      opts.filter = normalizeDesignDocFunctionName(opts.filter);\n\t    }\n\t  }\n\t}\n\t\n\tfunction shouldFilter(changesHandler, opts) {\n\t  return opts.filter && typeof opts.filter === 'string' &&\n\t    !opts.doc_ids && !isRemote(changesHandler.db);\n\t}\n\t\n\tfunction filter(changesHandler, opts) {\n\t  var callback = opts.complete;\n\t  if (opts.filter === '_view') {\n\t    if (!opts.view || typeof opts.view !== 'string') {\n\t      var err = createError(BAD_REQUEST,\n\t        '`view` filter parameter not found or invalid.');\n\t      return callback(err);\n\t    }\n\t    // fetch a view from a design doc, make it behave like a filter\n\t    var viewName = parseDesignDocFunctionName(opts.view);\n\t    changesHandler.db.get('_design/' + viewName[0], function (err, ddoc) {\n\t      /* istanbul ignore if */\n\t      if (changesHandler.isCancelled) {\n\t        return callback(null, {status: 'cancelled'});\n\t      }\n\t      /* istanbul ignore next */\n\t      if (err) {\n\t        return callback(generateErrorFromResponse(err));\n\t      }\n\t      var mapFun = ddoc && ddoc.views && ddoc.views[viewName[1]] &&\n\t        ddoc.views[viewName[1]].map;\n\t      if (!mapFun) {\n\t        return callback(createError(MISSING_DOC,\n\t          (ddoc.views ? 'missing json key: ' + viewName[1] :\n\t            'missing json key: views')));\n\t      }\n\t      opts.filter = evalView(mapFun);\n\t      changesHandler.doChanges(opts);\n\t    });\n\t  } else if (opts.selector) {\n\t    opts.filter = function (doc) {\n\t      return matchesSelector(doc, opts.selector);\n\t    };\n\t    changesHandler.doChanges(opts);\n\t  } else {\n\t    // fetch a filter from a design doc\n\t    var filterName = parseDesignDocFunctionName(opts.filter);\n\t    changesHandler.db.get('_design/' + filterName[0], function (err, ddoc) {\n\t      /* istanbul ignore if */\n\t      if (changesHandler.isCancelled) {\n\t        return callback(null, {status: 'cancelled'});\n\t      }\n\t      /* istanbul ignore next */\n\t      if (err) {\n\t        return callback(generateErrorFromResponse(err));\n\t      }\n\t      var filterFun = ddoc && ddoc.filters && ddoc.filters[filterName[1]];\n\t      if (!filterFun) {\n\t        return callback(createError(MISSING_DOC,\n\t          ((ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]\n\t            : 'missing json key: filters')));\n\t      }\n\t      opts.filter = evalFilter(filterFun);\n\t      changesHandler.doChanges(opts);\n\t    });\n\t  }\n\t}\n\t\n\tfunction applyChangesFilterPlugin(PouchDB) {\n\t  PouchDB._changesFilterPlugin = {\n\t    validate: validate,\n\t    normalize: normalize,\n\t    shouldFilter: shouldFilter,\n\t    filter: filter\n\t  };\n\t}\n\t\n\t// TODO: remove from pouchdb-core (breaking)\n\tPouchDB$5.plugin(debugPouch);\n\t\n\t// TODO: remove from pouchdb-core (breaking)\n\tPouchDB$5.plugin(applyChangesFilterPlugin);\n\t\n\tPouchDB$5.version = version;\n\t\n\tfunction toObject(array) {\n\t  return array.reduce(function (obj, item) {\n\t    obj[item] = true;\n\t    return obj;\n\t  }, {});\n\t}\n\t// List of top level reserved words for doc\n\tvar reservedWords = toObject([\n\t  '_id',\n\t  '_rev',\n\t  '_attachments',\n\t  '_deleted',\n\t  '_revisions',\n\t  '_revs_info',\n\t  '_conflicts',\n\t  '_deleted_conflicts',\n\t  '_local_seq',\n\t  '_rev_tree',\n\t  //replication documents\n\t  '_replication_id',\n\t  '_replication_state',\n\t  '_replication_state_time',\n\t  '_replication_state_reason',\n\t  '_replication_stats',\n\t  // Specific to Couchbase Sync Gateway\n\t  '_removed'\n\t]);\n\t\n\t// List of reserved words that should end up the document\n\tvar dataWords = toObject([\n\t  '_attachments',\n\t  //replication documents\n\t  '_replication_id',\n\t  '_replication_state',\n\t  '_replication_state_time',\n\t  '_replication_state_reason',\n\t  '_replication_stats'\n\t]);\n\t\n\tfunction parseRevisionInfo(rev$$1) {\n\t  if (!/^\\d+-./.test(rev$$1)) {\n\t    return createError(INVALID_REV);\n\t  }\n\t  var idx = rev$$1.indexOf('-');\n\t  var left = rev$$1.substring(0, idx);\n\t  var right = rev$$1.substring(idx + 1);\n\t  return {\n\t    prefix: parseInt(left, 10),\n\t    id: right\n\t  };\n\t}\n\t\n\tfunction makeRevTreeFromRevisions(revisions, opts) {\n\t  var pos = revisions.start - revisions.ids.length + 1;\n\t\n\t  var revisionIds = revisions.ids;\n\t  var ids = [revisionIds[0], opts, []];\n\t\n\t  for (var i = 1, len = revisionIds.length; i < len; i++) {\n\t    ids = [revisionIds[i], {status: 'missing'}, [ids]];\n\t  }\n\t\n\t  return [{\n\t    pos: pos,\n\t    ids: ids\n\t  }];\n\t}\n\t\n\t// Preprocess documents, parse their revisions, assign an id and a\n\t// revision for new writes that are missing them, etc\n\tfunction parseDoc(doc, newEdits) {\n\t\n\t  var nRevNum;\n\t  var newRevId;\n\t  var revInfo;\n\t  var opts = {status: 'available'};\n\t  if (doc._deleted) {\n\t    opts.deleted = true;\n\t  }\n\t\n\t  if (newEdits) {\n\t    if (!doc._id) {\n\t      doc._id = uuid();\n\t    }\n\t    newRevId = rev();\n\t    if (doc._rev) {\n\t      revInfo = parseRevisionInfo(doc._rev);\n\t      if (revInfo.error) {\n\t        return revInfo;\n\t      }\n\t      doc._rev_tree = [{\n\t        pos: revInfo.prefix,\n\t        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]\n\t      }];\n\t      nRevNum = revInfo.prefix + 1;\n\t    } else {\n\t      doc._rev_tree = [{\n\t        pos: 1,\n\t        ids : [newRevId, opts, []]\n\t      }];\n\t      nRevNum = 1;\n\t    }\n\t  } else {\n\t    if (doc._revisions) {\n\t      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);\n\t      nRevNum = doc._revisions.start;\n\t      newRevId = doc._revisions.ids[0];\n\t    }\n\t    if (!doc._rev_tree) {\n\t      revInfo = parseRevisionInfo(doc._rev);\n\t      if (revInfo.error) {\n\t        return revInfo;\n\t      }\n\t      nRevNum = revInfo.prefix;\n\t      newRevId = revInfo.id;\n\t      doc._rev_tree = [{\n\t        pos: nRevNum,\n\t        ids: [newRevId, opts, []]\n\t      }];\n\t    }\n\t  }\n\t\n\t  invalidIdError(doc._id);\n\t\n\t  doc._rev = nRevNum + '-' + newRevId;\n\t\n\t  var result = {metadata : {}, data : {}};\n\t  for (var key in doc) {\n\t    /* istanbul ignore else */\n\t    if (Object.prototype.hasOwnProperty.call(doc, key)) {\n\t      var specialKey = key[0] === '_';\n\t      if (specialKey && !reservedWords[key]) {\n\t        var error = createError(DOC_VALIDATION, key);\n\t        error.message = DOC_VALIDATION.message + ': ' + key;\n\t        throw error;\n\t      } else if (specialKey && !dataWords[key]) {\n\t        result.metadata[key.slice(1)] = doc[key];\n\t      } else {\n\t        result.data[key] = doc[key];\n\t      }\n\t    }\n\t  }\n\t  return result;\n\t}\n\t\n\tvar thisAtob = function (str) {\n\t  return atob(str);\n\t};\n\t\n\tvar thisBtoa = function (str) {\n\t  return btoa(str);\n\t};\n\t\n\t// Abstracts constructing a Blob object, so it also works in older\n\t// browsers that don't support the native Blob constructor (e.g.\n\t// old QtWebKit versions, Android < 4.4).\n\tfunction createBlob(parts, properties) {\n\t  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n\t  parts = parts || [];\n\t  properties = properties || {};\n\t  try {\n\t    return new Blob(parts, properties);\n\t  } catch (e) {\n\t    if (e.name !== \"TypeError\") {\n\t      throw e;\n\t    }\n\t    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n\t                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n\t                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n\t                  WebKitBlobBuilder;\n\t    var builder = new Builder();\n\t    for (var i = 0; i < parts.length; i += 1) {\n\t      builder.append(parts[i]);\n\t    }\n\t    return builder.getBlob(properties.type);\n\t  }\n\t}\n\t\n\t// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n\t// encode-decode-image-with-base64-breaks-image (2013-04-21)\n\tfunction binaryStringToArrayBuffer(bin) {\n\t  var length = bin.length;\n\t  var buf = new ArrayBuffer(length);\n\t  var arr = new Uint8Array(buf);\n\t  for (var i = 0; i < length; i++) {\n\t    arr[i] = bin.charCodeAt(i);\n\t  }\n\t  return buf;\n\t}\n\t\n\tfunction binStringToBluffer(binString, type) {\n\t  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});\n\t}\n\t\n\tfunction b64ToBluffer(b64, type) {\n\t  return binStringToBluffer(thisAtob(b64), type);\n\t}\n\t\n\t//Can't find original post, but this is close\n\t//http://stackoverflow.com/questions/6965107/ (continues on next line)\n\t//converting-between-strings-and-arraybuffers\n\tfunction arrayBufferToBinaryString(buffer) {\n\t  var binary = '';\n\t  var bytes = new Uint8Array(buffer);\n\t  var length = bytes.byteLength;\n\t  for (var i = 0; i < length; i++) {\n\t    binary += String.fromCharCode(bytes[i]);\n\t  }\n\t  return binary;\n\t}\n\t\n\t// shim for browsers that don't support it\n\tfunction readAsBinaryString(blob, callback) {\n\t  if (typeof FileReader === 'undefined') {\n\t    // fix for Firefox in a web worker\n\t    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n\t    return callback(arrayBufferToBinaryString(\n\t      new FileReaderSync().readAsArrayBuffer(blob)));\n\t  }\n\t\n\t  var reader = new FileReader();\n\t  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n\t  reader.onloadend = function (e) {\n\t    var result = e.target.result || '';\n\t    if (hasBinaryString) {\n\t      return callback(result);\n\t    }\n\t    callback(arrayBufferToBinaryString(result));\n\t  };\n\t  if (hasBinaryString) {\n\t    reader.readAsBinaryString(blob);\n\t  } else {\n\t    reader.readAsArrayBuffer(blob);\n\t  }\n\t}\n\t\n\tfunction blobToBinaryString(blobOrBuffer, callback) {\n\t  readAsBinaryString(blobOrBuffer, function (bin) {\n\t    callback(bin);\n\t  });\n\t}\n\t\n\tfunction blobToBase64(blobOrBuffer, callback) {\n\t  blobToBinaryString(blobOrBuffer, function (base64) {\n\t    callback(thisBtoa(base64));\n\t  });\n\t}\n\t\n\t// simplified API. universal browser support is assumed\n\tfunction readAsArrayBuffer(blob, callback) {\n\t  if (typeof FileReader === 'undefined') {\n\t    // fix for Firefox in a web worker:\n\t    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n\t    return callback(new FileReaderSync().readAsArrayBuffer(blob));\n\t  }\n\t\n\t  var reader = new FileReader();\n\t  reader.onloadend = function (e) {\n\t    var result = e.target.result || new ArrayBuffer(0);\n\t    callback(result);\n\t  };\n\t  reader.readAsArrayBuffer(blob);\n\t}\n\t\n\t// this is not used in the browser\n\t\n\tvar setImmediateShim = global.setImmediate || global.setTimeout;\n\tvar MD5_CHUNK_SIZE = 32768;\n\t\n\tfunction rawToBase64(raw) {\n\t  return thisBtoa(raw);\n\t}\n\t\n\tfunction sliceBlob(blob, start, end) {\n\t  if (blob.webkitSlice) {\n\t    return blob.webkitSlice(start, end);\n\t  }\n\t  return blob.slice(start, end);\n\t}\n\t\n\tfunction appendBlob(buffer, blob, start, end, callback) {\n\t  if (start > 0 || end < blob.size) {\n\t    // only slice blob if we really need to\n\t    blob = sliceBlob(blob, start, end);\n\t  }\n\t  readAsArrayBuffer(blob, function (arrayBuffer) {\n\t    buffer.append(arrayBuffer);\n\t    callback();\n\t  });\n\t}\n\t\n\tfunction appendString(buffer, string, start, end, callback) {\n\t  if (start > 0 || end < string.length) {\n\t    // only create a substring if we really need to\n\t    string = string.substring(start, end);\n\t  }\n\t  buffer.appendBinary(string);\n\t  callback();\n\t}\n\t\n\tfunction binaryMd5(data, callback) {\n\t  var inputIsString = typeof data === 'string';\n\t  var len = inputIsString ? data.length : data.size;\n\t  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n\t  var chunks = Math.ceil(len / chunkSize);\n\t  var currentChunk = 0;\n\t  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();\n\t\n\t  var append = inputIsString ? appendString : appendBlob;\n\t\n\t  function next() {\n\t    setImmediateShim(loadNextChunk);\n\t  }\n\t\n\t  function done() {\n\t    var raw = buffer.end(true);\n\t    var base64 = rawToBase64(raw);\n\t    callback(base64);\n\t    buffer.destroy();\n\t  }\n\t\n\t  function loadNextChunk() {\n\t    var start = currentChunk * chunkSize;\n\t    var end = start + chunkSize;\n\t    currentChunk++;\n\t    if (currentChunk < chunks) {\n\t      append(buffer, data, start, end, next);\n\t    } else {\n\t      append(buffer, data, start, end, done);\n\t    }\n\t  }\n\t  loadNextChunk();\n\t}\n\t\n\tfunction stringMd5(string) {\n\t  return Md5.hash(string);\n\t}\n\t\n\tfunction parseBase64(data) {\n\t  try {\n\t    return thisAtob(data);\n\t  } catch (e) {\n\t    var err = createError(BAD_ARG,\n\t      'Attachment is not a valid base64 string');\n\t    return {error: err};\n\t  }\n\t}\n\t\n\tfunction preprocessString(att, blobType, callback) {\n\t  var asBinary = parseBase64(att.data);\n\t  if (asBinary.error) {\n\t    return callback(asBinary.error);\n\t  }\n\t\n\t  att.length = asBinary.length;\n\t  if (blobType === 'blob') {\n\t    att.data = binStringToBluffer(asBinary, att.content_type);\n\t  } else if (blobType === 'base64') {\n\t    att.data = thisBtoa(asBinary);\n\t  } else { // binary\n\t    att.data = asBinary;\n\t  }\n\t  binaryMd5(asBinary, function (result) {\n\t    att.digest = 'md5-' + result;\n\t    callback();\n\t  });\n\t}\n\t\n\tfunction preprocessBlob(att, blobType, callback) {\n\t  binaryMd5(att.data, function (md5) {\n\t    att.digest = 'md5-' + md5;\n\t    // size is for blobs (browser), length is for buffers (node)\n\t    att.length = att.data.size || att.data.length || 0;\n\t    if (blobType === 'binary') {\n\t      blobToBinaryString(att.data, function (binString) {\n\t        att.data = binString;\n\t        callback();\n\t      });\n\t    } else if (blobType === 'base64') {\n\t      blobToBase64(att.data, function (b64) {\n\t        att.data = b64;\n\t        callback();\n\t      });\n\t    } else {\n\t      callback();\n\t    }\n\t  });\n\t}\n\t\n\tfunction preprocessAttachment(att, blobType, callback) {\n\t  if (att.stub) {\n\t    return callback();\n\t  }\n\t  if (typeof att.data === 'string') { // input is a base64 string\n\t    preprocessString(att, blobType, callback);\n\t  } else { // input is a blob\n\t    preprocessBlob(att, blobType, callback);\n\t  }\n\t}\n\t\n\tfunction preprocessAttachments(docInfos, blobType, callback) {\n\t\n\t  if (!docInfos.length) {\n\t    return callback();\n\t  }\n\t\n\t  var docv = 0;\n\t  var overallErr;\n\t\n\t  docInfos.forEach(function (docInfo) {\n\t    var attachments = docInfo.data && docInfo.data._attachments ?\n\t      Object.keys(docInfo.data._attachments) : [];\n\t    var recv = 0;\n\t\n\t    if (!attachments.length) {\n\t      return done();\n\t    }\n\t\n\t    function processedAttachment(err) {\n\t      overallErr = err;\n\t      recv++;\n\t      if (recv === attachments.length) {\n\t        done();\n\t      }\n\t    }\n\t\n\t    for (var key in docInfo.data._attachments) {\n\t      if (docInfo.data._attachments.hasOwnProperty(key)) {\n\t        preprocessAttachment(docInfo.data._attachments[key],\n\t          blobType, processedAttachment);\n\t      }\n\t    }\n\t  });\n\t\n\t  function done() {\n\t    docv++;\n\t    if (docInfos.length === docv) {\n\t      if (overallErr) {\n\t        callback(overallErr);\n\t      } else {\n\t        callback();\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction updateDoc(revLimit, prev, docInfo, results,\n\t                   i, cb, writeDoc, newEdits) {\n\t\n\t  if (revExists(prev.rev_tree, docInfo.metadata.rev)) {\n\t    results[i] = docInfo;\n\t    return cb();\n\t  }\n\t\n\t  // sometimes this is pre-calculated. historically not always\n\t  var previousWinningRev = prev.winningRev || winningRev(prev);\n\t  var previouslyDeleted = 'deleted' in prev ? prev.deleted :\n\t    isDeleted(prev, previousWinningRev);\n\t  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :\n\t    isDeleted(docInfo.metadata);\n\t  var isRoot = /^1-/.test(docInfo.metadata.rev);\n\t\n\t  if (previouslyDeleted && !deleted && newEdits && isRoot) {\n\t    var newDoc = docInfo.data;\n\t    newDoc._rev = previousWinningRev;\n\t    newDoc._id = docInfo.metadata.id;\n\t    docInfo = parseDoc(newDoc, newEdits);\n\t  }\n\t\n\t  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);\n\t\n\t  var inConflict = newEdits && ((\n\t    (previouslyDeleted && deleted && merged.conflicts !== 'new_leaf') ||\n\t    (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||\n\t    (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));\n\t\n\t  if (inConflict) {\n\t    var err = createError(REV_CONFLICT);\n\t    results[i] = err;\n\t    return cb();\n\t  }\n\t\n\t  var newRev = docInfo.metadata.rev;\n\t  docInfo.metadata.rev_tree = merged.tree;\n\t  docInfo.stemmedRevs = merged.stemmedRevs || [];\n\t  /* istanbul ignore else */\n\t  if (prev.rev_map) {\n\t    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb\n\t  }\n\t\n\t  // recalculate\n\t  var winningRev$$1 = winningRev(docInfo.metadata);\n\t  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$1);\n\t\n\t  // calculate the total number of documents that were added/removed,\n\t  // from the perspective of total_rows/doc_count\n\t  var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :\n\t    previouslyDeleted < winningRevIsDeleted ? -1 : 1;\n\t\n\t  var newRevIsDeleted;\n\t  if (newRev === winningRev$$1) {\n\t    // if the new rev is the same as the winning rev, we can reuse that value\n\t    newRevIsDeleted = winningRevIsDeleted;\n\t  } else {\n\t    // if they're not the same, then we need to recalculate\n\t    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);\n\t  }\n\t\n\t  writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n\t    true, delta, i, cb);\n\t}\n\t\n\tfunction rootIsMissing(docInfo) {\n\t  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';\n\t}\n\t\n\tfunction processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,\n\t                     writeDoc, opts, overallCallback) {\n\t\n\t  // Default to 1000 locally\n\t  revLimit = revLimit || 1000;\n\t\n\t  function insertDoc(docInfo, resultsIdx, callback) {\n\t    // Cant insert new deleted documents\n\t    var winningRev$$1 = winningRev(docInfo.metadata);\n\t    var deleted = isDeleted(docInfo.metadata, winningRev$$1);\n\t    if ('was_delete' in opts && deleted) {\n\t      results[resultsIdx] = createError(MISSING_DOC, 'deleted');\n\t      return callback();\n\t    }\n\t\n\t    // 4712 - detect whether a new document was inserted with a _rev\n\t    var inConflict = newEdits && rootIsMissing(docInfo);\n\t\n\t    if (inConflict) {\n\t      var err = createError(REV_CONFLICT);\n\t      results[resultsIdx] = err;\n\t      return callback();\n\t    }\n\t\n\t    var delta = deleted ? 0 : 1;\n\t\n\t    writeDoc(docInfo, winningRev$$1, deleted, deleted, false,\n\t      delta, resultsIdx, callback);\n\t  }\n\t\n\t  var newEdits = opts.new_edits;\n\t  var idsToDocs = new ExportedMap();\n\t\n\t  var docsDone = 0;\n\t  var docsToDo = docInfos.length;\n\t\n\t  function checkAllDocsDone() {\n\t    if (++docsDone === docsToDo && overallCallback) {\n\t      overallCallback();\n\t    }\n\t  }\n\t\n\t  docInfos.forEach(function (currentDoc, resultsIdx) {\n\t\n\t    if (currentDoc._id && isLocalId(currentDoc._id)) {\n\t      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';\n\t      api[fun](currentDoc, {ctx: tx}, function (err, res) {\n\t        results[resultsIdx] = err || res;\n\t        checkAllDocsDone();\n\t      });\n\t      return;\n\t    }\n\t\n\t    var id = currentDoc.metadata.id;\n\t    if (idsToDocs.has(id)) {\n\t      docsToDo--; // duplicate\n\t      idsToDocs.get(id).push([currentDoc, resultsIdx]);\n\t    } else {\n\t      idsToDocs.set(id, [[currentDoc, resultsIdx]]);\n\t    }\n\t  });\n\t\n\t  // in the case of new_edits, the user can provide multiple docs\n\t  // with the same id. these need to be processed sequentially\n\t  idsToDocs.forEach(function (docs, id) {\n\t    var numDone = 0;\n\t\n\t    function docWritten() {\n\t      if (++numDone < docs.length) {\n\t        nextDoc();\n\t      } else {\n\t        checkAllDocsDone();\n\t      }\n\t    }\n\t    function nextDoc() {\n\t      var value = docs[numDone];\n\t      var currentDoc = value[0];\n\t      var resultsIdx = value[1];\n\t\n\t      if (fetchedDocs.has(id)) {\n\t        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,\n\t          resultsIdx, docWritten, writeDoc, newEdits);\n\t      } else {\n\t        // Ensure stemming applies to new writes as well\n\t        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);\n\t        currentDoc.metadata.rev_tree = merged.tree;\n\t        currentDoc.stemmedRevs = merged.stemmedRevs || [];\n\t        insertDoc(currentDoc, resultsIdx, docWritten);\n\t      }\n\t    }\n\t    nextDoc();\n\t  });\n\t}\n\t\n\t// IndexedDB requires a versioned database structure, so we use the\n\t// version here to manage migrations.\n\tvar ADAPTER_VERSION = 5;\n\t\n\t// The object stores created for each database\n\t// DOC_STORE stores the document meta data, its revision history and state\n\t// Keyed by document id\n\tvar DOC_STORE = 'document-store';\n\t// BY_SEQ_STORE stores a particular version of a document, keyed by its\n\t// sequence id\n\tvar BY_SEQ_STORE = 'by-sequence';\n\t// Where we store attachments\n\tvar ATTACH_STORE = 'attach-store';\n\t// Where we store many-to-many relations\n\t// between attachment digests and seqs\n\tvar ATTACH_AND_SEQ_STORE = 'attach-seq-store';\n\t\n\t// Where we store database-wide meta data in a single record\n\t// keyed by id: META_STORE\n\tvar META_STORE = 'meta-store';\n\t// Where we store local documents\n\tvar LOCAL_STORE = 'local-store';\n\t// Where we detect blob support\n\tvar DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\n\t\n\tfunction safeJsonParse(str) {\n\t  // This try/catch guards against stack overflow errors.\n\t  // JSON.parse() is faster than vuvuzela.parse() but vuvuzela\n\t  // cannot overflow.\n\t  try {\n\t    return JSON.parse(str);\n\t  } catch (e) {\n\t    /* istanbul ignore next */\n\t    return vuvuzela.parse(str);\n\t  }\n\t}\n\t\n\tfunction safeJsonStringify(json) {\n\t  try {\n\t    return JSON.stringify(json);\n\t  } catch (e) {\n\t    /* istanbul ignore next */\n\t    return vuvuzela.stringify(json);\n\t  }\n\t}\n\t\n\tfunction idbError(callback) {\n\t  return function (evt) {\n\t    var message = 'unknown_error';\n\t    if (evt.target && evt.target.error) {\n\t      message = evt.target.error.name || evt.target.error.message;\n\t    }\n\t    callback(createError(IDB_ERROR, message, evt.type));\n\t  };\n\t}\n\t\n\t// Unfortunately, the metadata has to be stringified\n\t// when it is put into the database, because otherwise\n\t// IndexedDB can throw errors for deeply-nested objects.\n\t// Originally we just used JSON.parse/JSON.stringify; now\n\t// we use this custom vuvuzela library that avoids recursion.\n\t// If we could do it all over again, we'd probably use a\n\t// format for the revision trees other than JSON.\n\tfunction encodeMetadata(metadata, winningRev, deleted) {\n\t  return {\n\t    data: safeJsonStringify(metadata),\n\t    winningRev: winningRev,\n\t    deletedOrLocal: deleted ? '1' : '0',\n\t    seq: metadata.seq, // highest seq for this doc\n\t    id: metadata.id\n\t  };\n\t}\n\t\n\tfunction decodeMetadata(storedObject) {\n\t  if (!storedObject) {\n\t    return null;\n\t  }\n\t  var metadata = safeJsonParse(storedObject.data);\n\t  metadata.winningRev = storedObject.winningRev;\n\t  metadata.deleted = storedObject.deletedOrLocal === '1';\n\t  metadata.seq = storedObject.seq;\n\t  return metadata;\n\t}\n\t\n\t// read the doc back out from the database. we don't store the\n\t// _id or _rev because we already have _doc_id_rev.\n\tfunction decodeDoc(doc) {\n\t  if (!doc) {\n\t    return doc;\n\t  }\n\t  var idx = doc._doc_id_rev.lastIndexOf(':');\n\t  doc._id = doc._doc_id_rev.substring(0, idx - 1);\n\t  doc._rev = doc._doc_id_rev.substring(idx + 1);\n\t  delete doc._doc_id_rev;\n\t  return doc;\n\t}\n\t\n\t// Read a blob from the database, encoding as necessary\n\t// and translating from base64 if the IDB doesn't support\n\t// native Blobs\n\tfunction readBlobData(body, type, asBlob, callback) {\n\t  if (asBlob) {\n\t    if (!body) {\n\t      callback(createBlob([''], {type: type}));\n\t    } else if (typeof body !== 'string') { // we have blob support\n\t      callback(body);\n\t    } else { // no blob support\n\t      callback(b64ToBluffer(body, type));\n\t    }\n\t  } else { // as base64 string\n\t    if (!body) {\n\t      callback('');\n\t    } else if (typeof body !== 'string') { // we have blob support\n\t      readAsBinaryString(body, function (binary) {\n\t        callback(thisBtoa(binary));\n\t      });\n\t    } else { // no blob support\n\t      callback(body);\n\t    }\n\t  }\n\t}\n\t\n\tfunction fetchAttachmentsIfNecessary(doc, opts, txn, cb) {\n\t  var attachments = Object.keys(doc._attachments || {});\n\t  if (!attachments.length) {\n\t    return cb && cb();\n\t  }\n\t  var numDone = 0;\n\t\n\t  function checkDone() {\n\t    if (++numDone === attachments.length && cb) {\n\t      cb();\n\t    }\n\t  }\n\t\n\t  function fetchAttachment(doc, att) {\n\t    var attObj = doc._attachments[att];\n\t    var digest = attObj.digest;\n\t    var req = txn.objectStore(ATTACH_STORE).get(digest);\n\t    req.onsuccess = function (e) {\n\t      attObj.body = e.target.result.body;\n\t      checkDone();\n\t    };\n\t  }\n\t\n\t  attachments.forEach(function (att) {\n\t    if (opts.attachments && opts.include_docs) {\n\t      fetchAttachment(doc, att);\n\t    } else {\n\t      doc._attachments[att].stub = true;\n\t      checkDone();\n\t    }\n\t  });\n\t}\n\t\n\t// IDB-specific postprocessing necessary because\n\t// we don't know whether we stored a true Blob or\n\t// a base64-encoded string, and if it's a Blob it\n\t// needs to be read outside of the transaction context\n\tfunction postProcessAttachments(results, asBlob) {\n\t  return PouchPromise$1.all(results.map(function (row) {\n\t    if (row.doc && row.doc._attachments) {\n\t      var attNames = Object.keys(row.doc._attachments);\n\t      return PouchPromise$1.all(attNames.map(function (att) {\n\t        var attObj = row.doc._attachments[att];\n\t        if (!('body' in attObj)) { // already processed\n\t          return;\n\t        }\n\t        var body = attObj.body;\n\t        var type = attObj.content_type;\n\t        return new PouchPromise$1(function (resolve) {\n\t          readBlobData(body, type, asBlob, function (data) {\n\t            row.doc._attachments[att] = $inject_Object_assign(\n\t              pick(attObj, ['digest', 'content_type']),\n\t              {data: data}\n\t            );\n\t            resolve();\n\t          });\n\t        });\n\t      }));\n\t    }\n\t  }));\n\t}\n\t\n\tfunction compactRevs(revs, docId, txn) {\n\t\n\t  var possiblyOrphanedDigests = [];\n\t  var seqStore = txn.objectStore(BY_SEQ_STORE);\n\t  var attStore = txn.objectStore(ATTACH_STORE);\n\t  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\t  var count = revs.length;\n\t\n\t  function checkDone() {\n\t    count--;\n\t    if (!count) { // done processing all revs\n\t      deleteOrphanedAttachments();\n\t    }\n\t  }\n\t\n\t  function deleteOrphanedAttachments() {\n\t    if (!possiblyOrphanedDigests.length) {\n\t      return;\n\t    }\n\t    possiblyOrphanedDigests.forEach(function (digest) {\n\t      var countReq = attAndSeqStore.index('digestSeq').count(\n\t        IDBKeyRange.bound(\n\t          digest + '::', digest + '::\\uffff', false, false));\n\t      countReq.onsuccess = function (e) {\n\t        var count = e.target.result;\n\t        if (!count) {\n\t          // orphaned\n\t          attStore.delete(digest);\n\t        }\n\t      };\n\t    });\n\t  }\n\t\n\t  revs.forEach(function (rev$$1) {\n\t    var index = seqStore.index('_doc_id_rev');\n\t    var key = docId + \"::\" + rev$$1;\n\t    index.getKey(key).onsuccess = function (e) {\n\t      var seq = e.target.result;\n\t      if (typeof seq !== 'number') {\n\t        return checkDone();\n\t      }\n\t      seqStore.delete(seq);\n\t\n\t      var cursor = attAndSeqStore.index('seq')\n\t        .openCursor(IDBKeyRange.only(seq));\n\t\n\t      cursor.onsuccess = function (event) {\n\t        var cursor = event.target.result;\n\t        if (cursor) {\n\t          var digest = cursor.value.digestSeq.split('::')[0];\n\t          possiblyOrphanedDigests.push(digest);\n\t          attAndSeqStore.delete(cursor.primaryKey);\n\t          cursor.continue();\n\t        } else { // done\n\t          checkDone();\n\t        }\n\t      };\n\t    };\n\t  });\n\t}\n\t\n\tfunction openTransactionSafely(idb, stores, mode) {\n\t  try {\n\t    return {\n\t      txn: idb.transaction(stores, mode)\n\t    };\n\t  } catch (err) {\n\t    return {\n\t      error: err\n\t    };\n\t  }\n\t}\n\t\n\tvar changesHandler = new Changes();\n\t\n\tfunction idbBulkDocs(dbOpts, req, opts, api, idb, callback) {\n\t  var docInfos = req.docs;\n\t  var txn;\n\t  var docStore;\n\t  var bySeqStore;\n\t  var attachStore;\n\t  var attachAndSeqStore;\n\t  var metaStore;\n\t  var docInfoError;\n\t  var metaDoc;\n\t\n\t  for (var i = 0, len = docInfos.length; i < len; i++) {\n\t    var doc = docInfos[i];\n\t    if (doc._id && isLocalId(doc._id)) {\n\t      continue;\n\t    }\n\t    doc = docInfos[i] = parseDoc(doc, opts.new_edits);\n\t    if (doc.error && !docInfoError) {\n\t      docInfoError = doc;\n\t    }\n\t  }\n\t\n\t  if (docInfoError) {\n\t    return callback(docInfoError);\n\t  }\n\t\n\t  var allDocsProcessed = false;\n\t  var docCountDelta = 0;\n\t  var results = new Array(docInfos.length);\n\t  var fetchedDocs = new ExportedMap();\n\t  var preconditionErrored = false;\n\t  var blobType = api._meta.blobSupport ? 'blob' : 'base64';\n\t\n\t  preprocessAttachments(docInfos, blobType, function (err) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    startTransaction();\n\t  });\n\t\n\t  function startTransaction() {\n\t\n\t    var stores = [\n\t      DOC_STORE, BY_SEQ_STORE,\n\t      ATTACH_STORE,\n\t      LOCAL_STORE, ATTACH_AND_SEQ_STORE,\n\t      META_STORE\n\t    ];\n\t    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    txn = txnResult.txn;\n\t    txn.onabort = idbError(callback);\n\t    txn.ontimeout = idbError(callback);\n\t    txn.oncomplete = complete;\n\t    docStore = txn.objectStore(DOC_STORE);\n\t    bySeqStore = txn.objectStore(BY_SEQ_STORE);\n\t    attachStore = txn.objectStore(ATTACH_STORE);\n\t    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\t    metaStore = txn.objectStore(META_STORE);\n\t\n\t    metaStore.get(META_STORE).onsuccess = function (e) {\n\t      metaDoc = e.target.result;\n\t      updateDocCountIfReady();\n\t    };\n\t\n\t    verifyAttachments(function (err) {\n\t      if (err) {\n\t        preconditionErrored = true;\n\t        return callback(err);\n\t      }\n\t      fetchExistingDocs();\n\t    });\n\t  }\n\t\n\t  function onAllDocsProcessed() {\n\t    allDocsProcessed = true;\n\t    updateDocCountIfReady();\n\t  }\n\t\n\t  function idbProcessDocs() {\n\t    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,\n\t                txn, results, writeDoc, opts, onAllDocsProcessed);\n\t  }\n\t\n\t  function updateDocCountIfReady() {\n\t    if (!metaDoc || !allDocsProcessed) {\n\t      return;\n\t    }\n\t    // caching the docCount saves a lot of time in allDocs() and\n\t    // info(), which is why we go to all the trouble of doing this\n\t    metaDoc.docCount += docCountDelta;\n\t    metaStore.put(metaDoc);\n\t  }\n\t\n\t  function fetchExistingDocs() {\n\t\n\t    if (!docInfos.length) {\n\t      return;\n\t    }\n\t\n\t    var numFetched = 0;\n\t\n\t    function checkDone() {\n\t      if (++numFetched === docInfos.length) {\n\t        idbProcessDocs();\n\t      }\n\t    }\n\t\n\t    function readMetadata(event) {\n\t      var metadata = decodeMetadata(event.target.result);\n\t\n\t      if (metadata) {\n\t        fetchedDocs.set(metadata.id, metadata);\n\t      }\n\t      checkDone();\n\t    }\n\t\n\t    for (var i = 0, len = docInfos.length; i < len; i++) {\n\t      var docInfo = docInfos[i];\n\t      if (docInfo._id && isLocalId(docInfo._id)) {\n\t        checkDone(); // skip local docs\n\t        continue;\n\t      }\n\t      var req = docStore.get(docInfo.metadata.id);\n\t      req.onsuccess = readMetadata;\n\t    }\n\t  }\n\t\n\t  function complete() {\n\t    if (preconditionErrored) {\n\t      return;\n\t    }\n\t\n\t    changesHandler.notify(api._meta.name);\n\t    callback(null, results);\n\t  }\n\t\n\t  function verifyAttachment(digest, callback) {\n\t\n\t    var req = attachStore.get(digest);\n\t    req.onsuccess = function (e) {\n\t      if (!e.target.result) {\n\t        var err = createError(MISSING_STUB,\n\t          'unknown stub attachment with digest ' +\n\t          digest);\n\t        err.status = 412;\n\t        callback(err);\n\t      } else {\n\t        callback();\n\t      }\n\t    };\n\t  }\n\t\n\t  function verifyAttachments(finish) {\n\t\n\t\n\t    var digests = [];\n\t    docInfos.forEach(function (docInfo) {\n\t      if (docInfo.data && docInfo.data._attachments) {\n\t        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n\t          var att = docInfo.data._attachments[filename];\n\t          if (att.stub) {\n\t            digests.push(att.digest);\n\t          }\n\t        });\n\t      }\n\t    });\n\t    if (!digests.length) {\n\t      return finish();\n\t    }\n\t    var numDone = 0;\n\t    var err;\n\t\n\t    function checkDone() {\n\t      if (++numDone === digests.length) {\n\t        finish(err);\n\t      }\n\t    }\n\t    digests.forEach(function (digest) {\n\t      verifyAttachment(digest, function (attErr) {\n\t        if (attErr && !err) {\n\t          err = attErr;\n\t        }\n\t        checkDone();\n\t      });\n\t    });\n\t  }\n\t\n\t  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n\t                    isUpdate, delta, resultsIdx, callback) {\n\t\n\t    docInfo.metadata.winningRev = winningRev$$1;\n\t    docInfo.metadata.deleted = winningRevIsDeleted;\n\t\n\t    var doc = docInfo.data;\n\t    doc._id = docInfo.metadata.id;\n\t    doc._rev = docInfo.metadata.rev;\n\t\n\t    if (newRevIsDeleted) {\n\t      doc._deleted = true;\n\t    }\n\t\n\t    var hasAttachments = doc._attachments &&\n\t      Object.keys(doc._attachments).length;\n\t    if (hasAttachments) {\n\t      return writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n\t        isUpdate, resultsIdx, callback);\n\t    }\n\t\n\t    docCountDelta += delta;\n\t    updateDocCountIfReady();\n\t\n\t    finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n\t      isUpdate, resultsIdx, callback);\n\t  }\n\t\n\t  function finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n\t                     isUpdate, resultsIdx, callback) {\n\t\n\t    var doc = docInfo.data;\n\t    var metadata = docInfo.metadata;\n\t\n\t    doc._doc_id_rev = metadata.id + '::' + metadata.rev;\n\t    delete doc._id;\n\t    delete doc._rev;\n\t\n\t    function afterPutDoc(e) {\n\t      var revsToDelete = docInfo.stemmedRevs || [];\n\t\n\t      if (isUpdate && api.auto_compaction) {\n\t        revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));\n\t      }\n\t\n\t      if (revsToDelete && revsToDelete.length) {\n\t        compactRevs(revsToDelete, docInfo.metadata.id, txn);\n\t      }\n\t\n\t      metadata.seq = e.target.result;\n\t      // Current _rev is calculated from _rev_tree on read\n\t      // delete metadata.rev;\n\t      var metadataToStore = encodeMetadata(metadata, winningRev$$1,\n\t        winningRevIsDeleted);\n\t      var metaDataReq = docStore.put(metadataToStore);\n\t      metaDataReq.onsuccess = afterPutMetadata;\n\t    }\n\t\n\t    function afterPutDocError(e) {\n\t      // ConstraintError, need to update, not put (see #1638 for details)\n\t      e.preventDefault(); // avoid transaction abort\n\t      e.stopPropagation(); // avoid transaction onerror\n\t      var index = bySeqStore.index('_doc_id_rev');\n\t      var getKeyReq = index.getKey(doc._doc_id_rev);\n\t      getKeyReq.onsuccess = function (e) {\n\t        var putReq = bySeqStore.put(doc, e.target.result);\n\t        putReq.onsuccess = afterPutDoc;\n\t      };\n\t    }\n\t\n\t    function afterPutMetadata() {\n\t      results[resultsIdx] = {\n\t        ok: true,\n\t        id: metadata.id,\n\t        rev: metadata.rev\n\t      };\n\t      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);\n\t      insertAttachmentMappings(docInfo, metadata.seq, callback);\n\t    }\n\t\n\t    var putReq = bySeqStore.put(doc);\n\t\n\t    putReq.onsuccess = afterPutDoc;\n\t    putReq.onerror = afterPutDocError;\n\t  }\n\t\n\t  function writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n\t                            isUpdate, resultsIdx, callback) {\n\t\n\t\n\t    var doc = docInfo.data;\n\t\n\t    var numDone = 0;\n\t    var attachments = Object.keys(doc._attachments);\n\t\n\t    function collectResults() {\n\t      if (numDone === attachments.length) {\n\t        finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n\t          isUpdate, resultsIdx, callback);\n\t      }\n\t    }\n\t\n\t    function attachmentSaved() {\n\t      numDone++;\n\t      collectResults();\n\t    }\n\t\n\t    attachments.forEach(function (key) {\n\t      var att = docInfo.data._attachments[key];\n\t      if (!att.stub) {\n\t        var data = att.data;\n\t        delete att.data;\n\t        att.revpos = parseInt(winningRev$$1, 10);\n\t        var digest = att.digest;\n\t        saveAttachment(digest, data, attachmentSaved);\n\t      } else {\n\t        numDone++;\n\t        collectResults();\n\t      }\n\t    });\n\t  }\n\t\n\t  // map seqs to attachment digests, which\n\t  // we will need later during compaction\n\t  function insertAttachmentMappings(docInfo, seq, callback) {\n\t\n\t    var attsAdded = 0;\n\t    var attsToAdd = Object.keys(docInfo.data._attachments || {});\n\t\n\t    if (!attsToAdd.length) {\n\t      return callback();\n\t    }\n\t\n\t    function checkDone() {\n\t      if (++attsAdded === attsToAdd.length) {\n\t        callback();\n\t      }\n\t    }\n\t\n\t    function add(att) {\n\t      var digest = docInfo.data._attachments[att].digest;\n\t      var req = attachAndSeqStore.put({\n\t        seq: seq,\n\t        digestSeq: digest + '::' + seq\n\t      });\n\t\n\t      req.onsuccess = checkDone;\n\t      req.onerror = function (e) {\n\t        // this callback is for a constaint error, which we ignore\n\t        // because this docid/rev has already been associated with\n\t        // the digest (e.g. when new_edits == false)\n\t        e.preventDefault(); // avoid transaction abort\n\t        e.stopPropagation(); // avoid transaction onerror\n\t        checkDone();\n\t      };\n\t    }\n\t    for (var i = 0; i < attsToAdd.length; i++) {\n\t      add(attsToAdd[i]); // do in parallel\n\t    }\n\t  }\n\t\n\t  function saveAttachment(digest, data, callback) {\n\t\n\t\n\t    var getKeyReq = attachStore.count(digest);\n\t    getKeyReq.onsuccess = function (e) {\n\t      var count = e.target.result;\n\t      if (count) {\n\t        return callback(); // already exists\n\t      }\n\t      var newAtt = {\n\t        digest: digest,\n\t        body: data\n\t      };\n\t      var putReq = attachStore.put(newAtt);\n\t      putReq.onsuccess = callback;\n\t    };\n\t  }\n\t}\n\t\n\t// Abstraction over IDBCursor and getAll()/getAllKeys() that allows us to batch our operations\n\t// while falling back to a normal IDBCursor operation on browsers that don't support getAll() or\n\t// getAllKeys(). This allows for a much faster implementation than just straight-up cursors, because\n\t// we're not processing each document one-at-a-time.\n\tfunction runBatchedCursor(objectStore, keyRange, descending, batchSize, onBatch) {\n\t\n\t  // Bail out of getAll()/getAllKeys() in the following cases:\n\t  // 1) either method is unsupported - we need both\n\t  // 2) batchSize is 1 (might as well use IDBCursor), or batchSize is -1 (i.e. batchSize unlimited,\n\t  //    not really clear the user wants a batched approach where the entire DB is read into memory,\n\t  //    perhaps they are filtering on a per-doc basis)\n\t  // 3) descending – no real way to do this via getAll()/getAllKeys()\n\t\n\t  var useGetAll = typeof objectStore.getAll === 'function' &&\n\t    typeof objectStore.getAllKeys === 'function' &&\n\t    batchSize > 1 && !descending;\n\t\n\t  var keysBatch;\n\t  var valuesBatch;\n\t  var pseudoCursor;\n\t\n\t  function onGetAll(e) {\n\t    valuesBatch = e.target.result;\n\t    if (keysBatch) {\n\t      onBatch(keysBatch, valuesBatch, pseudoCursor);\n\t    }\n\t  }\n\t\n\t  function onGetAllKeys(e) {\n\t    keysBatch = e.target.result;\n\t    if (valuesBatch) {\n\t      onBatch(keysBatch, valuesBatch, pseudoCursor);\n\t    }\n\t  }\n\t\n\t  function continuePseudoCursor() {\n\t    if (!keysBatch.length) { // no more results\n\t      return onBatch();\n\t    }\n\t    // fetch next batch, exclusive start\n\t    var lastKey = keysBatch[keysBatch.length - 1];\n\t    var newKeyRange;\n\t    if (keyRange && keyRange.upper) {\n\t      try {\n\t        newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper,\n\t          true, keyRange.upperOpen);\n\t      } catch (e) {\n\t        if (e.name === \"DataError\" && e.code === 0) {\n\t          return onBatch(); // we're done, startkey and endkey are equal\n\t        }\n\t      }\n\t    } else {\n\t      newKeyRange = IDBKeyRange.lowerBound(lastKey, true);\n\t    }\n\t    keyRange = newKeyRange;\n\t    keysBatch = null;\n\t    valuesBatch = null;\n\t    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n\t    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n\t  }\n\t\n\t  function onCursor(e) {\n\t    var cursor = e.target.result;\n\t    if (!cursor) { // done\n\t      return onBatch();\n\t    }\n\t    // regular IDBCursor acts like a batch where batch size is always 1\n\t    onBatch([cursor.key], [cursor.value], cursor);\n\t  }\n\t\n\t  if (useGetAll) {\n\t    pseudoCursor = {\"continue\": continuePseudoCursor};\n\t    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n\t    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n\t  } else if (descending) {\n\t    objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;\n\t  } else {\n\t    objectStore.openCursor(keyRange).onsuccess = onCursor;\n\t  }\n\t}\n\t\n\t// simple shim for objectStore.getAll(), falling back to IDBCursor\n\tfunction getAll(objectStore, keyRange, onSuccess) {\n\t  if (typeof objectStore.getAll === 'function') {\n\t    // use native getAll\n\t    objectStore.getAll(keyRange).onsuccess = onSuccess;\n\t    return;\n\t  }\n\t  // fall back to cursors\n\t  var values = [];\n\t\n\t  function onCursor(e) {\n\t    var cursor = e.target.result;\n\t    if (cursor) {\n\t      values.push(cursor.value);\n\t      cursor.continue();\n\t    } else {\n\t      onSuccess({\n\t        target: {\n\t          result: values\n\t        }\n\t      });\n\t    }\n\t  }\n\t\n\t  objectStore.openCursor(keyRange).onsuccess = onCursor;\n\t}\n\t\n\tfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n\t  try {\n\t    if (start && end) {\n\t      if (descending) {\n\t        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n\t      } else {\n\t        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n\t      }\n\t    } else if (start) {\n\t      if (descending) {\n\t        return IDBKeyRange.upperBound(start);\n\t      } else {\n\t        return IDBKeyRange.lowerBound(start);\n\t      }\n\t    } else if (end) {\n\t      if (descending) {\n\t        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n\t      } else {\n\t        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n\t      }\n\t    } else if (key) {\n\t      return IDBKeyRange.only(key);\n\t    }\n\t  } catch (e) {\n\t    return {error: e};\n\t  }\n\t  return null;\n\t}\n\t\n\tfunction idbAllDocs(opts, idb, callback) {\n\t  var start = 'startkey' in opts ? opts.startkey : false;\n\t  var end = 'endkey' in opts ? opts.endkey : false;\n\t  var key = 'key' in opts ? opts.key : false;\n\t  var skip = opts.skip || 0;\n\t  var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n\t  var inclusiveEnd = opts.inclusive_end !== false;\n\t\n\t  var keyRange = createKeyRange(start, end, inclusiveEnd, key, opts.descending);\n\t  var keyRangeError = keyRange && keyRange.error;\n\t  if (keyRangeError && !(keyRangeError.name === \"DataError\" &&\n\t      keyRangeError.code === 0)) {\n\t    // DataError with error code 0 indicates start is less than end, so\n\t    // can just do an empty query. Else need to throw\n\t    return callback(createError(IDB_ERROR,\n\t      keyRangeError.name, keyRangeError.message));\n\t  }\n\t\n\t  var stores = [DOC_STORE, BY_SEQ_STORE, META_STORE];\n\t\n\t  if (opts.attachments) {\n\t    stores.push(ATTACH_STORE);\n\t  }\n\t  var txnResult = openTransactionSafely(idb, stores, 'readonly');\n\t  if (txnResult.error) {\n\t    return callback(txnResult.error);\n\t  }\n\t  var txn = txnResult.txn;\n\t  txn.oncomplete = onTxnComplete;\n\t  txn.onabort = idbError(callback);\n\t  var docStore = txn.objectStore(DOC_STORE);\n\t  var seqStore = txn.objectStore(BY_SEQ_STORE);\n\t  var metaStore = txn.objectStore(META_STORE);\n\t  var docIdRevIndex = seqStore.index('_doc_id_rev');\n\t  var results = [];\n\t  var docCount;\n\t\n\t  metaStore.get(META_STORE).onsuccess = function (e) {\n\t    docCount = e.target.result.docCount;\n\t  };\n\t\n\t  // if the user specifies include_docs=true, then we don't\n\t  // want to block the main cursor while we're fetching the doc\n\t  function fetchDocAsynchronously(metadata, row, winningRev$$1) {\n\t    var key = metadata.id + \"::\" + winningRev$$1;\n\t    docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {\n\t      row.doc = decodeDoc(e.target.result);\n\t      if (opts.conflicts) {\n\t        var conflicts = collectConflicts(metadata);\n\t        if (conflicts.length) {\n\t          row.doc._conflicts = conflicts;\n\t        }\n\t      }\n\t      fetchAttachmentsIfNecessary(row.doc, opts, txn);\n\t    };\n\t  }\n\t\n\t  function allDocsInner(winningRev$$1, metadata) {\n\t    var row = {\n\t      id: metadata.id,\n\t      key: metadata.id,\n\t      value: {\n\t        rev: winningRev$$1\n\t      }\n\t    };\n\t    var deleted = metadata.deleted;\n\t    if (opts.deleted === 'ok') {\n\t      results.push(row);\n\t      // deleted docs are okay with \"keys\" requests\n\t      if (deleted) {\n\t        row.value.deleted = true;\n\t        row.doc = null;\n\t      } else if (opts.include_docs) {\n\t        fetchDocAsynchronously(metadata, row, winningRev$$1);\n\t      }\n\t    } else if (!deleted && skip-- <= 0) {\n\t      results.push(row);\n\t      if (opts.include_docs) {\n\t        fetchDocAsynchronously(metadata, row, winningRev$$1);\n\t      }\n\t    }\n\t  }\n\t\n\t  function processBatch(batchValues) {\n\t    for (var i = 0, len = batchValues.length; i < len; i++) {\n\t      if (results.length === limit) {\n\t        break;\n\t      }\n\t      var batchValue = batchValues[i];\n\t      var metadata = decodeMetadata(batchValue);\n\t      var winningRev$$1 = metadata.winningRev;\n\t      allDocsInner(winningRev$$1, metadata);\n\t    }\n\t  }\n\t\n\t  function onBatch(batchKeys, batchValues, cursor) {\n\t    if (!cursor) {\n\t      return;\n\t    }\n\t    processBatch(batchValues);\n\t    if (results.length < limit) {\n\t      cursor.continue();\n\t    }\n\t  }\n\t\n\t  function onGetAll(e) {\n\t    var values = e.target.result;\n\t    if (opts.descending) {\n\t      values = values.reverse();\n\t    }\n\t    processBatch(values);\n\t  }\n\t\n\t  function onResultsReady() {\n\t    callback(null, {\n\t      total_rows: docCount,\n\t      offset: opts.skip,\n\t      rows: results\n\t    });\n\t  }\n\t\n\t  function onTxnComplete() {\n\t    if (opts.attachments) {\n\t      postProcessAttachments(results, opts.binary).then(onResultsReady);\n\t    } else {\n\t      onResultsReady();\n\t    }\n\t  }\n\t\n\t  // don't bother doing any requests if start > end or limit === 0\n\t  if (keyRangeError || limit === 0) {\n\t    return;\n\t  }\n\t  if (limit === -1) { // just fetch everything\n\t    return getAll(docStore, keyRange, onGetAll);\n\t  }\n\t  // else do a cursor\n\t  // choose a batch size based on the skip, since we'll need to skip that many\n\t  runBatchedCursor(docStore, keyRange, opts.descending, limit + skip, onBatch);\n\t}\n\t\n\t//\n\t// Blobs are not supported in all versions of IndexedDB, notably\n\t// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n\t//\n\t// Various other blob bugs exist in Chrome v37-42 (inclusive).\n\t// Detecting them is expensive and confusing to users, and Chrome 37-42\n\t// is at very low usage worldwide, so we do a hacky userAgent check instead.\n\t//\n\t// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n\t// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n\t// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n\t//\n\tfunction checkBlobSupport(txn) {\n\t  return new PouchPromise$1(function (resolve) {\n\t    var blob = createBlob(['']);\n\t    var req = txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\t\n\t    req.onsuccess = function () {\n\t      var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n\t      var matchedEdge = navigator.userAgent.match(/Edge\\//);\n\t      // MS Edge pretends to be Chrome 42:\n\t      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n\t      resolve(matchedEdge || !matchedChrome ||\n\t        parseInt(matchedChrome[1], 10) >= 43);\n\t    };\n\t\n\t    txn.onabort = function (e) {\n\t      // If the transaction aborts now its due to not being able to\n\t      // write to the database, likely due to the disk being full\n\t      e.preventDefault();\n\t      e.stopPropagation();\n\t      resolve(false);\n\t    };\n\t  }).catch(function () {\n\t    return false; // error, so assume unsupported\n\t  });\n\t}\n\t\n\tfunction countDocs(txn, cb) {\n\t  var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');\n\t  index.count(IDBKeyRange.only('0')).onsuccess = function (e) {\n\t    cb(e.target.result);\n\t  };\n\t}\n\t\n\t// This task queue ensures that IDB open calls are done in their own tick\n\t// and sequentially - i.e. we wait for the async IDB open to *fully* complete\n\t// before calling the next one. This works around IE/Edge race conditions in IDB.\n\t\n\tvar running = false;\n\tvar queue = [];\n\t\n\tfunction tryCode(fun, err, res, PouchDB) {\n\t  try {\n\t    fun(err, res);\n\t  } catch (err) {\n\t    // Shouldn't happen, but in some odd cases\n\t    // IndexedDB implementations might throw a sync\n\t    // error, in which case this will at least log it.\n\t    PouchDB.emit('error', err);\n\t  }\n\t}\n\t\n\tfunction applyNext() {\n\t  if (running || !queue.length) {\n\t    return;\n\t  }\n\t  running = true;\n\t  queue.shift()();\n\t}\n\t\n\tfunction enqueueTask(action, callback, PouchDB) {\n\t  queue.push(function runAction() {\n\t    action(function runCallback(err, res) {\n\t      tryCode(callback, err, res, PouchDB);\n\t      running = false;\n\t      nextTick(function runNext() {\n\t        applyNext(PouchDB);\n\t      });\n\t    });\n\t  });\n\t  applyNext();\n\t}\n\t\n\tfunction changes(opts, api, dbName, idb) {\n\t  opts = clone(opts);\n\t\n\t  if (opts.continuous) {\n\t    var id = dbName + ':' + uuid();\n\t    changesHandler.addListener(dbName, id, api, opts);\n\t    changesHandler.notify(dbName);\n\t    return {\n\t      cancel: function () {\n\t        changesHandler.removeListener(dbName, id);\n\t      }\n\t    };\n\t  }\n\t\n\t  var docIds = opts.doc_ids && new ExportedSet(opts.doc_ids);\n\t\n\t  opts.since = opts.since || 0;\n\t  var lastSeq = opts.since;\n\t\n\t  var limit = 'limit' in opts ? opts.limit : -1;\n\t  if (limit === 0) {\n\t    limit = 1; // per CouchDB _changes spec\n\t  }\n\t  var returnDocs;\n\t  if ('return_docs' in opts) {\n\t    returnDocs = opts.return_docs;\n\t  } else if ('returnDocs' in opts) {\n\t    // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n\t    returnDocs = opts.returnDocs;\n\t  } else {\n\t    returnDocs = true;\n\t  }\n\t\n\t  var results = [];\n\t  var numResults = 0;\n\t  var filter = filterChange(opts);\n\t  var docIdsToMetadata = new ExportedMap();\n\t\n\t  var txn;\n\t  var bySeqStore;\n\t  var docStore;\n\t  var docIdRevIndex;\n\t\n\t  function onBatch(batchKeys, batchValues, cursor) {\n\t    if (!cursor || !batchKeys.length) { // done\n\t      return;\n\t    }\n\t\n\t    var winningDocs = new Array(batchKeys.length);\n\t    var metadatas = new Array(batchKeys.length);\n\t\n\t    function processMetadataAndWinningDoc(metadata, winningDoc) {\n\t      var change = opts.processChange(winningDoc, metadata, opts);\n\t      lastSeq = change.seq = metadata.seq;\n\t\n\t      var filtered = filter(change);\n\t      if (typeof filtered === 'object') { // anything but true/false indicates error\n\t        return opts.complete(filtered);\n\t      }\n\t\n\t      if (filtered) {\n\t        numResults++;\n\t        if (returnDocs) {\n\t          results.push(change);\n\t        }\n\t        // process the attachment immediately\n\t        // for the benefit of live listeners\n\t        if (opts.attachments && opts.include_docs) {\n\t          fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {\n\t            postProcessAttachments([change], opts.binary).then(function () {\n\t              opts.onChange(change);\n\t            });\n\t          });\n\t        } else {\n\t          opts.onChange(change);\n\t        }\n\t      }\n\t    }\n\t\n\t    function onBatchDone() {\n\t      for (var i = 0, len = winningDocs.length; i < len; i++) {\n\t        if (numResults === limit) {\n\t          break;\n\t        }\n\t        var winningDoc = winningDocs[i];\n\t        if (!winningDoc) {\n\t          continue;\n\t        }\n\t        var metadata = metadatas[i];\n\t        processMetadataAndWinningDoc(metadata, winningDoc);\n\t      }\n\t\n\t      if (numResults !== limit) {\n\t        cursor.continue();\n\t      }\n\t    }\n\t\n\t    // Fetch all metadatas/winningdocs from this batch in parallel, then process\n\t    // them all only once all data has been collected. This is done in parallel\n\t    // because it's faster than doing it one-at-a-time.\n\t    var numDone = 0;\n\t    batchValues.forEach(function (value, i) {\n\t      var doc = decodeDoc(value);\n\t      var seq = batchKeys[i];\n\t      fetchWinningDocAndMetadata(doc, seq, function (metadata, winningDoc) {\n\t        metadatas[i] = metadata;\n\t        winningDocs[i] = winningDoc;\n\t        if (++numDone === batchKeys.length) {\n\t          onBatchDone();\n\t        }\n\t      });\n\t    });\n\t  }\n\t\n\t  function onGetMetadata(doc, seq, metadata, cb) {\n\t    if (metadata.seq !== seq) {\n\t      // some other seq is later\n\t      return cb();\n\t    }\n\t\n\t    if (metadata.winningRev === doc._rev) {\n\t      // this is the winning doc\n\t      return cb(metadata, doc);\n\t    }\n\t\n\t    // fetch winning doc in separate request\n\t    var docIdRev = doc._id + '::' + metadata.winningRev;\n\t    var req = docIdRevIndex.get(docIdRev);\n\t    req.onsuccess = function (e) {\n\t      cb(metadata, decodeDoc(e.target.result));\n\t    };\n\t  }\n\t\n\t  function fetchWinningDocAndMetadata(doc, seq, cb) {\n\t    if (docIds && !docIds.has(doc._id)) {\n\t      return cb();\n\t    }\n\t\n\t    var metadata = docIdsToMetadata.get(doc._id);\n\t    if (metadata) { // cached\n\t      return onGetMetadata(doc, seq, metadata, cb);\n\t    }\n\t    // metadata not cached, have to go fetch it\n\t    docStore.get(doc._id).onsuccess = function (e) {\n\t      metadata = decodeMetadata(e.target.result);\n\t      docIdsToMetadata.set(doc._id, metadata);\n\t      onGetMetadata(doc, seq, metadata, cb);\n\t    };\n\t  }\n\t\n\t  function finish() {\n\t    opts.complete(null, {\n\t      results: results,\n\t      last_seq: lastSeq\n\t    });\n\t  }\n\t\n\t  function onTxnComplete() {\n\t    if (!opts.continuous && opts.attachments) {\n\t      // cannot guarantee that postProcessing was already done,\n\t      // so do it again\n\t      postProcessAttachments(results).then(finish);\n\t    } else {\n\t      finish();\n\t    }\n\t  }\n\t\n\t  var objectStores = [DOC_STORE, BY_SEQ_STORE];\n\t  if (opts.attachments) {\n\t    objectStores.push(ATTACH_STORE);\n\t  }\n\t  var txnResult = openTransactionSafely(idb, objectStores, 'readonly');\n\t  if (txnResult.error) {\n\t    return opts.complete(txnResult.error);\n\t  }\n\t  txn = txnResult.txn;\n\t  txn.onabort = idbError(opts.complete);\n\t  txn.oncomplete = onTxnComplete;\n\t\n\t  bySeqStore = txn.objectStore(BY_SEQ_STORE);\n\t  docStore = txn.objectStore(DOC_STORE);\n\t  docIdRevIndex = bySeqStore.index('_doc_id_rev');\n\t\n\t  var keyRange = (opts.since && !opts.descending) ?\n\t    IDBKeyRange.lowerBound(opts.since, true) : null;\n\t\n\t  runBatchedCursor(bySeqStore, keyRange, opts.descending, limit, onBatch);\n\t}\n\t\n\tvar cachedDBs = new ExportedMap();\n\tvar blobSupportPromise;\n\tvar openReqList = new ExportedMap();\n\t\n\tfunction IdbPouch(opts, callback) {\n\t  var api = this;\n\t\n\t  enqueueTask(function (thisCallback) {\n\t    init(api, opts, thisCallback);\n\t  }, callback, api.constructor);\n\t}\n\t\n\tfunction init(api, opts, callback) {\n\t\n\t  var dbName = opts.name;\n\t\n\t  var idb = null;\n\t  api._meta = null;\n\t\n\t  // called when creating a fresh new database\n\t  function createSchema(db) {\n\t    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});\n\t    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})\n\t      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n\t    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\n\t    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\n\t    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n\t\n\t    // added in v2\n\t    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\t\n\t    // added in v3\n\t    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'});\n\t\n\t    // added in v4\n\t    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n\t      {autoIncrement: true});\n\t    attAndSeqStore.createIndex('seq', 'seq');\n\t    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n\t  }\n\t\n\t  // migration to version 2\n\t  // unfortunately \"deletedOrLocal\" is a misnomer now that we no longer\n\t  // store local docs in the main doc-store, but whaddyagonnado\n\t  function addDeletedOrLocalIndex(txn, callback) {\n\t    var docStore = txn.objectStore(DOC_STORE);\n\t    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\t\n\t    docStore.openCursor().onsuccess = function (event) {\n\t      var cursor = event.target.result;\n\t      if (cursor) {\n\t        var metadata = cursor.value;\n\t        var deleted = isDeleted(metadata);\n\t        metadata.deletedOrLocal = deleted ? \"1\" : \"0\";\n\t        docStore.put(metadata);\n\t        cursor.continue();\n\t      } else {\n\t        callback();\n\t      }\n\t    };\n\t  }\n\t\n\t  // migration to version 3 (part 1)\n\t  function createLocalStoreSchema(db) {\n\t    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})\n\t      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n\t  }\n\t\n\t  // migration to version 3 (part 2)\n\t  function migrateLocalStore(txn, cb) {\n\t    var localStore = txn.objectStore(LOCAL_STORE);\n\t    var docStore = txn.objectStore(DOC_STORE);\n\t    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\t\n\t    var cursor = docStore.openCursor();\n\t    cursor.onsuccess = function (event) {\n\t      var cursor = event.target.result;\n\t      if (cursor) {\n\t        var metadata = cursor.value;\n\t        var docId = metadata.id;\n\t        var local = isLocalId(docId);\n\t        var rev$$1 = winningRev(metadata);\n\t        if (local) {\n\t          var docIdRev = docId + \"::\" + rev$$1;\n\t          // remove all seq entries\n\t          // associated with this docId\n\t          var start = docId + \"::\";\n\t          var end = docId + \"::~\";\n\t          var index = seqStore.index('_doc_id_rev');\n\t          var range = IDBKeyRange.bound(start, end, false, false);\n\t          var seqCursor = index.openCursor(range);\n\t          seqCursor.onsuccess = function (e) {\n\t            seqCursor = e.target.result;\n\t            if (!seqCursor) {\n\t              // done\n\t              docStore.delete(cursor.primaryKey);\n\t              cursor.continue();\n\t            } else {\n\t              var data = seqCursor.value;\n\t              if (data._doc_id_rev === docIdRev) {\n\t                localStore.put(data);\n\t              }\n\t              seqStore.delete(seqCursor.primaryKey);\n\t              seqCursor.continue();\n\t            }\n\t          };\n\t        } else {\n\t          cursor.continue();\n\t        }\n\t      } else if (cb) {\n\t        cb();\n\t      }\n\t    };\n\t  }\n\t\n\t  // migration to version 4 (part 1)\n\t  function addAttachAndSeqStore(db) {\n\t    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n\t      {autoIncrement: true});\n\t    attAndSeqStore.createIndex('seq', 'seq');\n\t    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n\t  }\n\t\n\t  // migration to version 4 (part 2)\n\t  function migrateAttsAndSeqs(txn, callback) {\n\t    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\t    var attStore = txn.objectStore(ATTACH_STORE);\n\t    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\t\n\t    // need to actually populate the table. this is the expensive part,\n\t    // so as an optimization, check first that this database even\n\t    // contains attachments\n\t    var req = attStore.count();\n\t    req.onsuccess = function (e) {\n\t      var count = e.target.result;\n\t      if (!count) {\n\t        return callback(); // done\n\t      }\n\t\n\t      seqStore.openCursor().onsuccess = function (e) {\n\t        var cursor = e.target.result;\n\t        if (!cursor) {\n\t          return callback(); // done\n\t        }\n\t        var doc = cursor.value;\n\t        var seq = cursor.primaryKey;\n\t        var atts = Object.keys(doc._attachments || {});\n\t        var digestMap = {};\n\t        for (var j = 0; j < atts.length; j++) {\n\t          var att = doc._attachments[atts[j]];\n\t          digestMap[att.digest] = true; // uniq digests, just in case\n\t        }\n\t        var digests = Object.keys(digestMap);\n\t        for (j = 0; j < digests.length; j++) {\n\t          var digest = digests[j];\n\t          attAndSeqStore.put({\n\t            seq: seq,\n\t            digestSeq: digest + '::' + seq\n\t          });\n\t        }\n\t        cursor.continue();\n\t      };\n\t    };\n\t  }\n\t\n\t  // migration to version 5\n\t  // Instead of relying on on-the-fly migration of metadata,\n\t  // this brings the doc-store to its modern form:\n\t  // - metadata.winningrev\n\t  // - metadata.seq\n\t  // - stringify the metadata when storing it\n\t  function migrateMetadata(txn) {\n\t\n\t    function decodeMetadataCompat(storedObject) {\n\t      if (!storedObject.data) {\n\t        // old format, when we didn't store it stringified\n\t        storedObject.deleted = storedObject.deletedOrLocal === '1';\n\t        return storedObject;\n\t      }\n\t      return decodeMetadata(storedObject);\n\t    }\n\t\n\t    // ensure that every metadata has a winningRev and seq,\n\t    // which was previously created on-the-fly but better to migrate\n\t    var bySeqStore = txn.objectStore(BY_SEQ_STORE);\n\t    var docStore = txn.objectStore(DOC_STORE);\n\t    var cursor = docStore.openCursor();\n\t    cursor.onsuccess = function (e) {\n\t      var cursor = e.target.result;\n\t      if (!cursor) {\n\t        return; // done\n\t      }\n\t      var metadata = decodeMetadataCompat(cursor.value);\n\t\n\t      metadata.winningRev = metadata.winningRev ||\n\t        winningRev(metadata);\n\t\n\t      function fetchMetadataSeq() {\n\t        // metadata.seq was added post-3.2.0, so if it's missing,\n\t        // we need to fetch it manually\n\t        var start = metadata.id + '::';\n\t        var end = metadata.id + '::\\uffff';\n\t        var req = bySeqStore.index('_doc_id_rev').openCursor(\n\t          IDBKeyRange.bound(start, end));\n\t\n\t        var metadataSeq = 0;\n\t        req.onsuccess = function (e) {\n\t          var cursor = e.target.result;\n\t          if (!cursor) {\n\t            metadata.seq = metadataSeq;\n\t            return onGetMetadataSeq();\n\t          }\n\t          var seq = cursor.primaryKey;\n\t          if (seq > metadataSeq) {\n\t            metadataSeq = seq;\n\t          }\n\t          cursor.continue();\n\t        };\n\t      }\n\t\n\t      function onGetMetadataSeq() {\n\t        var metadataToStore = encodeMetadata(metadata,\n\t          metadata.winningRev, metadata.deleted);\n\t\n\t        var req = docStore.put(metadataToStore);\n\t        req.onsuccess = function () {\n\t          cursor.continue();\n\t        };\n\t      }\n\t\n\t      if (metadata.seq) {\n\t        return onGetMetadataSeq();\n\t      }\n\t\n\t      fetchMetadataSeq();\n\t    };\n\t\n\t  }\n\t\n\t  api._remote = false;\n\t  api.type = function () {\n\t    return 'idb';\n\t  };\n\t\n\t  api._id = toPromise(function (callback) {\n\t    callback(null, api._meta.instanceId);\n\t  });\n\t\n\t  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {\n\t    idbBulkDocs(opts, req, reqOpts, api, idb, callback);\n\t  };\n\t\n\t  // First we look up the metadata in the ids database, then we fetch the\n\t  // current revision(s) from the by sequence store\n\t  api._get = function idb_get(id, opts, callback) {\n\t    var doc;\n\t    var metadata;\n\t    var err;\n\t    var txn = opts.ctx;\n\t    if (!txn) {\n\t      var txnResult = openTransactionSafely(idb,\n\t        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n\t      if (txnResult.error) {\n\t        return callback(txnResult.error);\n\t      }\n\t      txn = txnResult.txn;\n\t    }\n\t\n\t    function finish() {\n\t      callback(err, {doc: doc, metadata: metadata, ctx: txn});\n\t    }\n\t\n\t    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n\t      metadata = decodeMetadata(e.target.result);\n\t      // we can determine the result here if:\n\t      // 1. there is no such document\n\t      // 2. the document is deleted and we don't ask about specific rev\n\t      // When we ask with opts.rev we expect the answer to be either\n\t      // doc (possibly with _deleted=true) or missing error\n\t      if (!metadata) {\n\t        err = createError(MISSING_DOC, 'missing');\n\t        return finish();\n\t      }\n\t\n\t      var rev$$1;\n\t      if (!opts.rev) {\n\t        rev$$1 = metadata.winningRev;\n\t        var deleted = isDeleted(metadata);\n\t        if (deleted) {\n\t          err = createError(MISSING_DOC, \"deleted\");\n\t          return finish();\n\t        }\n\t      } else {\n\t        rev$$1 = opts.latest ? latest(opts.rev, metadata) : opts.rev;\n\t      }\n\t\n\t      var objectStore = txn.objectStore(BY_SEQ_STORE);\n\t      var key = metadata.id + '::' + rev$$1;\n\t\n\t      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {\n\t        doc = e.target.result;\n\t        if (doc) {\n\t          doc = decodeDoc(doc);\n\t        }\n\t        if (!doc) {\n\t          err = createError(MISSING_DOC, 'missing');\n\t          return finish();\n\t        }\n\t        finish();\n\t      };\n\t    };\n\t  };\n\t\n\t  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n\t    var txn;\n\t    if (opts.ctx) {\n\t      txn = opts.ctx;\n\t    } else {\n\t      var txnResult = openTransactionSafely(idb,\n\t        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n\t      if (txnResult.error) {\n\t        return callback(txnResult.error);\n\t      }\n\t      txn = txnResult.txn;\n\t    }\n\t    var digest = attachment.digest;\n\t    var type = attachment.content_type;\n\t\n\t    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {\n\t      var body = e.target.result.body;\n\t      readBlobData(body, type, opts.binary, function (blobData) {\n\t        callback(null, blobData);\n\t      });\n\t    };\n\t  };\n\t\n\t  api._info = function idb_info(callback) {\n\t    var updateSeq;\n\t    var docCount;\n\t\n\t    var txnResult = openTransactionSafely(idb, [META_STORE, BY_SEQ_STORE], 'readonly');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    var txn = txnResult.txn;\n\t    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n\t      docCount = e.target.result.docCount;\n\t    };\n\t    txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev').onsuccess = function (e) {\n\t      var cursor = e.target.result;\n\t      updateSeq = cursor ? cursor.key : 0;\n\t    };\n\t\n\t    txn.oncomplete = function () {\n\t      callback(null, {\n\t        doc_count: docCount,\n\t        update_seq: updateSeq,\n\t        // for debugging\n\t        idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')\n\t      });\n\t    };\n\t  };\n\t\n\t  api._allDocs = function idb_allDocs(opts, callback) {\n\t    idbAllDocs(opts, idb, callback);\n\t  };\n\t\n\t  api._changes = function idbChanges(opts) {\n\t    return changes(opts, api, dbName, idb);\n\t  };\n\t\n\t  api._close = function (callback) {\n\t    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n\t    // \"Returns immediately and closes the connection in a separate thread...\"\n\t    idb.close();\n\t    cachedDBs.delete(dbName);\n\t    callback();\n\t  };\n\t\n\t  api._getRevisionTree = function (docId, callback) {\n\t    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    var txn = txnResult.txn;\n\t    var req = txn.objectStore(DOC_STORE).get(docId);\n\t    req.onsuccess = function (event) {\n\t      var doc = decodeMetadata(event.target.result);\n\t      if (!doc) {\n\t        callback(createError(MISSING_DOC));\n\t      } else {\n\t        callback(null, doc.rev_tree);\n\t      }\n\t    };\n\t  };\n\t\n\t  // This function removes revisions of document docId\n\t  // which are listed in revs and sets this document\n\t  // revision to to rev_tree\n\t  api._doCompaction = function (docId, revs, callback) {\n\t    var stores = [\n\t      DOC_STORE,\n\t      BY_SEQ_STORE,\n\t      ATTACH_STORE,\n\t      ATTACH_AND_SEQ_STORE\n\t    ];\n\t    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    var txn = txnResult.txn;\n\t\n\t    var docStore = txn.objectStore(DOC_STORE);\n\t\n\t    docStore.get(docId).onsuccess = function (event) {\n\t      var metadata = decodeMetadata(event.target.result);\n\t      traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n\t                                                         revHash, ctx, opts) {\n\t        var rev$$1 = pos + '-' + revHash;\n\t        if (revs.indexOf(rev$$1) !== -1) {\n\t          opts.status = 'missing';\n\t        }\n\t      });\n\t      compactRevs(revs, docId, txn);\n\t      var winningRev$$1 = metadata.winningRev;\n\t      var deleted = metadata.deleted;\n\t      txn.objectStore(DOC_STORE).put(\n\t        encodeMetadata(metadata, winningRev$$1, deleted));\n\t    };\n\t    txn.onabort = idbError(callback);\n\t    txn.oncomplete = function () {\n\t      callback();\n\t    };\n\t  };\n\t\n\t\n\t  api._getLocal = function (id, callback) {\n\t    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    var tx = txnResult.txn;\n\t    var req = tx.objectStore(LOCAL_STORE).get(id);\n\t\n\t    req.onerror = idbError(callback);\n\t    req.onsuccess = function (e) {\n\t      var doc = e.target.result;\n\t      if (!doc) {\n\t        callback(createError(MISSING_DOC));\n\t      } else {\n\t        delete doc['_doc_id_rev']; // for backwards compat\n\t        callback(null, doc);\n\t      }\n\t    };\n\t  };\n\t\n\t  api._putLocal = function (doc, opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    delete doc._revisions; // ignore this, trust the rev\n\t    var oldRev = doc._rev;\n\t    var id = doc._id;\n\t    if (!oldRev) {\n\t      doc._rev = '0-1';\n\t    } else {\n\t      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n\t    }\n\t\n\t    var tx = opts.ctx;\n\t    var ret;\n\t    if (!tx) {\n\t      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n\t      if (txnResult.error) {\n\t        return callback(txnResult.error);\n\t      }\n\t      tx = txnResult.txn;\n\t      tx.onerror = idbError(callback);\n\t      tx.oncomplete = function () {\n\t        if (ret) {\n\t          callback(null, ret);\n\t        }\n\t      };\n\t    }\n\t\n\t    var oStore = tx.objectStore(LOCAL_STORE);\n\t    var req;\n\t    if (oldRev) {\n\t      req = oStore.get(id);\n\t      req.onsuccess = function (e) {\n\t        var oldDoc = e.target.result;\n\t        if (!oldDoc || oldDoc._rev !== oldRev) {\n\t          callback(createError(REV_CONFLICT));\n\t        } else { // update\n\t          var req = oStore.put(doc);\n\t          req.onsuccess = function () {\n\t            ret = {ok: true, id: doc._id, rev: doc._rev};\n\t            if (opts.ctx) { // return immediately\n\t              callback(null, ret);\n\t            }\n\t          };\n\t        }\n\t      };\n\t    } else { // new doc\n\t      req = oStore.add(doc);\n\t      req.onerror = function (e) {\n\t        // constraint error, already exists\n\t        callback(createError(REV_CONFLICT));\n\t        e.preventDefault(); // avoid transaction abort\n\t        e.stopPropagation(); // avoid transaction onerror\n\t      };\n\t      req.onsuccess = function () {\n\t        ret = {ok: true, id: doc._id, rev: doc._rev};\n\t        if (opts.ctx) { // return immediately\n\t          callback(null, ret);\n\t        }\n\t      };\n\t    }\n\t  };\n\t\n\t  api._removeLocal = function (doc, opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    var tx = opts.ctx;\n\t    if (!tx) {\n\t      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n\t      if (txnResult.error) {\n\t        return callback(txnResult.error);\n\t      }\n\t      tx = txnResult.txn;\n\t      tx.oncomplete = function () {\n\t        if (ret) {\n\t          callback(null, ret);\n\t        }\n\t      };\n\t    }\n\t    var ret;\n\t    var id = doc._id;\n\t    var oStore = tx.objectStore(LOCAL_STORE);\n\t    var req = oStore.get(id);\n\t\n\t    req.onerror = idbError(callback);\n\t    req.onsuccess = function (e) {\n\t      var oldDoc = e.target.result;\n\t      if (!oldDoc || oldDoc._rev !== doc._rev) {\n\t        callback(createError(MISSING_DOC));\n\t      } else {\n\t        oStore.delete(id);\n\t        ret = {ok: true, id: id, rev: '0-0'};\n\t        if (opts.ctx) { // return immediately\n\t          callback(null, ret);\n\t        }\n\t      }\n\t    };\n\t  };\n\t\n\t  api._destroy = function (opts, callback) {\n\t    changesHandler.removeAllListeners(dbName);\n\t\n\t    //Close open request for \"dbName\" database to fix ie delay.\n\t    var openReq = openReqList.get(dbName);\n\t    if (openReq && openReq.result) {\n\t      openReq.result.close();\n\t      cachedDBs.delete(dbName);\n\t    }\n\t    var req = indexedDB.deleteDatabase(dbName);\n\t\n\t    req.onsuccess = function () {\n\t      //Remove open request from the list.\n\t      openReqList.delete(dbName);\n\t      if (hasLocalStorage() && (dbName in localStorage)) {\n\t        delete localStorage[dbName];\n\t      }\n\t      callback(null, { 'ok': true });\n\t    };\n\t\n\t    req.onerror = idbError(callback);\n\t  };\n\t\n\t  var cached = cachedDBs.get(dbName);\n\t\n\t  if (cached) {\n\t    idb = cached.idb;\n\t    api._meta = cached.global;\n\t    return nextTick(function () {\n\t      callback(null, api);\n\t    });\n\t  }\n\t\n\t  var req;\n\t  if (opts.storage) {\n\t    req = tryStorageOption(dbName, opts.storage);\n\t  } else {\n\t    req = indexedDB.open(dbName, ADAPTER_VERSION);\n\t  }\n\t\n\t  openReqList.set(dbName, req);\n\t\n\t  req.onupgradeneeded = function (e) {\n\t    var db = e.target.result;\n\t    if (e.oldVersion < 1) {\n\t      return createSchema(db); // new db, initial schema\n\t    }\n\t    // do migrations\n\t\n\t    var txn = e.currentTarget.transaction;\n\t    // these migrations have to be done in this function, before\n\t    // control is returned to the event loop, because IndexedDB\n\t\n\t    if (e.oldVersion < 3) {\n\t      createLocalStoreSchema(db); // v2 -> v3\n\t    }\n\t    if (e.oldVersion < 4) {\n\t      addAttachAndSeqStore(db); // v3 -> v4\n\t    }\n\t\n\t    var migrations = [\n\t      addDeletedOrLocalIndex, // v1 -> v2\n\t      migrateLocalStore,      // v2 -> v3\n\t      migrateAttsAndSeqs,     // v3 -> v4\n\t      migrateMetadata         // v4 -> v5\n\t    ];\n\t\n\t    var i = e.oldVersion;\n\t\n\t    function next() {\n\t      var migration = migrations[i - 1];\n\t      i++;\n\t      if (migration) {\n\t        migration(txn, next);\n\t      }\n\t    }\n\t\n\t    next();\n\t  };\n\t\n\t  req.onsuccess = function (e) {\n\t\n\t    idb = e.target.result;\n\t\n\t    idb.onversionchange = function () {\n\t      idb.close();\n\t      cachedDBs.delete(dbName);\n\t    };\n\t\n\t    idb.onabort = function (e) {\n\t      guardedConsole('error', 'Database has a global failure', e.target.error);\n\t      idb.close();\n\t      cachedDBs.delete(dbName);\n\t    };\n\t\n\t    // Do a few setup operations (in parallel as much as possible):\n\t    // 1. Fetch meta doc\n\t    // 2. Check blob support\n\t    // 3. Calculate docCount\n\t    // 4. Generate an instanceId if necessary\n\t    // 5. Store docCount and instanceId on meta doc\n\t\n\t    var txn = idb.transaction([\n\t      META_STORE,\n\t      DETECT_BLOB_SUPPORT_STORE,\n\t      DOC_STORE\n\t    ], 'readwrite');\n\t\n\t    var storedMetaDoc = false;\n\t    var metaDoc;\n\t    var docCount;\n\t    var blobSupport;\n\t    var instanceId;\n\t\n\t    function completeSetup() {\n\t      if (typeof blobSupport === 'undefined' || !storedMetaDoc) {\n\t        return;\n\t      }\n\t      api._meta = {\n\t        name: dbName,\n\t        instanceId: instanceId,\n\t        blobSupport: blobSupport\n\t      };\n\t\n\t      cachedDBs.set(dbName, {\n\t        idb: idb,\n\t        global: api._meta\n\t      });\n\t      callback(null, api);\n\t    }\n\t\n\t    function storeMetaDocIfReady() {\n\t      if (typeof docCount === 'undefined' || typeof metaDoc === 'undefined') {\n\t        return;\n\t      }\n\t      var instanceKey = dbName + '_id';\n\t      if (instanceKey in metaDoc) {\n\t        instanceId = metaDoc[instanceKey];\n\t      } else {\n\t        metaDoc[instanceKey] = instanceId = uuid();\n\t      }\n\t      metaDoc.docCount = docCount;\n\t      txn.objectStore(META_STORE).put(metaDoc);\n\t    }\n\t\n\t    //\n\t    // fetch or generate the instanceId\n\t    //\n\t    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n\t      metaDoc = e.target.result || { id: META_STORE };\n\t      storeMetaDocIfReady();\n\t    };\n\t\n\t    //\n\t    // countDocs\n\t    //\n\t    countDocs(txn, function (count) {\n\t      docCount = count;\n\t      storeMetaDocIfReady();\n\t    });\n\t\n\t    //\n\t    // check blob support\n\t    //\n\t    if (!blobSupportPromise) {\n\t      // make sure blob support is only checked once\n\t      blobSupportPromise = checkBlobSupport(txn);\n\t    }\n\t\n\t    blobSupportPromise.then(function (val) {\n\t      blobSupport = val;\n\t      completeSetup();\n\t    });\n\t\n\t    // only when the metadata put transaction has completed,\n\t    // consider the setup done\n\t    txn.oncomplete = function () {\n\t      storedMetaDoc = true;\n\t      completeSetup();\n\t    };\n\t  };\n\t\n\t  req.onerror = function () {\n\t    var msg = 'Failed to open indexedDB, are you in private browsing mode?';\n\t    guardedConsole('error', msg);\n\t    callback(createError(IDB_ERROR, msg));\n\t  };\n\t}\n\t\n\tIdbPouch.valid = function () {\n\t  // Issue #2533, we finally gave up on doing bug\n\t  // detection instead of browser sniffing. Safari brought us\n\t  // to our knees.\n\t  var isSafari = typeof openDatabase !== 'undefined' &&\n\t    /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) &&\n\t    !/Chrome/.test(navigator.userAgent) &&\n\t    !/BlackBerry/.test(navigator.platform);\n\t\n\t  // some outdated implementations of IDB that appear on Samsung\n\t  // and HTC Android devices <4.4 are missing IDBKeyRange\n\t  return !isSafari && typeof indexedDB !== 'undefined' &&\n\t    typeof IDBKeyRange !== 'undefined';\n\t};\n\t\n\tfunction tryStorageOption(dbName, storage) {\n\t  try { // option only available in Firefox 26+\n\t    return indexedDB.open(dbName, {\n\t      version: ADAPTER_VERSION,\n\t      storage: storage\n\t    });\n\t  } catch (err) {\n\t      return indexedDB.open(dbName, ADAPTER_VERSION);\n\t  }\n\t}\n\t\n\tvar IDBPouch = function (PouchDB) {\n\t  PouchDB.adapter('idb', IdbPouch, true);\n\t};\n\t\n\t//\n\t// Parsing hex strings. Yeah.\n\t//\n\t// So basically we need this because of a bug in WebSQL:\n\t// https://code.google.com/p/chromium/issues/detail?id=422690\n\t// https://bugs.webkit.org/show_bug.cgi?id=137637\n\t//\n\t// UTF-8 and UTF-16 are provided as separate functions\n\t// for meager performance improvements\n\t//\n\t\n\tfunction decodeUtf8(str) {\n\t  return decodeURIComponent(escape(str));\n\t}\n\t\n\tfunction hexToInt(charCode) {\n\t  // '0'-'9' is 48-57\n\t  // 'A'-'F' is 65-70\n\t  // SQLite will only give us uppercase hex\n\t  return charCode < 65 ? (charCode - 48) : (charCode - 55);\n\t}\n\t\n\t\n\t// Example:\n\t// pragma encoding=utf8;\n\t// select hex('A');\n\t// returns '41'\n\tfunction parseHexUtf8(str, start, end) {\n\t  var result = '';\n\t  while (start < end) {\n\t    result += String.fromCharCode(\n\t      (hexToInt(str.charCodeAt(start++)) << 4) |\n\t        hexToInt(str.charCodeAt(start++)));\n\t  }\n\t  return result;\n\t}\n\t\n\t// Example:\n\t// pragma encoding=utf16;\n\t// select hex('A');\n\t// returns '4100'\n\t// notice that the 00 comes after the 41 (i.e. it's swizzled)\n\tfunction parseHexUtf16(str, start, end) {\n\t  var result = '';\n\t  while (start < end) {\n\t    // UTF-16, so swizzle the bytes\n\t    result += String.fromCharCode(\n\t      (hexToInt(str.charCodeAt(start + 2)) << 12) |\n\t        (hexToInt(str.charCodeAt(start + 3)) << 8) |\n\t        (hexToInt(str.charCodeAt(start)) << 4) |\n\t        hexToInt(str.charCodeAt(start + 1)));\n\t    start += 4;\n\t  }\n\t  return result;\n\t}\n\t\n\tfunction parseHexString(str, encoding) {\n\t  if (encoding === 'UTF-8') {\n\t    return decodeUtf8(parseHexUtf8(str, 0, str.length));\n\t  } else {\n\t    return parseHexUtf16(str, 0, str.length);\n\t  }\n\t}\n\t\n\tfunction quote(str) {\n\t  return \"'\" + str + \"'\";\n\t}\n\t\n\tvar ADAPTER_VERSION$1 = 7; // used to manage migrations\n\t\n\t// The object stores created for each database\n\t// DOC_STORE stores the document meta data, its revision history and state\n\tvar DOC_STORE$1 = quote('document-store');\n\t// BY_SEQ_STORE stores a particular version of a document, keyed by its\n\t// sequence id\n\tvar BY_SEQ_STORE$1 = quote('by-sequence');\n\t// Where we store attachments\n\tvar ATTACH_STORE$1 = quote('attach-store');\n\tvar LOCAL_STORE$1 = quote('local-store');\n\tvar META_STORE$1 = quote('metadata-store');\n\t// where we store many-to-many relations between attachment\n\t// digests and seqs\n\tvar ATTACH_AND_SEQ_STORE$1 = quote('attach-seq-store');\n\t\n\t// escapeBlob and unescapeBlob are workarounds for a websql bug:\n\t// https://code.google.com/p/chromium/issues/detail?id=422690\n\t// https://bugs.webkit.org/show_bug.cgi?id=137637\n\t// The goal is to never actually insert the \\u0000 character\n\t// in the database.\n\tfunction escapeBlob(str) {\n\t  return str\n\t    .replace(/\\u0002/g, '\\u0002\\u0002')\n\t    .replace(/\\u0001/g, '\\u0001\\u0002')\n\t    .replace(/\\u0000/g, '\\u0001\\u0001');\n\t}\n\t\n\tfunction unescapeBlob(str) {\n\t  return str\n\t    .replace(/\\u0001\\u0001/g, '\\u0000')\n\t    .replace(/\\u0001\\u0002/g, '\\u0001')\n\t    .replace(/\\u0002\\u0002/g, '\\u0002');\n\t}\n\t\n\tfunction stringifyDoc(doc) {\n\t  // don't bother storing the id/rev. it uses lots of space,\n\t  // in persistent map/reduce especially\n\t  delete doc._id;\n\t  delete doc._rev;\n\t  return JSON.stringify(doc);\n\t}\n\t\n\tfunction unstringifyDoc(doc, id, rev$$1) {\n\t  doc = JSON.parse(doc);\n\t  doc._id = id;\n\t  doc._rev = rev$$1;\n\t  return doc;\n\t}\n\t\n\t// question mark groups IN queries, e.g. 3 -> '(?,?,?)'\n\tfunction qMarks(num) {\n\t  var s = '(';\n\t  while (num--) {\n\t    s += '?';\n\t    if (num) {\n\t      s += ',';\n\t    }\n\t  }\n\t  return s + ')';\n\t}\n\t\n\tfunction select(selector, table, joiner, where, orderBy) {\n\t  return 'SELECT ' + selector + ' FROM ' +\n\t    (typeof table === 'string' ? table : table.join(' JOIN ')) +\n\t    (joiner ? (' ON ' + joiner) : '') +\n\t    (where ? (' WHERE ' +\n\t    (typeof where === 'string' ? where : where.join(' AND '))) : '') +\n\t    (orderBy ? (' ORDER BY ' + orderBy) : '');\n\t}\n\t\n\tfunction compactRevs$1(revs, docId, tx) {\n\t\n\t  if (!revs.length) {\n\t    return;\n\t  }\n\t\n\t  var numDone = 0;\n\t  var seqs = [];\n\t\n\t  function checkDone() {\n\t    if (++numDone === revs.length) { // done\n\t      deleteOrphans();\n\t    }\n\t  }\n\t\n\t  function deleteOrphans() {\n\t    // find orphaned attachment digests\n\t\n\t    if (!seqs.length) {\n\t      return;\n\t    }\n\t\n\t    var sql = 'SELECT DISTINCT digest AS digest FROM ' +\n\t      ATTACH_AND_SEQ_STORE$1 + ' WHERE seq IN ' + qMarks(seqs.length);\n\t\n\t    tx.executeSql(sql, seqs, function (tx, res) {\n\t\n\t      var digestsToCheck = [];\n\t      for (var i = 0; i < res.rows.length; i++) {\n\t        digestsToCheck.push(res.rows.item(i).digest);\n\t      }\n\t      if (!digestsToCheck.length) {\n\t        return;\n\t      }\n\t\n\t      var sql = 'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 +\n\t        ' WHERE seq IN (' +\n\t        seqs.map(function () { return '?'; }).join(',') +\n\t        ')';\n\t      tx.executeSql(sql, seqs, function (tx) {\n\t\n\t        var sql = 'SELECT digest FROM ' + ATTACH_AND_SEQ_STORE$1 +\n\t          ' WHERE digest IN (' +\n\t          digestsToCheck.map(function () { return '?'; }).join(',') +\n\t          ')';\n\t        tx.executeSql(sql, digestsToCheck, function (tx, res) {\n\t          var nonOrphanedDigests = new ExportedSet();\n\t          for (var i = 0; i < res.rows.length; i++) {\n\t            nonOrphanedDigests.add(res.rows.item(i).digest);\n\t          }\n\t          digestsToCheck.forEach(function (digest) {\n\t            if (nonOrphanedDigests.has(digest)) {\n\t              return;\n\t            }\n\t            tx.executeSql(\n\t              'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE digest=?',\n\t              [digest]);\n\t            tx.executeSql(\n\t              'DELETE FROM ' + ATTACH_STORE$1 + ' WHERE digest=?', [digest]);\n\t          });\n\t        });\n\t      });\n\t    });\n\t  }\n\t\n\t  // update by-seq and attach stores in parallel\n\t  revs.forEach(function (rev$$1) {\n\t    var sql = 'SELECT seq FROM ' + BY_SEQ_STORE$1 +\n\t      ' WHERE doc_id=? AND rev=?';\n\t\n\t    tx.executeSql(sql, [docId, rev$$1], function (tx, res) {\n\t      if (!res.rows.length) { // already deleted\n\t        return checkDone();\n\t      }\n\t      var seq = res.rows.item(0).seq;\n\t      seqs.push(seq);\n\t\n\t      tx.executeSql(\n\t        'DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?', [seq], checkDone);\n\t    });\n\t  });\n\t}\n\t\n\tfunction websqlError(callback) {\n\t  return function (event) {\n\t    guardedConsole('error', 'WebSQL threw an error', event);\n\t    // event may actually be a SQLError object, so report is as such\n\t    var errorNameMatch = event && event.constructor.toString()\n\t        .match(/function ([^(]+)/);\n\t    var errorName = (errorNameMatch && errorNameMatch[1]) || event.type;\n\t    var errorReason = event.target || event.message;\n\t    callback(createError(WSQ_ERROR, errorReason, errorName));\n\t  };\n\t}\n\t\n\tfunction getSize(opts) {\n\t  if ('size' in opts) {\n\t    // triggers immediate popup in iOS, fixes #2347\n\t    // e.g. 5000001 asks for 5 MB, 10000001 asks for 10 MB,\n\t    return opts.size * 1000000;\n\t  }\n\t  // In iOS, doesn't matter as long as it's <= 5000000.\n\t  // Except that if you request too much, our tests fail\n\t  // because of the native \"do you accept?\" popup.\n\t  // In Android <=4.3, this value is actually used as an\n\t  // honest-to-god ceiling for data, so we need to\n\t  // set it to a decently high number.\n\t  var isAndroid = typeof navigator !== 'undefined' &&\n\t    /Android/.test(navigator.userAgent);\n\t  return isAndroid ? 5000000 : 1; // in PhantomJS, if you use 0 it will crash\n\t}\n\t\n\tfunction websqlBulkDocs(dbOpts, req, opts, api, db, websqlChanges, callback) {\n\t  var newEdits = opts.new_edits;\n\t  var userDocs = req.docs;\n\t\n\t  // Parse the docs, give them a sequence number for the result\n\t  var docInfos = userDocs.map(function (doc) {\n\t    if (doc._id && isLocalId(doc._id)) {\n\t      return doc;\n\t    }\n\t    var newDoc = parseDoc(doc, newEdits);\n\t    return newDoc;\n\t  });\n\t\n\t  var docInfoErrors = docInfos.filter(function (docInfo) {\n\t    return docInfo.error;\n\t  });\n\t  if (docInfoErrors.length) {\n\t    return callback(docInfoErrors[0]);\n\t  }\n\t\n\t  var tx;\n\t  var results = new Array(docInfos.length);\n\t  var fetchedDocs = new ExportedMap();\n\t\n\t  var preconditionErrored;\n\t  function complete() {\n\t    if (preconditionErrored) {\n\t      return callback(preconditionErrored);\n\t    }\n\t    websqlChanges.notify(api._name);\n\t    callback(null, results);\n\t  }\n\t\n\t  function verifyAttachment(digest, callback) {\n\t    var sql = 'SELECT count(*) as cnt FROM ' + ATTACH_STORE$1 +\n\t      ' WHERE digest=?';\n\t    tx.executeSql(sql, [digest], function (tx, result) {\n\t      if (result.rows.item(0).cnt === 0) {\n\t        var err = createError(MISSING_STUB,\n\t          'unknown stub attachment with digest ' +\n\t          digest);\n\t        callback(err);\n\t      } else {\n\t        callback();\n\t      }\n\t    });\n\t  }\n\t\n\t  function verifyAttachments(finish) {\n\t    var digests = [];\n\t    docInfos.forEach(function (docInfo) {\n\t      if (docInfo.data && docInfo.data._attachments) {\n\t        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n\t          var att = docInfo.data._attachments[filename];\n\t          if (att.stub) {\n\t            digests.push(att.digest);\n\t          }\n\t        });\n\t      }\n\t    });\n\t    if (!digests.length) {\n\t      return finish();\n\t    }\n\t    var numDone = 0;\n\t    var err;\n\t\n\t    function checkDone() {\n\t      if (++numDone === digests.length) {\n\t        finish(err);\n\t      }\n\t    }\n\t    digests.forEach(function (digest) {\n\t      verifyAttachment(digest, function (attErr) {\n\t        if (attErr && !err) {\n\t          err = attErr;\n\t        }\n\t        checkDone();\n\t      });\n\t    });\n\t  }\n\t\n\t  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n\t                    isUpdate, delta, resultsIdx, callback) {\n\t\n\t    function finish() {\n\t      var data = docInfo.data;\n\t      var deletedInt = newRevIsDeleted ? 1 : 0;\n\t\n\t      var id = data._id;\n\t      var rev = data._rev;\n\t      var json = stringifyDoc(data);\n\t      var sql = 'INSERT INTO ' + BY_SEQ_STORE$1 +\n\t        ' (doc_id, rev, json, deleted) VALUES (?, ?, ?, ?);';\n\t      var sqlArgs = [id, rev, json, deletedInt];\n\t\n\t      // map seqs to attachment digests, which\n\t      // we will need later during compaction\n\t      function insertAttachmentMappings(seq, callback) {\n\t        var attsAdded = 0;\n\t        var attsToAdd = Object.keys(data._attachments || {});\n\t\n\t        if (!attsToAdd.length) {\n\t          return callback();\n\t        }\n\t        function checkDone() {\n\t          if (++attsAdded === attsToAdd.length) {\n\t            callback();\n\t          }\n\t          return false; // ack handling a constraint error\n\t        }\n\t        function add(att) {\n\t          var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n\t            ' (digest, seq) VALUES (?,?)';\n\t          var sqlArgs = [data._attachments[att].digest, seq];\n\t          tx.executeSql(sql, sqlArgs, checkDone, checkDone);\n\t          // second callback is for a constaint error, which we ignore\n\t          // because this docid/rev has already been associated with\n\t          // the digest (e.g. when new_edits == false)\n\t        }\n\t        for (var i = 0; i < attsToAdd.length; i++) {\n\t          add(attsToAdd[i]); // do in parallel\n\t        }\n\t      }\n\t\n\t      tx.executeSql(sql, sqlArgs, function (tx, result) {\n\t        var seq = result.insertId;\n\t        insertAttachmentMappings(seq, function () {\n\t          dataWritten(tx, seq);\n\t        });\n\t      }, function () {\n\t        // constraint error, recover by updating instead (see #1638)\n\t        var fetchSql = select('seq', BY_SEQ_STORE$1, null,\n\t          'doc_id=? AND rev=?');\n\t        tx.executeSql(fetchSql, [id, rev], function (tx, res) {\n\t          var seq = res.rows.item(0).seq;\n\t          var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n\t            ' SET json=?, deleted=? WHERE doc_id=? AND rev=?;';\n\t          var sqlArgs = [json, deletedInt, id, rev];\n\t          tx.executeSql(sql, sqlArgs, function (tx) {\n\t            insertAttachmentMappings(seq, function () {\n\t              dataWritten(tx, seq);\n\t            });\n\t          });\n\t        });\n\t        return false; // ack that we've handled the error\n\t      });\n\t    }\n\t\n\t    function collectResults(attachmentErr) {\n\t      if (!err) {\n\t        if (attachmentErr) {\n\t          err = attachmentErr;\n\t          callback(err);\n\t        } else if (recv === attachments.length) {\n\t          finish();\n\t        }\n\t      }\n\t    }\n\t\n\t    var err = null;\n\t    var recv = 0;\n\t\n\t    docInfo.data._id = docInfo.metadata.id;\n\t    docInfo.data._rev = docInfo.metadata.rev;\n\t    var attachments = Object.keys(docInfo.data._attachments || {});\n\t\n\t\n\t    if (newRevIsDeleted) {\n\t      docInfo.data._deleted = true;\n\t    }\n\t\n\t    function attachmentSaved(err) {\n\t      recv++;\n\t      collectResults(err);\n\t    }\n\t\n\t    attachments.forEach(function (key) {\n\t      var att = docInfo.data._attachments[key];\n\t      if (!att.stub) {\n\t        var data = att.data;\n\t        delete att.data;\n\t        att.revpos = parseInt(winningRev$$1, 10);\n\t        var digest = att.digest;\n\t        saveAttachment(digest, data, attachmentSaved);\n\t      } else {\n\t        recv++;\n\t        collectResults();\n\t      }\n\t    });\n\t\n\t    if (!attachments.length) {\n\t      finish();\n\t    }\n\t\n\t    function dataWritten(tx, seq) {\n\t      var id = docInfo.metadata.id;\n\t\n\t      var revsToCompact = docInfo.stemmedRevs || [];\n\t      if (isUpdate && api.auto_compaction) {\n\t        revsToCompact = compactTree(docInfo.metadata).concat(revsToCompact);\n\t      }\n\t      if (revsToCompact.length) {\n\t        compactRevs$1(revsToCompact, id, tx);\n\t      }\n\t\n\t      docInfo.metadata.seq = seq;\n\t      var rev = docInfo.metadata.rev;\n\t      delete docInfo.metadata.rev;\n\t\n\t      var sql = isUpdate ?\n\t      'UPDATE ' + DOC_STORE$1 +\n\t      ' SET json=?, max_seq=?, winningseq=' +\n\t      '(SELECT seq FROM ' + BY_SEQ_STORE$1 +\n\t      ' WHERE doc_id=' + DOC_STORE$1 + '.id AND rev=?) WHERE id=?'\n\t        : 'INSERT INTO ' + DOC_STORE$1 +\n\t      ' (id, winningseq, max_seq, json) VALUES (?,?,?,?);';\n\t      var metadataStr = safeJsonStringify(docInfo.metadata);\n\t      var params = isUpdate ?\n\t        [metadataStr, seq, winningRev$$1, id] :\n\t        [id, seq, seq, metadataStr];\n\t      tx.executeSql(sql, params, function () {\n\t        results[resultsIdx] = {\n\t          ok: true,\n\t          id: docInfo.metadata.id,\n\t          rev: rev\n\t        };\n\t        fetchedDocs.set(id, docInfo.metadata);\n\t        callback();\n\t      });\n\t    }\n\t  }\n\t\n\t  function websqlProcessDocs() {\n\t    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs, tx,\n\t                results, writeDoc, opts);\n\t  }\n\t\n\t  function fetchExistingDocs(callback) {\n\t    if (!docInfos.length) {\n\t      return callback();\n\t    }\n\t\n\t    var numFetched = 0;\n\t\n\t    function checkDone() {\n\t      if (++numFetched === docInfos.length) {\n\t        callback();\n\t      }\n\t    }\n\t\n\t    docInfos.forEach(function (docInfo) {\n\t      if (docInfo._id && isLocalId(docInfo._id)) {\n\t        return checkDone(); // skip local docs\n\t      }\n\t      var id = docInfo.metadata.id;\n\t      tx.executeSql('SELECT json FROM ' + DOC_STORE$1 +\n\t      ' WHERE id = ?', [id], function (tx, result) {\n\t        if (result.rows.length) {\n\t          var metadata = safeJsonParse(result.rows.item(0).json);\n\t          fetchedDocs.set(id, metadata);\n\t        }\n\t        checkDone();\n\t      });\n\t    });\n\t  }\n\t\n\t  function saveAttachment(digest, data, callback) {\n\t    var sql = 'SELECT digest FROM ' + ATTACH_STORE$1 + ' WHERE digest=?';\n\t    tx.executeSql(sql, [digest], function (tx, result) {\n\t      if (result.rows.length) { // attachment already exists\n\t        return callback();\n\t      }\n\t      // we could just insert before selecting and catch the error,\n\t      // but my hunch is that it's cheaper not to serialize the blob\n\t      // from JS to C if we don't have to (TODO: confirm this)\n\t      sql = 'INSERT INTO ' + ATTACH_STORE$1 +\n\t      ' (digest, body, escaped) VALUES (?,?,1)';\n\t      tx.executeSql(sql, [digest, escapeBlob(data)], function () {\n\t        callback();\n\t      }, function () {\n\t        // ignore constaint errors, means it already exists\n\t        callback();\n\t        return false; // ack we handled the error\n\t      });\n\t    });\n\t  }\n\t\n\t  preprocessAttachments(docInfos, 'binary', function (err) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    db.transaction(function (txn) {\n\t      tx = txn;\n\t      verifyAttachments(function (err) {\n\t        if (err) {\n\t          preconditionErrored = err;\n\t        } else {\n\t          fetchExistingDocs(websqlProcessDocs);\n\t        }\n\t      });\n\t    }, websqlError(callback), complete);\n\t  });\n\t}\n\t\n\tvar cachedDatabases = new ExportedMap();\n\t\n\t// openDatabase passed in through opts (e.g. for node-websql)\n\tfunction openDatabaseWithOpts(opts) {\n\t  return opts.websql(opts.name, opts.version, opts.description, opts.size);\n\t}\n\t\n\tfunction openDBSafely(opts) {\n\t  try {\n\t    return {\n\t      db: openDatabaseWithOpts(opts)\n\t    };\n\t  } catch (err) {\n\t    return {\n\t      error: err\n\t    };\n\t  }\n\t}\n\t\n\tfunction openDB$1(opts) {\n\t  var cachedResult = cachedDatabases.get(opts.name);\n\t  if (!cachedResult) {\n\t    cachedResult = openDBSafely(opts);\n\t    cachedDatabases.set(opts.name, cachedResult);\n\t  }\n\t  return cachedResult;\n\t}\n\t\n\tvar websqlChanges = new Changes();\n\t\n\tfunction fetchAttachmentsIfNecessary$1(doc, opts, api, txn, cb) {\n\t  var attachments = Object.keys(doc._attachments || {});\n\t  if (!attachments.length) {\n\t    return cb && cb();\n\t  }\n\t  var numDone = 0;\n\t\n\t  function checkDone() {\n\t    if (++numDone === attachments.length && cb) {\n\t      cb();\n\t    }\n\t  }\n\t\n\t  function fetchAttachment(doc, att) {\n\t    var attObj = doc._attachments[att];\n\t    var attOpts = {binary: opts.binary, ctx: txn};\n\t    api._getAttachment(doc._id, att, attObj, attOpts, function (_, data) {\n\t      doc._attachments[att] = $inject_Object_assign(\n\t        pick(attObj, ['digest', 'content_type']),\n\t        { data: data }\n\t      );\n\t      checkDone();\n\t    });\n\t  }\n\t\n\t  attachments.forEach(function (att) {\n\t    if (opts.attachments && opts.include_docs) {\n\t      fetchAttachment(doc, att);\n\t    } else {\n\t      doc._attachments[att].stub = true;\n\t      checkDone();\n\t    }\n\t  });\n\t}\n\t\n\tvar POUCH_VERSION = 1;\n\t\n\t// these indexes cover the ground for most allDocs queries\n\tvar BY_SEQ_STORE_DELETED_INDEX_SQL =\n\t  'CREATE INDEX IF NOT EXISTS \\'by-seq-deleted-idx\\' ON ' +\n\t  BY_SEQ_STORE$1 + ' (seq, deleted)';\n\tvar BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL =\n\t  'CREATE UNIQUE INDEX IF NOT EXISTS \\'by-seq-doc-id-rev\\' ON ' +\n\t    BY_SEQ_STORE$1 + ' (doc_id, rev)';\n\tvar DOC_STORE_WINNINGSEQ_INDEX_SQL =\n\t  'CREATE INDEX IF NOT EXISTS \\'doc-winningseq-idx\\' ON ' +\n\t  DOC_STORE$1 + ' (winningseq)';\n\tvar ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL =\n\t  'CREATE INDEX IF NOT EXISTS \\'attach-seq-seq-idx\\' ON ' +\n\t    ATTACH_AND_SEQ_STORE$1 + ' (seq)';\n\tvar ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL =\n\t  'CREATE UNIQUE INDEX IF NOT EXISTS \\'attach-seq-digest-idx\\' ON ' +\n\t    ATTACH_AND_SEQ_STORE$1 + ' (digest, seq)';\n\t\n\tvar DOC_STORE_AND_BY_SEQ_JOINER = BY_SEQ_STORE$1 +\n\t  '.seq = ' + DOC_STORE$1 + '.winningseq';\n\t\n\tvar SELECT_DOCS = BY_SEQ_STORE$1 + '.seq AS seq, ' +\n\t  BY_SEQ_STORE$1 + '.deleted AS deleted, ' +\n\t  BY_SEQ_STORE$1 + '.json AS data, ' +\n\t  BY_SEQ_STORE$1 + '.rev AS rev, ' +\n\t  DOC_STORE$1 + '.json AS metadata';\n\t\n\tfunction WebSqlPouch$1(opts, callback) {\n\t  var api = this;\n\t  var instanceId = null;\n\t  var size = getSize(opts);\n\t  var idRequests = [];\n\t  var encoding;\n\t\n\t  api._name = opts.name;\n\t\n\t  // extend the options here, because sqlite plugin has a ton of options\n\t  // and they are constantly changing, so it's more prudent to allow anything\n\t  var websqlOpts = $inject_Object_assign({}, opts, {\n\t    version: POUCH_VERSION,\n\t    description: opts.name,\n\t    size: size\n\t  });\n\t  var openDBResult = openDB$1(websqlOpts);\n\t  if (openDBResult.error) {\n\t    return websqlError(callback)(openDBResult.error);\n\t  }\n\t  var db = openDBResult.db;\n\t  if (typeof db.readTransaction !== 'function') {\n\t    // doesn't exist in sqlite plugin\n\t    db.readTransaction = db.transaction;\n\t  }\n\t\n\t  function dbCreated() {\n\t    // note the db name in case the browser upgrades to idb\n\t    if (hasLocalStorage()) {\n\t      window.localStorage['_pouch__websqldb_' + api._name] = true;\n\t    }\n\t    callback(null, api);\n\t  }\n\t\n\t  // In this migration, we added the 'deleted' and 'local' columns to the\n\t  // by-seq and doc store tables.\n\t  // To preserve existing user data, we re-process all the existing JSON\n\t  // and add these values.\n\t  // Called migration2 because it corresponds to adapter version (db_version) #2\n\t  function runMigration2(tx, callback) {\n\t    // index used for the join in the allDocs query\n\t    tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n\t\n\t    tx.executeSql('ALTER TABLE ' + BY_SEQ_STORE$1 +\n\t      ' ADD COLUMN deleted TINYINT(1) DEFAULT 0', [], function () {\n\t      tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n\t      tx.executeSql('ALTER TABLE ' + DOC_STORE$1 +\n\t        ' ADD COLUMN local TINYINT(1) DEFAULT 0', [], function () {\n\t        tx.executeSql('CREATE INDEX IF NOT EXISTS \\'doc-store-local-idx\\' ON ' +\n\t          DOC_STORE$1 + ' (local, id)');\n\t\n\t        var sql = 'SELECT ' + DOC_STORE$1 + '.winningseq AS seq, ' + DOC_STORE$1 +\n\t          '.json AS metadata FROM ' + BY_SEQ_STORE$1 + ' JOIN ' + DOC_STORE$1 +\n\t          ' ON ' + BY_SEQ_STORE$1 + '.seq = ' + DOC_STORE$1 + '.winningseq';\n\t\n\t        tx.executeSql(sql, [], function (tx, result) {\n\t\n\t          var deleted = [];\n\t          var local = [];\n\t\n\t          for (var i = 0; i < result.rows.length; i++) {\n\t            var item = result.rows.item(i);\n\t            var seq = item.seq;\n\t            var metadata = JSON.parse(item.metadata);\n\t            if (isDeleted(metadata)) {\n\t              deleted.push(seq);\n\t            }\n\t            if (isLocalId(metadata.id)) {\n\t              local.push(metadata.id);\n\t            }\n\t          }\n\t          tx.executeSql('UPDATE ' + DOC_STORE$1 + 'SET local = 1 WHERE id IN ' +\n\t            qMarks(local.length), local, function () {\n\t            tx.executeSql('UPDATE ' + BY_SEQ_STORE$1 +\n\t              ' SET deleted = 1 WHERE seq IN ' +\n\t              qMarks(deleted.length), deleted, callback);\n\t          });\n\t        });\n\t      });\n\t    });\n\t  }\n\t\n\t  // in this migration, we make all the local docs unversioned\n\t  function runMigration3(tx, callback) {\n\t    var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n\t      ' (id UNIQUE, rev, json)';\n\t    tx.executeSql(local, [], function () {\n\t      var sql = 'SELECT ' + DOC_STORE$1 + '.id AS id, ' +\n\t        BY_SEQ_STORE$1 + '.json AS data ' +\n\t        'FROM ' + BY_SEQ_STORE$1 + ' JOIN ' +\n\t        DOC_STORE$1 + ' ON ' + BY_SEQ_STORE$1 + '.seq = ' +\n\t        DOC_STORE$1 + '.winningseq WHERE local = 1';\n\t      tx.executeSql(sql, [], function (tx, res) {\n\t        var rows = [];\n\t        for (var i = 0; i < res.rows.length; i++) {\n\t          rows.push(res.rows.item(i));\n\t        }\n\t        function doNext() {\n\t          if (!rows.length) {\n\t            return callback(tx);\n\t          }\n\t          var row = rows.shift();\n\t          var rev$$1 = JSON.parse(row.data)._rev;\n\t          tx.executeSql('INSERT INTO ' + LOCAL_STORE$1 +\n\t              ' (id, rev, json) VALUES (?,?,?)',\n\t              [row.id, rev$$1, row.data], function (tx) {\n\t            tx.executeSql('DELETE FROM ' + DOC_STORE$1 + ' WHERE id=?',\n\t                [row.id], function (tx) {\n\t              tx.executeSql('DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?',\n\t                  [row.seq], function () {\n\t                doNext();\n\t              });\n\t            });\n\t          });\n\t        }\n\t        doNext();\n\t      });\n\t    });\n\t  }\n\t\n\t  // in this migration, we remove doc_id_rev and just use rev\n\t  function runMigration4(tx, callback) {\n\t\n\t    function updateRows(rows) {\n\t      function doNext() {\n\t        if (!rows.length) {\n\t          return callback(tx);\n\t        }\n\t        var row = rows.shift();\n\t        var doc_id_rev = parseHexString(row.hex, encoding);\n\t        var idx = doc_id_rev.lastIndexOf('::');\n\t        var doc_id = doc_id_rev.substring(0, idx);\n\t        var rev$$1 = doc_id_rev.substring(idx + 2);\n\t        var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n\t          ' SET doc_id=?, rev=? WHERE doc_id_rev=?';\n\t        tx.executeSql(sql, [doc_id, rev$$1, doc_id_rev], function () {\n\t          doNext();\n\t        });\n\t      }\n\t      doNext();\n\t    }\n\t\n\t    var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN doc_id';\n\t    tx.executeSql(sql, [], function (tx) {\n\t      var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN rev';\n\t      tx.executeSql(sql, [], function (tx) {\n\t        tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL, [], function (tx) {\n\t          var sql = 'SELECT hex(doc_id_rev) as hex FROM ' + BY_SEQ_STORE$1;\n\t          tx.executeSql(sql, [], function (tx, res) {\n\t            var rows = [];\n\t            for (var i = 0; i < res.rows.length; i++) {\n\t              rows.push(res.rows.item(i));\n\t            }\n\t            updateRows(rows);\n\t          });\n\t        });\n\t      });\n\t    });\n\t  }\n\t\n\t  // in this migration, we add the attach_and_seq table\n\t  // for issue #2818\n\t  function runMigration5(tx, callback) {\n\t\n\t    function migrateAttsAndSeqs(tx) {\n\t      // need to actually populate the table. this is the expensive part,\n\t      // so as an optimization, check first that this database even\n\t      // contains attachments\n\t      var sql = 'SELECT COUNT(*) AS cnt FROM ' + ATTACH_STORE$1;\n\t      tx.executeSql(sql, [], function (tx, res) {\n\t        var count = res.rows.item(0).cnt;\n\t        if (!count) {\n\t          return callback(tx);\n\t        }\n\t\n\t        var offset = 0;\n\t        var pageSize = 10;\n\t        function nextPage() {\n\t          var sql = select(\n\t            SELECT_DOCS + ', ' + DOC_STORE$1 + '.id AS id',\n\t            [DOC_STORE$1, BY_SEQ_STORE$1],\n\t            DOC_STORE_AND_BY_SEQ_JOINER,\n\t            null,\n\t            DOC_STORE$1 + '.id '\n\t          );\n\t          sql += ' LIMIT ' + pageSize + ' OFFSET ' + offset;\n\t          offset += pageSize;\n\t          tx.executeSql(sql, [], function (tx, res) {\n\t            if (!res.rows.length) {\n\t              return callback(tx);\n\t            }\n\t            var digestSeqs = {};\n\t            function addDigestSeq(digest, seq) {\n\t              // uniq digest/seq pairs, just in case there are dups\n\t              var seqs = digestSeqs[digest] = (digestSeqs[digest] || []);\n\t              if (seqs.indexOf(seq) === -1) {\n\t                seqs.push(seq);\n\t              }\n\t            }\n\t            for (var i = 0; i < res.rows.length; i++) {\n\t              var row = res.rows.item(i);\n\t              var doc = unstringifyDoc(row.data, row.id, row.rev);\n\t              var atts = Object.keys(doc._attachments || {});\n\t              for (var j = 0; j < atts.length; j++) {\n\t                var att = doc._attachments[atts[j]];\n\t                addDigestSeq(att.digest, row.seq);\n\t              }\n\t            }\n\t            var digestSeqPairs = [];\n\t            Object.keys(digestSeqs).forEach(function (digest) {\n\t              var seqs = digestSeqs[digest];\n\t              seqs.forEach(function (seq) {\n\t                digestSeqPairs.push([digest, seq]);\n\t              });\n\t            });\n\t            if (!digestSeqPairs.length) {\n\t              return nextPage();\n\t            }\n\t            var numDone = 0;\n\t            digestSeqPairs.forEach(function (pair) {\n\t              var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n\t                ' (digest, seq) VALUES (?,?)';\n\t              tx.executeSql(sql, pair, function () {\n\t                if (++numDone === digestSeqPairs.length) {\n\t                  nextPage();\n\t                }\n\t              });\n\t            });\n\t          });\n\t        }\n\t        nextPage();\n\t      });\n\t    }\n\t\n\t    var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n\t      ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n\t    tx.executeSql(attachAndRev, [], function (tx) {\n\t      tx.executeSql(\n\t        ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL, [], function (tx) {\n\t          tx.executeSql(\n\t            ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL, [],\n\t            migrateAttsAndSeqs);\n\t        });\n\t    });\n\t  }\n\t\n\t  // in this migration, we use escapeBlob() and unescapeBlob()\n\t  // instead of reading out the binary as HEX, which is slow\n\t  function runMigration6(tx, callback) {\n\t    var sql = 'ALTER TABLE ' + ATTACH_STORE$1 +\n\t      ' ADD COLUMN escaped TINYINT(1) DEFAULT 0';\n\t    tx.executeSql(sql, [], callback);\n\t  }\n\t\n\t  // issue #3136, in this migration we need a \"latest seq\" as well\n\t  // as the \"winning seq\" in the doc store\n\t  function runMigration7(tx, callback) {\n\t    var sql = 'ALTER TABLE ' + DOC_STORE$1 +\n\t      ' ADD COLUMN max_seq INTEGER';\n\t    tx.executeSql(sql, [], function (tx) {\n\t      var sql = 'UPDATE ' + DOC_STORE$1 + ' SET max_seq=(SELECT MAX(seq) FROM ' +\n\t        BY_SEQ_STORE$1 + ' WHERE doc_id=id)';\n\t      tx.executeSql(sql, [], function (tx) {\n\t        // add unique index after filling, else we'll get a constraint\n\t        // error when we do the ALTER TABLE\n\t        var sql =\n\t          'CREATE UNIQUE INDEX IF NOT EXISTS \\'doc-max-seq-idx\\' ON ' +\n\t          DOC_STORE$1 + ' (max_seq)';\n\t        tx.executeSql(sql, [], callback);\n\t      });\n\t    });\n\t  }\n\t\n\t  function checkEncoding(tx, cb) {\n\t    // UTF-8 on chrome/android, UTF-16 on safari < 7.1\n\t    tx.executeSql('SELECT HEX(\"a\") AS hex', [], function (tx, res) {\n\t        var hex = res.rows.item(0).hex;\n\t        encoding = hex.length === 2 ? 'UTF-8' : 'UTF-16';\n\t        cb();\n\t      }\n\t    );\n\t  }\n\t\n\t  function onGetInstanceId() {\n\t    while (idRequests.length > 0) {\n\t      var idCallback = idRequests.pop();\n\t      idCallback(null, instanceId);\n\t    }\n\t  }\n\t\n\t  function onGetVersion(tx, dbVersion) {\n\t    if (dbVersion === 0) {\n\t      // initial schema\n\t\n\t      var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE$1 +\n\t        ' (dbid, db_version INTEGER)';\n\t      var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE$1 +\n\t        ' (digest UNIQUE, escaped TINYINT(1), body BLOB)';\n\t      var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n\t        ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n\t      // TODO: migrate winningseq to INTEGER\n\t      var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE$1 +\n\t        ' (id unique, json, winningseq, max_seq INTEGER UNIQUE)';\n\t      var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE$1 +\n\t        ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, ' +\n\t        'json, deleted TINYINT(1), doc_id, rev)';\n\t      var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n\t        ' (id UNIQUE, rev, json)';\n\t\n\t      // creates\n\t      tx.executeSql(attach);\n\t      tx.executeSql(local);\n\t      tx.executeSql(attachAndRev, [], function () {\n\t        tx.executeSql(ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL);\n\t        tx.executeSql(ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL);\n\t      });\n\t      tx.executeSql(doc, [], function () {\n\t        tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n\t        tx.executeSql(seq, [], function () {\n\t          tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n\t          tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL);\n\t          tx.executeSql(meta, [], function () {\n\t            // mark the db version, and new dbid\n\t            var initSeq = 'INSERT INTO ' + META_STORE$1 +\n\t              ' (db_version, dbid) VALUES (?,?)';\n\t            instanceId = uuid();\n\t            var initSeqArgs = [ADAPTER_VERSION$1, instanceId];\n\t            tx.executeSql(initSeq, initSeqArgs, function () {\n\t              onGetInstanceId();\n\t            });\n\t          });\n\t        });\n\t      });\n\t    } else { // version > 0\n\t\n\t      var setupDone = function () {\n\t        var migrated = dbVersion < ADAPTER_VERSION$1;\n\t        if (migrated) {\n\t          // update the db version within this transaction\n\t          tx.executeSql('UPDATE ' + META_STORE$1 + ' SET db_version = ' +\n\t            ADAPTER_VERSION$1);\n\t        }\n\t        // notify db.id() callers\n\t        var sql = 'SELECT dbid FROM ' + META_STORE$1;\n\t        tx.executeSql(sql, [], function (tx, result) {\n\t          instanceId = result.rows.item(0).dbid;\n\t          onGetInstanceId();\n\t        });\n\t      };\n\t\n\t      // would love to use promises here, but then websql\n\t      // ends the transaction early\n\t      var tasks = [\n\t        runMigration2,\n\t        runMigration3,\n\t        runMigration4,\n\t        runMigration5,\n\t        runMigration6,\n\t        runMigration7,\n\t        setupDone\n\t      ];\n\t\n\t      // run each migration sequentially\n\t      var i = dbVersion;\n\t      var nextMigration = function (tx) {\n\t        tasks[i - 1](tx, nextMigration);\n\t        i++;\n\t      };\n\t      nextMigration(tx);\n\t    }\n\t  }\n\t\n\t  function setup() {\n\t    db.transaction(function (tx) {\n\t      // first check the encoding\n\t      checkEncoding(tx, function () {\n\t        // then get the version\n\t        fetchVersion(tx);\n\t      });\n\t    }, websqlError(callback), dbCreated);\n\t  }\n\t\n\t  function fetchVersion(tx) {\n\t    var sql = 'SELECT sql FROM sqlite_master WHERE tbl_name = ' + META_STORE$1;\n\t    tx.executeSql(sql, [], function (tx, result) {\n\t      if (!result.rows.length) {\n\t        // database hasn't even been created yet (version 0)\n\t        onGetVersion(tx, 0);\n\t      } else if (!/db_version/.test(result.rows.item(0).sql)) {\n\t        // table was created, but without the new db_version column,\n\t        // so add it.\n\t        tx.executeSql('ALTER TABLE ' + META_STORE$1 +\n\t          ' ADD COLUMN db_version INTEGER', [], function () {\n\t          // before version 2, this column didn't even exist\n\t          onGetVersion(tx, 1);\n\t        });\n\t      } else { // column exists, we can safely get it\n\t        tx.executeSql('SELECT db_version FROM ' + META_STORE$1,\n\t          [], function (tx, result) {\n\t          var dbVersion = result.rows.item(0).db_version;\n\t          onGetVersion(tx, dbVersion);\n\t        });\n\t      }\n\t    });\n\t  }\n\t\n\t  setup();\n\t\n\t  function getMaxSeq(tx, callback) {\n\t    var sql = 'SELECT MAX(seq) AS seq FROM ' + BY_SEQ_STORE$1;\n\t    tx.executeSql(sql, [], function (tx, res) {\n\t      var updateSeq = res.rows.item(0).seq || 0;\n\t      callback(updateSeq);\n\t    });\n\t  }\n\t\n\t  function countDocs(tx, callback) {\n\t    // count the total rows\n\t    var sql = select(\n\t      'COUNT(' + DOC_STORE$1 + '.id) AS \\'num\\'',\n\t      [DOC_STORE$1, BY_SEQ_STORE$1],\n\t      DOC_STORE_AND_BY_SEQ_JOINER,\n\t      BY_SEQ_STORE$1 + '.deleted=0');\n\t\n\t    tx.executeSql(sql, [], function (tx, result) {\n\t      callback(result.rows.item(0).num);\n\t    });\n\t  }\n\t\n\t  api._remote = false;\n\t  api.type = function () {\n\t    return 'websql';\n\t  };\n\t\n\t  api._id = toPromise(function (callback) {\n\t    callback(null, instanceId);\n\t  });\n\t\n\t  api._info = function (callback) {\n\t    var seq;\n\t    var docCount;\n\t    db.readTransaction(function (tx) {\n\t      getMaxSeq(tx, function (theSeq) {\n\t        seq = theSeq;\n\t      });\n\t      countDocs(tx, function (theDocCount) {\n\t        docCount = theDocCount;\n\t      });\n\t    }, websqlError(callback), function () {\n\t      callback(null, {\n\t        doc_count: docCount,\n\t        update_seq: seq,\n\t        websql_encoding: encoding\n\t      });\n\t    });\n\t  };\n\t\n\t  api._bulkDocs = function (req, reqOpts, callback) {\n\t    websqlBulkDocs(opts, req, reqOpts, api, db, websqlChanges, callback);\n\t  };\n\t\n\t  function latest$$1(tx, id, rev$$1, callback, finish) {\n\t    var sql = select(\n\t        SELECT_DOCS,\n\t        [DOC_STORE$1, BY_SEQ_STORE$1],\n\t        DOC_STORE_AND_BY_SEQ_JOINER,\n\t        DOC_STORE$1 + '.id=?');\n\t    var sqlArgs = [id];\n\t\n\t    tx.executeSql(sql, sqlArgs, function (a, results) {\n\t      if (!results.rows.length) {\n\t        var err = createError(MISSING_DOC, 'missing');\n\t        return finish(err);\n\t      }\n\t      var item = results.rows.item(0);\n\t      var metadata = safeJsonParse(item.metadata);\n\t      callback(latest(rev$$1, metadata));\n\t    });\n\t  }\n\t\n\t  api._get = function (id, opts, callback) {\n\t    var doc;\n\t    var metadata;\n\t    var tx = opts.ctx;\n\t    if (!tx) {\n\t      return db.readTransaction(function (txn) {\n\t        api._get(id, $inject_Object_assign({ctx: txn}, opts), callback);\n\t      });\n\t    }\n\t\n\t    function finish(err) {\n\t      callback(err, {doc: doc, metadata: metadata, ctx: tx});\n\t    }\n\t\n\t    var sql;\n\t    var sqlArgs;\n\t\n\t    if (!opts.rev) {\n\t      sql = select(\n\t        SELECT_DOCS,\n\t        [DOC_STORE$1, BY_SEQ_STORE$1],\n\t        DOC_STORE_AND_BY_SEQ_JOINER,\n\t        DOC_STORE$1 + '.id=?');\n\t      sqlArgs = [id];\n\t    } else if (opts.latest) {\n\t      latest$$1(tx, id, opts.rev, function (latestRev) {\n\t        opts.latest = false;\n\t        opts.rev = latestRev;\n\t        api._get(id, opts, callback);\n\t      }, finish);\n\t      return;\n\t    } else {\n\t      sql = select(\n\t        SELECT_DOCS,\n\t        [DOC_STORE$1, BY_SEQ_STORE$1],\n\t        DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id',\n\t        [BY_SEQ_STORE$1 + '.doc_id=?', BY_SEQ_STORE$1 + '.rev=?']);\n\t      sqlArgs = [id, opts.rev];\n\t    }\n\t\n\t    tx.executeSql(sql, sqlArgs, function (a, results) {\n\t      if (!results.rows.length) {\n\t        var missingErr = createError(MISSING_DOC, 'missing');\n\t        return finish(missingErr);\n\t      }\n\t      var item = results.rows.item(0);\n\t      metadata = safeJsonParse(item.metadata);\n\t      if (item.deleted && !opts.rev) {\n\t        var deletedErr = createError(MISSING_DOC, 'deleted');\n\t        return finish(deletedErr);\n\t      }\n\t      doc = unstringifyDoc(item.data, metadata.id, item.rev);\n\t      finish();\n\t    });\n\t  };\n\t\n\t  api._allDocs = function (opts, callback) {\n\t    var results = [];\n\t    var totalRows;\n\t\n\t    var start = 'startkey' in opts ? opts.startkey : false;\n\t    var end = 'endkey' in opts ? opts.endkey : false;\n\t    var key = 'key' in opts ? opts.key : false;\n\t    var descending = 'descending' in opts ? opts.descending : false;\n\t    var limit = 'limit' in opts ? opts.limit : -1;\n\t    var offset = 'skip' in opts ? opts.skip : 0;\n\t    var inclusiveEnd = opts.inclusive_end !== false;\n\t\n\t    var sqlArgs = [];\n\t    var criteria = [];\n\t\n\t    if (key !== false) {\n\t      criteria.push(DOC_STORE$1 + '.id = ?');\n\t      sqlArgs.push(key);\n\t    } else if (start !== false || end !== false) {\n\t      if (start !== false) {\n\t        criteria.push(DOC_STORE$1 + '.id ' + (descending ? '<=' : '>=') + ' ?');\n\t        sqlArgs.push(start);\n\t      }\n\t      if (end !== false) {\n\t        var comparator = descending ? '>' : '<';\n\t        if (inclusiveEnd) {\n\t          comparator += '=';\n\t        }\n\t        criteria.push(DOC_STORE$1 + '.id ' + comparator + ' ?');\n\t        sqlArgs.push(end);\n\t      }\n\t      if (key !== false) {\n\t        criteria.push(DOC_STORE$1 + '.id = ?');\n\t        sqlArgs.push(key);\n\t      }\n\t    }\n\t\n\t    if (opts.deleted !== 'ok') {\n\t      // report deleted if keys are specified\n\t      criteria.push(BY_SEQ_STORE$1 + '.deleted = 0');\n\t    }\n\t\n\t    db.readTransaction(function (tx) {\n\t      // count the docs in parallel to other operations\n\t      countDocs(tx, function (docCount) {\n\t        totalRows = docCount;\n\t      });\n\t\n\t      if (limit === 0) {\n\t        return;\n\t      }\n\t\n\t      // do a single query to fetch the documents\n\t      var sql = select(\n\t        SELECT_DOCS,\n\t        [DOC_STORE$1, BY_SEQ_STORE$1],\n\t        DOC_STORE_AND_BY_SEQ_JOINER,\n\t        criteria,\n\t        DOC_STORE$1 + '.id ' + (descending ? 'DESC' : 'ASC')\n\t        );\n\t      sql += ' LIMIT ' + limit + ' OFFSET ' + offset;\n\t\n\t      tx.executeSql(sql, sqlArgs, function (tx, result) {\n\t        for (var i = 0, l = result.rows.length; i < l; i++) {\n\t          var item = result.rows.item(i);\n\t          var metadata = safeJsonParse(item.metadata);\n\t          var id = metadata.id;\n\t          var data = unstringifyDoc(item.data, id, item.rev);\n\t          var winningRev$$1 = data._rev;\n\t          var doc = {\n\t            id: id,\n\t            key: id,\n\t            value: {rev: winningRev$$1}\n\t          };\n\t          if (opts.include_docs) {\n\t            doc.doc = data;\n\t            doc.doc._rev = winningRev$$1;\n\t            if (opts.conflicts) {\n\t              var conflicts = collectConflicts(metadata);\n\t              if (conflicts.length) {\n\t                doc.doc._conflicts = conflicts;\n\t              }\n\t            }\n\t            fetchAttachmentsIfNecessary$1(doc.doc, opts, api, tx);\n\t          }\n\t          if (item.deleted) {\n\t            if (opts.deleted === 'ok') {\n\t              doc.value.deleted = true;\n\t              doc.doc = null;\n\t            } else {\n\t              continue;\n\t            }\n\t          }\n\t          results.push(doc);\n\t        }\n\t      });\n\t    }, websqlError(callback), function () {\n\t      callback(null, {\n\t        total_rows: totalRows,\n\t        offset: opts.skip,\n\t        rows: results\n\t      });\n\t    });\n\t  };\n\t\n\t  api._changes = function (opts) {\n\t    opts = clone(opts);\n\t\n\t    if (opts.continuous) {\n\t      var id = api._name + ':' + uuid();\n\t      websqlChanges.addListener(api._name, id, api, opts);\n\t      websqlChanges.notify(api._name);\n\t      return {\n\t        cancel: function () {\n\t          websqlChanges.removeListener(api._name, id);\n\t        }\n\t      };\n\t    }\n\t\n\t    var descending = opts.descending;\n\t\n\t    // Ignore the `since` parameter when `descending` is true\n\t    opts.since = opts.since && !descending ? opts.since : 0;\n\t\n\t    var limit = 'limit' in opts ? opts.limit : -1;\n\t    if (limit === 0) {\n\t      limit = 1; // per CouchDB _changes spec\n\t    }\n\t\n\t    var returnDocs;\n\t    if ('return_docs' in opts) {\n\t      returnDocs = opts.return_docs;\n\t    } else if ('returnDocs' in opts) {\n\t      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n\t      returnDocs = opts.returnDocs;\n\t    } else {\n\t      returnDocs = true;\n\t    }\n\t    var results = [];\n\t    var numResults = 0;\n\t\n\t    function fetchChanges() {\n\t\n\t      var selectStmt =\n\t        DOC_STORE$1 + '.json AS metadata, ' +\n\t        DOC_STORE$1 + '.max_seq AS maxSeq, ' +\n\t        BY_SEQ_STORE$1 + '.json AS winningDoc, ' +\n\t        BY_SEQ_STORE$1 + '.rev AS winningRev ';\n\t\n\t      var from = DOC_STORE$1 + ' JOIN ' + BY_SEQ_STORE$1;\n\t\n\t      var joiner = DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id' +\n\t        ' AND ' + DOC_STORE$1 + '.winningseq=' + BY_SEQ_STORE$1 + '.seq';\n\t\n\t      var criteria = ['maxSeq > ?'];\n\t      var sqlArgs = [opts.since];\n\t\n\t      if (opts.doc_ids) {\n\t        criteria.push(DOC_STORE$1 + '.id IN ' + qMarks(opts.doc_ids.length));\n\t        sqlArgs = sqlArgs.concat(opts.doc_ids);\n\t      }\n\t\n\t      var orderBy = 'maxSeq ' + (descending ? 'DESC' : 'ASC');\n\t\n\t      var sql = select(selectStmt, from, joiner, criteria, orderBy);\n\t\n\t      var filter = filterChange(opts);\n\t      if (!opts.view && !opts.filter) {\n\t        // we can just limit in the query\n\t        sql += ' LIMIT ' + limit;\n\t      }\n\t\n\t      var lastSeq = opts.since || 0;\n\t      db.readTransaction(function (tx) {\n\t        tx.executeSql(sql, sqlArgs, function (tx, result) {\n\t          function reportChange(change) {\n\t            return function () {\n\t              opts.onChange(change);\n\t            };\n\t          }\n\t          for (var i = 0, l = result.rows.length; i < l; i++) {\n\t            var item = result.rows.item(i);\n\t            var metadata = safeJsonParse(item.metadata);\n\t            lastSeq = item.maxSeq;\n\t\n\t            var doc = unstringifyDoc(item.winningDoc, metadata.id,\n\t              item.winningRev);\n\t            var change = opts.processChange(doc, metadata, opts);\n\t            change.seq = item.maxSeq;\n\t\n\t            var filtered = filter(change);\n\t            if (typeof filtered === 'object') {\n\t              return opts.complete(filtered);\n\t            }\n\t\n\t            if (filtered) {\n\t              numResults++;\n\t              if (returnDocs) {\n\t                results.push(change);\n\t              }\n\t              // process the attachment immediately\n\t              // for the benefit of live listeners\n\t              if (opts.attachments && opts.include_docs) {\n\t                fetchAttachmentsIfNecessary$1(doc, opts, api, tx,\n\t                  reportChange(change));\n\t              } else {\n\t                reportChange(change)();\n\t              }\n\t            }\n\t            if (numResults === limit) {\n\t              break;\n\t            }\n\t          }\n\t        });\n\t      }, websqlError(opts.complete), function () {\n\t        if (!opts.continuous) {\n\t          opts.complete(null, {\n\t            results: results,\n\t            last_seq: lastSeq\n\t          });\n\t        }\n\t      });\n\t    }\n\t\n\t    fetchChanges();\n\t  };\n\t\n\t  api._close = function (callback) {\n\t    //WebSQL databases do not need to be closed\n\t    callback();\n\t  };\n\t\n\t  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n\t    var res;\n\t    var tx = opts.ctx;\n\t    var digest = attachment.digest;\n\t    var type = attachment.content_type;\n\t    var sql = 'SELECT escaped, ' +\n\t      'CASE WHEN escaped = 1 THEN body ELSE HEX(body) END AS body FROM ' +\n\t      ATTACH_STORE$1 + ' WHERE digest=?';\n\t    tx.executeSql(sql, [digest], function (tx, result) {\n\t      // websql has a bug where \\u0000 causes early truncation in strings\n\t      // and blobs. to work around this, we used to use the hex() function,\n\t      // but that's not performant. after migration 6, we remove \\u0000\n\t      // and add it back in afterwards\n\t      var item = result.rows.item(0);\n\t      var data = item.escaped ? unescapeBlob(item.body) :\n\t        parseHexString(item.body, encoding);\n\t      if (opts.binary) {\n\t        res = binStringToBluffer(data, type);\n\t      } else {\n\t        res = thisBtoa(data);\n\t      }\n\t      callback(null, res);\n\t    });\n\t  };\n\t\n\t  api._getRevisionTree = function (docId, callback) {\n\t    db.readTransaction(function (tx) {\n\t      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n\t      tx.executeSql(sql, [docId], function (tx, result) {\n\t        if (!result.rows.length) {\n\t          callback(createError(MISSING_DOC));\n\t        } else {\n\t          var data = safeJsonParse(result.rows.item(0).metadata);\n\t          callback(null, data.rev_tree);\n\t        }\n\t      });\n\t    });\n\t  };\n\t\n\t  api._doCompaction = function (docId, revs, callback) {\n\t    if (!revs.length) {\n\t      return callback();\n\t    }\n\t    db.transaction(function (tx) {\n\t\n\t      // update doc store\n\t      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n\t      tx.executeSql(sql, [docId], function (tx, result) {\n\t        var metadata = safeJsonParse(result.rows.item(0).metadata);\n\t        traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n\t                                                           revHash, ctx, opts) {\n\t          var rev$$1 = pos + '-' + revHash;\n\t          if (revs.indexOf(rev$$1) !== -1) {\n\t            opts.status = 'missing';\n\t          }\n\t        });\n\t\n\t        var sql = 'UPDATE ' + DOC_STORE$1 + ' SET json = ? WHERE id = ?';\n\t        tx.executeSql(sql, [safeJsonStringify(metadata), docId]);\n\t      });\n\t\n\t      compactRevs$1(revs, docId, tx);\n\t    }, websqlError(callback), function () {\n\t      callback();\n\t    });\n\t  };\n\t\n\t  api._getLocal = function (id, callback) {\n\t    db.readTransaction(function (tx) {\n\t      var sql = 'SELECT json, rev FROM ' + LOCAL_STORE$1 + ' WHERE id=?';\n\t      tx.executeSql(sql, [id], function (tx, res) {\n\t        if (res.rows.length) {\n\t          var item = res.rows.item(0);\n\t          var doc = unstringifyDoc(item.json, id, item.rev);\n\t          callback(null, doc);\n\t        } else {\n\t          callback(createError(MISSING_DOC));\n\t        }\n\t      });\n\t    });\n\t  };\n\t\n\t  api._putLocal = function (doc, opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    delete doc._revisions; // ignore this, trust the rev\n\t    var oldRev = doc._rev;\n\t    var id = doc._id;\n\t    var newRev;\n\t    if (!oldRev) {\n\t      newRev = doc._rev = '0-1';\n\t    } else {\n\t      newRev = doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n\t    }\n\t    var json = stringifyDoc(doc);\n\t\n\t    var ret;\n\t    function putLocal(tx) {\n\t      var sql;\n\t      var values;\n\t      if (oldRev) {\n\t        sql = 'UPDATE ' + LOCAL_STORE$1 + ' SET rev=?, json=? ' +\n\t          'WHERE id=? AND rev=?';\n\t        values = [newRev, json, id, oldRev];\n\t      } else {\n\t        sql = 'INSERT INTO ' + LOCAL_STORE$1 + ' (id, rev, json) VALUES (?,?,?)';\n\t        values = [id, newRev, json];\n\t      }\n\t      tx.executeSql(sql, values, function (tx, res) {\n\t        if (res.rowsAffected) {\n\t          ret = {ok: true, id: id, rev: newRev};\n\t          if (opts.ctx) { // return immediately\n\t            callback(null, ret);\n\t          }\n\t        } else {\n\t          callback(createError(REV_CONFLICT));\n\t        }\n\t      }, function () {\n\t        callback(createError(REV_CONFLICT));\n\t        return false; // ack that we handled the error\n\t      });\n\t    }\n\t\n\t    if (opts.ctx) {\n\t      putLocal(opts.ctx);\n\t    } else {\n\t      db.transaction(putLocal, websqlError(callback), function () {\n\t        if (ret) {\n\t          callback(null, ret);\n\t        }\n\t      });\n\t    }\n\t  };\n\t\n\t  api._removeLocal = function (doc, opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    var ret;\n\t\n\t    function removeLocal(tx) {\n\t      var sql = 'DELETE FROM ' + LOCAL_STORE$1 + ' WHERE id=? AND rev=?';\n\t      var params = [doc._id, doc._rev];\n\t      tx.executeSql(sql, params, function (tx, res) {\n\t        if (!res.rowsAffected) {\n\t          return callback(createError(MISSING_DOC));\n\t        }\n\t        ret = {ok: true, id: doc._id, rev: '0-0'};\n\t        if (opts.ctx) { // return immediately\n\t          callback(null, ret);\n\t        }\n\t      });\n\t    }\n\t\n\t    if (opts.ctx) {\n\t      removeLocal(opts.ctx);\n\t    } else {\n\t      db.transaction(removeLocal, websqlError(callback), function () {\n\t        if (ret) {\n\t          callback(null, ret);\n\t        }\n\t      });\n\t    }\n\t  };\n\t\n\t  api._destroy = function (opts, callback) {\n\t    websqlChanges.removeAllListeners(api._name);\n\t    db.transaction(function (tx) {\n\t      var stores = [DOC_STORE$1, BY_SEQ_STORE$1, ATTACH_STORE$1, META_STORE$1,\n\t        LOCAL_STORE$1, ATTACH_AND_SEQ_STORE$1];\n\t      stores.forEach(function (store) {\n\t        tx.executeSql('DROP TABLE IF EXISTS ' + store, []);\n\t      });\n\t    }, websqlError(callback), function () {\n\t      if (hasLocalStorage()) {\n\t        delete window.localStorage['_pouch__websqldb_' + api._name];\n\t        delete window.localStorage[api._name];\n\t      }\n\t      callback(null, {'ok': true});\n\t    });\n\t  };\n\t}\n\t\n\tfunction canOpenTestDB() {\n\t  try {\n\t    openDatabase('_pouch_validate_websql', 1, '', 1);\n\t    return true;\n\t  } catch (err) {\n\t    return false;\n\t  }\n\t}\n\t\n\t// WKWebView had a bug where WebSQL would throw a DOM Exception 18\n\t// (see https://bugs.webkit.org/show_bug.cgi?id=137760 and\n\t// https://github.com/pouchdb/pouchdb/issues/5079)\n\t// This has been fixed in latest WebKit, so we try to detect it here.\n\tfunction isValidWebSQL() {\n\t  // WKWebView UA:\n\t  //   Mozilla/5.0 (iPhone; CPU iPhone OS 9_2 like Mac OS X)\n\t  //   AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13C75\n\t  // Chrome for iOS UA:\n\t  //   Mozilla/5.0 (iPhone; U; CPU iPhone OS 5_1_1 like Mac OS X; en)\n\t  //   AppleWebKit/534.46.0 (KHTML, like Gecko) CriOS/19.0.1084.60\n\t  //   Mobile/9B206 Safari/7534.48.3\n\t  // Firefox for iOS UA:\n\t  //   Mozilla/5.0 (iPhone; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4\n\t  //   (KHTML, like Gecko) FxiOS/1.0 Mobile/12F69 Safari/600.1.4\n\t\n\t  // indexedDB is null on some UIWebViews and undefined in others\n\t  // see: https://bugs.webkit.org/show_bug.cgi?id=137034\n\t  if (typeof indexedDB === 'undefined' || indexedDB === null ||\n\t      !/iP(hone|od|ad)/.test(navigator.userAgent)) {\n\t    // definitely not WKWebView, avoid creating an unnecessary database\n\t    return true;\n\t  }\n\t  // Cache the result in LocalStorage. Reason we do this is because if we\n\t  // call openDatabase() too many times, Safari craps out in SauceLabs and\n\t  // starts throwing DOM Exception 14s.\n\t  var hasLS = hasLocalStorage();\n\t  // Include user agent in the hash, so that if Safari is upgraded, we don't\n\t  // continually think it's broken.\n\t  var localStorageKey = '_pouch__websqldb_valid_' + navigator.userAgent;\n\t  if (hasLS && localStorage[localStorageKey]) {\n\t    return localStorage[localStorageKey] === '1';\n\t  }\n\t  var openedTestDB = canOpenTestDB();\n\t  if (hasLS) {\n\t    localStorage[localStorageKey] = openedTestDB ? '1' : '0';\n\t  }\n\t  return openedTestDB;\n\t}\n\t\n\tfunction valid() {\n\t  if (typeof openDatabase !== 'function') {\n\t    return false;\n\t  }\n\t  return isValidWebSQL();\n\t}\n\t\n\tfunction openDB(name, version, description, size) {\n\t  // Traditional WebSQL API\n\t  return openDatabase(name, version, description, size);\n\t}\n\t\n\tfunction WebSQLPouch(opts, callback) {\n\t  var _opts = $inject_Object_assign({\n\t    websql: openDB\n\t  }, opts);\n\t\n\t  WebSqlPouch$1.call(this, _opts, callback);\n\t}\n\t\n\tWebSQLPouch.valid = valid;\n\t\n\tWebSQLPouch.use_prefix = true;\n\t\n\tvar WebSqlPouch = function (PouchDB) {\n\t  PouchDB.adapter('websql', WebSQLPouch, true);\n\t};\n\t\n\t/* global fetch */\n\t/* global Headers */\n\tfunction wrappedFetch() {\n\t  var wrappedPromise = {};\n\t\n\t  var promise = new PouchPromise$1(function (resolve, reject) {\n\t    wrappedPromise.resolve = resolve;\n\t    wrappedPromise.reject = reject;\n\t  });\n\t\n\t  var args = new Array(arguments.length);\n\t\n\t  for (var i = 0; i < args.length; i++) {\n\t    args[i] = arguments[i];\n\t  }\n\t\n\t  wrappedPromise.promise = promise;\n\t\n\t  PouchPromise$1.resolve().then(function () {\n\t    return fetch.apply(null, args);\n\t  }).then(function (response) {\n\t    wrappedPromise.resolve(response);\n\t  }).catch(function (error) {\n\t    wrappedPromise.reject(error);\n\t  });\n\t\n\t  return wrappedPromise;\n\t}\n\t\n\tfunction fetchRequest(options, callback) {\n\t  var wrappedPromise, timer, response;\n\t\n\t  var headers = new Headers();\n\t\n\t  var fetchOptions = {\n\t    method: options.method,\n\t    credentials: 'include',\n\t    headers: headers\n\t  };\n\t\n\t  if (options.json) {\n\t    headers.set('Accept', 'application/json');\n\t    headers.set('Content-Type', options.headers['Content-Type'] ||\n\t      'application/json');\n\t  }\n\t\n\t  if (options.body &&\n\t      options.processData &&\n\t      typeof options.body !== 'string') {\n\t    fetchOptions.body = JSON.stringify(options.body);\n\t  } else if ('body' in options) {\n\t    fetchOptions.body = options.body;\n\t  } else {\n\t    fetchOptions.body = null;\n\t  }\n\t\n\t  Object.keys(options.headers).forEach(function (key) {\n\t    if (options.headers.hasOwnProperty(key)) {\n\t      headers.set(key, options.headers[key]);\n\t    }\n\t  });\n\t\n\t  wrappedPromise = wrappedFetch(options.url, fetchOptions);\n\t\n\t  if (options.timeout > 0) {\n\t    timer = setTimeout(function () {\n\t      wrappedPromise.reject(new Error('Load timeout for resource: ' +\n\t        options.url));\n\t    }, options.timeout);\n\t  }\n\t\n\t  wrappedPromise.promise.then(function (fetchResponse) {\n\t    response = {\n\t      statusCode: fetchResponse.status\n\t    };\n\t\n\t    if (options.timeout > 0) {\n\t      clearTimeout(timer);\n\t    }\n\t\n\t    if (response.statusCode >= 200 && response.statusCode < 300) {\n\t      return options.binary ? fetchResponse.blob() : fetchResponse.text();\n\t    }\n\t\n\t    return fetchResponse.json();\n\t  }).then(function (result) {\n\t    if (response.statusCode >= 200 && response.statusCode < 300) {\n\t      callback(null, response, result);\n\t    } else {\n\t      result.status = response.statusCode;\n\t      callback(result);\n\t    }\n\t  }).catch(function (error) {\n\t    if (!error) {\n\t      // this happens when the listener is canceled\n\t      error = new Error('canceled');\n\t    }\n\t    callback(error);\n\t  });\n\t\n\t  return {abort: wrappedPromise.reject};\n\t}\n\t\n\tfunction xhRequest(options, callback) {\n\t\n\t  var xhr, timer;\n\t  var timedout = false;\n\t\n\t  var abortReq = function () {\n\t    xhr.abort();\n\t    cleanUp();\n\t  };\n\t\n\t  var timeoutReq = function () {\n\t    timedout = true;\n\t    xhr.abort();\n\t    cleanUp();\n\t  };\n\t\n\t  var ret = {abort: abortReq};\n\t\n\t  var cleanUp = function () {\n\t    clearTimeout(timer);\n\t    ret.abort = function () {};\n\t    if (xhr) {\n\t      xhr.onprogress = undefined;\n\t      if (xhr.upload) {\n\t        xhr.upload.onprogress = undefined;\n\t      }\n\t      xhr.onreadystatechange = undefined;\n\t      xhr = undefined;\n\t    }\n\t  };\n\t\n\t  if (options.xhr) {\n\t    xhr = new options.xhr();\n\t  } else {\n\t    xhr = new XMLHttpRequest();\n\t  }\n\t\n\t  try {\n\t    xhr.open(options.method, options.url);\n\t  } catch (exception) {\n\t    return callback(new Error(exception.name || 'Url is invalid'));\n\t  }\n\t\n\t  xhr.withCredentials = ('withCredentials' in options) ?\n\t    options.withCredentials : true;\n\t\n\t  if (options.method === 'GET') {\n\t    delete options.headers['Content-Type'];\n\t  } else if (options.json) {\n\t    options.headers.Accept = 'application/json';\n\t    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n\t      'application/json';\n\t    if (options.body &&\n\t        options.processData &&\n\t        typeof options.body !== \"string\") {\n\t      options.body = JSON.stringify(options.body);\n\t    }\n\t  }\n\t\n\t  if (options.binary) {\n\t    xhr.responseType = 'arraybuffer';\n\t  }\n\t\n\t  if (!('body' in options)) {\n\t    options.body = null;\n\t  }\n\t\n\t  for (var key in options.headers) {\n\t    if (options.headers.hasOwnProperty(key)) {\n\t      xhr.setRequestHeader(key, options.headers[key]);\n\t    }\n\t  }\n\t\n\t  if (options.timeout > 0) {\n\t    timer = setTimeout(timeoutReq, options.timeout);\n\t    xhr.onprogress = function () {\n\t      clearTimeout(timer);\n\t      if (xhr.readyState !== 4) {\n\t        timer = setTimeout(timeoutReq, options.timeout);\n\t      }\n\t    };\n\t    if (typeof xhr.upload !== 'undefined') { // does not exist in ie9\n\t      xhr.upload.onprogress = xhr.onprogress;\n\t    }\n\t  }\n\t\n\t  xhr.onreadystatechange = function () {\n\t    if (xhr.readyState !== 4) {\n\t      return;\n\t    }\n\t\n\t    var response = {\n\t      statusCode: xhr.status\n\t    };\n\t\n\t    if (xhr.status >= 200 && xhr.status < 300) {\n\t      var data;\n\t      if (options.binary) {\n\t        data = createBlob([xhr.response || ''], {\n\t          type: xhr.getResponseHeader('Content-Type')\n\t        });\n\t      } else {\n\t        data = xhr.responseText;\n\t      }\n\t      callback(null, response, data);\n\t    } else {\n\t      var err = {};\n\t      if (timedout) {\n\t        err = new Error('ETIMEDOUT');\n\t        err.code = 'ETIMEDOUT';\n\t      } else if (typeof xhr.response === 'string') {\n\t        try {\n\t          err = JSON.parse(xhr.response);\n\t        } catch (e) {}\n\t      }\n\t      err.status = xhr.status;\n\t      callback(err);\n\t    }\n\t    cleanUp();\n\t  };\n\t\n\t  if (options.body && (options.body instanceof Blob)) {\n\t    readAsArrayBuffer(options.body, function (arrayBuffer) {\n\t      xhr.send(arrayBuffer);\n\t    });\n\t  } else {\n\t    xhr.send(options.body);\n\t  }\n\t\n\t  return ret;\n\t}\n\t\n\tfunction testXhr() {\n\t  try {\n\t    new XMLHttpRequest();\n\t    return true;\n\t  } catch (err) {\n\t    return false;\n\t  }\n\t}\n\t\n\tvar hasXhr = testXhr();\n\t\n\tfunction ajax$1(options, callback) {\n\t  if (!false && (hasXhr || options.xhr)) {\n\t    return xhRequest(options, callback);\n\t  } else {\n\t    return fetchRequest(options, callback);\n\t  }\n\t}\n\t\n\t// the blob already has a type; do nothing\n\tvar res$2 = function () {};\n\t\n\tfunction defaultBody() {\n\t  return '';\n\t}\n\t\n\tfunction ajaxCore$1(options, callback) {\n\t\n\t  options = clone(options);\n\t\n\t  var defaultOptions = {\n\t    method : \"GET\",\n\t    headers: {},\n\t    json: true,\n\t    processData: true,\n\t    timeout: 10000,\n\t    cache: false\n\t  };\n\t\n\t  options = $inject_Object_assign(defaultOptions, options);\n\t\n\t  function onSuccess(obj, resp, cb) {\n\t    if (!options.binary && options.json && typeof obj === 'string') {\n\t      /* istanbul ignore next */\n\t      try {\n\t        obj = JSON.parse(obj);\n\t      } catch (e) {\n\t        // Probably a malformed JSON from server\n\t        return cb(e);\n\t      }\n\t    }\n\t    if (Array.isArray(obj)) {\n\t      obj = obj.map(function (v) {\n\t        if (v.error || v.missing) {\n\t          return generateErrorFromResponse(v);\n\t        } else {\n\t          return v;\n\t        }\n\t      });\n\t    }\n\t    if (options.binary) {\n\t      res$2(obj, resp);\n\t    }\n\t    cb(null, obj, resp);\n\t  }\n\t\n\t  if (options.json) {\n\t    if (!options.binary) {\n\t      options.headers.Accept = 'application/json';\n\t    }\n\t    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n\t      'application/json';\n\t  }\n\t\n\t  if (options.binary) {\n\t    options.encoding = null;\n\t    options.json = false;\n\t  }\n\t\n\t  if (!options.processData) {\n\t    options.json = false;\n\t  }\n\t\n\t  return ajax$1(options, function (err, response, body) {\n\t\n\t    if (err) {\n\t      return callback(generateErrorFromResponse(err));\n\t    }\n\t\n\t    var error;\n\t    var content_type = response.headers && response.headers['content-type'];\n\t    var data = body || defaultBody();\n\t\n\t    // CouchDB doesn't always return the right content-type for JSON data, so\n\t    // we check for ^{ and }$ (ignoring leading/trailing whitespace)\n\t    if (!options.binary && (options.json || !options.processData) &&\n\t        typeof data !== 'object' &&\n\t        (/json/.test(content_type) ||\n\t         (/^[\\s]*\\{/.test(data) && /\\}[\\s]*$/.test(data)))) {\n\t      try {\n\t        data = JSON.parse(data.toString());\n\t      } catch (e) {}\n\t    }\n\t\n\t    if (response.statusCode >= 200 && response.statusCode < 300) {\n\t      onSuccess(data, response, callback);\n\t    } else {\n\t      error = generateErrorFromResponse(data);\n\t      error.status = response.statusCode;\n\t      callback(error);\n\t    }\n\t  });\n\t}\n\t\n\tfunction ajax(opts, callback) {\n\t\n\t  // cache-buster, specifically designed to work around IE's aggressive caching\n\t  // see http://www.dashbay.com/2011/05/internet-explorer-caches-ajax/\n\t  // Also Safari caches POSTs, so we need to cache-bust those too.\n\t  var ua = (navigator && navigator.userAgent) ?\n\t    navigator.userAgent.toLowerCase() : '';\n\t\n\t  var isSafari = ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1;\n\t  var isIE = ua.indexOf('msie') !== -1;\n\t  var isEdge = ua.indexOf('edge') !== -1;\n\t\n\t  // it appears the new version of safari also caches GETs,\n\t  // see https://github.com/pouchdb/pouchdb/issues/5010\n\t  var shouldCacheBust = (isSafari ||\n\t    ((isIE || isEdge) && opts.method === 'GET'));\n\t\n\t  var cache = 'cache' in opts ? opts.cache : true;\n\t\n\t  var isBlobUrl = /^blob:/.test(opts.url); // don't append nonces for blob URLs\n\t\n\t  if (!isBlobUrl && (shouldCacheBust || !cache)) {\n\t    var hasArgs = opts.url.indexOf('?') !== -1;\n\t    opts.url += (hasArgs ? '&' : '?') + '_nonce=' + Date.now();\n\t  }\n\t\n\t  return ajaxCore$1(opts, callback);\n\t}\n\t\n\t// dead simple promise pool, inspired by https://github.com/timdp/es6-promise-pool\n\t// but much smaller in code size. limits the number of concurrent promises that are executed\n\t\n\t\n\tfunction pool(promiseFactories, limit) {\n\t  return new PouchPromise$1(function (resolve, reject) {\n\t    var running = 0;\n\t    var current = 0;\n\t    var done = 0;\n\t    var len = promiseFactories.length;\n\t    var err;\n\t\n\t    function runNext() {\n\t      running++;\n\t      promiseFactories[current++]().then(onSuccess, onError);\n\t    }\n\t\n\t    function doNext() {\n\t      if (++done === len) {\n\t        /* istanbul ignore if */\n\t        if (err) {\n\t          reject(err);\n\t        } else {\n\t          resolve();\n\t        }\n\t      } else {\n\t        runNextBatch();\n\t      }\n\t    }\n\t\n\t    function onSuccess() {\n\t      running--;\n\t      doNext();\n\t    }\n\t\n\t    /* istanbul ignore next */\n\t    function onError(thisErr) {\n\t      running--;\n\t      err = err || thisErr;\n\t      doNext();\n\t    }\n\t\n\t    function runNextBatch() {\n\t      while (running < limit && current < len) {\n\t        runNext();\n\t      }\n\t    }\n\t\n\t    runNextBatch();\n\t  });\n\t}\n\t\n\tvar CHANGES_BATCH_SIZE = 25;\n\tvar MAX_SIMULTANEOUS_REVS = 50;\n\tvar CHANGES_TIMEOUT_BUFFER = 5000;\n\tvar DEFAULT_HEARTBEAT = 10000;\n\t\n\tvar supportsBulkGetMap = {};\n\t\n\tfunction readAttachmentsAsBlobOrBuffer(row) {\n\t  var atts = row.doc && row.doc._attachments;\n\t  if (!atts) {\n\t    return;\n\t  }\n\t  Object.keys(atts).forEach(function (filename) {\n\t    var att = atts[filename];\n\t    att.data = b64ToBluffer(att.data, att.content_type);\n\t  });\n\t}\n\t\n\tfunction encodeDocId(id) {\n\t  if (/^_design/.test(id)) {\n\t    return '_design/' + encodeURIComponent(id.slice(8));\n\t  }\n\t  if (/^_local/.test(id)) {\n\t    return '_local/' + encodeURIComponent(id.slice(7));\n\t  }\n\t  return encodeURIComponent(id);\n\t}\n\t\n\tfunction preprocessAttachments$2(doc) {\n\t  if (!doc._attachments || !Object.keys(doc._attachments)) {\n\t    return PouchPromise$1.resolve();\n\t  }\n\t\n\t  return PouchPromise$1.all(Object.keys(doc._attachments).map(function (key) {\n\t    var attachment = doc._attachments[key];\n\t    if (attachment.data && typeof attachment.data !== 'string') {\n\t      return new PouchPromise$1(function (resolve) {\n\t        blobToBase64(attachment.data, resolve);\n\t      }).then(function (b64) {\n\t        attachment.data = b64;\n\t      });\n\t    }\n\t  }));\n\t}\n\t\n\tfunction hasUrlPrefix(opts) {\n\t  if (!opts.prefix) {\n\t    return false;\n\t  }\n\t\n\t  var protocol = parseUri(opts.prefix).protocol;\n\t\n\t  return protocol === 'http' || protocol === 'https';\n\t}\n\t\n\t// Get all the information you possibly can about the URI given by name and\n\t// return it as a suitable object.\n\tfunction getHost(name, opts) {\n\t\n\t  // encode db name if opts.prefix is a url (#5574)\n\t  if (hasUrlPrefix(opts)) {\n\t    var dbName = opts.name.substr(opts.prefix.length);\n\t    name = opts.prefix + encodeURIComponent(dbName);\n\t  }\n\t\n\t  // Prase the URI into all its little bits\n\t  var uri = parseUri(name);\n\t\n\t  // Store the user and password as a separate auth object\n\t  if (uri.user || uri.password) {\n\t    uri.auth = {username: uri.user, password: uri.password};\n\t  }\n\t\n\t  // Split the path part of the URI into parts using '/' as the delimiter\n\t  // after removing any leading '/' and any trailing '/'\n\t  var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\t\n\t  // Store the first part as the database name and remove it from the parts\n\t  // array\n\t  uri.db = parts.pop();\n\t  // Prevent double encoding of URI component\n\t  if (uri.db.indexOf('%') === -1) {\n\t    uri.db = encodeURIComponent(uri.db);\n\t  }\n\t\n\t  // Restore the path by joining all the remaining parts (all the parts\n\t  // except for the database name) with '/'s\n\t  uri.path = parts.join('/');\n\t\n\t  return uri;\n\t}\n\t\n\t// Generate a URL with the host data given by opts and the given path\n\tfunction genDBUrl(opts, path) {\n\t  return genUrl(opts, opts.db + '/' + path);\n\t}\n\t\n\t// Generate a URL with the host data given by opts and the given path\n\tfunction genUrl(opts, path) {\n\t  // If the host already has a path, then we need to have a path delimiter\n\t  // Otherwise, the path delimiter is the empty string\n\t  var pathDel = !opts.path ? '' : '/';\n\t\n\t  // If the host already has a path, then we need to have a path delimiter\n\t  // Otherwise, the path delimiter is the empty string\n\t  return opts.protocol + '://' + opts.host +\n\t         (opts.port ? (':' + opts.port) : '') +\n\t         '/' + opts.path + pathDel + path;\n\t}\n\t\n\tfunction paramsToStr(params) {\n\t  return '?' + Object.keys(params).map(function (k) {\n\t    return k + '=' + encodeURIComponent(params[k]);\n\t  }).join('&');\n\t}\n\t\n\t// Implements the PouchDB API for dealing with CouchDB instances over HTTP\n\tfunction HttpPouch(opts, callback) {\n\t\n\t  // The functions that will be publicly available for HttpPouch\n\t  var api = this;\n\t\n\t  var host = getHost(opts.name, opts);\n\t  var dbUrl = genDBUrl(host, '');\n\t\n\t  opts = clone(opts);\n\t  var ajaxOpts = opts.ajax || {};\n\t\n\t  if (opts.auth || host.auth) {\n\t    var nAuth = opts.auth || host.auth;\n\t    var str = nAuth.username + ':' + nAuth.password;\n\t    var token = thisBtoa(unescape(encodeURIComponent(str)));\n\t    ajaxOpts.headers = ajaxOpts.headers || {};\n\t    ajaxOpts.headers.Authorization = 'Basic ' + token;\n\t  }\n\t\n\t  // Not strictly necessary, but we do this because numerous tests\n\t  // rely on swapping ajax in and out.\n\t  api._ajax = ajax;\n\t\n\t  function ajax$$1(userOpts, options, callback) {\n\t    var reqAjax = userOpts.ajax || {};\n\t    var reqOpts = $inject_Object_assign(clone(ajaxOpts), reqAjax, options);\n\t    var defaultHeaders = clone(ajaxOpts.headers || {});\n\t    reqOpts.headers = $inject_Object_assign(defaultHeaders, reqAjax.headers,\n\t      options.headers || {});\n\t    /* istanbul ignore if */\n\t    if (api.constructor.listeners('debug').length) {\n\t      api.constructor.emit('debug', ['http', reqOpts.method, reqOpts.url]);\n\t    }\n\t    return api._ajax(reqOpts, callback);\n\t  }\n\t\n\t  function ajaxPromise(userOpts, opts) {\n\t    return new PouchPromise$1(function (resolve, reject) {\n\t      ajax$$1(userOpts, opts, function (err, res) {\n\t        /* istanbul ignore if */\n\t        if (err) {\n\t          return reject(err);\n\t        }\n\t        resolve(res);\n\t      });\n\t    });\n\t  }\n\t\n\t  function adapterFun$$1(name, fun) {\n\t    return adapterFun(name, getArguments(function (args) {\n\t      setup().then(function () {\n\t        return fun.apply(this, args);\n\t      }).catch(function (e) {\n\t        var callback = args.pop();\n\t        callback(e);\n\t      });\n\t    }));\n\t  }\n\t\n\t  var setupPromise;\n\t\n\t  function setup() {\n\t    // TODO: Remove `skipSetup` in favor of `skip_setup` in a future release\n\t    if (opts.skipSetup || opts.skip_setup) {\n\t      return PouchPromise$1.resolve();\n\t    }\n\t\n\t    // If there is a setup in process or previous successful setup\n\t    // done then we will use that\n\t    // If previous setups have been rejected we will try again\n\t    if (setupPromise) {\n\t      return setupPromise;\n\t    }\n\t\n\t    var checkExists = {method: 'GET', url: dbUrl};\n\t    setupPromise = ajaxPromise({}, checkExists).catch(function (err) {\n\t      if (err && err.status && err.status === 404) {\n\t        // Doesnt exist, create it\n\t        explainError(404, 'PouchDB is just detecting if the remote exists.');\n\t        return ajaxPromise({}, {method: 'PUT', url: dbUrl});\n\t      } else {\n\t        return PouchPromise$1.reject(err);\n\t      }\n\t    }).catch(function (err) {\n\t      // If we try to create a database that already exists, skipped in\n\t      // istanbul since its catching a race condition.\n\t      /* istanbul ignore if */\n\t      if (err && err.status && err.status === 412) {\n\t        return true;\n\t      }\n\t      return PouchPromise$1.reject(err);\n\t    });\n\t\n\t    setupPromise.catch(function () {\n\t      setupPromise = null;\n\t    });\n\t\n\t    return setupPromise;\n\t  }\n\t\n\t  nextTick(function () {\n\t    callback(null, api);\n\t  });\n\t\n\t  api._remote = true;\n\t  /* istanbul ignore next */\n\t  api.type = function () {\n\t    return 'http';\n\t  };\n\t\n\t  api.id = adapterFun$$1('id', function (callback) {\n\t    ajax$$1({}, {method: 'GET', url: genUrl(host, '')}, function (err, result) {\n\t      var uuid$$1 = (result && result.uuid) ?\n\t        (result.uuid + host.db) : genDBUrl(host, '');\n\t      callback(null, uuid$$1);\n\t    });\n\t  });\n\t\n\t  api.request = adapterFun$$1('request', function (options, callback) {\n\t    options.url = genDBUrl(host, options.url);\n\t    ajax$$1({}, options, callback);\n\t  });\n\t\n\t  // Sends a POST request to the host calling the couchdb _compact function\n\t  //    version: The version of CouchDB it is running\n\t  api.compact = adapterFun$$1('compact', function (opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    opts = clone(opts);\n\t    ajax$$1(opts, {\n\t      url: genDBUrl(host, '_compact'),\n\t      method: 'POST'\n\t    }, function () {\n\t      function ping() {\n\t        api.info(function (err, res) {\n\t          // CouchDB may send a \"compact_running:true\" if it's\n\t          // already compacting. PouchDB Server doesn't.\n\t          /* istanbul ignore else */\n\t          if (res && !res.compact_running) {\n\t            callback(null, {ok: true});\n\t          } else {\n\t            setTimeout(ping, opts.interval || 200);\n\t          }\n\t        });\n\t      }\n\t      // Ping the http if it's finished compaction\n\t      ping();\n\t    });\n\t  });\n\t\n\t  api.bulkGet = adapterFun('bulkGet', function (opts, callback) {\n\t    var self = this;\n\t\n\t    function doBulkGet(cb) {\n\t      var params = {};\n\t      if (opts.revs) {\n\t        params.revs = true;\n\t      }\n\t      if (opts.attachments) {\n\t        /* istanbul ignore next */\n\t        params.attachments = true;\n\t      }\n\t      if (opts.latest) {\n\t        params.latest = true;\n\t      }\n\t      ajax$$1(opts, {\n\t        url: genDBUrl(host, '_bulk_get' + paramsToStr(params)),\n\t        method: 'POST',\n\t        body: { docs: opts.docs}\n\t      }, cb);\n\t    }\n\t\n\t    /* istanbul ignore next */\n\t    function doBulkGetShim() {\n\t      // avoid \"url too long error\" by splitting up into multiple requests\n\t      var batchSize = MAX_SIMULTANEOUS_REVS;\n\t      var numBatches = Math.ceil(opts.docs.length / batchSize);\n\t      var numDone = 0;\n\t      var results = new Array(numBatches);\n\t\n\t      function onResult(batchNum) {\n\t        return function (err, res) {\n\t          // err is impossible because shim returns a list of errs in that case\n\t          results[batchNum] = res.results;\n\t          if (++numDone === numBatches) {\n\t            callback(null, {results: flatten(results)});\n\t          }\n\t        };\n\t      }\n\t\n\t      for (var i = 0; i < numBatches; i++) {\n\t        var subOpts = pick(opts, ['revs', 'attachments', 'latest']);\n\t        subOpts.ajax = ajaxOpts;\n\t        subOpts.docs = opts.docs.slice(i * batchSize,\n\t          Math.min(opts.docs.length, (i + 1) * batchSize));\n\t        bulkGet(self, subOpts, onResult(i));\n\t      }\n\t    }\n\t\n\t    // mark the whole database as either supporting or not supporting _bulk_get\n\t    var dbUrl = genUrl(host, '');\n\t    var supportsBulkGet = supportsBulkGetMap[dbUrl];\n\t\n\t    /* istanbul ignore next */\n\t    if (typeof supportsBulkGet !== 'boolean') {\n\t      // check if this database supports _bulk_get\n\t      doBulkGet(function (err, res) {\n\t        if (err) {\n\t          supportsBulkGetMap[dbUrl] = false;\n\t          explainError(\n\t            err.status,\n\t            'PouchDB is just detecting if the remote ' +\n\t            'supports the _bulk_get API.'\n\t          );\n\t          doBulkGetShim();\n\t        } else {\n\t          supportsBulkGetMap[dbUrl] = true;\n\t          callback(null, res);\n\t        }\n\t      });\n\t    } else if (supportsBulkGet) {\n\t      doBulkGet(callback);\n\t    } else {\n\t      doBulkGetShim();\n\t    }\n\t  });\n\t\n\t  // Calls GET on the host, which gets back a JSON string containing\n\t  //    couchdb: A welcome string\n\t  //    version: The version of CouchDB it is running\n\t  api._info = function (callback) {\n\t    setup().then(function () {\n\t      ajax$$1({}, {\n\t        method: 'GET',\n\t        url: genDBUrl(host, '')\n\t      }, function (err, res) {\n\t        /* istanbul ignore next */\n\t        if (err) {\n\t        return callback(err);\n\t        }\n\t        res.host = genDBUrl(host, '');\n\t        callback(null, res);\n\t      });\n\t    }).catch(callback);\n\t  };\n\t\n\t  // Get the document with the given id from the database given by host.\n\t  // The id could be solely the _id in the database, or it may be a\n\t  // _design/ID or _local/ID path\n\t  api.get = adapterFun$$1('get', function (id, opts, callback) {\n\t    // If no options were given, set the callback to the second parameter\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    opts = clone(opts);\n\t\n\t    // List of parameters to add to the GET request\n\t    var params = {};\n\t\n\t    if (opts.revs) {\n\t      params.revs = true;\n\t    }\n\t\n\t    if (opts.revs_info) {\n\t      params.revs_info = true;\n\t    }\n\t\n\t    if (opts.latest) {\n\t      params.latest = true;\n\t    }\n\t\n\t    if (opts.open_revs) {\n\t      if (opts.open_revs !== \"all\") {\n\t        opts.open_revs = JSON.stringify(opts.open_revs);\n\t      }\n\t      params.open_revs = opts.open_revs;\n\t    }\n\t\n\t    if (opts.rev) {\n\t      params.rev = opts.rev;\n\t    }\n\t\n\t    if (opts.conflicts) {\n\t      params.conflicts = opts.conflicts;\n\t    }\n\t\n\t    id = encodeDocId(id);\n\t\n\t    // Set the options for the ajax call\n\t    var options = {\n\t      method: 'GET',\n\t      url: genDBUrl(host, id + paramsToStr(params))\n\t    };\n\t\n\t    function fetchAttachments(doc) {\n\t      var atts = doc._attachments;\n\t      var filenames = atts && Object.keys(atts);\n\t      if (!atts || !filenames.length) {\n\t        return;\n\t      }\n\t      // we fetch these manually in separate XHRs, because\n\t      // Sync Gateway would normally send it back as multipart/mixed,\n\t      // which we cannot parse. Also, this is more efficient than\n\t      // receiving attachments as base64-encoded strings.\n\t      function fetch(filename) {\n\t        var att = atts[filename];\n\t        var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +\n\t          '?rev=' + doc._rev;\n\t        return ajaxPromise(opts, {\n\t          method: 'GET',\n\t          url: genDBUrl(host, path),\n\t          binary: true\n\t        }).then(function (blob) {\n\t          if (opts.binary) {\n\t            return blob;\n\t          }\n\t          return new PouchPromise$1(function (resolve) {\n\t            blobToBase64(blob, resolve);\n\t          });\n\t        }).then(function (data) {\n\t          delete att.stub;\n\t          delete att.length;\n\t          att.data = data;\n\t        });\n\t      }\n\t\n\t      var promiseFactories = filenames.map(function (filename) {\n\t        return function () {\n\t          return fetch(filename);\n\t        };\n\t      });\n\t\n\t      // This limits the number of parallel xhr requests to 5 any time\n\t      // to avoid issues with maximum browser request limits\n\t      return pool(promiseFactories, 5);\n\t    }\n\t\n\t    function fetchAllAttachments(docOrDocs) {\n\t      if (Array.isArray(docOrDocs)) {\n\t        return PouchPromise$1.all(docOrDocs.map(function (doc) {\n\t          if (doc.ok) {\n\t            return fetchAttachments(doc.ok);\n\t          }\n\t        }));\n\t      }\n\t      return fetchAttachments(docOrDocs);\n\t    }\n\t\n\t    ajaxPromise(opts, options).then(function (res) {\n\t      return PouchPromise$1.resolve().then(function () {\n\t        if (opts.attachments) {\n\t          return fetchAllAttachments(res);\n\t        }\n\t      }).then(function () {\n\t        callback(null, res);\n\t      });\n\t    }).catch(function (e) {\n\t      e.docId = id;\n\t      callback(e);\n\t    });\n\t  });\n\t\n\t  // Delete the document given by doc from the database given by host.\n\t  api.remove = adapterFun$$1('remove',\n\t      function (docOrId, optsOrRev, opts, callback) {\n\t    var doc;\n\t    if (typeof optsOrRev === 'string') {\n\t      // id, rev, opts, callback style\n\t      doc = {\n\t        _id: docOrId,\n\t        _rev: optsOrRev\n\t      };\n\t      if (typeof opts === 'function') {\n\t        callback = opts;\n\t        opts = {};\n\t      }\n\t    } else {\n\t      // doc, opts, callback style\n\t      doc = docOrId;\n\t      if (typeof optsOrRev === 'function') {\n\t        callback = optsOrRev;\n\t        opts = {};\n\t      } else {\n\t        callback = opts;\n\t        opts = optsOrRev;\n\t      }\n\t    }\n\t\n\t    var rev$$1 = (doc._rev || opts.rev);\n\t\n\t    // Delete the document\n\t    ajax$$1(opts, {\n\t      method: 'DELETE',\n\t      url: genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev$$1\n\t    }, callback);\n\t  });\n\t\n\t  function encodeAttachmentId(attachmentId) {\n\t    return attachmentId.split(\"/\").map(encodeURIComponent).join(\"/\");\n\t  }\n\t\n\t  // Get the attachment\n\t  api.getAttachment =\n\t    adapterFun$$1('getAttachment', function (docId, attachmentId, opts,\n\t                                                callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    var params = opts.rev ? ('?rev=' + opts.rev) : '';\n\t    var url = genDBUrl(host, encodeDocId(docId)) + '/' +\n\t      encodeAttachmentId(attachmentId) + params;\n\t    ajax$$1(opts, {\n\t      method: 'GET',\n\t      url: url,\n\t      binary: true\n\t    }, callback);\n\t  });\n\t\n\t  // Remove the attachment given by the id and rev\n\t  api.removeAttachment =\n\t    adapterFun$$1('removeAttachment', function (docId, attachmentId, rev$$1,\n\t                                                   callback) {\n\t\n\t    var url = genDBUrl(host, encodeDocId(docId) + '/' +\n\t      encodeAttachmentId(attachmentId)) + '?rev=' + rev$$1;\n\t\n\t    ajax$$1({}, {\n\t      method: 'DELETE',\n\t      url: url\n\t    }, callback);\n\t  });\n\t\n\t  // Add the attachment given by blob and its contentType property\n\t  // to the document with the given id, the revision given by rev, and\n\t  // add it to the database given by host.\n\t  api.putAttachment =\n\t    adapterFun$$1('putAttachment', function (docId, attachmentId, rev$$1, blob,\n\t                                                type, callback) {\n\t    if (typeof type === 'function') {\n\t      callback = type;\n\t      type = blob;\n\t      blob = rev$$1;\n\t      rev$$1 = null;\n\t    }\n\t    var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);\n\t    var url = genDBUrl(host, id);\n\t    if (rev$$1) {\n\t      url += '?rev=' + rev$$1;\n\t    }\n\t\n\t    if (typeof blob === 'string') {\n\t      // input is assumed to be a base64 string\n\t      var binary;\n\t      try {\n\t        binary = thisAtob(blob);\n\t      } catch (err) {\n\t        return callback(createError(BAD_ARG,\n\t                        'Attachment is not a valid base64 string'));\n\t      }\n\t      blob = binary ? binStringToBluffer(binary, type) : '';\n\t    }\n\t\n\t    var opts = {\n\t      headers: {'Content-Type': type},\n\t      method: 'PUT',\n\t      url: url,\n\t      processData: false,\n\t      body: blob,\n\t      timeout: ajaxOpts.timeout || 60000\n\t    };\n\t    // Add the attachment\n\t    ajax$$1({}, opts, callback);\n\t  });\n\t\n\t  // Update/create multiple documents given by req in the database\n\t  // given by host.\n\t  api._bulkDocs = function (req, opts, callback) {\n\t    // If new_edits=false then it prevents the database from creating\n\t    // new revision numbers for the documents. Instead it just uses\n\t    // the old ones. This is used in database replication.\n\t    req.new_edits = opts.new_edits;\n\t\n\t    setup().then(function () {\n\t      return PouchPromise$1.all(req.docs.map(preprocessAttachments$2));\n\t    }).then(function () {\n\t      // Update/create the documents\n\t      ajax$$1(opts, {\n\t        method: 'POST',\n\t        url: genDBUrl(host, '_bulk_docs'),\n\t        timeout: opts.timeout,\n\t        body: req\n\t      }, function (err, results) {\n\t        if (err) {\n\t          return callback(err);\n\t        }\n\t        results.forEach(function (result) {\n\t          result.ok = true; // smooths out cloudant not adding this\n\t        });\n\t        callback(null, results);\n\t      });\n\t    }).catch(callback);\n\t  };\n\t\n\t\n\t  // Update/create document\n\t  api._put = function (doc, opts, callback) {\n\t    setup().then(function () {\n\t      return preprocessAttachments$2(doc);\n\t    }).then(function () {\n\t      // Update/create the document\n\t      ajax$$1(opts, {\n\t        method: 'PUT',\n\t        url: genDBUrl(host, encodeDocId(doc._id)),\n\t        body: doc\n\t      }, function (err, result) {\n\t        if (err) {\n\t          err.docId = doc && doc._id;\n\t          return callback(err);\n\t        }\n\t        callback(null, result);\n\t      });\n\t    }).catch(callback);\n\t  };\n\t\n\t\n\t  // Get a listing of the documents in the database given\n\t  // by host and ordered by increasing id.\n\t  api.allDocs = adapterFun$$1('allDocs', function (opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    opts = clone(opts);\n\t\n\t    // List of parameters to add to the GET request\n\t    var params = {};\n\t    var body;\n\t    var method = 'GET';\n\t\n\t    if (opts.conflicts) {\n\t      params.conflicts = true;\n\t    }\n\t\n\t    if (opts.descending) {\n\t      params.descending = true;\n\t    }\n\t\n\t    if (opts.include_docs) {\n\t      params.include_docs = true;\n\t    }\n\t\n\t    // added in CouchDB 1.6.0\n\t    if (opts.attachments) {\n\t      params.attachments = true;\n\t    }\n\t\n\t    if (opts.key) {\n\t      params.key = JSON.stringify(opts.key);\n\t    }\n\t\n\t    if (opts.start_key) {\n\t      opts.startkey = opts.start_key;\n\t    }\n\t\n\t    if (opts.startkey) {\n\t      params.startkey = JSON.stringify(opts.startkey);\n\t    }\n\t\n\t    if (opts.end_key) {\n\t      opts.endkey = opts.end_key;\n\t    }\n\t\n\t    if (opts.endkey) {\n\t      params.endkey = JSON.stringify(opts.endkey);\n\t    }\n\t\n\t    if (typeof opts.inclusive_end !== 'undefined') {\n\t      params.inclusive_end = !!opts.inclusive_end;\n\t    }\n\t\n\t    if (typeof opts.limit !== 'undefined') {\n\t      params.limit = opts.limit;\n\t    }\n\t\n\t    if (typeof opts.skip !== 'undefined') {\n\t      params.skip = opts.skip;\n\t    }\n\t\n\t    var paramStr = paramsToStr(params);\n\t\n\t    if (typeof opts.keys !== 'undefined') {\n\t      method = 'POST';\n\t      body = {keys: opts.keys};\n\t    }\n\t\n\t    // Get the document listing\n\t    ajaxPromise(opts, {\n\t      method: method,\n\t      url: genDBUrl(host, '_all_docs' + paramStr),\n\t      body: body\n\t    }).then(function (res) {\n\t      if (opts.include_docs && opts.attachments && opts.binary) {\n\t        res.rows.forEach(readAttachmentsAsBlobOrBuffer);\n\t      }\n\t      callback(null, res);\n\t    }).catch(callback);\n\t  });\n\t\n\t  // Get a list of changes made to documents in the database given by host.\n\t  // TODO According to the README, there should be two other methods here,\n\t  // api.changes.addListener and api.changes.removeListener.\n\t  api._changes = function (opts) {\n\t\n\t    // We internally page the results of a changes request, this means\n\t    // if there is a large set of changes to be returned we can start\n\t    // processing them quicker instead of waiting on the entire\n\t    // set of changes to return and attempting to process them at once\n\t    var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;\n\t\n\t    opts = clone(opts);\n\t\n\t    if (opts.continuous && !('heartbeat' in opts)) {\n\t      opts.heartbeat = DEFAULT_HEARTBEAT;\n\t    }\n\t\n\t    var requestTimeout = ('timeout' in opts) ? opts.timeout :\n\t      ('timeout' in ajaxOpts) ? ajaxOpts.timeout :\n\t      30 * 1000;\n\t\n\t    // ensure CHANGES_TIMEOUT_BUFFER applies\n\t    if ('timeout' in opts && opts.timeout &&\n\t      (requestTimeout - opts.timeout) < CHANGES_TIMEOUT_BUFFER) {\n\t        requestTimeout = opts.timeout + CHANGES_TIMEOUT_BUFFER;\n\t    }\n\t\n\t    if ('heartbeat' in opts && opts.heartbeat &&\n\t       (requestTimeout - opts.heartbeat) < CHANGES_TIMEOUT_BUFFER) {\n\t        requestTimeout = opts.heartbeat + CHANGES_TIMEOUT_BUFFER;\n\t    }\n\t\n\t    var params = {};\n\t    if ('timeout' in opts && opts.timeout) {\n\t      params.timeout = opts.timeout;\n\t    }\n\t\n\t    var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;\n\t    var returnDocs;\n\t    if ('return_docs' in opts) {\n\t      returnDocs = opts.return_docs;\n\t    } else if ('returnDocs' in opts) {\n\t      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n\t      returnDocs = opts.returnDocs;\n\t    } else {\n\t      returnDocs = true;\n\t    }\n\t    //\n\t    var leftToFetch = limit;\n\t\n\t    if (opts.style) {\n\t      params.style = opts.style;\n\t    }\n\t\n\t    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n\t      params.include_docs = true;\n\t    }\n\t\n\t    if (opts.attachments) {\n\t      params.attachments = true;\n\t    }\n\t\n\t    if (opts.continuous) {\n\t      params.feed = 'longpoll';\n\t    }\n\t\n\t    if (opts.conflicts) {\n\t      params.conflicts = true;\n\t    }\n\t\n\t    if (opts.descending) {\n\t      params.descending = true;\n\t    }\n\t\n\t    if ('heartbeat' in opts) {\n\t      // If the heartbeat value is false, it disables the default heartbeat\n\t      if (opts.heartbeat) {\n\t        params.heartbeat = opts.heartbeat;\n\t      }\n\t    }\n\t\n\t    if (opts.filter && typeof opts.filter === 'string') {\n\t      params.filter = opts.filter;\n\t    }\n\t\n\t    if (opts.view && typeof opts.view === 'string') {\n\t      params.filter = '_view';\n\t      params.view = opts.view;\n\t    }\n\t\n\t    // If opts.query_params exists, pass it through to the changes request.\n\t    // These parameters may be used by the filter on the source database.\n\t    if (opts.query_params && typeof opts.query_params === 'object') {\n\t      for (var param_name in opts.query_params) {\n\t        /* istanbul ignore else */\n\t        if (opts.query_params.hasOwnProperty(param_name)) {\n\t          params[param_name] = opts.query_params[param_name];\n\t        }\n\t      }\n\t    }\n\t\n\t    var method = 'GET';\n\t    var body;\n\t\n\t    if (opts.doc_ids) {\n\t      // set this automagically for the user; it's annoying that couchdb\n\t      // requires both a \"filter\" and a \"doc_ids\" param.\n\t      params.filter = '_doc_ids';\n\t      method = 'POST';\n\t      body = {doc_ids: opts.doc_ids };\n\t    }\n\t    /* istanbul ignore next */\n\t    else if (opts.selector) {\n\t      // set this automagically for the user, similar to above\n\t      params.filter = '_selector';\n\t      method = 'POST';\n\t      body = {selector: opts.selector };\n\t    }\n\t\n\t    var xhr;\n\t    var lastFetchedSeq;\n\t\n\t    // Get all the changes starting wtih the one immediately after the\n\t    // sequence number given by since.\n\t    var fetch = function (since, callback) {\n\t      if (opts.aborted) {\n\t        return;\n\t      }\n\t      params.since = since;\n\t      // \"since\" can be any kind of json object in Coudant/CouchDB 2.x\n\t      /* istanbul ignore next */\n\t      if (typeof params.since === \"object\") {\n\t        params.since = JSON.stringify(params.since);\n\t      }\n\t\n\t      if (opts.descending) {\n\t        if (limit) {\n\t          params.limit = leftToFetch;\n\t        }\n\t      } else {\n\t        params.limit = (!limit || leftToFetch > batchSize) ?\n\t          batchSize : leftToFetch;\n\t      }\n\t\n\t      // Set the options for the ajax call\n\t      var xhrOpts = {\n\t        method: method,\n\t        url: genDBUrl(host, '_changes' + paramsToStr(params)),\n\t        timeout: requestTimeout,\n\t        body: body\n\t      };\n\t      lastFetchedSeq = since;\n\t\n\t      /* istanbul ignore if */\n\t      if (opts.aborted) {\n\t        return;\n\t      }\n\t\n\t      // Get the changes\n\t      setup().then(function () {\n\t        xhr = ajax$$1(opts, xhrOpts, callback);\n\t      }).catch(callback);\n\t    };\n\t\n\t    // If opts.since exists, get all the changes from the sequence\n\t    // number given by opts.since. Otherwise, get all the changes\n\t    // from the sequence number 0.\n\t    var results = {results: []};\n\t\n\t    var fetched = function (err, res) {\n\t      if (opts.aborted) {\n\t        return;\n\t      }\n\t      var raw_results_length = 0;\n\t      // If the result of the ajax call (res) contains changes (res.results)\n\t      if (res && res.results) {\n\t        raw_results_length = res.results.length;\n\t        results.last_seq = res.last_seq;\n\t        // For each change\n\t        var req = {};\n\t        req.query = opts.query_params;\n\t        res.results = res.results.filter(function (c) {\n\t          leftToFetch--;\n\t          var ret = filterChange(opts)(c);\n\t          if (ret) {\n\t            if (opts.include_docs && opts.attachments && opts.binary) {\n\t              readAttachmentsAsBlobOrBuffer(c);\n\t            }\n\t            if (returnDocs) {\n\t              results.results.push(c);\n\t            }\n\t            opts.onChange(c);\n\t          }\n\t          return ret;\n\t        });\n\t      } else if (err) {\n\t        // In case of an error, stop listening for changes and call\n\t        // opts.complete\n\t        opts.aborted = true;\n\t        opts.complete(err);\n\t        return;\n\t      }\n\t\n\t      // The changes feed may have timed out with no results\n\t      // if so reuse last update sequence\n\t      if (res && res.last_seq) {\n\t        lastFetchedSeq = res.last_seq;\n\t      }\n\t\n\t      var finished = (limit && leftToFetch <= 0) ||\n\t        (res && raw_results_length < batchSize) ||\n\t        (opts.descending);\n\t\n\t      if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {\n\t        // Queue a call to fetch again with the newest sequence number\n\t        nextTick(function () { fetch(lastFetchedSeq, fetched); });\n\t      } else {\n\t        // We're done, call the callback\n\t        opts.complete(null, results);\n\t      }\n\t    };\n\t\n\t    fetch(opts.since || 0, fetched);\n\t\n\t    // Return a method to cancel this method from processing any more\n\t    return {\n\t      cancel: function () {\n\t        opts.aborted = true;\n\t        if (xhr) {\n\t          xhr.abort();\n\t        }\n\t      }\n\t    };\n\t  };\n\t\n\t  // Given a set of document/revision IDs (given by req), tets the subset of\n\t  // those that do NOT correspond to revisions stored in the database.\n\t  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n\t  api.revsDiff = adapterFun$$1('revsDiff', function (req, opts, callback) {\n\t    // If no options were given, set the callback to be the second parameter\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t\n\t    // Get the missing document/revision IDs\n\t    ajax$$1(opts, {\n\t      method: 'POST',\n\t      url: genDBUrl(host, '_revs_diff'),\n\t      body: req\n\t    }, callback);\n\t  });\n\t\n\t  api._close = function (callback) {\n\t    callback();\n\t  };\n\t\n\t  api._destroy = function (options, callback) {\n\t    ajax$$1(options, {\n\t      url: genDBUrl(host, ''),\n\t      method: 'DELETE'\n\t    }, function (err, resp) {\n\t      if (err && err.status && err.status !== 404) {\n\t        return callback(err);\n\t      }\n\t      callback(null, resp);\n\t    });\n\t  };\n\t}\n\t\n\t// HttpPouch is a valid adapter.\n\tHttpPouch.valid = function () {\n\t  return true;\n\t};\n\t\n\tvar HttpPouch$1 = function (PouchDB) {\n\t  PouchDB.adapter('http', HttpPouch, false);\n\t  PouchDB.adapter('https', HttpPouch, false);\n\t};\n\t\n\tfunction QueryParseError(message) {\n\t  this.status = 400;\n\t  this.name = 'query_parse_error';\n\t  this.message = message;\n\t  this.error = true;\n\t  try {\n\t    Error.captureStackTrace(this, QueryParseError);\n\t  } catch (e) {}\n\t}\n\t\n\tinherits(QueryParseError, Error);\n\t\n\tfunction NotFoundError(message) {\n\t  this.status = 404;\n\t  this.name = 'not_found';\n\t  this.message = message;\n\t  this.error = true;\n\t  try {\n\t    Error.captureStackTrace(this, NotFoundError);\n\t  } catch (e) {}\n\t}\n\t\n\tinherits(NotFoundError, Error);\n\t\n\tfunction BuiltInError(message) {\n\t  this.status = 500;\n\t  this.name = 'invalid_value';\n\t  this.message = message;\n\t  this.error = true;\n\t  try {\n\t    Error.captureStackTrace(this, BuiltInError);\n\t  } catch (e) {}\n\t}\n\t\n\tinherits(BuiltInError, Error);\n\t\n\tfunction promisedCallback(promise, callback) {\n\t  if (callback) {\n\t    promise.then(function (res) {\n\t      nextTick(function () {\n\t        callback(null, res);\n\t      });\n\t    }, function (reason) {\n\t      nextTick(function () {\n\t        callback(reason);\n\t      });\n\t    });\n\t  }\n\t  return promise;\n\t}\n\t\n\tfunction callbackify(fun) {\n\t  return getArguments(function (args) {\n\t    var cb = args.pop();\n\t    var promise = fun.apply(this, args);\n\t    if (typeof cb === 'function') {\n\t      promisedCallback(promise, cb);\n\t    }\n\t    return promise;\n\t  });\n\t}\n\t\n\t// Promise finally util similar to Q.finally\n\tfunction fin(promise, finalPromiseFactory) {\n\t  return promise.then(function (res) {\n\t    return finalPromiseFactory().then(function () {\n\t      return res;\n\t    });\n\t  }, function (reason) {\n\t    return finalPromiseFactory().then(function () {\n\t      throw reason;\n\t    });\n\t  });\n\t}\n\t\n\tfunction sequentialize(queue, promiseFactory) {\n\t  return function () {\n\t    var args = arguments;\n\t    var that = this;\n\t    return queue.add(function () {\n\t      return promiseFactory.apply(that, args);\n\t    });\n\t  };\n\t}\n\t\n\t// uniq an array of strings, order not guaranteed\n\t// similar to underscore/lodash _.uniq\n\tfunction uniq(arr) {\n\t  var theSet = new ExportedSet(arr);\n\t  var result = new Array(theSet.size);\n\t  var index = -1;\n\t  theSet.forEach(function (value) {\n\t    result[++index] = value;\n\t  });\n\t  return result;\n\t}\n\t\n\tfunction mapToKeysArray(map) {\n\t  var result = new Array(map.size);\n\t  var index = -1;\n\t  map.forEach(function (value, key) {\n\t    result[++index] = key;\n\t  });\n\t  return result;\n\t}\n\t\n\tfunction createBuiltInError(name) {\n\t  var message = 'builtin ' + name +\n\t    ' function requires map values to be numbers' +\n\t    ' or number arrays';\n\t  return new BuiltInError(message);\n\t}\n\t\n\tfunction sum(values) {\n\t  var result = 0;\n\t  for (var i = 0, len = values.length; i < len; i++) {\n\t    var num = values[i];\n\t    if (typeof num !== 'number') {\n\t      if (Array.isArray(num)) {\n\t        // lists of numbers are also allowed, sum them separately\n\t        result = typeof result === 'number' ? [result] : result;\n\t        for (var j = 0, jLen = num.length; j < jLen; j++) {\n\t          var jNum = num[j];\n\t          if (typeof jNum !== 'number') {\n\t            throw createBuiltInError('_sum');\n\t          } else if (typeof result[j] === 'undefined') {\n\t            result.push(jNum);\n\t          } else {\n\t            result[j] += jNum;\n\t          }\n\t        }\n\t      } else { // not array/number\n\t        throw createBuiltInError('_sum');\n\t      }\n\t    } else if (typeof result === 'number') {\n\t      result += num;\n\t    } else { // add number to array\n\t      result[0] += num;\n\t    }\n\t  }\n\t  return result;\n\t}\n\t\n\tvar log = guardedConsole.bind(null, 'log');\n\tvar isArray = Array.isArray;\n\tvar toJSON = JSON.parse;\n\t\n\tfunction evalFunctionWithEval(func, emit) {\n\t  return scopeEval(\n\t    \"return (\" + func.replace(/;\\s*$/, \"\") + \");\",\n\t    {\n\t      emit: emit,\n\t      sum: sum,\n\t      log: log,\n\t      isArray: isArray,\n\t      toJSON: toJSON\n\t    }\n\t  );\n\t}\n\t\n\t/*\n\t * Simple task queue to sequentialize actions. Assumes\n\t * callbacks will eventually fire (once).\n\t */\n\t\n\t\n\tfunction TaskQueue$2() {\n\t  this.promise = new PouchPromise$1(function (fulfill) {fulfill(); });\n\t}\n\tTaskQueue$2.prototype.add = function (promiseFactory) {\n\t  this.promise = this.promise.catch(function () {\n\t    // just recover\n\t  }).then(function () {\n\t    return promiseFactory();\n\t  });\n\t  return this.promise;\n\t};\n\tTaskQueue$2.prototype.finish = function () {\n\t  return this.promise;\n\t};\n\t\n\tfunction stringify(input) {\n\t  if (!input) {\n\t    return 'undefined'; // backwards compat for empty reduce\n\t  }\n\t  // for backwards compat with mapreduce, functions/strings are stringified\n\t  // as-is. everything else is JSON-stringified.\n\t  switch (typeof input) {\n\t    case 'function':\n\t      // e.g. a mapreduce map\n\t      return input.toString();\n\t    case 'string':\n\t      // e.g. a mapreduce built-in _reduce function\n\t      return input.toString();\n\t    default:\n\t      // e.g. a JSON object in the case of mango queries\n\t      return JSON.stringify(input);\n\t  }\n\t}\n\t\n\t/* create a string signature for a view so we can cache it and uniq it */\n\tfunction createViewSignature(mapFun, reduceFun) {\n\t  // the \"undefined\" part is for backwards compatibility\n\t  return stringify(mapFun) + stringify(reduceFun) + 'undefined';\n\t}\n\t\n\tfunction createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {\n\t  var viewSignature = createViewSignature(mapFun, reduceFun);\n\t\n\t  var cachedViews;\n\t  if (!temporary) {\n\t    // cache this to ensure we don't try to update the same view twice\n\t    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n\t    if (cachedViews[viewSignature]) {\n\t      return cachedViews[viewSignature];\n\t    }\n\t  }\n\t\n\t  var promiseForView = sourceDB.info().then(function (info) {\n\t\n\t    var depDbName = info.db_name + '-mrview-' +\n\t      (temporary ? 'temp' : stringMd5(viewSignature));\n\t\n\t    // save the view name in the source db so it can be cleaned up if necessary\n\t    // (e.g. when the _design doc is deleted, remove all associated view data)\n\t    function diffFunction(doc) {\n\t      doc.views = doc.views || {};\n\t      var fullViewName = viewName;\n\t      if (fullViewName.indexOf('/') === -1) {\n\t        fullViewName = viewName + '/' + viewName;\n\t      }\n\t      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n\t      /* istanbul ignore if */\n\t      if (depDbs[depDbName]) {\n\t        return; // no update necessary\n\t      }\n\t      depDbs[depDbName] = true;\n\t      return doc;\n\t    }\n\t    return upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {\n\t      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n\t        var db = res.db;\n\t        db.auto_compaction = true;\n\t        var view = {\n\t          name: depDbName,\n\t          db: db,\n\t          sourceDB: sourceDB,\n\t          adapter: sourceDB.adapter,\n\t          mapFun: mapFun,\n\t          reduceFun: reduceFun\n\t        };\n\t        return view.db.get('_local/lastSeq').catch(function (err) {\n\t          /* istanbul ignore if */\n\t          if (err.status !== 404) {\n\t            throw err;\n\t          }\n\t        }).then(function (lastSeqDoc) {\n\t          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n\t          if (cachedViews) {\n\t            view.db.once('destroyed', function () {\n\t              delete cachedViews[viewSignature];\n\t            });\n\t          }\n\t          return view;\n\t        });\n\t      });\n\t    });\n\t  });\n\t\n\t  if (cachedViews) {\n\t    cachedViews[viewSignature] = promiseForView;\n\t  }\n\t  return promiseForView;\n\t}\n\t\n\tvar persistentQueues = {};\n\tvar tempViewQueue = new TaskQueue$2();\n\tvar CHANGES_BATCH_SIZE$1 = 50;\n\t\n\tfunction parseViewName(name) {\n\t  // can be either 'ddocname/viewname' or just 'viewname'\n\t  // (where the ddoc name is the same)\n\t  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n\t}\n\t\n\tfunction isGenOne(changes) {\n\t  // only return true if the current change is 1-\n\t  // and there are no other leafs\n\t  return changes.length === 1 && /^1-/.test(changes[0].rev);\n\t}\n\t\n\tfunction emitError(db, e) {\n\t  try {\n\t    db.emit('error', e);\n\t  } catch (err) {\n\t    guardedConsole('error',\n\t      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n\t      'You can debug this error by doing:\\n' +\n\t      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n\t      'Please double-check your map/reduce function.');\n\t    guardedConsole('error', e);\n\t  }\n\t}\n\t\n\t/**\n\t * Returns an \"abstract\" mapreduce object of the form:\n\t *\n\t *   {\n\t *     query: queryFun,\n\t *     viewCleanup: viewCleanupFun\n\t *   }\n\t *\n\t * Arguments are:\n\t *\n\t * localDoc: string\n\t *   This is for the local doc that gets saved in order to track the\n\t *   \"dependent\" DBs and clean them up for viewCleanup. It should be\n\t *   unique, so that indexer plugins don't collide with each other.\n\t * mapper: function (mapFunDef, emit)\n\t *   Returns a map function based on the mapFunDef, which in the case of\n\t *   normal map/reduce is just the de-stringified function, but may be\n\t *   something else, such as an object in the case of pouchdb-find.\n\t * reducer: function (reduceFunDef)\n\t *   Ditto, but for reducing. Modules don't have to support reducing\n\t *   (e.g. pouchdb-find).\n\t * ddocValidator: function (ddoc, viewName)\n\t *   Throws an error if the ddoc or viewName is not valid.\n\t *   This could be a way to communicate to the user that the configuration for the\n\t *   indexer is invalid.\n\t */\n\tfunction createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {\n\t\n\t  function tryMap(db, fun, doc) {\n\t    // emit an event if there was an error thrown by a map function.\n\t    // putting try/catches in a single function also avoids deoptimizations.\n\t    try {\n\t      fun(doc);\n\t    } catch (e) {\n\t      emitError(db, e);\n\t    }\n\t  }\n\t\n\t  function tryReduce(db, fun, keys, values, rereduce) {\n\t    // same as above, but returning the result or an error. there are two separate\n\t    // functions to avoid extra memory allocations since the tryCode() case is used\n\t    // for custom map functions (common) vs this function, which is only used for\n\t    // custom reduce functions (rare)\n\t    try {\n\t      return {output : fun(keys, values, rereduce)};\n\t    } catch (e) {\n\t      emitError(db, e);\n\t      return {error: e};\n\t    }\n\t  }\n\t\n\t  function sortByKeyThenValue(x, y) {\n\t    var keyCompare = collate(x.key, y.key);\n\t    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n\t  }\n\t\n\t  function sliceResults(results, limit, skip) {\n\t    skip = skip || 0;\n\t    if (typeof limit === 'number') {\n\t      return results.slice(skip, limit + skip);\n\t    } else if (skip > 0) {\n\t      return results.slice(skip);\n\t    }\n\t    return results;\n\t  }\n\t\n\t  function rowToDocId(row) {\n\t    var val = row.value;\n\t    // Users can explicitly specify a joined doc _id, or it\n\t    // defaults to the doc _id that emitted the key/value.\n\t    var docId = (val && typeof val === 'object' && val._id) || row.id;\n\t    return docId;\n\t  }\n\t\n\t  function readAttachmentsAsBlobOrBuffer(res) {\n\t    res.rows.forEach(function (row) {\n\t      var atts = row.doc && row.doc._attachments;\n\t      if (!atts) {\n\t        return;\n\t      }\n\t      Object.keys(atts).forEach(function (filename) {\n\t        var att = atts[filename];\n\t        atts[filename].data = b64ToBluffer(att.data, att.content_type);\n\t      });\n\t    });\n\t  }\n\t\n\t  function postprocessAttachments(opts) {\n\t    return function (res) {\n\t      if (opts.include_docs && opts.attachments && opts.binary) {\n\t        readAttachmentsAsBlobOrBuffer(res);\n\t      }\n\t      return res;\n\t    };\n\t  }\n\t\n\t  function addHttpParam(paramName, opts, params, asJson) {\n\t    // add an http param from opts to params, optionally json-encoded\n\t    var val = opts[paramName];\n\t    if (typeof val !== 'undefined') {\n\t      if (asJson) {\n\t        val = encodeURIComponent(JSON.stringify(val));\n\t      }\n\t      params.push(paramName + '=' + val);\n\t    }\n\t  }\n\t\n\t  function coerceInteger(integerCandidate) {\n\t    if (typeof integerCandidate !== 'undefined') {\n\t      var asNumber = Number(integerCandidate);\n\t      // prevents e.g. '1foo' or '1.1' being coerced to 1\n\t      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n\t        return asNumber;\n\t      } else {\n\t        return integerCandidate;\n\t      }\n\t    }\n\t  }\n\t\n\t  function coerceOptions(opts) {\n\t    opts.group_level = coerceInteger(opts.group_level);\n\t    opts.limit = coerceInteger(opts.limit);\n\t    opts.skip = coerceInteger(opts.skip);\n\t    return opts;\n\t  }\n\t\n\t  function checkPositiveInteger(number) {\n\t    if (number) {\n\t      if (typeof number !== 'number') {\n\t        return  new QueryParseError('Invalid value for integer: \"' +\n\t          number + '\"');\n\t      }\n\t      if (number < 0) {\n\t        return new QueryParseError('Invalid value for positive integer: ' +\n\t          '\"' + number + '\"');\n\t      }\n\t    }\n\t  }\n\t\n\t  function checkQueryParseError(options, fun) {\n\t    var startkeyName = options.descending ? 'endkey' : 'startkey';\n\t    var endkeyName = options.descending ? 'startkey' : 'endkey';\n\t\n\t    if (typeof options[startkeyName] !== 'undefined' &&\n\t      typeof options[endkeyName] !== 'undefined' &&\n\t      collate(options[startkeyName], options[endkeyName]) > 0) {\n\t      throw new QueryParseError('No rows can match your key range, ' +\n\t        'reverse your start_key and end_key or set {descending : true}');\n\t    } else if (fun.reduce && options.reduce !== false) {\n\t      if (options.include_docs) {\n\t        throw new QueryParseError('{include_docs:true} is invalid for reduce');\n\t      } else if (options.keys && options.keys.length > 1 &&\n\t        !options.group && !options.group_level) {\n\t        throw new QueryParseError('Multi-key fetches for reduce views must use ' +\n\t          '{group: true}');\n\t      }\n\t    }\n\t    ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n\t      var error = checkPositiveInteger(options[optionName]);\n\t      if (error) {\n\t        throw error;\n\t      }\n\t    });\n\t  }\n\t\n\t  function httpQuery(db, fun, opts) {\n\t    // List of parameters to add to the PUT request\n\t    var params = [];\n\t    var body;\n\t    var method = 'GET';\n\t\n\t    // If opts.reduce exists and is defined, then add it to the list\n\t    // of parameters.\n\t    // If reduce=false then the results are that of only the map function\n\t    // not the final result of map and reduce.\n\t    addHttpParam('reduce', opts, params);\n\t    addHttpParam('include_docs', opts, params);\n\t    addHttpParam('attachments', opts, params);\n\t    addHttpParam('limit', opts, params);\n\t    addHttpParam('descending', opts, params);\n\t    addHttpParam('group', opts, params);\n\t    addHttpParam('group_level', opts, params);\n\t    addHttpParam('skip', opts, params);\n\t    addHttpParam('stale', opts, params);\n\t    addHttpParam('conflicts', opts, params);\n\t    addHttpParam('startkey', opts, params, true);\n\t    addHttpParam('start_key', opts, params, true);\n\t    addHttpParam('endkey', opts, params, true);\n\t    addHttpParam('end_key', opts, params, true);\n\t    addHttpParam('inclusive_end', opts, params);\n\t    addHttpParam('key', opts, params, true);\n\t\n\t    // Format the list of parameters into a valid URI query string\n\t    params = params.join('&');\n\t    params = params === '' ? '' : '?' + params;\n\t\n\t    // If keys are supplied, issue a POST to circumvent GET query string limits\n\t    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n\t    if (typeof opts.keys !== 'undefined') {\n\t      var MAX_URL_LENGTH = 2000;\n\t      // according to http://stackoverflow.com/a/417184/680742,\n\t      // the de facto URL length limit is 2000 characters\n\t\n\t      var keysAsString =\n\t        'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n\t      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n\t        // If the keys are short enough, do a GET. we do this to work around\n\t        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n\t        params += (params[0] === '?' ? '&' : '?') + keysAsString;\n\t      } else {\n\t        method = 'POST';\n\t        if (typeof fun === 'string') {\n\t          body = {keys: opts.keys};\n\t        } else { // fun is {map : mapfun}, so append to this\n\t          fun.keys = opts.keys;\n\t        }\n\t      }\n\t    }\n\t\n\t    // We are referencing a query defined in the design doc\n\t    if (typeof fun === 'string') {\n\t      var parts = parseViewName(fun);\n\t      return db.request({\n\t        method: method,\n\t        url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\n\t        body: body\n\t      }).then(\n\t        /* istanbul ignore next */\n\t        function (result) {\n\t          // fail the entire request if the result contains an error\n\t          result.rows.forEach(function (row) {\n\t            if (row.value && row.value.error && row.value.error === \"builtin_reduce_error\") {\n\t              throw new Error(row.reason);\n\t            }\n\t          });\n\t\n\t          return result;\n\t      })\n\t      .then(postprocessAttachments(opts));\n\t    }\n\t\n\t    // We are using a temporary view, terrible for performance, good for testing\n\t    body = body || {};\n\t    Object.keys(fun).forEach(function (key) {\n\t      if (Array.isArray(fun[key])) {\n\t        body[key] = fun[key];\n\t      } else {\n\t        body[key] = fun[key].toString();\n\t      }\n\t    });\n\t    return db.request({\n\t      method: 'POST',\n\t      url: '_temp_view' + params,\n\t      body: body\n\t    }).then(postprocessAttachments(opts));\n\t  }\n\t\n\t  // custom adapters can define their own api._query\n\t  // and override the default behavior\n\t  /* istanbul ignore next */\n\t  function customQuery(db, fun, opts) {\n\t    return new PouchPromise$1(function (resolve, reject) {\n\t      db._query(fun, opts, function (err, res) {\n\t        if (err) {\n\t          return reject(err);\n\t        }\n\t        resolve(res);\n\t      });\n\t    });\n\t  }\n\t\n\t  // custom adapters can define their own api._viewCleanup\n\t  // and override the default behavior\n\t  /* istanbul ignore next */\n\t  function customViewCleanup(db) {\n\t    return new PouchPromise$1(function (resolve, reject) {\n\t      db._viewCleanup(function (err, res) {\n\t        if (err) {\n\t          return reject(err);\n\t        }\n\t        resolve(res);\n\t      });\n\t    });\n\t  }\n\t\n\t  function defaultsTo(value) {\n\t    return function (reason) {\n\t      /* istanbul ignore else */\n\t      if (reason.status === 404) {\n\t        return value;\n\t      } else {\n\t        throw reason;\n\t      }\n\t    };\n\t  }\n\t\n\t  // returns a promise for a list of docs to update, based on the input docId.\n\t  // the order doesn't matter, because post-3.2.0, bulkDocs\n\t  // is an atomic operation in all three adapters.\n\t  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n\t    var metaDocId = '_local/doc_' + docId;\n\t    var defaultMetaDoc = {_id: metaDocId, keys: []};\n\t    var docData = docIdsToChangesAndEmits.get(docId);\n\t    var indexableKeysToKeyValues = docData[0];\n\t    var changes = docData[1];\n\t\n\t    function getMetaDoc() {\n\t      if (isGenOne(changes)) {\n\t        // generation 1, so we can safely assume initial state\n\t        // for performance reasons (avoids unnecessary GETs)\n\t        return PouchPromise$1.resolve(defaultMetaDoc);\n\t      }\n\t      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n\t    }\n\t\n\t    function getKeyValueDocs(metaDoc) {\n\t      if (!metaDoc.keys.length) {\n\t        // no keys, no need for a lookup\n\t        return PouchPromise$1.resolve({rows: []});\n\t      }\n\t      return view.db.allDocs({\n\t        keys: metaDoc.keys,\n\t        include_docs: true\n\t      });\n\t    }\n\t\n\t    function processKeyValueDocs(metaDoc, kvDocsRes) {\n\t      var kvDocs = [];\n\t      var oldKeys = new ExportedSet();\n\t\n\t      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n\t        var row = kvDocsRes.rows[i];\n\t        var doc = row.doc;\n\t        if (!doc) { // deleted\n\t          continue;\n\t        }\n\t        kvDocs.push(doc);\n\t        oldKeys.add(doc._id);\n\t        doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n\t        if (!doc._deleted) {\n\t          var keyValue = indexableKeysToKeyValues.get(doc._id);\n\t          if ('value' in keyValue) {\n\t            doc.value = keyValue.value;\n\t          }\n\t        }\n\t      }\n\t      var newKeys = mapToKeysArray(indexableKeysToKeyValues);\n\t      newKeys.forEach(function (key) {\n\t        if (!oldKeys.has(key)) {\n\t          // new doc\n\t          var kvDoc = {\n\t            _id: key\n\t          };\n\t          var keyValue = indexableKeysToKeyValues.get(key);\n\t          if ('value' in keyValue) {\n\t            kvDoc.value = keyValue.value;\n\t          }\n\t          kvDocs.push(kvDoc);\n\t        }\n\t      });\n\t      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n\t      kvDocs.push(metaDoc);\n\t\n\t      return kvDocs;\n\t    }\n\t\n\t    return getMetaDoc().then(function (metaDoc) {\n\t      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n\t        return processKeyValueDocs(metaDoc, kvDocsRes);\n\t      });\n\t    });\n\t  }\n\t\n\t  // updates all emitted key/value docs and metaDocs in the mrview database\n\t  // for the given batch of documents from the source database\n\t  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n\t    var seqDocId = '_local/lastSeq';\n\t    return view.db.get(seqDocId)\n\t      .catch(defaultsTo({_id: seqDocId, seq: 0}))\n\t      .then(function (lastSeqDoc) {\n\t        var docIds = mapToKeysArray(docIdsToChangesAndEmits);\n\t        return PouchPromise$1.all(docIds.map(function (docId) {\n\t          return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n\t        })).then(function (listOfDocsToPersist) {\n\t          var docsToPersist = flatten(listOfDocsToPersist);\n\t          lastSeqDoc.seq = seq;\n\t          docsToPersist.push(lastSeqDoc);\n\t          // write all docs in a single operation, update the seq once\n\t          return view.db.bulkDocs({docs : docsToPersist});\n\t        });\n\t      });\n\t  }\n\t\n\t  function getQueue(view) {\n\t    var viewName = typeof view === 'string' ? view : view.name;\n\t    var queue = persistentQueues[viewName];\n\t    if (!queue) {\n\t      queue = persistentQueues[viewName] = new TaskQueue$2();\n\t    }\n\t    return queue;\n\t  }\n\t\n\t  function updateView(view) {\n\t    return sequentialize(getQueue(view), function () {\n\t      return updateViewInQueue(view);\n\t    })();\n\t  }\n\t\n\t  function updateViewInQueue(view) {\n\t    // bind the emit function once\n\t    var mapResults;\n\t    var doc;\n\t\n\t    function emit(key, value) {\n\t      var output = {id: doc._id, key: normalizeKey(key)};\n\t      // Don't explicitly store the value unless it's defined and non-null.\n\t      // This saves on storage space, because often people don't use it.\n\t      if (typeof value !== 'undefined' && value !== null) {\n\t        output.value = normalizeKey(value);\n\t      }\n\t      mapResults.push(output);\n\t    }\n\t\n\t    var mapFun = mapper(view.mapFun, emit);\n\t\n\t    var currentSeq = view.seq || 0;\n\t\n\t    function processChange(docIdsToChangesAndEmits, seq) {\n\t      return function () {\n\t        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n\t      };\n\t    }\n\t\n\t    var queue = new TaskQueue$2();\n\t\n\t    function processNextBatch() {\n\t      return view.sourceDB.changes({\n\t        conflicts: true,\n\t        include_docs: true,\n\t        style: 'all_docs',\n\t        since: currentSeq,\n\t        limit: CHANGES_BATCH_SIZE$1\n\t      }).then(processBatch);\n\t    }\n\t\n\t    function processBatch(response) {\n\t      var results = response.results;\n\t      if (!results.length) {\n\t        return;\n\t      }\n\t      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n\t      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n\t      if (results.length < CHANGES_BATCH_SIZE$1) {\n\t        return;\n\t      }\n\t      return processNextBatch();\n\t    }\n\t\n\t    function createDocIdsToChangesAndEmits(results) {\n\t      var docIdsToChangesAndEmits = new ExportedMap();\n\t      for (var i = 0, len = results.length; i < len; i++) {\n\t        var change = results[i];\n\t        if (change.doc._id[0] !== '_') {\n\t          mapResults = [];\n\t          doc = change.doc;\n\t\n\t          if (!doc._deleted) {\n\t            tryMap(view.sourceDB, mapFun, doc);\n\t          }\n\t          mapResults.sort(sortByKeyThenValue);\n\t\n\t          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n\t          docIdsToChangesAndEmits.set(change.doc._id, [\n\t            indexableKeysToKeyValues,\n\t            change.changes\n\t          ]);\n\t        }\n\t        currentSeq = change.seq;\n\t      }\n\t      return docIdsToChangesAndEmits;\n\t    }\n\t\n\t    function createIndexableKeysToKeyValues(mapResults) {\n\t      var indexableKeysToKeyValues = new ExportedMap();\n\t      var lastKey;\n\t      for (var i = 0, len = mapResults.length; i < len; i++) {\n\t        var emittedKeyValue = mapResults[i];\n\t        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n\t        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {\n\t          complexKey.push(i); // dup key+id, so make it unique\n\t        }\n\t        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);\n\t        lastKey = emittedKeyValue.key;\n\t      }\n\t      return indexableKeysToKeyValues;\n\t    }\n\t\n\t    return processNextBatch().then(function () {\n\t      return queue.finish();\n\t    }).then(function () {\n\t      view.seq = currentSeq;\n\t    });\n\t  }\n\t\n\t  function reduceView(view, results, options) {\n\t    if (options.group_level === 0) {\n\t      delete options.group_level;\n\t    }\n\t\n\t    var shouldGroup = options.group || options.group_level;\n\t\n\t    var reduceFun = reducer(view.reduceFun);\n\t\n\t    var groups = [];\n\t    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n\t      options.group_level;\n\t    results.forEach(function (e) {\n\t      var last = groups[groups.length - 1];\n\t      var groupKey = shouldGroup ? e.key : null;\n\t\n\t      // only set group_level for array keys\n\t      if (shouldGroup && Array.isArray(groupKey)) {\n\t        groupKey = groupKey.slice(0, lvl);\n\t      }\n\t\n\t      if (last && collate(last.groupKey, groupKey) === 0) {\n\t        last.keys.push([e.key, e.id]);\n\t        last.values.push(e.value);\n\t        return;\n\t      }\n\t      groups.push({\n\t        keys: [[e.key, e.id]],\n\t        values: [e.value],\n\t        groupKey: groupKey\n\t      });\n\t    });\n\t    results = [];\n\t    for (var i = 0, len = groups.length; i < len; i++) {\n\t      var e = groups[i];\n\t      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n\t      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n\t        // CouchDB returns an error if a built-in errors out\n\t        throw reduceTry.error;\n\t      }\n\t      results.push({\n\t        // CouchDB just sets the value to null if a non-built-in errors out\n\t        value: reduceTry.error ? null : reduceTry.output,\n\t        key: e.groupKey\n\t      });\n\t    }\n\t    // no total_rows/offset when reducing\n\t    return {rows: sliceResults(results, options.limit, options.skip)};\n\t  }\n\t\n\t  function queryView(view, opts) {\n\t    return sequentialize(getQueue(view), function () {\n\t      return queryViewInQueue(view, opts);\n\t    })();\n\t  }\n\t\n\t  function queryViewInQueue(view, opts) {\n\t    var totalRows;\n\t    var shouldReduce = view.reduceFun && opts.reduce !== false;\n\t    var skip = opts.skip || 0;\n\t    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n\t      // equivalent query\n\t      opts.limit = 0;\n\t      delete opts.keys;\n\t    }\n\t\n\t    function fetchFromView(viewOpts) {\n\t      viewOpts.include_docs = true;\n\t      return view.db.allDocs(viewOpts).then(function (res) {\n\t        totalRows = res.total_rows;\n\t        return res.rows.map(function (result) {\n\t\n\t          // implicit migration - in older versions of PouchDB,\n\t          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n\t          // this is tested in a migration test\n\t          /* istanbul ignore next */\n\t          if ('value' in result.doc && typeof result.doc.value === 'object' &&\n\t            result.doc.value !== null) {\n\t            var keys = Object.keys(result.doc.value).sort();\n\t            // this detection method is not perfect, but it's unlikely the user\n\t            // emitted a value which was an object with these 3 exact keys\n\t            var expectedKeys = ['id', 'key', 'value'];\n\t            if (!(keys < expectedKeys || keys > expectedKeys)) {\n\t              return result.doc.value;\n\t            }\n\t          }\n\t\n\t          var parsedKeyAndDocId = parseIndexableString(result.doc._id);\n\t          return {\n\t            key: parsedKeyAndDocId[0],\n\t            id: parsedKeyAndDocId[1],\n\t            value: ('value' in result.doc ? result.doc.value : null)\n\t          };\n\t        });\n\t      });\n\t    }\n\t\n\t    function onMapResultsReady(rows) {\n\t      var finalResults;\n\t      if (shouldReduce) {\n\t        finalResults = reduceView(view, rows, opts);\n\t      } else {\n\t        finalResults = {\n\t          total_rows: totalRows,\n\t          offset: skip,\n\t          rows: rows\n\t        };\n\t      }\n\t      if (opts.include_docs) {\n\t        var docIds = uniq(rows.map(rowToDocId));\n\t\n\t        return view.sourceDB.allDocs({\n\t          keys: docIds,\n\t          include_docs: true,\n\t          conflicts: opts.conflicts,\n\t          attachments: opts.attachments,\n\t          binary: opts.binary\n\t        }).then(function (allDocsRes) {\n\t          var docIdsToDocs = new ExportedMap();\n\t          allDocsRes.rows.forEach(function (row) {\n\t            docIdsToDocs.set(row.id, row.doc);\n\t          });\n\t          rows.forEach(function (row) {\n\t            var docId = rowToDocId(row);\n\t            var doc = docIdsToDocs.get(docId);\n\t            if (doc) {\n\t              row.doc = doc;\n\t            }\n\t          });\n\t          return finalResults;\n\t        });\n\t      } else {\n\t        return finalResults;\n\t      }\n\t    }\n\t\n\t    if (typeof opts.keys !== 'undefined') {\n\t      var keys = opts.keys;\n\t      var fetchPromises = keys.map(function (key) {\n\t        var viewOpts = {\n\t          startkey : toIndexableString([key]),\n\t          endkey   : toIndexableString([key, {}])\n\t        };\n\t        return fetchFromView(viewOpts);\n\t      });\n\t      return PouchPromise$1.all(fetchPromises).then(flatten).then(onMapResultsReady);\n\t    } else { // normal query, no 'keys'\n\t      var viewOpts = {\n\t        descending : opts.descending\n\t      };\n\t      var startkey;\n\t      var endkey;\n\t      if ('start_key' in opts) {\n\t        startkey = opts.start_key;\n\t      }\n\t      if ('startkey' in opts) {\n\t        startkey = opts.startkey;\n\t      }\n\t      if ('end_key' in opts) {\n\t        endkey = opts.end_key;\n\t      }\n\t      if ('endkey' in opts) {\n\t        endkey = opts.endkey;\n\t      }\n\t      if (typeof startkey !== 'undefined') {\n\t        viewOpts.startkey = opts.descending ?\n\t          toIndexableString([startkey, {}]) :\n\t          toIndexableString([startkey]);\n\t      }\n\t      if (typeof endkey !== 'undefined') {\n\t        var inclusiveEnd = opts.inclusive_end !== false;\n\t        if (opts.descending) {\n\t          inclusiveEnd = !inclusiveEnd;\n\t        }\n\t\n\t        viewOpts.endkey = toIndexableString(\n\t          inclusiveEnd ? [endkey, {}] : [endkey]);\n\t      }\n\t      if (typeof opts.key !== 'undefined') {\n\t        var keyStart = toIndexableString([opts.key]);\n\t        var keyEnd = toIndexableString([opts.key, {}]);\n\t        if (viewOpts.descending) {\n\t          viewOpts.endkey = keyStart;\n\t          viewOpts.startkey = keyEnd;\n\t        } else {\n\t          viewOpts.startkey = keyStart;\n\t          viewOpts.endkey = keyEnd;\n\t        }\n\t      }\n\t      if (!shouldReduce) {\n\t        if (typeof opts.limit === 'number') {\n\t          viewOpts.limit = opts.limit;\n\t        }\n\t        viewOpts.skip = skip;\n\t      }\n\t      return fetchFromView(viewOpts).then(onMapResultsReady);\n\t    }\n\t  }\n\t\n\t  function httpViewCleanup(db) {\n\t    return db.request({\n\t      method: 'POST',\n\t      url: '_view_cleanup'\n\t    });\n\t  }\n\t\n\t  function localViewCleanup(db) {\n\t    return db.get('_local/' + localDocName).then(function (metaDoc) {\n\t      var docsToViews = new ExportedMap();\n\t      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n\t        var parts = parseViewName(fullViewName);\n\t        var designDocName = '_design/' + parts[0];\n\t        var viewName = parts[1];\n\t        var views = docsToViews.get(designDocName);\n\t        if (!views) {\n\t          views = new ExportedSet();\n\t          docsToViews.set(designDocName, views);\n\t        }\n\t        views.add(viewName);\n\t      });\n\t      var opts = {\n\t        keys : mapToKeysArray(docsToViews),\n\t        include_docs : true\n\t      };\n\t      return db.allDocs(opts).then(function (res) {\n\t        var viewsToStatus = {};\n\t        res.rows.forEach(function (row) {\n\t          var ddocName = row.key.substring(8); // cuts off '_design/'\n\t          docsToViews.get(row.key).forEach(function (viewName) {\n\t            var fullViewName = ddocName + '/' + viewName;\n\t            /* istanbul ignore if */\n\t            if (!metaDoc.views[fullViewName]) {\n\t              // new format, without slashes, to support PouchDB 2.2.0\n\t              // migration test in pouchdb's browser.migration.js verifies this\n\t              fullViewName = viewName;\n\t            }\n\t            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n\t            // design doc deleted, or view function nonexistent\n\t            var statusIsGood = row.doc && row.doc.views &&\n\t              row.doc.views[viewName];\n\t            viewDBNames.forEach(function (viewDBName) {\n\t              viewsToStatus[viewDBName] =\n\t                viewsToStatus[viewDBName] || statusIsGood;\n\t            });\n\t          });\n\t        });\n\t        var dbsToDelete = Object.keys(viewsToStatus).filter(\n\t          function (viewDBName) { return !viewsToStatus[viewDBName]; });\n\t        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n\t          return sequentialize(getQueue(viewDBName), function () {\n\t            return new db.constructor(viewDBName, db.__opts).destroy();\n\t          })();\n\t        });\n\t        return PouchPromise$1.all(destroyPromises).then(function () {\n\t          return {ok: true};\n\t        });\n\t      });\n\t    }, defaultsTo({ok: true}));\n\t  }\n\t\n\t  function queryPromised(db, fun, opts) {\n\t    /* istanbul ignore next */\n\t    if (typeof db._query === 'function') {\n\t      return customQuery(db, fun, opts);\n\t    }\n\t    if (isRemote(db)) {\n\t      return httpQuery(db, fun, opts);\n\t    }\n\t\n\t    if (typeof fun !== 'string') {\n\t      // temp_view\n\t      checkQueryParseError(opts, fun);\n\t\n\t      tempViewQueue.add(function () {\n\t        var createViewPromise = createView(\n\t          /* sourceDB */ db,\n\t          /* viewName */ 'temp_view/temp_view',\n\t          /* mapFun */ fun.map,\n\t          /* reduceFun */ fun.reduce,\n\t          /* temporary */ true,\n\t          /* localDocName */ localDocName);\n\t        return createViewPromise.then(function (view) {\n\t          return fin(updateView(view).then(function () {\n\t            return queryView(view, opts);\n\t          }), function () {\n\t            return view.db.destroy();\n\t          });\n\t        });\n\t      });\n\t      return tempViewQueue.finish();\n\t    } else {\n\t      // persistent view\n\t      var fullViewName = fun;\n\t      var parts = parseViewName(fullViewName);\n\t      var designDocName = parts[0];\n\t      var viewName = parts[1];\n\t      return db.get('_design/' + designDocName).then(function (doc) {\n\t        var fun = doc.views && doc.views[viewName];\n\t\n\t        if (!fun) {\n\t          // basic validator; it's assumed that every subclass would want this\n\t          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +\n\t            viewName);\n\t        }\n\t\n\t        ddocValidator(doc, viewName);\n\t        checkQueryParseError(opts, fun);\n\t\n\t        var createViewPromise = createView(\n\t          /* sourceDB */ db,\n\t          /* viewName */ fullViewName,\n\t          /* mapFun */ fun.map,\n\t          /* reduceFun */ fun.reduce,\n\t          /* temporary */ false,\n\t          /* localDocName */ localDocName);\n\t        return createViewPromise.then(function (view) {\n\t          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n\t            if (opts.stale === 'update_after') {\n\t              nextTick(function () {\n\t                updateView(view);\n\t              });\n\t            }\n\t            return queryView(view, opts);\n\t          } else { // stale not ok\n\t            return updateView(view).then(function () {\n\t              return queryView(view, opts);\n\t            });\n\t          }\n\t        });\n\t      });\n\t    }\n\t  }\n\t\n\t  function abstractQuery(fun, opts, callback) {\n\t    var db = this;\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    opts = opts ? coerceOptions(opts) : {};\n\t\n\t    if (typeof fun === 'function') {\n\t      fun = {map : fun};\n\t    }\n\t\n\t    var promise = PouchPromise$1.resolve().then(function () {\n\t      return queryPromised(db, fun, opts);\n\t    });\n\t    promisedCallback(promise, callback);\n\t    return promise;\n\t  }\n\t\n\t  var abstractViewCleanup = callbackify(function () {\n\t    var db = this;\n\t    /* istanbul ignore next */\n\t    if (typeof db._viewCleanup === 'function') {\n\t      return customViewCleanup(db);\n\t    }\n\t    if (isRemote(db)) {\n\t      return httpViewCleanup(db);\n\t    }\n\t    return localViewCleanup(db);\n\t  });\n\t\n\t  return {\n\t    query: abstractQuery,\n\t    viewCleanup: abstractViewCleanup\n\t  };\n\t}\n\t\n\tvar builtInReduce = {\n\t  _sum: function (keys, values) {\n\t    return sum(values);\n\t  },\n\t\n\t  _count: function (keys, values) {\n\t    return values.length;\n\t  },\n\t\n\t  _stats: function (keys, values) {\n\t    // no need to implement rereduce=true, because Pouch\n\t    // will never call it\n\t    function sumsqr(values) {\n\t      var _sumsqr = 0;\n\t      for (var i = 0, len = values.length; i < len; i++) {\n\t        var num = values[i];\n\t        _sumsqr += (num * num);\n\t      }\n\t      return _sumsqr;\n\t    }\n\t    return {\n\t      sum     : sum(values),\n\t      min     : Math.min.apply(null, values),\n\t      max     : Math.max.apply(null, values),\n\t      count   : values.length,\n\t      sumsqr : sumsqr(values)\n\t    };\n\t  }\n\t};\n\t\n\tfunction getBuiltIn(reduceFunString) {\n\t  if (/^_sum/.test(reduceFunString)) {\n\t    return builtInReduce._sum;\n\t  } else if (/^_count/.test(reduceFunString)) {\n\t    return builtInReduce._count;\n\t  } else if (/^_stats/.test(reduceFunString)) {\n\t    return builtInReduce._stats;\n\t  } else if (/^_/.test(reduceFunString)) {\n\t    throw new Error(reduceFunString + ' is not a supported reduce function.');\n\t  }\n\t}\n\t\n\tfunction mapper(mapFun, emit) {\n\t  // for temp_views one can use emit(doc, emit), see #38\n\t  if (typeof mapFun === \"function\" && mapFun.length === 2) {\n\t    var origMap = mapFun;\n\t    return function (doc) {\n\t      return origMap(doc, emit);\n\t    };\n\t  } else {\n\t    return evalFunctionWithEval(mapFun.toString(), emit);\n\t  }\n\t}\n\t\n\tfunction reducer(reduceFun) {\n\t  var reduceFunString = reduceFun.toString();\n\t  var builtIn = getBuiltIn(reduceFunString);\n\t  if (builtIn) {\n\t    return builtIn;\n\t  } else {\n\t    return evalFunctionWithEval(reduceFunString);\n\t  }\n\t}\n\t\n\tfunction ddocValidator(ddoc, viewName) {\n\t  var fun = ddoc.views && ddoc.views[viewName];\n\t  if (typeof fun.map !== 'string') {\n\t    throw new NotFoundError('ddoc ' + ddoc._id + ' has no string view named ' +\n\t      viewName + ', instead found object of type: ' + typeof fun.map);\n\t  }\n\t}\n\t\n\tvar localDocName = 'mrviews';\n\tvar abstract = createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator);\n\t\n\tfunction query(fun, opts, callback) {\n\t  return abstract.query.call(this, fun, opts, callback);\n\t}\n\t\n\tfunction viewCleanup(callback) {\n\t  return abstract.viewCleanup.call(this, callback);\n\t}\n\t\n\tvar mapreduce = {\n\t  query: query,\n\t  viewCleanup: viewCleanup\n\t};\n\t\n\tfunction isGenOne$1(rev$$1) {\n\t  return /^1-/.test(rev$$1);\n\t}\n\t\n\tfunction fileHasChanged(localDoc, remoteDoc, filename) {\n\t  return !localDoc._attachments ||\n\t         !localDoc._attachments[filename] ||\n\t         localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;\n\t}\n\t\n\tfunction getDocAttachments(db, doc) {\n\t  var filenames = Object.keys(doc._attachments);\n\t  return PouchPromise$1.all(filenames.map(function (filename) {\n\t    return db.getAttachment(doc._id, filename, {rev: doc._rev});\n\t  }));\n\t}\n\t\n\tfunction getDocAttachmentsFromTargetOrSource(target, src, doc) {\n\t  var doCheckForLocalAttachments = isRemote(src) && !isRemote(target);\n\t  var filenames = Object.keys(doc._attachments);\n\t\n\t  if (!doCheckForLocalAttachments) {\n\t    return getDocAttachments(src, doc);\n\t  }\n\t\n\t  return target.get(doc._id).then(function (localDoc) {\n\t    return PouchPromise$1.all(filenames.map(function (filename) {\n\t      if (fileHasChanged(localDoc, doc, filename)) {\n\t        return src.getAttachment(doc._id, filename);\n\t      }\n\t\n\t      return target.getAttachment(localDoc._id, filename);\n\t    }));\n\t  }).catch(function (error) {\n\t    /* istanbul ignore if */\n\t    if (error.status !== 404) {\n\t      throw error;\n\t    }\n\t\n\t    return getDocAttachments(src, doc);\n\t  });\n\t}\n\t\n\tfunction createBulkGetOpts(diffs) {\n\t  var requests = [];\n\t  Object.keys(diffs).forEach(function (id) {\n\t    var missingRevs = diffs[id].missing;\n\t    missingRevs.forEach(function (missingRev) {\n\t      requests.push({\n\t        id: id,\n\t        rev: missingRev\n\t      });\n\t    });\n\t  });\n\t\n\t  return {\n\t    docs: requests,\n\t    revs: true,\n\t    latest: true\n\t  };\n\t}\n\t\n\t//\n\t// Fetch all the documents from the src as described in the \"diffs\",\n\t// which is a mapping of docs IDs to revisions. If the state ever\n\t// changes to \"cancelled\", then the returned promise will be rejected.\n\t// Else it will be resolved with a list of fetched documents.\n\t//\n\tfunction getDocs(src, target, diffs, state) {\n\t  diffs = clone(diffs); // we do not need to modify this\n\t\n\t  var resultDocs = [],\n\t      ok = true;\n\t\n\t  function getAllDocs() {\n\t\n\t    var bulkGetOpts = createBulkGetOpts(diffs);\n\t\n\t    if (!bulkGetOpts.docs.length) { // optimization: skip empty requests\n\t      return;\n\t    }\n\t\n\t    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {\n\t      /* istanbul ignore if */\n\t      if (state.cancelled) {\n\t        throw new Error('cancelled');\n\t      }\n\t      return PouchPromise$1.all(bulkGetResponse.results.map(function (bulkGetInfo) {\n\t        return PouchPromise$1.all(bulkGetInfo.docs.map(function (doc) {\n\t          var remoteDoc = doc.ok;\n\t\n\t          if (doc.error) {\n\t            // when AUTO_COMPACTION is set, docs can be returned which look\n\t            // like this: {\"missing\":\"1-7c3ac256b693c462af8442f992b83696\"}\n\t            ok = false;\n\t          }\n\t\n\t          if (!remoteDoc || !remoteDoc._attachments) {\n\t            return remoteDoc;\n\t          }\n\t\n\t          return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc)\n\t                   .then(function (attachments) {\n\t                           var filenames = Object.keys(remoteDoc._attachments);\n\t                           attachments\n\t                             .forEach(function (attachment, i) {\n\t                                        var att = remoteDoc._attachments[filenames[i]];\n\t                                        delete att.stub;\n\t                                        delete att.length;\n\t                                        att.data = attachment;\n\t                                      });\n\t\n\t                                      return remoteDoc;\n\t                                    });\n\t        }));\n\t      }))\n\t\n\t      .then(function (results) {\n\t        resultDocs = resultDocs.concat(flatten(results).filter(Boolean));\n\t      });\n\t    });\n\t  }\n\t\n\t  function hasAttachments(doc) {\n\t    return doc._attachments && Object.keys(doc._attachments).length > 0;\n\t  }\n\t\n\t  function hasConflicts(doc) {\n\t    return doc._conflicts && doc._conflicts.length > 0;\n\t  }\n\t\n\t  function fetchRevisionOneDocs(ids) {\n\t    // Optimization: fetch gen-1 docs and attachments in\n\t    // a single request using _all_docs\n\t    return src.allDocs({\n\t      keys: ids,\n\t      include_docs: true,\n\t      conflicts: true\n\t    }).then(function (res) {\n\t      if (state.cancelled) {\n\t        throw new Error('cancelled');\n\t      }\n\t      res.rows.forEach(function (row) {\n\t        if (row.deleted || !row.doc || !isGenOne$1(row.value.rev) ||\n\t            hasAttachments(row.doc) || hasConflicts(row.doc)) {\n\t          // if any of these conditions apply, we need to fetch using get()\n\t          return;\n\t        }\n\t\n\t        // strip _conflicts array to appease CSG (#5793)\n\t        /* istanbul ignore if */\n\t        if (row.doc._conflicts) {\n\t          delete row.doc._conflicts;\n\t        }\n\t\n\t        // the doc we got back from allDocs() is sufficient\n\t        resultDocs.push(row.doc);\n\t        delete diffs[row.id];\n\t      });\n\t    });\n\t  }\n\t\n\t  function getRevisionOneDocs() {\n\t    // filter out the generation 1 docs and get them\n\t    // leaving the non-generation one docs to be got otherwise\n\t    var ids = Object.keys(diffs).filter(function (id) {\n\t      var missing = diffs[id].missing;\n\t      return missing.length === 1 && isGenOne$1(missing[0]);\n\t    });\n\t    if (ids.length > 0) {\n\t      return fetchRevisionOneDocs(ids);\n\t    }\n\t  }\n\t\n\t  function returnResult() {\n\t    return { ok:ok, docs:resultDocs };\n\t  }\n\t\n\t  return PouchPromise$1.resolve()\n\t    .then(getRevisionOneDocs)\n\t    .then(getAllDocs)\n\t    .then(returnResult);\n\t}\n\t\n\tvar CHECKPOINT_VERSION = 1;\n\tvar REPLICATOR = \"pouchdb\";\n\t// This is an arbitrary number to limit the\n\t// amount of replication history we save in the checkpoint.\n\t// If we save too much, the checkpoing docs will become very big,\n\t// if we save fewer, we'll run a greater risk of having to\n\t// read all the changes from 0 when checkpoint PUTs fail\n\t// CouchDB 2.0 has a more involved history pruning,\n\t// but let's go for the simple version for now.\n\tvar CHECKPOINT_HISTORY_SIZE = 5;\n\tvar LOWEST_SEQ = 0;\n\t\n\tfunction updateCheckpoint(db, id, checkpoint, session, returnValue) {\n\t  return db.get(id).catch(function (err) {\n\t    if (err.status === 404) {\n\t      if (db.adapter === 'http' || db.adapter === 'https') {\n\t        explainError(\n\t          404, 'PouchDB is just checking if a remote checkpoint exists.'\n\t        );\n\t      }\n\t      return {\n\t        session_id: session,\n\t        _id: id,\n\t        history: [],\n\t        replicator: REPLICATOR,\n\t        version: CHECKPOINT_VERSION\n\t      };\n\t    }\n\t    throw err;\n\t  }).then(function (doc) {\n\t    if (returnValue.cancelled) {\n\t      return;\n\t    }\n\t\n\t    // if the checkpoint has not changed, do not update\n\t    if (doc.last_seq === checkpoint) {\n\t      return;\n\t    }\n\t\n\t    // Filter out current entry for this replication\n\t    doc.history = (doc.history || []).filter(function (item) {\n\t      return item.session_id !== session;\n\t    });\n\t\n\t    // Add the latest checkpoint to history\n\t    doc.history.unshift({\n\t      last_seq: checkpoint,\n\t      session_id: session\n\t    });\n\t\n\t    // Just take the last pieces in history, to\n\t    // avoid really big checkpoint docs.\n\t    // see comment on history size above\n\t    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);\n\t\n\t    doc.version = CHECKPOINT_VERSION;\n\t    doc.replicator = REPLICATOR;\n\t\n\t    doc.session_id = session;\n\t    doc.last_seq = checkpoint;\n\t\n\t    return db.put(doc).catch(function (err) {\n\t      if (err.status === 409) {\n\t        // retry; someone is trying to write a checkpoint simultaneously\n\t        return updateCheckpoint(db, id, checkpoint, session, returnValue);\n\t      }\n\t      throw err;\n\t    });\n\t  });\n\t}\n\t\n\tfunction Checkpointer(src, target, id, returnValue, opts) {\n\t  this.src = src;\n\t  this.target = target;\n\t  this.id = id;\n\t  this.returnValue = returnValue;\n\t  this.opts = opts;\n\t}\n\t\n\tCheckpointer.prototype.writeCheckpoint = function (checkpoint, session) {\n\t  var self = this;\n\t  return this.updateTarget(checkpoint, session).then(function () {\n\t    return self.updateSource(checkpoint, session);\n\t  });\n\t};\n\t\n\tCheckpointer.prototype.updateTarget = function (checkpoint, session) {\n\t  if (this.opts.writeTargetCheckpoint) {\n\t    return updateCheckpoint(this.target, this.id, checkpoint,\n\t      session, this.returnValue);\n\t  } else {\n\t    return PouchPromise$1.resolve(true);\n\t  }\n\t};\n\t\n\tCheckpointer.prototype.updateSource = function (checkpoint, session) {\n\t  if (this.opts.writeSourceCheckpoint) {\n\t    var self = this;\n\t    if (this.readOnlySource) {\n\t      return PouchPromise$1.resolve(true);\n\t    }\n\t    return updateCheckpoint(this.src, this.id, checkpoint,\n\t      session, this.returnValue)\n\t      .catch(function (err) {\n\t        if (isForbiddenError(err)) {\n\t          self.readOnlySource = true;\n\t          return true;\n\t        }\n\t        throw err;\n\t      });\n\t  } else {\n\t    return PouchPromise$1.resolve(true);\n\t  }\n\t};\n\t\n\tvar comparisons = {\n\t  \"undefined\": function (targetDoc, sourceDoc) {\n\t    // This is the previous comparison function\n\t    if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {\n\t      return sourceDoc.last_seq;\n\t    }\n\t    /* istanbul ignore next */\n\t    return 0;\n\t  },\n\t  \"1\": function (targetDoc, sourceDoc) {\n\t    // This is the comparison function ported from CouchDB\n\t    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;\n\t  }\n\t};\n\t\n\tCheckpointer.prototype.getCheckpoint = function () {\n\t  var self = this;\n\t  return self.target.get(self.id).then(function (targetDoc) {\n\t    if (self.readOnlySource) {\n\t      return PouchPromise$1.resolve(targetDoc.last_seq);\n\t    }\n\t\n\t    return self.src.get(self.id).then(function (sourceDoc) {\n\t      // Since we can't migrate an old version doc to a new one\n\t      // (no session id), we just go with the lowest seq in this case\n\t      /* istanbul ignore if */\n\t      if (targetDoc.version !== sourceDoc.version) {\n\t        return LOWEST_SEQ;\n\t      }\n\t\n\t      var version;\n\t      if (targetDoc.version) {\n\t        version = targetDoc.version.toString();\n\t      } else {\n\t        version = \"undefined\";\n\t      }\n\t\n\t      if (version in comparisons) {\n\t        return comparisons[version](targetDoc, sourceDoc);\n\t      }\n\t      /* istanbul ignore next */\n\t      return LOWEST_SEQ;\n\t    }, function (err) {\n\t      if (err.status === 404 && targetDoc.last_seq) {\n\t        return self.src.put({\n\t          _id: self.id,\n\t          last_seq: LOWEST_SEQ\n\t        }).then(function () {\n\t          return LOWEST_SEQ;\n\t        }, function (err) {\n\t          if (isForbiddenError(err)) {\n\t            self.readOnlySource = true;\n\t            return targetDoc.last_seq;\n\t          }\n\t          /* istanbul ignore next */\n\t          return LOWEST_SEQ;\n\t        });\n\t      }\n\t      throw err;\n\t    });\n\t  }).catch(function (err) {\n\t    if (err.status !== 404) {\n\t      throw err;\n\t    }\n\t    return LOWEST_SEQ;\n\t  });\n\t};\n\t// This checkpoint comparison is ported from CouchDBs source\n\t// they come from here:\n\t// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906\n\t\n\tfunction compareReplicationLogs(srcDoc, tgtDoc) {\n\t  if (srcDoc.session_id === tgtDoc.session_id) {\n\t    return {\n\t      last_seq: srcDoc.last_seq,\n\t      history: srcDoc.history\n\t    };\n\t  }\n\t\n\t  return compareReplicationHistory(srcDoc.history, tgtDoc.history);\n\t}\n\t\n\tfunction compareReplicationHistory(sourceHistory, targetHistory) {\n\t  // the erlang loop via function arguments is not so easy to repeat in JS\n\t  // therefore, doing this as recursion\n\t  var S = sourceHistory[0];\n\t  var sourceRest = sourceHistory.slice(1);\n\t  var T = targetHistory[0];\n\t  var targetRest = targetHistory.slice(1);\n\t\n\t  if (!S || targetHistory.length === 0) {\n\t    return {\n\t      last_seq: LOWEST_SEQ,\n\t      history: []\n\t    };\n\t  }\n\t\n\t  var sourceId = S.session_id;\n\t  /* istanbul ignore if */\n\t  if (hasSessionId(sourceId, targetHistory)) {\n\t    return {\n\t      last_seq: S.last_seq,\n\t      history: sourceHistory\n\t    };\n\t  }\n\t\n\t  var targetId = T.session_id;\n\t  if (hasSessionId(targetId, sourceRest)) {\n\t    return {\n\t      last_seq: T.last_seq,\n\t      history: targetRest\n\t    };\n\t  }\n\t\n\t  return compareReplicationHistory(sourceRest, targetRest);\n\t}\n\t\n\tfunction hasSessionId(sessionId, history) {\n\t  var props = history[0];\n\t  var rest = history.slice(1);\n\t\n\t  if (!sessionId || history.length === 0) {\n\t    return false;\n\t  }\n\t\n\t  if (sessionId === props.session_id) {\n\t    return true;\n\t  }\n\t\n\t  return hasSessionId(sessionId, rest);\n\t}\n\t\n\tfunction isForbiddenError(err) {\n\t  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;\n\t}\n\t\n\tvar STARTING_BACK_OFF = 0;\n\t\n\tfunction backOff(opts, returnValue, error, callback) {\n\t  if (opts.retry === false) {\n\t    returnValue.emit('error', error);\n\t    returnValue.removeAllListeners();\n\t    return;\n\t  }\n\t  if (typeof opts.back_off_function !== 'function') {\n\t    opts.back_off_function = defaultBackOff;\n\t  }\n\t  returnValue.emit('requestError', error);\n\t  if (returnValue.state === 'active' || returnValue.state === 'pending') {\n\t    returnValue.emit('paused', error);\n\t    returnValue.state = 'stopped';\n\t    var backOffSet = function backoffTimeSet() {\n\t      opts.current_back_off = STARTING_BACK_OFF;\n\t    };\n\t    var removeBackOffSetter = function removeBackOffTimeSet() {\n\t      returnValue.removeListener('active', backOffSet);\n\t    };\n\t    returnValue.once('paused', removeBackOffSetter);\n\t    returnValue.once('active', backOffSet);\n\t  }\n\t\n\t  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;\n\t  opts.current_back_off = opts.back_off_function(opts.current_back_off);\n\t  setTimeout(callback, opts.current_back_off);\n\t}\n\t\n\tfunction sortObjectPropertiesByKey(queryParams) {\n\t  return Object.keys(queryParams).sort(collate).reduce(function (result, key) {\n\t    result[key] = queryParams[key];\n\t    return result;\n\t  }, {});\n\t}\n\t\n\t// Generate a unique id particular to this replication.\n\t// Not guaranteed to align perfectly with CouchDB's rep ids.\n\tfunction generateReplicationId(src, target, opts) {\n\t  var docIds = opts.doc_ids ? opts.doc_ids.sort(collate) : '';\n\t  var filterFun = opts.filter ? opts.filter.toString() : '';\n\t  var queryParams = '';\n\t  var filterViewName =  '';\n\t  var selector = '';\n\t\n\t  // possibility for checkpoints to be lost here as behaviour of\n\t  // JSON.stringify is not stable (see #6226)\n\t  /* istanbul ignore if */\n\t  if (opts.selector) {\n\t    selector = JSON.stringify(opts.selector);\n\t  }\n\t\n\t  if (opts.filter && opts.query_params) {\n\t    queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));\n\t  }\n\t\n\t  if (opts.filter && opts.filter === '_view') {\n\t    filterViewName = opts.view.toString();\n\t  }\n\t\n\t  return PouchPromise$1.all([src.id(), target.id()]).then(function (res) {\n\t    var queryData = res[0] + res[1] + filterFun + filterViewName +\n\t      queryParams + docIds + selector;\n\t    return new PouchPromise$1(function (resolve) {\n\t      binaryMd5(queryData, resolve);\n\t    });\n\t  }).then(function (md5sum) {\n\t    // can't use straight-up md5 alphabet, because\n\t    // the char '/' is interpreted as being for attachments,\n\t    // and + is also not url-safe\n\t    md5sum = md5sum.replace(/\\//g, '.').replace(/\\+/g, '_');\n\t    return '_local/' + md5sum;\n\t  });\n\t}\n\t\n\tfunction replicate(src, target, opts, returnValue, result) {\n\t  var batches = [];               // list of batches to be processed\n\t  var currentBatch;               // the batch currently being processed\n\t  var pendingBatch = {\n\t    seq: 0,\n\t    changes: [],\n\t    docs: []\n\t  }; // next batch, not yet ready to be processed\n\t  var writingCheckpoint = false;  // true while checkpoint is being written\n\t  var changesCompleted = false;   // true when all changes received\n\t  var replicationCompleted = false; // true when replication has completed\n\t  var last_seq = 0;\n\t  var continuous = opts.continuous || opts.live || false;\n\t  var batch_size = opts.batch_size || 100;\n\t  var batches_limit = opts.batches_limit || 10;\n\t  var changesPending = false;     // true while src.changes is running\n\t  var doc_ids = opts.doc_ids;\n\t  var selector = opts.selector;\n\t  var repId;\n\t  var checkpointer;\n\t  var changedDocs = [];\n\t  // Like couchdb, every replication gets a unique session id\n\t  var session = uuid();\n\t\n\t  result = result || {\n\t    ok: true,\n\t    start_time: new Date(),\n\t    docs_read: 0,\n\t    docs_written: 0,\n\t    doc_write_failures: 0,\n\t    errors: []\n\t  };\n\t\n\t  var changesOpts = {};\n\t  returnValue.ready(src, target);\n\t\n\t  function initCheckpointer() {\n\t    if (checkpointer) {\n\t      return PouchPromise$1.resolve();\n\t    }\n\t    return generateReplicationId(src, target, opts).then(function (res) {\n\t      repId = res;\n\t\n\t      var checkpointOpts = {};\n\t      if (opts.checkpoint === false) {\n\t        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: false };\n\t      } else if (opts.checkpoint === 'source') {\n\t        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: false };\n\t      } else if (opts.checkpoint === 'target') {\n\t        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: true };\n\t      } else {\n\t        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: true };\n\t      }\n\t\n\t      checkpointer = new Checkpointer(src, target, repId, returnValue, checkpointOpts);\n\t    });\n\t  }\n\t\n\t  function writeDocs() {\n\t    changedDocs = [];\n\t\n\t    if (currentBatch.docs.length === 0) {\n\t      return;\n\t    }\n\t    var docs = currentBatch.docs;\n\t    var bulkOpts = {timeout: opts.timeout};\n\t    return target.bulkDocs({docs: docs, new_edits: false}, bulkOpts).then(function (res) {\n\t      /* istanbul ignore if */\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        throw new Error('cancelled');\n\t      }\n\t\n\t      // `res` doesn't include full documents (which live in `docs`), so we create a map of \n\t      // (id -> error), and check for errors while iterating over `docs`\n\t      var errorsById = Object.create(null);\n\t      res.forEach(function (res) {\n\t        if (res.error) {\n\t          errorsById[res.id] = res;\n\t        }\n\t      });\n\t\n\t      var errorsNo = Object.keys(errorsById).length;\n\t      result.doc_write_failures += errorsNo;\n\t      result.docs_written += docs.length - errorsNo;\n\t\n\t      docs.forEach(function (doc) {\n\t        var error = errorsById[doc._id];\n\t        if (error) {\n\t          result.errors.push(error);\n\t          if (error.name === 'unauthorized' || error.name === 'forbidden') {\n\t            returnValue.emit('denied', clone(error));\n\t          } else {\n\t            throw error;\n\t          }\n\t        } else {\n\t          changedDocs.push(doc);\n\t        }\n\t      });\n\t\n\t    }, function (err) {\n\t      result.doc_write_failures += docs.length;\n\t      throw err;\n\t    });\n\t  }\n\t\n\t  function finishBatch() {\n\t    if (currentBatch.error) {\n\t      throw new Error('There was a problem getting docs.');\n\t    }\n\t    result.last_seq = last_seq = currentBatch.seq;\n\t    var outResult = clone(result);\n\t    if (changedDocs.length) {\n\t      outResult.docs = changedDocs;\n\t      returnValue.emit('change', outResult);\n\t    }\n\t    writingCheckpoint = true;\n\t    return checkpointer.writeCheckpoint(currentBatch.seq,\n\t        session).then(function () {\n\t      writingCheckpoint = false;\n\t      /* istanbul ignore if */\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        throw new Error('cancelled');\n\t      }\n\t      currentBatch = undefined;\n\t      getChanges();\n\t    }).catch(function (err) {\n\t      onCheckpointError(err);\n\t      throw err;\n\t    });\n\t  }\n\t\n\t  function getDiffs() {\n\t    var diff = {};\n\t    currentBatch.changes.forEach(function (change) {\n\t      // Couchbase Sync Gateway emits these, but we can ignore them\n\t      /* istanbul ignore if */\n\t      if (change.id === \"_user/\") {\n\t        return;\n\t      }\n\t      diff[change.id] = change.changes.map(function (x) {\n\t        return x.rev;\n\t      });\n\t    });\n\t    return target.revsDiff(diff).then(function (diffs) {\n\t      /* istanbul ignore if */\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        throw new Error('cancelled');\n\t      }\n\t      // currentBatch.diffs elements are deleted as the documents are written\n\t      currentBatch.diffs = diffs;\n\t    });\n\t  }\n\t\n\t  function getBatchDocs() {\n\t    return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {\n\t      currentBatch.error = !got.ok;\n\t      got.docs.forEach(function (doc) {\n\t        delete currentBatch.diffs[doc._id];\n\t        result.docs_read++;\n\t        currentBatch.docs.push(doc);\n\t      });\n\t    });\n\t  }\n\t\n\t  function startNextBatch() {\n\t    if (returnValue.cancelled || currentBatch) {\n\t      return;\n\t    }\n\t    if (batches.length === 0) {\n\t      processPendingBatch(true);\n\t      return;\n\t    }\n\t    currentBatch = batches.shift();\n\t    getDiffs()\n\t      .then(getBatchDocs)\n\t      .then(writeDocs)\n\t      .then(finishBatch)\n\t      .then(startNextBatch)\n\t      .catch(function (err) {\n\t        abortReplication('batch processing terminated with error', err);\n\t      });\n\t  }\n\t\n\t\n\t  function processPendingBatch(immediate) {\n\t    if (pendingBatch.changes.length === 0) {\n\t      if (batches.length === 0 && !currentBatch) {\n\t        if ((continuous && changesOpts.live) || changesCompleted) {\n\t          returnValue.state = 'pending';\n\t          returnValue.emit('paused');\n\t        }\n\t        if (changesCompleted) {\n\t          completeReplication();\n\t        }\n\t      }\n\t      return;\n\t    }\n\t    if (\n\t      immediate ||\n\t      changesCompleted ||\n\t      pendingBatch.changes.length >= batch_size\n\t    ) {\n\t      batches.push(pendingBatch);\n\t      pendingBatch = {\n\t        seq: 0,\n\t        changes: [],\n\t        docs: []\n\t      };\n\t      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {\n\t        returnValue.state = 'active';\n\t        returnValue.emit('active');\n\t      }\n\t      startNextBatch();\n\t    }\n\t  }\n\t\n\t\n\t  function abortReplication(reason, err) {\n\t    if (replicationCompleted) {\n\t      return;\n\t    }\n\t    if (!err.message) {\n\t      err.message = reason;\n\t    }\n\t    result.ok = false;\n\t    result.status = 'aborting';\n\t    batches = [];\n\t    pendingBatch = {\n\t      seq: 0,\n\t      changes: [],\n\t      docs: []\n\t    };\n\t    completeReplication(err);\n\t  }\n\t\n\t\n\t  function completeReplication(fatalError) {\n\t    if (replicationCompleted) {\n\t      return;\n\t    }\n\t    /* istanbul ignore if */\n\t    if (returnValue.cancelled) {\n\t      result.status = 'cancelled';\n\t      if (writingCheckpoint) {\n\t        return;\n\t      }\n\t    }\n\t    result.status = result.status || 'complete';\n\t    result.end_time = new Date();\n\t    result.last_seq = last_seq;\n\t    replicationCompleted = true;\n\t\n\t    if (fatalError) {\n\t      // need to extend the error because Firefox considers \".result\" read-only\n\t      fatalError = createError(fatalError);\n\t      fatalError.result = result;\n\t\n\t      if (fatalError.name === 'unauthorized' || fatalError.name === 'forbidden') {\n\t        returnValue.emit('error', fatalError);\n\t        returnValue.removeAllListeners();\n\t      } else {\n\t        backOff(opts, returnValue, fatalError, function () {\n\t          replicate(src, target, opts, returnValue);\n\t        });\n\t      }\n\t    } else {\n\t      returnValue.emit('complete', result);\n\t      returnValue.removeAllListeners();\n\t    }\n\t  }\n\t\n\t\n\t  function onChange(change) {\n\t    /* istanbul ignore if */\n\t    if (returnValue.cancelled) {\n\t      return completeReplication();\n\t    }\n\t    var filter = filterChange(opts)(change);\n\t    if (!filter) {\n\t      return;\n\t    }\n\t    pendingBatch.seq = change.seq;\n\t    pendingBatch.changes.push(change);\n\t    processPendingBatch(batches.length === 0 && changesOpts.live);\n\t  }\n\t\n\t\n\t  function onChangesComplete(changes) {\n\t    changesPending = false;\n\t    /* istanbul ignore if */\n\t    if (returnValue.cancelled) {\n\t      return completeReplication();\n\t    }\n\t\n\t    // if no results were returned then we're done,\n\t    // else fetch more\n\t    if (changes.results.length > 0) {\n\t      changesOpts.since = changes.last_seq;\n\t      getChanges();\n\t      processPendingBatch(true);\n\t    } else {\n\t\n\t      var complete = function () {\n\t        if (continuous) {\n\t          changesOpts.live = true;\n\t          getChanges();\n\t        } else {\n\t          changesCompleted = true;\n\t        }\n\t        processPendingBatch(true);\n\t      };\n\t\n\t      // update the checkpoint so we start from the right seq next time\n\t      if (!currentBatch && changes.results.length === 0) {\n\t        writingCheckpoint = true;\n\t        checkpointer.writeCheckpoint(changes.last_seq,\n\t            session).then(function () {\n\t          writingCheckpoint = false;\n\t          result.last_seq = last_seq = changes.last_seq;\n\t          complete();\n\t        })\n\t        .catch(onCheckpointError);\n\t      } else {\n\t        complete();\n\t      }\n\t    }\n\t  }\n\t\n\t\n\t  function onChangesError(err) {\n\t    changesPending = false;\n\t    /* istanbul ignore if */\n\t    if (returnValue.cancelled) {\n\t      return completeReplication();\n\t    }\n\t    abortReplication('changes rejected', err);\n\t  }\n\t\n\t\n\t  function getChanges() {\n\t    if (!(\n\t      !changesPending &&\n\t      !changesCompleted &&\n\t      batches.length < batches_limit\n\t      )) {\n\t      return;\n\t    }\n\t    changesPending = true;\n\t    function abortChanges() {\n\t      changes.cancel();\n\t    }\n\t    function removeListener() {\n\t      returnValue.removeListener('cancel', abortChanges);\n\t    }\n\t\n\t    if (returnValue._changes) { // remove old changes() and listeners\n\t      returnValue.removeListener('cancel', returnValue._abortChanges);\n\t      returnValue._changes.cancel();\n\t    }\n\t    returnValue.once('cancel', abortChanges);\n\t\n\t    var changes = src.changes(changesOpts)\n\t      .on('change', onChange);\n\t    changes.then(removeListener, removeListener);\n\t    changes.then(onChangesComplete)\n\t      .catch(onChangesError);\n\t\n\t    if (opts.retry) {\n\t      // save for later so we can cancel if necessary\n\t      returnValue._changes = changes;\n\t      returnValue._abortChanges = abortChanges;\n\t    }\n\t  }\n\t\n\t\n\t  function startChanges() {\n\t    initCheckpointer().then(function () {\n\t      /* istanbul ignore if */\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        return;\n\t      }\n\t      return checkpointer.getCheckpoint().then(function (checkpoint) {\n\t        last_seq = checkpoint;\n\t        changesOpts = {\n\t          since: last_seq,\n\t          limit: batch_size,\n\t          batch_size: batch_size,\n\t          style: 'all_docs',\n\t          doc_ids: doc_ids,\n\t          selector: selector,\n\t          return_docs: true // required so we know when we're done\n\t        };\n\t        if (opts.filter) {\n\t          if (typeof opts.filter !== 'string') {\n\t            // required for the client-side filter in onChange\n\t            changesOpts.include_docs = true;\n\t          } else { // ddoc filter\n\t            changesOpts.filter = opts.filter;\n\t          }\n\t        }\n\t        if ('heartbeat' in opts) {\n\t          changesOpts.heartbeat = opts.heartbeat;\n\t        }\n\t        if ('timeout' in opts) {\n\t          changesOpts.timeout = opts.timeout;\n\t        }\n\t        if (opts.query_params) {\n\t          changesOpts.query_params = opts.query_params;\n\t        }\n\t        if (opts.view) {\n\t          changesOpts.view = opts.view;\n\t        }\n\t        getChanges();\n\t      });\n\t    }).catch(function (err) {\n\t      abortReplication('getCheckpoint rejected with ', err);\n\t    });\n\t  }\n\t\n\t  /* istanbul ignore next */\n\t  function onCheckpointError(err) {\n\t    writingCheckpoint = false;\n\t    abortReplication('writeCheckpoint completed with error', err);\n\t  }\n\t\n\t  /* istanbul ignore if */\n\t  if (returnValue.cancelled) { // cancelled immediately\n\t    completeReplication();\n\t    return;\n\t  }\n\t\n\t  if (!returnValue._addedListeners) {\n\t    returnValue.once('cancel', completeReplication);\n\t\n\t    if (typeof opts.complete === 'function') {\n\t      returnValue.once('error', opts.complete);\n\t      returnValue.once('complete', function (result) {\n\t        opts.complete(null, result);\n\t      });\n\t    }\n\t    returnValue._addedListeners = true;\n\t  }\n\t\n\t  if (typeof opts.since === 'undefined') {\n\t    startChanges();\n\t  } else {\n\t    initCheckpointer().then(function () {\n\t      writingCheckpoint = true;\n\t      return checkpointer.writeCheckpoint(opts.since, session);\n\t    }).then(function () {\n\t      writingCheckpoint = false;\n\t      /* istanbul ignore if */\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        return;\n\t      }\n\t      last_seq = opts.since;\n\t      startChanges();\n\t    }).catch(onCheckpointError);\n\t  }\n\t}\n\t\n\t// We create a basic promise so the caller can cancel the replication possibly\n\t// before we have actually started listening to changes etc\n\tinherits(Replication, events.EventEmitter);\n\tfunction Replication() {\n\t  events.EventEmitter.call(this);\n\t  this.cancelled = false;\n\t  this.state = 'pending';\n\t  var self = this;\n\t  var promise = new PouchPromise$1(function (fulfill, reject) {\n\t    self.once('complete', fulfill);\n\t    self.once('error', reject);\n\t  });\n\t  self.then = function (resolve, reject) {\n\t    return promise.then(resolve, reject);\n\t  };\n\t  self.catch = function (reject) {\n\t    return promise.catch(reject);\n\t  };\n\t  // As we allow error handling via \"error\" event as well,\n\t  // put a stub in here so that rejecting never throws UnhandledError.\n\t  self.catch(function () {});\n\t}\n\t\n\tReplication.prototype.cancel = function () {\n\t  this.cancelled = true;\n\t  this.state = 'cancelled';\n\t  this.emit('cancel');\n\t};\n\t\n\tReplication.prototype.ready = function (src, target) {\n\t  var self = this;\n\t  if (self._readyCalled) {\n\t    return;\n\t  }\n\t  self._readyCalled = true;\n\t\n\t  function onDestroy() {\n\t    self.cancel();\n\t  }\n\t  src.once('destroyed', onDestroy);\n\t  target.once('destroyed', onDestroy);\n\t  function cleanup() {\n\t    src.removeListener('destroyed', onDestroy);\n\t    target.removeListener('destroyed', onDestroy);\n\t  }\n\t  self.once('complete', cleanup);\n\t};\n\t\n\tfunction toPouch(db, opts) {\n\t  var PouchConstructor = opts.PouchConstructor;\n\t  if (typeof db === 'string') {\n\t    return new PouchConstructor(db, opts);\n\t  } else {\n\t    return db;\n\t  }\n\t}\n\t\n\tfunction replicateWrapper(src, target, opts, callback) {\n\t\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  if (typeof opts === 'undefined') {\n\t    opts = {};\n\t  }\n\t\n\t  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {\n\t    throw createError(BAD_REQUEST,\n\t                       \"`doc_ids` filter parameter is not a list.\");\n\t  }\n\t\n\t  opts.complete = callback;\n\t  opts = clone(opts);\n\t  opts.continuous = opts.continuous || opts.live;\n\t  opts.retry = ('retry' in opts) ? opts.retry : false;\n\t  /*jshint validthis:true */\n\t  opts.PouchConstructor = opts.PouchConstructor || this;\n\t  var replicateRet = new Replication(opts);\n\t  var srcPouch = toPouch(src, opts);\n\t  var targetPouch = toPouch(target, opts);\n\t  replicate(srcPouch, targetPouch, opts, replicateRet);\n\t  return replicateRet;\n\t}\n\t\n\tinherits(Sync, events.EventEmitter);\n\tfunction sync$1(src, target, opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  if (typeof opts === 'undefined') {\n\t    opts = {};\n\t  }\n\t  opts = clone(opts);\n\t  /*jshint validthis:true */\n\t  opts.PouchConstructor = opts.PouchConstructor || this;\n\t  src = toPouch(src, opts);\n\t  target = toPouch(target, opts);\n\t  return new Sync(src, target, opts, callback);\n\t}\n\t\n\tfunction Sync(src, target, opts, callback) {\n\t  var self = this;\n\t  this.canceled = false;\n\t\n\t  var optsPush = opts.push ? $inject_Object_assign({}, opts, opts.push) : opts;\n\t  var optsPull = opts.pull ? $inject_Object_assign({}, opts, opts.pull) : opts;\n\t\n\t  this.push = replicateWrapper(src, target, optsPush);\n\t  this.pull = replicateWrapper(target, src, optsPull);\n\t\n\t  this.pushPaused = true;\n\t  this.pullPaused = true;\n\t\n\t  function pullChange(change) {\n\t    self.emit('change', {\n\t      direction: 'pull',\n\t      change: change\n\t    });\n\t  }\n\t  function pushChange(change) {\n\t    self.emit('change', {\n\t      direction: 'push',\n\t      change: change\n\t    });\n\t  }\n\t  function pushDenied(doc) {\n\t    self.emit('denied', {\n\t      direction: 'push',\n\t      doc: doc\n\t    });\n\t  }\n\t  function pullDenied(doc) {\n\t    self.emit('denied', {\n\t      direction: 'pull',\n\t      doc: doc\n\t    });\n\t  }\n\t  function pushPaused() {\n\t    self.pushPaused = true;\n\t    /* istanbul ignore if */\n\t    if (self.pullPaused) {\n\t      self.emit('paused');\n\t    }\n\t  }\n\t  function pullPaused() {\n\t    self.pullPaused = true;\n\t    /* istanbul ignore if */\n\t    if (self.pushPaused) {\n\t      self.emit('paused');\n\t    }\n\t  }\n\t  function pushActive() {\n\t    self.pushPaused = false;\n\t    /* istanbul ignore if */\n\t    if (self.pullPaused) {\n\t      self.emit('active', {\n\t        direction: 'push'\n\t      });\n\t    }\n\t  }\n\t  function pullActive() {\n\t    self.pullPaused = false;\n\t    /* istanbul ignore if */\n\t    if (self.pushPaused) {\n\t      self.emit('active', {\n\t        direction: 'pull'\n\t      });\n\t    }\n\t  }\n\t\n\t  var removed = {};\n\t\n\t  function removeAll(type) { // type is 'push' or 'pull'\n\t    return function (event, func) {\n\t      var isChange = event === 'change' &&\n\t        (func === pullChange || func === pushChange);\n\t      var isDenied = event === 'denied' &&\n\t        (func === pullDenied || func === pushDenied);\n\t      var isPaused = event === 'paused' &&\n\t        (func === pullPaused || func === pushPaused);\n\t      var isActive = event === 'active' &&\n\t        (func === pullActive || func === pushActive);\n\t\n\t      if (isChange || isDenied || isPaused || isActive) {\n\t        if (!(event in removed)) {\n\t          removed[event] = {};\n\t        }\n\t        removed[event][type] = true;\n\t        if (Object.keys(removed[event]).length === 2) {\n\t          // both push and pull have asked to be removed\n\t          self.removeAllListeners(event);\n\t        }\n\t      }\n\t    };\n\t  }\n\t\n\t  if (opts.live) {\n\t    this.push.on('complete', self.pull.cancel.bind(self.pull));\n\t    this.pull.on('complete', self.push.cancel.bind(self.push));\n\t  }\n\t\n\t  function addOneListener(ee, event, listener) {\n\t    if (ee.listeners(event).indexOf(listener) == -1) {\n\t      ee.on(event, listener);\n\t    }\n\t  }\n\t\n\t  this.on('newListener', function (event) {\n\t    if (event === 'change') {\n\t      addOneListener(self.pull, 'change', pullChange);\n\t      addOneListener(self.push, 'change', pushChange);\n\t    } else if (event === 'denied') {\n\t      addOneListener(self.pull, 'denied', pullDenied);\n\t      addOneListener(self.push, 'denied', pushDenied);\n\t    } else if (event === 'active') {\n\t      addOneListener(self.pull, 'active', pullActive);\n\t      addOneListener(self.push, 'active', pushActive);\n\t    } else if (event === 'paused') {\n\t      addOneListener(self.pull, 'paused', pullPaused);\n\t      addOneListener(self.push, 'paused', pushPaused);\n\t    }\n\t  });\n\t\n\t  this.on('removeListener', function (event) {\n\t    if (event === 'change') {\n\t      self.pull.removeListener('change', pullChange);\n\t      self.push.removeListener('change', pushChange);\n\t    } else if (event === 'denied') {\n\t      self.pull.removeListener('denied', pullDenied);\n\t      self.push.removeListener('denied', pushDenied);\n\t    } else if (event === 'active') {\n\t      self.pull.removeListener('active', pullActive);\n\t      self.push.removeListener('active', pushActive);\n\t    } else if (event === 'paused') {\n\t      self.pull.removeListener('paused', pullPaused);\n\t      self.push.removeListener('paused', pushPaused);\n\t    }\n\t  });\n\t\n\t  this.pull.on('removeListener', removeAll('pull'));\n\t  this.push.on('removeListener', removeAll('push'));\n\t\n\t  var promise = PouchPromise$1.all([\n\t    this.push,\n\t    this.pull\n\t  ]).then(function (resp) {\n\t    var out = {\n\t      push: resp[0],\n\t      pull: resp[1]\n\t    };\n\t    self.emit('complete', out);\n\t    if (callback) {\n\t      callback(null, out);\n\t    }\n\t    self.removeAllListeners();\n\t    return out;\n\t  }, function (err) {\n\t    self.cancel();\n\t    if (callback) {\n\t      // if there's a callback, then the callback can receive\n\t      // the error event\n\t      callback(err);\n\t    } else {\n\t      // if there's no callback, then we're safe to emit an error\n\t      // event, which would otherwise throw an unhandled error\n\t      // due to 'error' being a special event in EventEmitters\n\t      self.emit('error', err);\n\t    }\n\t    self.removeAllListeners();\n\t    if (callback) {\n\t      // no sense throwing if we're already emitting an 'error' event\n\t      throw err;\n\t    }\n\t  });\n\t\n\t  this.then = function (success, err) {\n\t    return promise.then(success, err);\n\t  };\n\t\n\t  this.catch = function (err) {\n\t    return promise.catch(err);\n\t  };\n\t}\n\t\n\tSync.prototype.cancel = function () {\n\t  if (!this.canceled) {\n\t    this.canceled = true;\n\t    this.push.cancel();\n\t    this.pull.cancel();\n\t  }\n\t};\n\t\n\tfunction replication(PouchDB) {\n\t  PouchDB.replicate = replicateWrapper;\n\t  PouchDB.sync = sync$1;\n\t\n\t  Object.defineProperty(PouchDB.prototype, 'replicate', {\n\t    get: function () {\n\t      var self = this;\n\t      return {\n\t        from: function (other, opts, callback) {\n\t          return self.constructor.replicate(other, self, opts, callback);\n\t        },\n\t        to: function (other, opts, callback) {\n\t          return self.constructor.replicate(self, other, opts, callback);\n\t        }\n\t      };\n\t    }\n\t  });\n\t\n\t  PouchDB.prototype.sync = function (dbName, opts, callback) {\n\t    return this.constructor.sync(this, dbName, opts, callback);\n\t  };\n\t}\n\t\n\tPouchDB$5.plugin(IDBPouch)\n\t  .plugin(WebSqlPouch)\n\t  .plugin(HttpPouch$1)\n\t  .plugin(mapreduce)\n\t  .plugin(replication);\n\t\n\t// Pull from src because pouchdb-node/pouchdb-browser themselves\n\t// are aggressively optimized and jsnext:main would normally give us this\n\t// aggressive bundle.\n\t\n\tmodule.exports = PouchDB$5;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar v1 = __webpack_require__(5);\n\tvar v4 = __webpack_require__(8);\n\t\n\tvar uuid = v4;\n\tuuid.v1 = v1;\n\tuuid.v4 = v4;\n\t\n\tmodule.exports = uuid;\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar rng = __webpack_require__(6);\n\tvar bytesToUuid = __webpack_require__(7);\n\t\n\t// **`v1()` - Generate time-based UUID**\n\t//\n\t// Inspired by https://github.com/LiosK/UUID.js\n\t// and http://docs.python.org/library/uuid.html\n\t\n\t// random #'s we need to init node and clockseq\n\tvar _seedBytes = rng();\n\t\n\t// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n\tvar _nodeId = [\n\t  _seedBytes[0] | 0x01,\n\t  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n\t];\n\t\n\t// Per 4.2.2, randomize (14 bit) clockseq\n\tvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\t\n\t// Previous uuid creation time\n\tvar _lastMSecs = 0, _lastNSecs = 0;\n\t\n\t// See https://github.com/broofa/node-uuid for API details\n\tfunction v1(options, buf, offset) {\n\t  var i = buf && offset || 0;\n\t  var b = buf || [];\n\t\n\t  options = options || {};\n\t\n\t  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\t\n\t  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n\t  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n\t  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n\t  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\t  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\t\n\t  // Per 4.2.1.2, use count of uuid's generated during the current clock\n\t  // cycle to simulate higher resolution clock\n\t  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\t\n\t  // Time since last uuid creation (in msecs)\n\t  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\t\n\t  // Per 4.2.1.2, Bump clockseq on clock regression\n\t  if (dt < 0 && options.clockseq === undefined) {\n\t    clockseq = clockseq + 1 & 0x3fff;\n\t  }\n\t\n\t  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n\t  // time interval\n\t  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n\t    nsecs = 0;\n\t  }\n\t\n\t  // Per 4.2.1.2 Throw error if too many uuids are requested\n\t  if (nsecs >= 10000) {\n\t    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n\t  }\n\t\n\t  _lastMSecs = msecs;\n\t  _lastNSecs = nsecs;\n\t  _clockseq = clockseq;\n\t\n\t  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\t  msecs += 12219292800000;\n\t\n\t  // `time_low`\n\t  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n\t  b[i++] = tl >>> 24 & 0xff;\n\t  b[i++] = tl >>> 16 & 0xff;\n\t  b[i++] = tl >>> 8 & 0xff;\n\t  b[i++] = tl & 0xff;\n\t\n\t  // `time_mid`\n\t  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n\t  b[i++] = tmh >>> 8 & 0xff;\n\t  b[i++] = tmh & 0xff;\n\t\n\t  // `time_high_and_version`\n\t  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\t  b[i++] = tmh >>> 16 & 0xff;\n\t\n\t  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\t  b[i++] = clockseq >>> 8 | 0x80;\n\t\n\t  // `clock_seq_low`\n\t  b[i++] = clockseq & 0xff;\n\t\n\t  // `node`\n\t  var node = options.node || _nodeId;\n\t  for (var n = 0; n < 6; ++n) {\n\t    b[i + n] = node[n];\n\t  }\n\t\n\t  return buf ? buf : bytesToUuid(b);\n\t}\n\t\n\tmodule.exports = v1;\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {// Unique ID creation requires a high quality random # generator.  In the\n\t// browser this is a little complicated due to unknown quality of Math.random()\n\t// and inconsistent support for the `crypto` API.  We do the best we can via\n\t// feature-detection\n\tvar rng;\n\t\n\tvar crypto = global.crypto || global.msCrypto; // for IE 11\n\tif (crypto && crypto.getRandomValues) {\n\t  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n\t  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\t  rng = function whatwgRNG() {\n\t    crypto.getRandomValues(rnds8);\n\t    return rnds8;\n\t  };\n\t}\n\t\n\tif (!rng) {\n\t  // Math.random()-based (RNG)\n\t  //\n\t  // If all else fails, use Math.random().  It's fast, but is of unspecified\n\t  // quality.\n\t  var rnds = new Array(16);\n\t  rng = function() {\n\t    for (var i = 0, r; i < 16; i++) {\n\t      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n\t      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n\t    }\n\t\n\t    return rnds;\n\t  };\n\t}\n\t\n\tmodule.exports = rng;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Convert array of 16 byte values to UUID string format of the form:\n\t * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n\t */\n\tvar byteToHex = [];\n\tfor (var i = 0; i < 256; ++i) {\n\t  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n\t}\n\t\n\tfunction bytesToUuid(buf, offset) {\n\t  var i = offset || 0;\n\t  var bth = byteToHex;\n\t  return bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]];\n\t}\n\t\n\tmodule.exports = bytesToUuid;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar rng = __webpack_require__(6);\n\tvar bytesToUuid = __webpack_require__(7);\n\t\n\tfunction v4(options, buf, offset) {\n\t  var i = buf && offset || 0;\n\t\n\t  if (typeof(options) == 'string') {\n\t    buf = options == 'binary' ? new Array(16) : null;\n\t    options = null;\n\t  }\n\t  options = options || {};\n\t\n\t  var rnds = options.random || (options.rng || rng)();\n\t\n\t  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n\t  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\t\n\t  // Copy bytes to buffer, if provided\n\t  if (buf) {\n\t    for (var ii = 0; ii < 16; ++ii) {\n\t      buf[i + ii] = rnds[ii];\n\t    }\n\t  }\n\t\n\t  return buf || bytesToUuid(rnds);\n\t}\n\t\n\tmodule.exports = v4;\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar immediate = __webpack_require__(10);\n\t\n\t/* istanbul ignore next */\n\tfunction INTERNAL() {}\n\t\n\tvar handlers = {};\n\t\n\tvar REJECTED = ['REJECTED'];\n\tvar FULFILLED = ['FULFILLED'];\n\tvar PENDING = ['PENDING'];\n\t\n\tmodule.exports = Promise;\n\t\n\tfunction Promise(resolver) {\n\t  if (typeof resolver !== 'function') {\n\t    throw new TypeError('resolver must be a function');\n\t  }\n\t  this.state = PENDING;\n\t  this.queue = [];\n\t  this.outcome = void 0;\n\t  if (resolver !== INTERNAL) {\n\t    safelyResolveThenable(this, resolver);\n\t  }\n\t}\n\t\n\tPromise.prototype[\"catch\"] = function (onRejected) {\n\t  return this.then(null, onRejected);\n\t};\n\tPromise.prototype.then = function (onFulfilled, onRejected) {\n\t  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n\t    typeof onRejected !== 'function' && this.state === REJECTED) {\n\t    return this;\n\t  }\n\t  var promise = new this.constructor(INTERNAL);\n\t  if (this.state !== PENDING) {\n\t    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n\t    unwrap(promise, resolver, this.outcome);\n\t  } else {\n\t    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n\t  }\n\t\n\t  return promise;\n\t};\n\tfunction QueueItem(promise, onFulfilled, onRejected) {\n\t  this.promise = promise;\n\t  if (typeof onFulfilled === 'function') {\n\t    this.onFulfilled = onFulfilled;\n\t    this.callFulfilled = this.otherCallFulfilled;\n\t  }\n\t  if (typeof onRejected === 'function') {\n\t    this.onRejected = onRejected;\n\t    this.callRejected = this.otherCallRejected;\n\t  }\n\t}\n\tQueueItem.prototype.callFulfilled = function (value) {\n\t  handlers.resolve(this.promise, value);\n\t};\n\tQueueItem.prototype.otherCallFulfilled = function (value) {\n\t  unwrap(this.promise, this.onFulfilled, value);\n\t};\n\tQueueItem.prototype.callRejected = function (value) {\n\t  handlers.reject(this.promise, value);\n\t};\n\tQueueItem.prototype.otherCallRejected = function (value) {\n\t  unwrap(this.promise, this.onRejected, value);\n\t};\n\t\n\tfunction unwrap(promise, func, value) {\n\t  immediate(function () {\n\t    var returnValue;\n\t    try {\n\t      returnValue = func(value);\n\t    } catch (e) {\n\t      return handlers.reject(promise, e);\n\t    }\n\t    if (returnValue === promise) {\n\t      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n\t    } else {\n\t      handlers.resolve(promise, returnValue);\n\t    }\n\t  });\n\t}\n\t\n\thandlers.resolve = function (self, value) {\n\t  var result = tryCatch(getThen, value);\n\t  if (result.status === 'error') {\n\t    return handlers.reject(self, result.value);\n\t  }\n\t  var thenable = result.value;\n\t\n\t  if (thenable) {\n\t    safelyResolveThenable(self, thenable);\n\t  } else {\n\t    self.state = FULFILLED;\n\t    self.outcome = value;\n\t    var i = -1;\n\t    var len = self.queue.length;\n\t    while (++i < len) {\n\t      self.queue[i].callFulfilled(value);\n\t    }\n\t  }\n\t  return self;\n\t};\n\thandlers.reject = function (self, error) {\n\t  self.state = REJECTED;\n\t  self.outcome = error;\n\t  var i = -1;\n\t  var len = self.queue.length;\n\t  while (++i < len) {\n\t    self.queue[i].callRejected(error);\n\t  }\n\t  return self;\n\t};\n\t\n\tfunction getThen(obj) {\n\t  // Make sure we only access the accessor once as required by the spec\n\t  var then = obj && obj.then;\n\t  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n\t    return function appyThen() {\n\t      then.apply(obj, arguments);\n\t    };\n\t  }\n\t}\n\t\n\tfunction safelyResolveThenable(self, thenable) {\n\t  // Either fulfill, reject or reject with error\n\t  var called = false;\n\t  function onError(value) {\n\t    if (called) {\n\t      return;\n\t    }\n\t    called = true;\n\t    handlers.reject(self, value);\n\t  }\n\t\n\t  function onSuccess(value) {\n\t    if (called) {\n\t      return;\n\t    }\n\t    called = true;\n\t    handlers.resolve(self, value);\n\t  }\n\t\n\t  function tryToUnwrap() {\n\t    thenable(onSuccess, onError);\n\t  }\n\t\n\t  var result = tryCatch(tryToUnwrap);\n\t  if (result.status === 'error') {\n\t    onError(result.value);\n\t  }\n\t}\n\t\n\tfunction tryCatch(func, value) {\n\t  var out = {};\n\t  try {\n\t    out.value = func(value);\n\t    out.status = 'success';\n\t  } catch (e) {\n\t    out.status = 'error';\n\t    out.value = e;\n\t  }\n\t  return out;\n\t}\n\t\n\tPromise.resolve = resolve;\n\tfunction resolve(value) {\n\t  if (value instanceof this) {\n\t    return value;\n\t  }\n\t  return handlers.resolve(new this(INTERNAL), value);\n\t}\n\t\n\tPromise.reject = reject;\n\tfunction reject(reason) {\n\t  var promise = new this(INTERNAL);\n\t  return handlers.reject(promise, reason);\n\t}\n\t\n\tPromise.all = all;\n\tfunction all(iterable) {\n\t  var self = this;\n\t  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n\t    return this.reject(new TypeError('must be an array'));\n\t  }\n\t\n\t  var len = iterable.length;\n\t  var called = false;\n\t  if (!len) {\n\t    return this.resolve([]);\n\t  }\n\t\n\t  var values = new Array(len);\n\t  var resolved = 0;\n\t  var i = -1;\n\t  var promise = new this(INTERNAL);\n\t\n\t  while (++i < len) {\n\t    allResolver(iterable[i], i);\n\t  }\n\t  return promise;\n\t  function allResolver(value, i) {\n\t    self.resolve(value).then(resolveFromAll, function (error) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.reject(promise, error);\n\t      }\n\t    });\n\t    function resolveFromAll(outValue) {\n\t      values[i] = outValue;\n\t      if (++resolved === len && !called) {\n\t        called = true;\n\t        handlers.resolve(promise, values);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tPromise.race = race;\n\tfunction race(iterable) {\n\t  var self = this;\n\t  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n\t    return this.reject(new TypeError('must be an array'));\n\t  }\n\t\n\t  var len = iterable.length;\n\t  var called = false;\n\t  if (!len) {\n\t    return this.resolve([]);\n\t  }\n\t\n\t  var i = -1;\n\t  var promise = new this(INTERNAL);\n\t\n\t  while (++i < len) {\n\t    resolver(iterable[i]);\n\t  }\n\t  return promise;\n\t  function resolver(value) {\n\t    self.resolve(value).then(function (response) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.resolve(promise, response);\n\t      }\n\t    }, function (error) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.reject(promise, error);\n\t      }\n\t    });\n\t  }\n\t}\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\tvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\t\n\tvar scheduleDrain;\n\t\n\t{\n\t  if (Mutation) {\n\t    var called = 0;\n\t    var observer = new Mutation(nextTick);\n\t    var element = global.document.createTextNode('');\n\t    observer.observe(element, {\n\t      characterData: true\n\t    });\n\t    scheduleDrain = function () {\n\t      element.data = (called = ++called % 2);\n\t    };\n\t  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n\t    var channel = new global.MessageChannel();\n\t    channel.port1.onmessage = nextTick;\n\t    scheduleDrain = function () {\n\t      channel.port2.postMessage(0);\n\t    };\n\t  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n\t    scheduleDrain = function () {\n\t\n\t      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n\t      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n\t      var scriptEl = global.document.createElement('script');\n\t      scriptEl.onreadystatechange = function () {\n\t        nextTick();\n\t\n\t        scriptEl.onreadystatechange = null;\n\t        scriptEl.parentNode.removeChild(scriptEl);\n\t        scriptEl = null;\n\t      };\n\t      global.document.documentElement.appendChild(scriptEl);\n\t    };\n\t  } else {\n\t    scheduleDrain = function () {\n\t      setTimeout(nextTick, 0);\n\t    };\n\t  }\n\t}\n\t\n\tvar draining;\n\tvar queue = [];\n\t//named nextTick for less confusing stack traces\n\tfunction nextTick() {\n\t  draining = true;\n\t  var i, oldQueue;\n\t  var len = queue.length;\n\t  while (len) {\n\t    oldQueue = queue;\n\t    queue = [];\n\t    i = -1;\n\t    while (++i < len) {\n\t      oldQueue[i]();\n\t    }\n\t    len = queue.length;\n\t  }\n\t  draining = false;\n\t}\n\t\n\tmodule.exports = immediate;\n\tfunction immediate(task) {\n\t  if (queue.push(task) === 1 && !draining) {\n\t    scheduleDrain();\n\t  }\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = argsArray;\n\t\n\tfunction argsArray(fun) {\n\t  return function () {\n\t    var len = arguments.length;\n\t    if (len) {\n\t      var args = [];\n\t      var i = -1;\n\t      while (++i < len) {\n\t        args[i] = arguments[i];\n\t      }\n\t      return fun.call(this, args);\n\t    } else {\n\t      return fun.call(this, []);\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tfunction EventEmitter() {\n\t  this._events = this._events || {};\n\t  this._maxListeners = this._maxListeners || undefined;\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!isNumber(n) || n < 0 || isNaN(n))\n\t    throw TypeError('n must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var er, handler, len, args, i, listeners;\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error') {\n\t    if (!this._events.error ||\n\t        (isObject(this._events.error) && !this._events.error.length)) {\n\t      er = arguments[1];\n\t      if (er instanceof Error) {\n\t        throw er; // Unhandled 'error' event\n\t      } else {\n\t        // At least give some kind of context to the user\n\t        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n\t        err.context = er;\n\t        throw err;\n\t      }\n\t    }\n\t  }\n\t\n\t  handler = this._events[type];\n\t\n\t  if (isUndefined(handler))\n\t    return false;\n\t\n\t  if (isFunction(handler)) {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        args = Array.prototype.slice.call(arguments, 1);\n\t        handler.apply(this, args);\n\t    }\n\t  } else if (isObject(handler)) {\n\t    args = Array.prototype.slice.call(arguments, 1);\n\t    listeners = handler.slice();\n\t    len = listeners.length;\n\t    for (i = 0; i < len; i++)\n\t      listeners[i].apply(this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  var m;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // To avoid recursion in the case that type === \"newListener\"! Before\n\t  // adding it to the listeners, first emit \"newListener\".\n\t  if (this._events.newListener)\n\t    this.emit('newListener', type,\n\t              isFunction(listener.listener) ?\n\t              listener.listener : listener);\n\t\n\t  if (!this._events[type])\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  else if (isObject(this._events[type]))\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t  else\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t\n\t  // Check for listener leak\n\t  if (isObject(this._events[type]) && !this._events[type].warned) {\n\t    if (!isUndefined(this._maxListeners)) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = EventEmitter.defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t      console.error('(node) warning: possible EventEmitter memory ' +\n\t                    'leak detected. %d listeners added. ' +\n\t                    'Use emitter.setMaxListeners() to increase limit.',\n\t                    this._events[type].length);\n\t      if (typeof console.trace === 'function') {\n\t        // not supported in IE 10\n\t        console.trace();\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  var list, position, length, i;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events || !this._events[type])\n\t    return this;\n\t\n\t  list = this._events[type];\n\t  length = list.length;\n\t  position = -1;\n\t\n\t  if (list === listener ||\n\t      (isFunction(list.listener) && list.listener === listener)) {\n\t    delete this._events[type];\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t\n\t  } else if (isObject(list)) {\n\t    for (i = length; i-- > 0;) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener)) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0)\n\t      return this;\n\t\n\t    if (list.length === 1) {\n\t      list.length = 0;\n\t      delete this._events[type];\n\t    } else {\n\t      list.splice(position, 1);\n\t    }\n\t\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  var key, listeners;\n\t\n\t  if (!this._events)\n\t    return this;\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!this._events.removeListener) {\n\t    if (arguments.length === 0)\n\t      this._events = {};\n\t    else if (this._events[type])\n\t      delete this._events[type];\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    for (key in this._events) {\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  listeners = this._events[type];\n\t\n\t  if (isFunction(listeners)) {\n\t    this.removeListener(type, listeners);\n\t  } else if (listeners) {\n\t    // LIFO order\n\t    while (listeners.length)\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t  }\n\t  delete this._events[type];\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  var ret;\n\t  if (!this._events || !this._events[type])\n\t    ret = [];\n\t  else if (isFunction(this._events[type]))\n\t    ret = [this._events[type]];\n\t  else\n\t    ret = this._events[type].slice();\n\t  return ret;\n\t};\n\t\n\tEventEmitter.prototype.listenerCount = function(type) {\n\t  if (this._events) {\n\t    var evlistener = this._events[type];\n\t\n\t    if (isFunction(evlistener))\n\t      return 1;\n\t    else if (evlistener)\n\t      return evlistener.length;\n\t  }\n\t  return 0;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  return emitter.listenerCount(type);\n\t};\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\tif (typeof Object.create === 'function') {\n\t  // implementation from standard node.js 'util' module\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    ctor.prototype = Object.create(superCtor.prototype, {\n\t      constructor: {\n\t        value: ctor,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t  };\n\t} else {\n\t  // old school shim for old browsers\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    var TempCtor = function () {}\n\t    TempCtor.prototype = superCtor.prototype\n\t    ctor.prototype = new TempCtor()\n\t    ctor.prototype.constructor = ctor\n\t  }\n\t}\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {/**\n\t * This is the web browser implementation of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = __webpack_require__(15);\n\texports.log = log;\n\texports.formatArgs = formatArgs;\n\texports.save = save;\n\texports.load = load;\n\texports.useColors = useColors;\n\texports.storage = 'undefined' != typeof chrome\n\t               && 'undefined' != typeof chrome.storage\n\t                  ? chrome.storage.local\n\t                  : localstorage();\n\t\n\t/**\n\t * Colors.\n\t */\n\t\n\texports.colors = [\n\t  'lightseagreen',\n\t  'forestgreen',\n\t  'goldenrod',\n\t  'dodgerblue',\n\t  'darkorchid',\n\t  'crimson'\n\t];\n\t\n\t/**\n\t * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n\t * and the Firebug extension (any Firefox version) are known\n\t * to support \"%c\" CSS customizations.\n\t *\n\t * TODO: add a `localStorage` variable to explicitly enable/disable colors\n\t */\n\t\n\tfunction useColors() {\n\t  // NB: In an Electron preload script, document will be defined but not fully\n\t  // initialized. Since we know we're in Chrome, we'll just detect this case\n\t  // explicitly\n\t  if (typeof window !== 'undefined' && window && typeof window.process !== 'undefined' && window.process.type === 'renderer') {\n\t    return true;\n\t  }\n\t\n\t  // is webkit? http://stackoverflow.com/a/16459606/376773\n\t  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\t  return (typeof document !== 'undefined' && document && 'WebkitAppearance' in document.documentElement.style) ||\n\t    // is firebug? http://stackoverflow.com/a/398120/376773\n\t    (typeof window !== 'undefined' && window && window.console && (console.firebug || (console.exception && console.table))) ||\n\t    // is firefox >= v31?\n\t    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t    // double check webkit in userAgent just in case we are in a worker\n\t    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n\t}\n\t\n\t/**\n\t * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n\t */\n\t\n\texports.formatters.j = function(v) {\n\t  try {\n\t    return JSON.stringify(v);\n\t  } catch (err) {\n\t    return '[UnexpectedJSONParseError]: ' + err.message;\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Colorize log arguments if enabled.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction formatArgs(args) {\n\t  var useColors = this.useColors;\n\t\n\t  args[0] = (useColors ? '%c' : '')\n\t    + this.namespace\n\t    + (useColors ? ' %c' : ' ')\n\t    + args[0]\n\t    + (useColors ? '%c ' : ' ')\n\t    + '+' + exports.humanize(this.diff);\n\t\n\t  if (!useColors) return;\n\t\n\t  var c = 'color: ' + this.color;\n\t  args.splice(1, 0, c, 'color: inherit')\n\t\n\t  // the final \"%c\" is somewhat tricky, because there could be other\n\t  // arguments passed either before or after the %c, so we need to\n\t  // figure out the correct index to insert the CSS into\n\t  var index = 0;\n\t  var lastC = 0;\n\t  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n\t    if ('%%' === match) return;\n\t    index++;\n\t    if ('%c' === match) {\n\t      // we only are interested in the *last* %c\n\t      // (the user may have provided their own)\n\t      lastC = index;\n\t    }\n\t  });\n\t\n\t  args.splice(lastC, 0, c);\n\t}\n\t\n\t/**\n\t * Invokes `console.log()` when available.\n\t * No-op when `console.log` is not a \"function\".\n\t *\n\t * @api public\n\t */\n\t\n\tfunction log() {\n\t  // this hackery is required for IE8/9, where\n\t  // the `console.log` function doesn't have 'apply'\n\t  return 'object' === typeof console\n\t    && console.log\n\t    && Function.prototype.apply.call(console.log, console, arguments);\n\t}\n\t\n\t/**\n\t * Save `namespaces`.\n\t *\n\t * @param {String} namespaces\n\t * @api private\n\t */\n\t\n\tfunction save(namespaces) {\n\t  try {\n\t    if (null == namespaces) {\n\t      exports.storage.removeItem('debug');\n\t    } else {\n\t      exports.storage.debug = namespaces;\n\t    }\n\t  } catch(e) {}\n\t}\n\t\n\t/**\n\t * Load `namespaces`.\n\t *\n\t * @return {String} returns the previously persisted debug modes\n\t * @api private\n\t */\n\t\n\tfunction load() {\n\t  var r;\n\t  try {\n\t    r = exports.storage.debug;\n\t  } catch(e) {}\n\t\n\t  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\t  if (!r && typeof process !== 'undefined' && 'env' in process) {\n\t    r = process.env.DEBUG;\n\t  }\n\t\n\t  return r;\n\t}\n\t\n\t/**\n\t * Enable namespaces listed in `localStorage.debug` initially.\n\t */\n\t\n\texports.enable(load());\n\t\n\t/**\n\t * Localstorage attempts to return the localstorage.\n\t *\n\t * This is necessary because safari throws\n\t * when a user disables cookies/localstorage\n\t * and you attempt to access it.\n\t *\n\t * @return {LocalStorage}\n\t * @api private\n\t */\n\t\n\tfunction localstorage() {\n\t  try {\n\t    return window.localStorage;\n\t  } catch (e) {}\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * This is the common logic for both the Node.js and web browser\n\t * implementations of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\n\texports.coerce = coerce;\n\texports.disable = disable;\n\texports.enable = enable;\n\texports.enabled = enabled;\n\texports.humanize = __webpack_require__(16);\n\t\n\t/**\n\t * The currently active debug mode names, and names to skip.\n\t */\n\t\n\texports.names = [];\n\texports.skips = [];\n\t\n\t/**\n\t * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t *\n\t * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t */\n\t\n\texports.formatters = {};\n\t\n\t/**\n\t * Previous log timestamp.\n\t */\n\t\n\tvar prevTime;\n\t\n\t/**\n\t * Select a color.\n\t * @param {String} namespace\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction selectColor(namespace) {\n\t  var hash = 0, i;\n\t\n\t  for (i in namespace) {\n\t    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t    hash |= 0; // Convert to 32bit integer\n\t  }\n\t\n\t  return exports.colors[Math.abs(hash) % exports.colors.length];\n\t}\n\t\n\t/**\n\t * Create a debugger with the given `namespace`.\n\t *\n\t * @param {String} namespace\n\t * @return {Function}\n\t * @api public\n\t */\n\t\n\tfunction createDebug(namespace) {\n\t\n\t  function debug() {\n\t    // disabled?\n\t    if (!debug.enabled) return;\n\t\n\t    var self = debug;\n\t\n\t    // set `diff` timestamp\n\t    var curr = +new Date();\n\t    var ms = curr - (prevTime || curr);\n\t    self.diff = ms;\n\t    self.prev = prevTime;\n\t    self.curr = curr;\n\t    prevTime = curr;\n\t\n\t    // turn the `arguments` into a proper Array\n\t    var args = new Array(arguments.length);\n\t    for (var i = 0; i < args.length; i++) {\n\t      args[i] = arguments[i];\n\t    }\n\t\n\t    args[0] = exports.coerce(args[0]);\n\t\n\t    if ('string' !== typeof args[0]) {\n\t      // anything else let's inspect with %O\n\t      args.unshift('%O');\n\t    }\n\t\n\t    // apply any `formatters` transformations\n\t    var index = 0;\n\t    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n\t      // if we encounter an escaped % then don't increase the array index\n\t      if (match === '%%') return match;\n\t      index++;\n\t      var formatter = exports.formatters[format];\n\t      if ('function' === typeof formatter) {\n\t        var val = args[index];\n\t        match = formatter.call(self, val);\n\t\n\t        // now we need to remove `args[index]` since it's inlined in the `format`\n\t        args.splice(index, 1);\n\t        index--;\n\t      }\n\t      return match;\n\t    });\n\t\n\t    // apply env-specific formatting (colors, etc.)\n\t    exports.formatArgs.call(self, args);\n\t\n\t    var logFn = debug.log || exports.log || console.log.bind(console);\n\t    logFn.apply(self, args);\n\t  }\n\t\n\t  debug.namespace = namespace;\n\t  debug.enabled = exports.enabled(namespace);\n\t  debug.useColors = exports.useColors();\n\t  debug.color = selectColor(namespace);\n\t\n\t  // env-specific initialization logic for debug instances\n\t  if ('function' === typeof exports.init) {\n\t    exports.init(debug);\n\t  }\n\t\n\t  return debug;\n\t}\n\t\n\t/**\n\t * Enables a debug mode by namespaces. This can include modes\n\t * separated by a colon and wildcards.\n\t *\n\t * @param {String} namespaces\n\t * @api public\n\t */\n\t\n\tfunction enable(namespaces) {\n\t  exports.save(namespaces);\n\t\n\t  exports.names = [];\n\t  exports.skips = [];\n\t\n\t  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t  var len = split.length;\n\t\n\t  for (var i = 0; i < len; i++) {\n\t    if (!split[i]) continue; // ignore empty strings\n\t    namespaces = split[i].replace(/\\*/g, '.*?');\n\t    if (namespaces[0] === '-') {\n\t      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t    } else {\n\t      exports.names.push(new RegExp('^' + namespaces + '$'));\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Disable debug output.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction disable() {\n\t  exports.enable('');\n\t}\n\t\n\t/**\n\t * Returns true if the given mode name is enabled, false otherwise.\n\t *\n\t * @param {String} name\n\t * @return {Boolean}\n\t * @api public\n\t */\n\t\n\tfunction enabled(name) {\n\t  var i, len;\n\t  for (i = 0, len = exports.skips.length; i < len; i++) {\n\t    if (exports.skips[i].test(name)) {\n\t      return false;\n\t    }\n\t  }\n\t  for (i = 0, len = exports.names.length; i < len; i++) {\n\t    if (exports.names[i].test(name)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t * Coerce `val`.\n\t *\n\t * @param {Mixed} val\n\t * @return {Mixed}\n\t * @api private\n\t */\n\t\n\tfunction coerce(val) {\n\t  if (val instanceof Error) return val.stack || val.message;\n\t  return val;\n\t}\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Helpers.\n\t */\n\t\n\tvar s = 1000\n\tvar m = s * 60\n\tvar h = m * 60\n\tvar d = h * 24\n\tvar y = d * 365.25\n\t\n\t/**\n\t * Parse or format the given `val`.\n\t *\n\t * Options:\n\t *\n\t *  - `long` verbose formatting [false]\n\t *\n\t * @param {String|Number} val\n\t * @param {Object} [options]\n\t * @throws {Error} throw an error if val is not a non-empty string or a number\n\t * @return {String|Number}\n\t * @api public\n\t */\n\t\n\tmodule.exports = function (val, options) {\n\t  options = options || {}\n\t  var type = typeof val\n\t  if (type === 'string' && val.length > 0) {\n\t    return parse(val)\n\t  } else if (type === 'number' && isNaN(val) === false) {\n\t    return options.long ?\n\t\t\t\tfmtLong(val) :\n\t\t\t\tfmtShort(val)\n\t  }\n\t  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))\n\t}\n\t\n\t/**\n\t * Parse the given `str` and return milliseconds.\n\t *\n\t * @param {String} str\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction parse(str) {\n\t  str = String(str)\n\t  if (str.length > 10000) {\n\t    return\n\t  }\n\t  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)\n\t  if (!match) {\n\t    return\n\t  }\n\t  var n = parseFloat(match[1])\n\t  var type = (match[2] || 'ms').toLowerCase()\n\t  switch (type) {\n\t    case 'years':\n\t    case 'year':\n\t    case 'yrs':\n\t    case 'yr':\n\t    case 'y':\n\t      return n * y\n\t    case 'days':\n\t    case 'day':\n\t    case 'd':\n\t      return n * d\n\t    case 'hours':\n\t    case 'hour':\n\t    case 'hrs':\n\t    case 'hr':\n\t    case 'h':\n\t      return n * h\n\t    case 'minutes':\n\t    case 'minute':\n\t    case 'mins':\n\t    case 'min':\n\t    case 'm':\n\t      return n * m\n\t    case 'seconds':\n\t    case 'second':\n\t    case 'secs':\n\t    case 'sec':\n\t    case 's':\n\t      return n * s\n\t    case 'milliseconds':\n\t    case 'millisecond':\n\t    case 'msecs':\n\t    case 'msec':\n\t    case 'ms':\n\t      return n\n\t    default:\n\t      return undefined\n\t  }\n\t}\n\t\n\t/**\n\t * Short format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction fmtShort(ms) {\n\t  if (ms >= d) {\n\t    return Math.round(ms / d) + 'd'\n\t  }\n\t  if (ms >= h) {\n\t    return Math.round(ms / h) + 'h'\n\t  }\n\t  if (ms >= m) {\n\t    return Math.round(ms / m) + 'm'\n\t  }\n\t  if (ms >= s) {\n\t    return Math.round(ms / s) + 's'\n\t  }\n\t  return ms + 'ms'\n\t}\n\t\n\t/**\n\t * Long format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction fmtLong(ms) {\n\t  return plural(ms, d, 'day') ||\n\t    plural(ms, h, 'hour') ||\n\t    plural(ms, m, 'minute') ||\n\t    plural(ms, s, 'second') ||\n\t    ms + ' ms'\n\t}\n\t\n\t/**\n\t * Pluralization helper.\n\t */\n\t\n\tfunction plural(ms, n, name) {\n\t  if (ms < n) {\n\t    return\n\t  }\n\t  if (ms < n * 1.5) {\n\t    return Math.floor(ms / n) + ' ' + name\n\t  }\n\t  return Math.ceil(ms / n) + ' ' + name + 's'\n\t}\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function (factory) {\n\t    if (true) {\n\t        // Node/CommonJS\n\t        module.exports = factory();\n\t    } else if (typeof define === 'function' && define.amd) {\n\t        // AMD\n\t        define(factory);\n\t    } else {\n\t        // Browser globals (with support for web workers)\n\t        var glob;\n\t\n\t        try {\n\t            glob = window;\n\t        } catch (e) {\n\t            glob = self;\n\t        }\n\t\n\t        glob.SparkMD5 = factory();\n\t    }\n\t}(function (undefined) {\n\t\n\t    'use strict';\n\t\n\t    /*\n\t     * Fastest md5 implementation around (JKM md5).\n\t     * Credits: Joseph Myers\n\t     *\n\t     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n\t     * @see http://jsperf.com/md5-shootout/7\n\t     */\n\t\n\t    /* this function is much faster,\n\t      so if possible we use it. Some IEs\n\t      are the only ones I know of that\n\t      need the idiotic second function,\n\t      generated by an if clause.  */\n\t    var add32 = function (a, b) {\n\t        return (a + b) & 0xFFFFFFFF;\n\t    },\n\t        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\t\n\t\n\t    function cmn(q, a, b, x, s, t) {\n\t        a = add32(add32(a, q), add32(x, t));\n\t        return add32((a << s) | (a >>> (32 - s)), b);\n\t    }\n\t\n\t    function md5cycle(x, k) {\n\t        var a = x[0],\n\t            b = x[1],\n\t            c = x[2],\n\t            d = x[3];\n\t\n\t        a += (b & c | ~b & d) + k[0] - 680876936 | 0;\n\t        a  = (a << 7 | a >>> 25) + b | 0;\n\t        d += (a & b | ~a & c) + k[1] - 389564586 | 0;\n\t        d  = (d << 12 | d >>> 20) + a | 0;\n\t        c += (d & a | ~d & b) + k[2] + 606105819 | 0;\n\t        c  = (c << 17 | c >>> 15) + d | 0;\n\t        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;\n\t        b  = (b << 22 | b >>> 10) + c | 0;\n\t        a += (b & c | ~b & d) + k[4] - 176418897 | 0;\n\t        a  = (a << 7 | a >>> 25) + b | 0;\n\t        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;\n\t        d  = (d << 12 | d >>> 20) + a | 0;\n\t        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;\n\t        c  = (c << 17 | c >>> 15) + d | 0;\n\t        b += (c & d | ~c & a) + k[7] - 45705983 | 0;\n\t        b  = (b << 22 | b >>> 10) + c | 0;\n\t        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;\n\t        a  = (a << 7 | a >>> 25) + b | 0;\n\t        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;\n\t        d  = (d << 12 | d >>> 20) + a | 0;\n\t        c += (d & a | ~d & b) + k[10] - 42063 | 0;\n\t        c  = (c << 17 | c >>> 15) + d | 0;\n\t        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;\n\t        b  = (b << 22 | b >>> 10) + c | 0;\n\t        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;\n\t        a  = (a << 7 | a >>> 25) + b | 0;\n\t        d += (a & b | ~a & c) + k[13] - 40341101 | 0;\n\t        d  = (d << 12 | d >>> 20) + a | 0;\n\t        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;\n\t        c  = (c << 17 | c >>> 15) + d | 0;\n\t        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;\n\t        b  = (b << 22 | b >>> 10) + c | 0;\n\t\n\t        a += (b & d | c & ~d) + k[1] - 165796510 | 0;\n\t        a  = (a << 5 | a >>> 27) + b | 0;\n\t        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;\n\t        d  = (d << 9 | d >>> 23) + a | 0;\n\t        c += (d & b | a & ~b) + k[11] + 643717713 | 0;\n\t        c  = (c << 14 | c >>> 18) + d | 0;\n\t        b += (c & a | d & ~a) + k[0] - 373897302 | 0;\n\t        b  = (b << 20 | b >>> 12) + c | 0;\n\t        a += (b & d | c & ~d) + k[5] - 701558691 | 0;\n\t        a  = (a << 5 | a >>> 27) + b | 0;\n\t        d += (a & c | b & ~c) + k[10] + 38016083 | 0;\n\t        d  = (d << 9 | d >>> 23) + a | 0;\n\t        c += (d & b | a & ~b) + k[15] - 660478335 | 0;\n\t        c  = (c << 14 | c >>> 18) + d | 0;\n\t        b += (c & a | d & ~a) + k[4] - 405537848 | 0;\n\t        b  = (b << 20 | b >>> 12) + c | 0;\n\t        a += (b & d | c & ~d) + k[9] + 568446438 | 0;\n\t        a  = (a << 5 | a >>> 27) + b | 0;\n\t        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;\n\t        d  = (d << 9 | d >>> 23) + a | 0;\n\t        c += (d & b | a & ~b) + k[3] - 187363961 | 0;\n\t        c  = (c << 14 | c >>> 18) + d | 0;\n\t        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;\n\t        b  = (b << 20 | b >>> 12) + c | 0;\n\t        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;\n\t        a  = (a << 5 | a >>> 27) + b | 0;\n\t        d += (a & c | b & ~c) + k[2] - 51403784 | 0;\n\t        d  = (d << 9 | d >>> 23) + a | 0;\n\t        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;\n\t        c  = (c << 14 | c >>> 18) + d | 0;\n\t        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;\n\t        b  = (b << 20 | b >>> 12) + c | 0;\n\t\n\t        a += (b ^ c ^ d) + k[5] - 378558 | 0;\n\t        a  = (a << 4 | a >>> 28) + b | 0;\n\t        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;\n\t        d  = (d << 11 | d >>> 21) + a | 0;\n\t        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;\n\t        c  = (c << 16 | c >>> 16) + d | 0;\n\t        b += (c ^ d ^ a) + k[14] - 35309556 | 0;\n\t        b  = (b << 23 | b >>> 9) + c | 0;\n\t        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;\n\t        a  = (a << 4 | a >>> 28) + b | 0;\n\t        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;\n\t        d  = (d << 11 | d >>> 21) + a | 0;\n\t        c += (d ^ a ^ b) + k[7] - 155497632 | 0;\n\t        c  = (c << 16 | c >>> 16) + d | 0;\n\t        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;\n\t        b  = (b << 23 | b >>> 9) + c | 0;\n\t        a += (b ^ c ^ d) + k[13] + 681279174 | 0;\n\t        a  = (a << 4 | a >>> 28) + b | 0;\n\t        d += (a ^ b ^ c) + k[0] - 358537222 | 0;\n\t        d  = (d << 11 | d >>> 21) + a | 0;\n\t        c += (d ^ a ^ b) + k[3] - 722521979 | 0;\n\t        c  = (c << 16 | c >>> 16) + d | 0;\n\t        b += (c ^ d ^ a) + k[6] + 76029189 | 0;\n\t        b  = (b << 23 | b >>> 9) + c | 0;\n\t        a += (b ^ c ^ d) + k[9] - 640364487 | 0;\n\t        a  = (a << 4 | a >>> 28) + b | 0;\n\t        d += (a ^ b ^ c) + k[12] - 421815835 | 0;\n\t        d  = (d << 11 | d >>> 21) + a | 0;\n\t        c += (d ^ a ^ b) + k[15] + 530742520 | 0;\n\t        c  = (c << 16 | c >>> 16) + d | 0;\n\t        b += (c ^ d ^ a) + k[2] - 995338651 | 0;\n\t        b  = (b << 23 | b >>> 9) + c | 0;\n\t\n\t        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;\n\t        a  = (a << 6 | a >>> 26) + b | 0;\n\t        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;\n\t        d  = (d << 10 | d >>> 22) + a | 0;\n\t        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;\n\t        c  = (c << 15 | c >>> 17) + d | 0;\n\t        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;\n\t        b  = (b << 21 |b >>> 11) + c | 0;\n\t        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;\n\t        a  = (a << 6 | a >>> 26) + b | 0;\n\t        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;\n\t        d  = (d << 10 | d >>> 22) + a | 0;\n\t        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;\n\t        c  = (c << 15 | c >>> 17) + d | 0;\n\t        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;\n\t        b  = (b << 21 |b >>> 11) + c | 0;\n\t        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;\n\t        a  = (a << 6 | a >>> 26) + b | 0;\n\t        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;\n\t        d  = (d << 10 | d >>> 22) + a | 0;\n\t        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;\n\t        c  = (c << 15 | c >>> 17) + d | 0;\n\t        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;\n\t        b  = (b << 21 |b >>> 11) + c | 0;\n\t        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;\n\t        a  = (a << 6 | a >>> 26) + b | 0;\n\t        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;\n\t        d  = (d << 10 | d >>> 22) + a | 0;\n\t        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;\n\t        c  = (c << 15 | c >>> 17) + d | 0;\n\t        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;\n\t        b  = (b << 21 | b >>> 11) + c | 0;\n\t\n\t        x[0] = a + x[0] | 0;\n\t        x[1] = b + x[1] | 0;\n\t        x[2] = c + x[2] | 0;\n\t        x[3] = d + x[3] | 0;\n\t    }\n\t\n\t    function md5blk(s) {\n\t        var md5blks = [],\n\t            i; /* Andy King said do it this way. */\n\t\n\t        for (i = 0; i < 64; i += 4) {\n\t            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n\t        }\n\t        return md5blks;\n\t    }\n\t\n\t    function md5blk_array(a) {\n\t        var md5blks = [],\n\t            i; /* Andy King said do it this way. */\n\t\n\t        for (i = 0; i < 64; i += 4) {\n\t            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n\t        }\n\t        return md5blks;\n\t    }\n\t\n\t    function md51(s) {\n\t        var n = s.length,\n\t            state = [1732584193, -271733879, -1732584194, 271733878],\n\t            i,\n\t            length,\n\t            tail,\n\t            tmp,\n\t            lo,\n\t            hi;\n\t\n\t        for (i = 64; i <= n; i += 64) {\n\t            md5cycle(state, md5blk(s.substring(i - 64, i)));\n\t        }\n\t        s = s.substring(i - 64);\n\t        length = s.length;\n\t        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n\t        }\n\t        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n\t        if (i > 55) {\n\t            md5cycle(state, tail);\n\t            for (i = 0; i < 16; i += 1) {\n\t                tail[i] = 0;\n\t            }\n\t        }\n\t\n\t        // Beware that the final length might not fit in 32 bits so we take care of that\n\t        tmp = n * 8;\n\t        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n\t        lo = parseInt(tmp[2], 16);\n\t        hi = parseInt(tmp[1], 16) || 0;\n\t\n\t        tail[14] = lo;\n\t        tail[15] = hi;\n\t\n\t        md5cycle(state, tail);\n\t        return state;\n\t    }\n\t\n\t    function md51_array(a) {\n\t        var n = a.length,\n\t            state = [1732584193, -271733879, -1732584194, 271733878],\n\t            i,\n\t            length,\n\t            tail,\n\t            tmp,\n\t            lo,\n\t            hi;\n\t\n\t        for (i = 64; i <= n; i += 64) {\n\t            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n\t        }\n\t\n\t        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n\t        // containing the last element of the parent array if the sub array specified starts\n\t        // beyond the length of the parent array - weird.\n\t        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n\t        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\t\n\t        length = a.length;\n\t        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n\t        }\n\t\n\t        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n\t        if (i > 55) {\n\t            md5cycle(state, tail);\n\t            for (i = 0; i < 16; i += 1) {\n\t                tail[i] = 0;\n\t            }\n\t        }\n\t\n\t        // Beware that the final length might not fit in 32 bits so we take care of that\n\t        tmp = n * 8;\n\t        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n\t        lo = parseInt(tmp[2], 16);\n\t        hi = parseInt(tmp[1], 16) || 0;\n\t\n\t        tail[14] = lo;\n\t        tail[15] = hi;\n\t\n\t        md5cycle(state, tail);\n\t\n\t        return state;\n\t    }\n\t\n\t    function rhex(n) {\n\t        var s = '',\n\t            j;\n\t        for (j = 0; j < 4; j += 1) {\n\t            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n\t        }\n\t        return s;\n\t    }\n\t\n\t    function hex(x) {\n\t        var i;\n\t        for (i = 0; i < x.length; i += 1) {\n\t            x[i] = rhex(x[i]);\n\t        }\n\t        return x.join('');\n\t    }\n\t\n\t    // In some cases the fast add32 function cannot be used..\n\t    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {\n\t        add32 = function (x, y) {\n\t            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n\t                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n\t            return (msw << 16) | (lsw & 0xFFFF);\n\t        };\n\t    }\n\t\n\t    // ---------------------------------------------------\n\t\n\t    /**\n\t     * ArrayBuffer slice polyfill.\n\t     *\n\t     * @see https://github.com/ttaubert/node-arraybuffer-slice\n\t     */\n\t\n\t    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {\n\t        (function () {\n\t            function clamp(val, length) {\n\t                val = (val | 0) || 0;\n\t\n\t                if (val < 0) {\n\t                    return Math.max(val + length, 0);\n\t                }\n\t\n\t                return Math.min(val, length);\n\t            }\n\t\n\t            ArrayBuffer.prototype.slice = function (from, to) {\n\t                var length = this.byteLength,\n\t                    begin = clamp(from, length),\n\t                    end = length,\n\t                    num,\n\t                    target,\n\t                    targetArray,\n\t                    sourceArray;\n\t\n\t                if (to !== undefined) {\n\t                    end = clamp(to, length);\n\t                }\n\t\n\t                if (begin > end) {\n\t                    return new ArrayBuffer(0);\n\t                }\n\t\n\t                num = end - begin;\n\t                target = new ArrayBuffer(num);\n\t                targetArray = new Uint8Array(target);\n\t\n\t                sourceArray = new Uint8Array(this, begin, num);\n\t                targetArray.set(sourceArray);\n\t\n\t                return target;\n\t            };\n\t        })();\n\t    }\n\t\n\t    // ---------------------------------------------------\n\t\n\t    /**\n\t     * Helpers.\n\t     */\n\t\n\t    function toUtf8(str) {\n\t        if (/[\\u0080-\\uFFFF]/.test(str)) {\n\t            str = unescape(encodeURIComponent(str));\n\t        }\n\t\n\t        return str;\n\t    }\n\t\n\t    function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n\t        var length = str.length,\n\t           buff = new ArrayBuffer(length),\n\t           arr = new Uint8Array(buff),\n\t           i;\n\t\n\t        for (i = 0; i < length; i += 1) {\n\t            arr[i] = str.charCodeAt(i);\n\t        }\n\t\n\t        return returnUInt8Array ? arr : buff;\n\t    }\n\t\n\t    function arrayBuffer2Utf8Str(buff) {\n\t        return String.fromCharCode.apply(null, new Uint8Array(buff));\n\t    }\n\t\n\t    function concatenateArrayBuffers(first, second, returnUInt8Array) {\n\t        var result = new Uint8Array(first.byteLength + second.byteLength);\n\t\n\t        result.set(new Uint8Array(first));\n\t        result.set(new Uint8Array(second), first.byteLength);\n\t\n\t        return returnUInt8Array ? result : result.buffer;\n\t    }\n\t\n\t    function hexToBinaryString(hex) {\n\t        var bytes = [],\n\t            length = hex.length,\n\t            x;\n\t\n\t        for (x = 0; x < length - 1; x += 2) {\n\t            bytes.push(parseInt(hex.substr(x, 2), 16));\n\t        }\n\t\n\t        return String.fromCharCode.apply(String, bytes);\n\t    }\n\t\n\t    // ---------------------------------------------------\n\t\n\t    /**\n\t     * SparkMD5 OOP implementation.\n\t     *\n\t     * Use this class to perform an incremental md5, otherwise use the\n\t     * static methods instead.\n\t     */\n\t\n\t    function SparkMD5() {\n\t        // call reset to init the instance\n\t        this.reset();\n\t    }\n\t\n\t    /**\n\t     * Appends a string.\n\t     * A conversion will be applied if an utf8 string is detected.\n\t     *\n\t     * @param {String} str The string to be appended\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.append = function (str) {\n\t        // Converts the string to utf8 bytes if necessary\n\t        // Then append as binary\n\t        this.appendBinary(toUtf8(str));\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Appends a binary string.\n\t     *\n\t     * @param {String} contents The binary string to be appended\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.appendBinary = function (contents) {\n\t        this._buff += contents;\n\t        this._length += contents.length;\n\t\n\t        var length = this._buff.length,\n\t            i;\n\t\n\t        for (i = 64; i <= length; i += 64) {\n\t            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n\t        }\n\t\n\t        this._buff = this._buff.substring(i - 64);\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Finishes the incremental computation, reseting the internal state and\n\t     * returning the result.\n\t     *\n\t     * @param {Boolean} raw True to get the raw string, false to get the hex string\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.prototype.end = function (raw) {\n\t        var buff = this._buff,\n\t            length = buff.length,\n\t            i,\n\t            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n\t            ret;\n\t\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n\t        }\n\t\n\t        this._finish(tail, length);\n\t        ret = hex(this._hash);\n\t\n\t        if (raw) {\n\t            ret = hexToBinaryString(ret);\n\t        }\n\t\n\t        this.reset();\n\t\n\t        return ret;\n\t    };\n\t\n\t    /**\n\t     * Resets the internal state of the computation.\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.reset = function () {\n\t        this._buff = '';\n\t        this._length = 0;\n\t        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Gets the internal state of the computation.\n\t     *\n\t     * @return {Object} The state\n\t     */\n\t    SparkMD5.prototype.getState = function () {\n\t        return {\n\t            buff: this._buff,\n\t            length: this._length,\n\t            hash: this._hash\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Gets the internal state of the computation.\n\t     *\n\t     * @param {Object} state The state\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.setState = function (state) {\n\t        this._buff = state.buff;\n\t        this._length = state.length;\n\t        this._hash = state.hash;\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Releases memory used by the incremental buffer and other additional\n\t     * resources. If you plan to use the instance again, use reset instead.\n\t     */\n\t    SparkMD5.prototype.destroy = function () {\n\t        delete this._hash;\n\t        delete this._buff;\n\t        delete this._length;\n\t    };\n\t\n\t    /**\n\t     * Finish the final calculation based on the tail.\n\t     *\n\t     * @param {Array}  tail   The tail (will be modified)\n\t     * @param {Number} length The length of the remaining buffer\n\t     */\n\t    SparkMD5.prototype._finish = function (tail, length) {\n\t        var i = length,\n\t            tmp,\n\t            lo,\n\t            hi;\n\t\n\t        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n\t        if (i > 55) {\n\t            md5cycle(this._hash, tail);\n\t            for (i = 0; i < 16; i += 1) {\n\t                tail[i] = 0;\n\t            }\n\t        }\n\t\n\t        // Do the final computation based on the tail and length\n\t        // Beware that the final length may not fit in 32 bits so we take care of that\n\t        tmp = this._length * 8;\n\t        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n\t        lo = parseInt(tmp[2], 16);\n\t        hi = parseInt(tmp[1], 16) || 0;\n\t\n\t        tail[14] = lo;\n\t        tail[15] = hi;\n\t        md5cycle(this._hash, tail);\n\t    };\n\t\n\t    /**\n\t     * Performs the md5 hash on a string.\n\t     * A conversion will be applied if utf8 string is detected.\n\t     *\n\t     * @param {String}  str The string\n\t     * @param {Boolean} raw True to get the raw string, false to get the hex string\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.hash = function (str, raw) {\n\t        // Converts the string to utf8 bytes if necessary\n\t        // Then compute it using the binary function\n\t        return SparkMD5.hashBinary(toUtf8(str), raw);\n\t    };\n\t\n\t    /**\n\t     * Performs the md5 hash on a binary string.\n\t     *\n\t     * @param {String}  content The binary string\n\t     * @param {Boolean} raw     True to get the raw string, false to get the hex string\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.hashBinary = function (content, raw) {\n\t        var hash = md51(content),\n\t            ret = hex(hash);\n\t\n\t        return raw ? hexToBinaryString(ret) : ret;\n\t    };\n\t\n\t    // ---------------------------------------------------\n\t\n\t    /**\n\t     * SparkMD5 OOP implementation for array buffers.\n\t     *\n\t     * Use this class to perform an incremental md5 ONLY for array buffers.\n\t     */\n\t    SparkMD5.ArrayBuffer = function () {\n\t        // call reset to init the instance\n\t        this.reset();\n\t    };\n\t\n\t    /**\n\t     * Appends an array buffer.\n\t     *\n\t     * @param {ArrayBuffer} arr The array to be appended\n\t     *\n\t     * @return {SparkMD5.ArrayBuffer} The instance itself\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n\t        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),\n\t            length = buff.length,\n\t            i;\n\t\n\t        this._length += arr.byteLength;\n\t\n\t        for (i = 64; i <= length; i += 64) {\n\t            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n\t        }\n\t\n\t        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Finishes the incremental computation, reseting the internal state and\n\t     * returning the result.\n\t     *\n\t     * @param {Boolean} raw True to get the raw string, false to get the hex string\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n\t        var buff = this._buff,\n\t            length = buff.length,\n\t            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n\t            i,\n\t            ret;\n\t\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n\t        }\n\t\n\t        this._finish(tail, length);\n\t        ret = hex(this._hash);\n\t\n\t        if (raw) {\n\t            ret = hexToBinaryString(ret);\n\t        }\n\t\n\t        this.reset();\n\t\n\t        return ret;\n\t    };\n\t\n\t    /**\n\t     * Resets the internal state of the computation.\n\t     *\n\t     * @return {SparkMD5.ArrayBuffer} The instance itself\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.reset = function () {\n\t        this._buff = new Uint8Array(0);\n\t        this._length = 0;\n\t        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Gets the internal state of the computation.\n\t     *\n\t     * @return {Object} The state\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.getState = function () {\n\t        var state = SparkMD5.prototype.getState.call(this);\n\t\n\t        // Convert buffer to a string\n\t        state.buff = arrayBuffer2Utf8Str(state.buff);\n\t\n\t        return state;\n\t    };\n\t\n\t    /**\n\t     * Gets the internal state of the computation.\n\t     *\n\t     * @param {Object} state The state\n\t     *\n\t     * @return {SparkMD5.ArrayBuffer} The instance itself\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.setState = function (state) {\n\t        // Convert string to buffer\n\t        state.buff = utf8Str2ArrayBuffer(state.buff, true);\n\t\n\t        return SparkMD5.prototype.setState.call(this, state);\n\t    };\n\t\n\t    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\t\n\t    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\t\n\t    /**\n\t     * Performs the md5 hash on an array buffer.\n\t     *\n\t     * @param {ArrayBuffer} arr The array buffer\n\t     * @param {Boolean}     raw True to get the raw string, false to get the hex one\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n\t        var hash = md51_array(new Uint8Array(arr)),\n\t            ret = hex(hash);\n\t\n\t        return raw ? hexToBinaryString(ret) : ret;\n\t    };\n\t\n\t    return SparkMD5;\n\t}));\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Stringify/parse functions that don't operate\n\t * recursively, so they avoid call stack exceeded\n\t * errors.\n\t */\n\texports.stringify = function stringify(input) {\n\t  var queue = [];\n\t  queue.push({obj: input});\n\t\n\t  var res = '';\n\t  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;\n\t  while ((next = queue.pop())) {\n\t    obj = next.obj;\n\t    prefix = next.prefix || '';\n\t    val = next.val || '';\n\t    res += prefix;\n\t    if (val) {\n\t      res += val;\n\t    } else if (typeof obj !== 'object') {\n\t      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);\n\t    } else if (obj === null) {\n\t      res += 'null';\n\t    } else if (Array.isArray(obj)) {\n\t      queue.push({val: ']'});\n\t      for (i = obj.length - 1; i >= 0; i--) {\n\t        arrayPrefix = i === 0 ? '' : ',';\n\t        queue.push({obj: obj[i], prefix: arrayPrefix});\n\t      }\n\t      queue.push({val: '['});\n\t    } else { // object\n\t      keys = [];\n\t      for (k in obj) {\n\t        if (obj.hasOwnProperty(k)) {\n\t          keys.push(k);\n\t        }\n\t      }\n\t      queue.push({val: '}'});\n\t      for (i = keys.length - 1; i >= 0; i--) {\n\t        key = keys[i];\n\t        value = obj[key];\n\t        objPrefix = (i > 0 ? ',' : '');\n\t        objPrefix += JSON.stringify(key) + ':';\n\t        queue.push({obj: value, prefix: objPrefix});\n\t      }\n\t      queue.push({val: '{'});\n\t    }\n\t  }\n\t  return res;\n\t};\n\t\n\t// Convenience function for the parse function.\n\t// This pop function is basically copied from\n\t// pouchCollate.parseIndexableString\n\tfunction pop(obj, stack, metaStack) {\n\t  var lastMetaElement = metaStack[metaStack.length - 1];\n\t  if (obj === lastMetaElement.element) {\n\t    // popping a meta-element, e.g. an object whose value is another object\n\t    metaStack.pop();\n\t    lastMetaElement = metaStack[metaStack.length - 1];\n\t  }\n\t  var element = lastMetaElement.element;\n\t  var lastElementIndex = lastMetaElement.index;\n\t  if (Array.isArray(element)) {\n\t    element.push(obj);\n\t  } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n\t    var key = stack.pop();\n\t    element[key] = obj;\n\t  } else {\n\t    stack.push(obj); // obj with key only\n\t  }\n\t}\n\t\n\texports.parse = function (str) {\n\t  var stack = [];\n\t  var metaStack = []; // stack for arrays and objects\n\t  var i = 0;\n\t  var collationIndex,parsedNum,numChar;\n\t  var parsedString,lastCh,numConsecutiveSlashes,ch;\n\t  var arrayElement, objElement;\n\t  while (true) {\n\t    collationIndex = str[i++];\n\t    if (collationIndex === '}' ||\n\t        collationIndex === ']' ||\n\t        typeof collationIndex === 'undefined') {\n\t      if (stack.length === 1) {\n\t        return stack.pop();\n\t      } else {\n\t        pop(stack.pop(), stack, metaStack);\n\t        continue;\n\t      }\n\t    }\n\t    switch (collationIndex) {\n\t      case ' ':\n\t      case '\\t':\n\t      case '\\n':\n\t      case ':':\n\t      case ',':\n\t        break;\n\t      case 'n':\n\t        i += 3; // 'ull'\n\t        pop(null, stack, metaStack);\n\t        break;\n\t      case 't':\n\t        i += 3; // 'rue'\n\t        pop(true, stack, metaStack);\n\t        break;\n\t      case 'f':\n\t        i += 4; // 'alse'\n\t        pop(false, stack, metaStack);\n\t        break;\n\t      case '0':\n\t      case '1':\n\t      case '2':\n\t      case '3':\n\t      case '4':\n\t      case '5':\n\t      case '6':\n\t      case '7':\n\t      case '8':\n\t      case '9':\n\t      case '-':\n\t        parsedNum = '';\n\t        i--;\n\t        while (true) {\n\t          numChar = str[i++];\n\t          if (/[\\d\\.\\-e\\+]/.test(numChar)) {\n\t            parsedNum += numChar;\n\t          } else {\n\t            i--;\n\t            break;\n\t          }\n\t        }\n\t        pop(parseFloat(parsedNum), stack, metaStack);\n\t        break;\n\t      case '\"':\n\t        parsedString = '';\n\t        lastCh = void 0;\n\t        numConsecutiveSlashes = 0;\n\t        while (true) {\n\t          ch = str[i++];\n\t          if (ch !== '\"' || (lastCh === '\\\\' &&\n\t              numConsecutiveSlashes % 2 === 1)) {\n\t            parsedString += ch;\n\t            lastCh = ch;\n\t            if (lastCh === '\\\\') {\n\t              numConsecutiveSlashes++;\n\t            } else {\n\t              numConsecutiveSlashes = 0;\n\t            }\n\t          } else {\n\t            break;\n\t          }\n\t        }\n\t        pop(JSON.parse('\"' + parsedString + '\"'), stack, metaStack);\n\t        break;\n\t      case '[':\n\t        arrayElement = { element: [], index: stack.length };\n\t        stack.push(arrayElement.element);\n\t        metaStack.push(arrayElement);\n\t        break;\n\t      case '{':\n\t        objElement = { element: {}, index: stack.length };\n\t        stack.push(objElement.element);\n\t        metaStack.push(objElement);\n\t        break;\n\t      default:\n\t        throw new Error(\n\t          'unexpectedly reached end of input: ' + collationIndex);\n\t    }\n\t  }\n\t};\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _superagent = __webpack_require__(20);\n\t\n\tvar _superagent2 = _interopRequireDefault(_superagent);\n\t\n\tvar _sha = __webpack_require__(25);\n\t\n\tvar _sha2 = _interopRequireDefault(_sha);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar API = {\n\t  apiEndpoint: null,\n\t  apiKey: null,\n\t  appId: null,\n\t  UDID: null,\n\t  authenticationToken: null,\n\t  tokenUpdateCallback: function tokenUpdateCallback(newToken) {}\n\t};\n\t\n\tAPI.call = function (endpoint, data) {\n\t  var _this = this;\n\t\n\t  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n\t  var method = arguments[3];\n\t\n\t  if (!this.apiEndpoint) {\n\t    callback(new Error('No API endpoint set - run Telepat.configure or Telepat.connect first'), null);\n\t  }\n\t  var req;\n\t\n\t  if (method === 'get') {\n\t    req = _superagent2.default.get(this.apiEndpoint + endpoint + '?' + data);\n\t  } else if (method === 'delete') {\n\t    req = _superagent2.default.del(this.apiEndpoint + endpoint);\n\t  } else {\n\t    req = _superagent2.default.post(this.apiEndpoint + endpoint);\n\t  }\n\t\n\t  if (method !== 'get') {\n\t    req.send(data);\n\t  }\n\t\n\t  req.set('Content-Type', 'application/json').set('X-BLGREQ-SIGN', (0, _sha2.default)(this.apiKey)).set('X-BLGREQ-APPID', this.appId).set('X-BLGREQ-UDID', this.UDID || 'TP_EMPTY_UDID');\n\t\n\t  if (this.authenticationToken) {\n\t    req.set('Authorization', 'Bearer ' + this.authenticationToken);\n\t  }\n\t\n\t  req.end(function (err, res) {\n\t    if (_this.needsTokenUpdate(res)) {\n\t      _this.updateToken(function (error, result) {\n\t        if (error) {\n\t          callback(error, null);\n\t        } else {\n\t          _this.call(endpoint, data, callback, method);\n\t        }\n\t      });\n\t    } else {\n\t      callback(err, res);\n\t    }\n\t  });\n\t};\n\t\n\tAPI.needsTokenUpdate = function (response) {\n\t  return this.authenticationToken && response.status === 401;\n\t};\n\t\n\tAPI.updateToken = function (callback) {\n\t  var _this2 = this;\n\t\n\t  this.get('user/refresh_token', '', function (err, res) {\n\t    if (err) {\n\t      callback(err, null);\n\t    } else {\n\t      _this2.authenticationToken = res.body.content.token;\n\t      _this2.tokenUpdateCallback(_this2.authenticationToken);\n\t      callback(null, res);\n\t    }\n\t  });\n\t};\n\t\n\tAPI.get = function (endpoint, data, callback) {\n\t  return this.call(endpoint, data, callback, 'get');\n\t};\n\t\n\tAPI.del = function (endpoint, data, callback) {\n\t  return this.call(endpoint, data, callback, 'delete');\n\t};\n\t\n\texports.default = API;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Root reference for iframes.\n\t */\n\t\n\tvar root;\n\tif (typeof window !== 'undefined') { // Browser window\n\t  root = window;\n\t} else if (typeof self !== 'undefined') { // Web Worker\n\t  root = self;\n\t} else { // Other environments\n\t  console.warn(\"Using browser-only version of superagent in non-browser environment\");\n\t  root = this;\n\t}\n\t\n\tvar Emitter = __webpack_require__(21);\n\tvar requestBase = __webpack_require__(22);\n\tvar isObject = __webpack_require__(23);\n\t\n\t/**\n\t * Noop.\n\t */\n\t\n\tfunction noop(){};\n\t\n\t/**\n\t * Expose `request`.\n\t */\n\t\n\tvar request = module.exports = __webpack_require__(24).bind(null, Request);\n\t\n\t/**\n\t * Determine XHR.\n\t */\n\t\n\trequest.getXHR = function () {\n\t  if (root.XMLHttpRequest\n\t      && (!root.location || 'file:' != root.location.protocol\n\t          || !root.ActiveXObject)) {\n\t    return new XMLHttpRequest;\n\t  } else {\n\t    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\n\t    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\n\t    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\n\t    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\n\t  }\n\t  throw Error(\"Browser-only verison of superagent could not find XHR\");\n\t};\n\t\n\t/**\n\t * Removes leading and trailing whitespace, added to support IE.\n\t *\n\t * @param {String} s\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tvar trim = ''.trim\n\t  ? function(s) { return s.trim(); }\n\t  : function(s) { return s.replace(/(^\\s*|\\s*$)/g, ''); };\n\t\n\t/**\n\t * Serialize the given `obj`.\n\t *\n\t * @param {Object} obj\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction serialize(obj) {\n\t  if (!isObject(obj)) return obj;\n\t  var pairs = [];\n\t  for (var key in obj) {\n\t    pushEncodedKeyValuePair(pairs, key, obj[key]);\n\t  }\n\t  return pairs.join('&');\n\t}\n\t\n\t/**\n\t * Helps 'serialize' with serializing arrays.\n\t * Mutates the pairs array.\n\t *\n\t * @param {Array} pairs\n\t * @param {String} key\n\t * @param {Mixed} val\n\t */\n\t\n\tfunction pushEncodedKeyValuePair(pairs, key, val) {\n\t  if (val != null) {\n\t    if (Array.isArray(val)) {\n\t      val.forEach(function(v) {\n\t        pushEncodedKeyValuePair(pairs, key, v);\n\t      });\n\t    } else if (isObject(val)) {\n\t      for(var subkey in val) {\n\t        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);\n\t      }\n\t    } else {\n\t      pairs.push(encodeURIComponent(key)\n\t        + '=' + encodeURIComponent(val));\n\t    }\n\t  } else if (val === null) {\n\t    pairs.push(encodeURIComponent(key));\n\t  }\n\t}\n\t\n\t/**\n\t * Expose serialization method.\n\t */\n\t\n\t request.serializeObject = serialize;\n\t\n\t /**\n\t  * Parse the given x-www-form-urlencoded `str`.\n\t  *\n\t  * @param {String} str\n\t  * @return {Object}\n\t  * @api private\n\t  */\n\t\n\tfunction parseString(str) {\n\t  var obj = {};\n\t  var pairs = str.split('&');\n\t  var pair;\n\t  var pos;\n\t\n\t  for (var i = 0, len = pairs.length; i < len; ++i) {\n\t    pair = pairs[i];\n\t    pos = pair.indexOf('=');\n\t    if (pos == -1) {\n\t      obj[decodeURIComponent(pair)] = '';\n\t    } else {\n\t      obj[decodeURIComponent(pair.slice(0, pos))] =\n\t        decodeURIComponent(pair.slice(pos + 1));\n\t    }\n\t  }\n\t\n\t  return obj;\n\t}\n\t\n\t/**\n\t * Expose parser.\n\t */\n\t\n\trequest.parseString = parseString;\n\t\n\t/**\n\t * Default MIME type map.\n\t *\n\t *     superagent.types.xml = 'application/xml';\n\t *\n\t */\n\t\n\trequest.types = {\n\t  html: 'text/html',\n\t  json: 'application/json',\n\t  xml: 'application/xml',\n\t  urlencoded: 'application/x-www-form-urlencoded',\n\t  'form': 'application/x-www-form-urlencoded',\n\t  'form-data': 'application/x-www-form-urlencoded'\n\t};\n\t\n\t/**\n\t * Default serialization map.\n\t *\n\t *     superagent.serialize['application/xml'] = function(obj){\n\t *       return 'generated xml here';\n\t *     };\n\t *\n\t */\n\t\n\t request.serialize = {\n\t   'application/x-www-form-urlencoded': serialize,\n\t   'application/json': JSON.stringify\n\t };\n\t\n\t /**\n\t  * Default parsers.\n\t  *\n\t  *     superagent.parse['application/xml'] = function(str){\n\t  *       return { object parsed from str };\n\t  *     };\n\t  *\n\t  */\n\t\n\trequest.parse = {\n\t  'application/x-www-form-urlencoded': parseString,\n\t  'application/json': JSON.parse\n\t};\n\t\n\t/**\n\t * Parse the given header `str` into\n\t * an object containing the mapped fields.\n\t *\n\t * @param {String} str\n\t * @return {Object}\n\t * @api private\n\t */\n\t\n\tfunction parseHeader(str) {\n\t  var lines = str.split(/\\r?\\n/);\n\t  var fields = {};\n\t  var index;\n\t  var line;\n\t  var field;\n\t  var val;\n\t\n\t  lines.pop(); // trailing CRLF\n\t\n\t  for (var i = 0, len = lines.length; i < len; ++i) {\n\t    line = lines[i];\n\t    index = line.indexOf(':');\n\t    field = line.slice(0, index).toLowerCase();\n\t    val = trim(line.slice(index + 1));\n\t    fields[field] = val;\n\t  }\n\t\n\t  return fields;\n\t}\n\t\n\t/**\n\t * Check if `mime` is json or has +json structured syntax suffix.\n\t *\n\t * @param {String} mime\n\t * @return {Boolean}\n\t * @api private\n\t */\n\t\n\tfunction isJSON(mime) {\n\t  return /[\\/+]json\\b/.test(mime);\n\t}\n\t\n\t/**\n\t * Return the mime type for the given `str`.\n\t *\n\t * @param {String} str\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction type(str){\n\t  return str.split(/ *; */).shift();\n\t};\n\t\n\t/**\n\t * Return header field parameters.\n\t *\n\t * @param {String} str\n\t * @return {Object}\n\t * @api private\n\t */\n\t\n\tfunction params(str){\n\t  return str.split(/ *; */).reduce(function(obj, str){\n\t    var parts = str.split(/ *= */),\n\t        key = parts.shift(),\n\t        val = parts.shift();\n\t\n\t    if (key && val) obj[key] = val;\n\t    return obj;\n\t  }, {});\n\t};\n\t\n\t/**\n\t * Initialize a new `Response` with the given `xhr`.\n\t *\n\t *  - set flags (.ok, .error, etc)\n\t *  - parse header\n\t *\n\t * Examples:\n\t *\n\t *  Aliasing `superagent` as `request` is nice:\n\t *\n\t *      request = superagent;\n\t *\n\t *  We can use the promise-like API, or pass callbacks:\n\t *\n\t *      request.get('/').end(function(res){});\n\t *      request.get('/', function(res){});\n\t *\n\t *  Sending data can be chained:\n\t *\n\t *      request\n\t *        .post('/user')\n\t *        .send({ name: 'tj' })\n\t *        .end(function(res){});\n\t *\n\t *  Or passed to `.send()`:\n\t *\n\t *      request\n\t *        .post('/user')\n\t *        .send({ name: 'tj' }, function(res){});\n\t *\n\t *  Or passed to `.post()`:\n\t *\n\t *      request\n\t *        .post('/user', { name: 'tj' })\n\t *        .end(function(res){});\n\t *\n\t * Or further reduced to a single call for simple cases:\n\t *\n\t *      request\n\t *        .post('/user', { name: 'tj' }, function(res){});\n\t *\n\t * @param {XMLHTTPRequest} xhr\n\t * @param {Object} options\n\t * @api private\n\t */\n\t\n\tfunction Response(req, options) {\n\t  options = options || {};\n\t  this.req = req;\n\t  this.xhr = this.req.xhr;\n\t  // responseText is accessible only if responseType is '' or 'text' and on older browsers\n\t  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')\n\t     ? this.xhr.responseText\n\t     : null;\n\t  this.statusText = this.req.xhr.statusText;\n\t  this._setStatusProperties(this.xhr.status);\n\t  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());\n\t  // getAllResponseHeaders sometimes falsely returns \"\" for CORS requests, but\n\t  // getResponseHeader still works. so we get content-type even if getting\n\t  // other headers fails.\n\t  this.header['content-type'] = this.xhr.getResponseHeader('content-type');\n\t  this._setHeaderProperties(this.header);\n\t  this.body = this.req.method != 'HEAD'\n\t    ? this._parseBody(this.text ? this.text : this.xhr.response)\n\t    : null;\n\t}\n\t\n\t/**\n\t * Get case-insensitive `field` value.\n\t *\n\t * @param {String} field\n\t * @return {String}\n\t * @api public\n\t */\n\t\n\tResponse.prototype.get = function(field){\n\t  return this.header[field.toLowerCase()];\n\t};\n\t\n\t/**\n\t * Set header related properties:\n\t *\n\t *   - `.type` the content type without params\n\t *\n\t * A response of \"Content-Type: text/plain; charset=utf-8\"\n\t * will provide you with a `.type` of \"text/plain\".\n\t *\n\t * @param {Object} header\n\t * @api private\n\t */\n\t\n\tResponse.prototype._setHeaderProperties = function(header){\n\t  // content-type\n\t  var ct = this.header['content-type'] || '';\n\t  this.type = type(ct);\n\t\n\t  // params\n\t  var obj = params(ct);\n\t  for (var key in obj) this[key] = obj[key];\n\t};\n\t\n\t/**\n\t * Parse the given body `str`.\n\t *\n\t * Used for auto-parsing of bodies. Parsers\n\t * are defined on the `superagent.parse` object.\n\t *\n\t * @param {String} str\n\t * @return {Mixed}\n\t * @api private\n\t */\n\t\n\tResponse.prototype._parseBody = function(str){\n\t  var parse = request.parse[this.type];\n\t  if (!parse && isJSON(this.type)) {\n\t    parse = request.parse['application/json'];\n\t  }\n\t  return parse && str && (str.length || str instanceof Object)\n\t    ? parse(str)\n\t    : null;\n\t};\n\t\n\t/**\n\t * Set flags such as `.ok` based on `status`.\n\t *\n\t * For example a 2xx response will give you a `.ok` of __true__\n\t * whereas 5xx will be __false__ and `.error` will be __true__. The\n\t * `.clientError` and `.serverError` are also available to be more\n\t * specific, and `.statusType` is the class of error ranging from 1..5\n\t * sometimes useful for mapping respond colors etc.\n\t *\n\t * \"sugar\" properties are also defined for common cases. Currently providing:\n\t *\n\t *   - .noContent\n\t *   - .badRequest\n\t *   - .unauthorized\n\t *   - .notAcceptable\n\t *   - .notFound\n\t *\n\t * @param {Number} status\n\t * @api private\n\t */\n\t\n\tResponse.prototype._setStatusProperties = function(status){\n\t  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n\t  if (status === 1223) {\n\t    status = 204;\n\t  }\n\t\n\t  var type = status / 100 | 0;\n\t\n\t  // status / class\n\t  this.status = this.statusCode = status;\n\t  this.statusType = type;\n\t\n\t  // basics\n\t  this.info = 1 == type;\n\t  this.ok = 2 == type;\n\t  this.clientError = 4 == type;\n\t  this.serverError = 5 == type;\n\t  this.error = (4 == type || 5 == type)\n\t    ? this.toError()\n\t    : false;\n\t\n\t  // sugar\n\t  this.accepted = 202 == status;\n\t  this.noContent = 204 == status;\n\t  this.badRequest = 400 == status;\n\t  this.unauthorized = 401 == status;\n\t  this.notAcceptable = 406 == status;\n\t  this.notFound = 404 == status;\n\t  this.forbidden = 403 == status;\n\t};\n\t\n\t/**\n\t * Return an `Error` representative of this response.\n\t *\n\t * @return {Error}\n\t * @api public\n\t */\n\t\n\tResponse.prototype.toError = function(){\n\t  var req = this.req;\n\t  var method = req.method;\n\t  var url = req.url;\n\t\n\t  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';\n\t  var err = new Error(msg);\n\t  err.status = this.status;\n\t  err.method = method;\n\t  err.url = url;\n\t\n\t  return err;\n\t};\n\t\n\t/**\n\t * Expose `Response`.\n\t */\n\t\n\trequest.Response = Response;\n\t\n\t/**\n\t * Initialize a new `Request` with the given `method` and `url`.\n\t *\n\t * @param {String} method\n\t * @param {String} url\n\t * @api public\n\t */\n\t\n\tfunction Request(method, url) {\n\t  var self = this;\n\t  this._query = this._query || [];\n\t  this.method = method;\n\t  this.url = url;\n\t  this.header = {}; // preserves header name case\n\t  this._header = {}; // coerces header names to lowercase\n\t  this.on('end', function(){\n\t    var err = null;\n\t    var res = null;\n\t\n\t    try {\n\t      res = new Response(self);\n\t    } catch(e) {\n\t      err = new Error('Parser is unable to parse the response');\n\t      err.parse = true;\n\t      err.original = e;\n\t      // issue #675: return the raw response if the response parsing fails\n\t      err.rawResponse = self.xhr && self.xhr.responseText ? self.xhr.responseText : null;\n\t      // issue #876: return the http status code if the response parsing fails\n\t      err.statusCode = self.xhr && self.xhr.status ? self.xhr.status : null;\n\t      return self.callback(err);\n\t    }\n\t\n\t    self.emit('response', res);\n\t\n\t    var new_err;\n\t    try {\n\t      if (res.status < 200 || res.status >= 300) {\n\t        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');\n\t        new_err.original = err;\n\t        new_err.response = res;\n\t        new_err.status = res.status;\n\t      }\n\t    } catch(e) {\n\t      new_err = e; // #985 touching res may cause INVALID_STATE_ERR on old Android\n\t    }\n\t\n\t    // #1000 don't catch errors from the callback to avoid double calling it\n\t    if (new_err) {\n\t      self.callback(new_err, res);\n\t    } else {\n\t      self.callback(null, res);\n\t    }\n\t  });\n\t}\n\t\n\t/**\n\t * Mixin `Emitter` and `requestBase`.\n\t */\n\t\n\tEmitter(Request.prototype);\n\tfor (var key in requestBase) {\n\t  Request.prototype[key] = requestBase[key];\n\t}\n\t\n\t/**\n\t * Set Content-Type to `type`, mapping values from `request.types`.\n\t *\n\t * Examples:\n\t *\n\t *      superagent.types.xml = 'application/xml';\n\t *\n\t *      request.post('/')\n\t *        .type('xml')\n\t *        .send(xmlstring)\n\t *        .end(callback);\n\t *\n\t *      request.post('/')\n\t *        .type('application/xml')\n\t *        .send(xmlstring)\n\t *        .end(callback);\n\t *\n\t * @param {String} type\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.type = function(type){\n\t  this.set('Content-Type', request.types[type] || type);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set responseType to `val`. Presently valid responseTypes are 'blob' and\n\t * 'arraybuffer'.\n\t *\n\t * Examples:\n\t *\n\t *      req.get('/')\n\t *        .responseType('blob')\n\t *        .end(callback);\n\t *\n\t * @param {String} val\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.responseType = function(val){\n\t  this._responseType = val;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set Accept to `type`, mapping values from `request.types`.\n\t *\n\t * Examples:\n\t *\n\t *      superagent.types.json = 'application/json';\n\t *\n\t *      request.get('/agent')\n\t *        .accept('json')\n\t *        .end(callback);\n\t *\n\t *      request.get('/agent')\n\t *        .accept('application/json')\n\t *        .end(callback);\n\t *\n\t * @param {String} accept\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.accept = function(type){\n\t  this.set('Accept', request.types[type] || type);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set Authorization field value with `user` and `pass`.\n\t *\n\t * @param {String} user\n\t * @param {String} pass\n\t * @param {Object} options with 'type' property 'auto' or 'basic' (default 'basic')\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.auth = function(user, pass, options){\n\t  if (!options) {\n\t    options = {\n\t      type: 'basic'\n\t    }\n\t  }\n\t\n\t  switch (options.type) {\n\t    case 'basic':\n\t      var str = btoa(user + ':' + pass);\n\t      this.set('Authorization', 'Basic ' + str);\n\t    break;\n\t\n\t    case 'auto':\n\t      this.username = user;\n\t      this.password = pass;\n\t    break;\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t* Add query-string `val`.\n\t*\n\t* Examples:\n\t*\n\t*   request.get('/shoes')\n\t*     .query('size=10')\n\t*     .query({ color: 'blue' })\n\t*\n\t* @param {Object|String} val\n\t* @return {Request} for chaining\n\t* @api public\n\t*/\n\t\n\tRequest.prototype.query = function(val){\n\t  if ('string' != typeof val) val = serialize(val);\n\t  if (val) this._query.push(val);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Queue the given `file` as an attachment to the specified `field`,\n\t * with optional `filename`.\n\t *\n\t * ``` js\n\t * request.post('/upload')\n\t *   .attach('content', new Blob(['<a id=\"a\"><b id=\"b\">hey!</b></a>'], { type: \"text/html\"}))\n\t *   .end(callback);\n\t * ```\n\t *\n\t * @param {String} field\n\t * @param {Blob|File} file\n\t * @param {String} filename\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.attach = function(field, file, filename){\n\t  this._getFormData().append(field, file, filename || file.name);\n\t  return this;\n\t};\n\t\n\tRequest.prototype._getFormData = function(){\n\t  if (!this._formData) {\n\t    this._formData = new root.FormData();\n\t  }\n\t  return this._formData;\n\t};\n\t\n\t/**\n\t * Invoke the callback with `err` and `res`\n\t * and handle arity check.\n\t *\n\t * @param {Error} err\n\t * @param {Response} res\n\t * @api private\n\t */\n\t\n\tRequest.prototype.callback = function(err, res){\n\t  var fn = this._callback;\n\t  this.clearTimeout();\n\t  fn(err, res);\n\t};\n\t\n\t/**\n\t * Invoke callback with x-domain error.\n\t *\n\t * @api private\n\t */\n\t\n\tRequest.prototype.crossDomainError = function(){\n\t  var err = new Error('Request has been terminated\\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');\n\t  err.crossDomain = true;\n\t\n\t  err.status = this.status;\n\t  err.method = this.method;\n\t  err.url = this.url;\n\t\n\t  this.callback(err);\n\t};\n\t\n\t/**\n\t * Invoke callback with timeout error.\n\t *\n\t * @api private\n\t */\n\t\n\tRequest.prototype._timeoutError = function(){\n\t  var timeout = this._timeout;\n\t  var err = new Error('timeout of ' + timeout + 'ms exceeded');\n\t  err.timeout = timeout;\n\t  this.callback(err);\n\t};\n\t\n\t/**\n\t * Compose querystring to append to req.url\n\t *\n\t * @api private\n\t */\n\t\n\tRequest.prototype._appendQueryString = function(){\n\t  var query = this._query.join('&');\n\t  if (query) {\n\t    this.url += ~this.url.indexOf('?')\n\t      ? '&' + query\n\t      : '?' + query;\n\t  }\n\t};\n\t\n\t/**\n\t * Initiate request, invoking callback `fn(res)`\n\t * with an instanceof `Response`.\n\t *\n\t * @param {Function} fn\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.end = function(fn){\n\t  var self = this;\n\t  var xhr = this.xhr = request.getXHR();\n\t  var timeout = this._timeout;\n\t  var data = this._formData || this._data;\n\t\n\t  // store callback\n\t  this._callback = fn || noop;\n\t\n\t  // state change\n\t  xhr.onreadystatechange = function(){\n\t    if (4 != xhr.readyState) return;\n\t\n\t    // In IE9, reads to any property (e.g. status) off of an aborted XHR will\n\t    // result in the error \"Could not complete the operation due to error c00c023f\"\n\t    var status;\n\t    try { status = xhr.status } catch(e) { status = 0; }\n\t\n\t    if (0 == status) {\n\t      if (self.timedout) return self._timeoutError();\n\t      if (self._aborted) return;\n\t      return self.crossDomainError();\n\t    }\n\t    self.emit('end');\n\t  };\n\t\n\t  // progress\n\t  var handleProgress = function(direction, e) {\n\t    if (e.total > 0) {\n\t      e.percent = e.loaded / e.total * 100;\n\t    }\n\t    e.direction = direction;\n\t    self.emit('progress', e);\n\t  }\n\t  if (this.hasListeners('progress')) {\n\t    try {\n\t      xhr.onprogress = handleProgress.bind(null, 'download');\n\t      if (xhr.upload) {\n\t        xhr.upload.onprogress = handleProgress.bind(null, 'upload');\n\t      }\n\t    } catch(e) {\n\t      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.\n\t      // Reported here:\n\t      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context\n\t    }\n\t  }\n\t\n\t  // timeout\n\t  if (timeout && !this._timer) {\n\t    this._timer = setTimeout(function(){\n\t      self.timedout = true;\n\t      self.abort();\n\t    }, timeout);\n\t  }\n\t\n\t  // querystring\n\t  this._appendQueryString();\n\t\n\t  // initiate request\n\t  if (this.username && this.password) {\n\t    xhr.open(this.method, this.url, true, this.username, this.password);\n\t  } else {\n\t    xhr.open(this.method, this.url, true);\n\t  }\n\t\n\t  // CORS\n\t  if (this._withCredentials) xhr.withCredentials = true;\n\t\n\t  // body\n\t  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {\n\t    // serialize stuff\n\t    var contentType = this._header['content-type'];\n\t    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];\n\t    if (!serialize && isJSON(contentType)) serialize = request.serialize['application/json'];\n\t    if (serialize) data = serialize(data);\n\t  }\n\t\n\t  // set header fields\n\t  for (var field in this.header) {\n\t    if (null == this.header[field]) continue;\n\t    xhr.setRequestHeader(field, this.header[field]);\n\t  }\n\t\n\t  if (this._responseType) {\n\t    xhr.responseType = this._responseType;\n\t  }\n\t\n\t  // send stuff\n\t  this.emit('request', this);\n\t\n\t  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)\n\t  // We need null here if data is undefined\n\t  xhr.send(typeof data !== 'undefined' ? data : null);\n\t  return this;\n\t};\n\t\n\t\n\t/**\n\t * Expose `Request`.\n\t */\n\t\n\trequest.Request = Request;\n\t\n\t/**\n\t * GET `url` with optional callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Mixed|Function} [data] or fn\n\t * @param {Function} [fn]\n\t * @return {Request}\n\t * @api public\n\t */\n\t\n\trequest.get = function(url, data, fn){\n\t  var req = request('GET', url);\n\t  if ('function' == typeof data) fn = data, data = null;\n\t  if (data) req.query(data);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\t\n\t/**\n\t * HEAD `url` with optional callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Mixed|Function} [data] or fn\n\t * @param {Function} [fn]\n\t * @return {Request}\n\t * @api public\n\t */\n\t\n\trequest.head = function(url, data, fn){\n\t  var req = request('HEAD', url);\n\t  if ('function' == typeof data) fn = data, data = null;\n\t  if (data) req.send(data);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\t\n\t/**\n\t * OPTIONS query to `url` with optional callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Mixed|Function} [data] or fn\n\t * @param {Function} [fn]\n\t * @return {Request}\n\t * @api public\n\t */\n\t\n\trequest.options = function(url, data, fn){\n\t  var req = request('OPTIONS', url);\n\t  if ('function' == typeof data) fn = data, data = null;\n\t  if (data) req.send(data);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\t\n\t/**\n\t * DELETE `url` with optional callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Function} [fn]\n\t * @return {Request}\n\t * @api public\n\t */\n\t\n\tfunction del(url, fn){\n\t  var req = request('DELETE', url);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\t\n\trequest['del'] = del;\n\trequest['delete'] = del;\n\t\n\t/**\n\t * PATCH `url` with optional `data` and callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Mixed} [data]\n\t * @param {Function} [fn]\n\t * @return {Request}\n\t * @api public\n\t */\n\t\n\trequest.patch = function(url, data, fn){\n\t  var req = request('PATCH', url);\n\t  if ('function' == typeof data) fn = data, data = null;\n\t  if (data) req.send(data);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\t\n\t/**\n\t * POST `url` with optional `data` and callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Mixed} [data]\n\t * @param {Function} [fn]\n\t * @return {Request}\n\t * @api public\n\t */\n\t\n\trequest.post = function(url, data, fn){\n\t  var req = request('POST', url);\n\t  if ('function' == typeof data) fn = data, data = null;\n\t  if (data) req.send(data);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\t\n\t/**\n\t * PUT `url` with optional `data` and callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Mixed|Function} [data] or fn\n\t * @param {Function} [fn]\n\t * @return {Request}\n\t * @api public\n\t */\n\t\n\trequest.put = function(url, data, fn){\n\t  var req = request('PUT', url);\n\t  if ('function' == typeof data) fn = data, data = null;\n\t  if (data) req.send(data);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t/**\r\n\t * Expose `Emitter`.\r\n\t */\r\n\t\r\n\tif (true) {\r\n\t  module.exports = Emitter;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Initialize a new `Emitter`.\r\n\t *\r\n\t * @api public\r\n\t */\r\n\t\r\n\tfunction Emitter(obj) {\r\n\t  if (obj) return mixin(obj);\r\n\t};\r\n\t\r\n\t/**\r\n\t * Mixin the emitter properties.\r\n\t *\r\n\t * @param {Object} obj\r\n\t * @return {Object}\r\n\t * @api private\r\n\t */\r\n\t\r\n\tfunction mixin(obj) {\r\n\t  for (var key in Emitter.prototype) {\r\n\t    obj[key] = Emitter.prototype[key];\r\n\t  }\r\n\t  return obj;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Listen on the given `event` with `fn`.\r\n\t *\r\n\t * @param {String} event\r\n\t * @param {Function} fn\r\n\t * @return {Emitter}\r\n\t * @api public\r\n\t */\r\n\t\r\n\tEmitter.prototype.on =\r\n\tEmitter.prototype.addEventListener = function(event, fn){\r\n\t  this._callbacks = this._callbacks || {};\r\n\t  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\r\n\t    .push(fn);\r\n\t  return this;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Adds an `event` listener that will be invoked a single\r\n\t * time then automatically removed.\r\n\t *\r\n\t * @param {String} event\r\n\t * @param {Function} fn\r\n\t * @return {Emitter}\r\n\t * @api public\r\n\t */\r\n\t\r\n\tEmitter.prototype.once = function(event, fn){\r\n\t  function on() {\r\n\t    this.off(event, on);\r\n\t    fn.apply(this, arguments);\r\n\t  }\r\n\t\r\n\t  on.fn = fn;\r\n\t  this.on(event, on);\r\n\t  return this;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Remove the given callback for `event` or all\r\n\t * registered callbacks.\r\n\t *\r\n\t * @param {String} event\r\n\t * @param {Function} fn\r\n\t * @return {Emitter}\r\n\t * @api public\r\n\t */\r\n\t\r\n\tEmitter.prototype.off =\r\n\tEmitter.prototype.removeListener =\r\n\tEmitter.prototype.removeAllListeners =\r\n\tEmitter.prototype.removeEventListener = function(event, fn){\r\n\t  this._callbacks = this._callbacks || {};\r\n\t\r\n\t  // all\r\n\t  if (0 == arguments.length) {\r\n\t    this._callbacks = {};\r\n\t    return this;\r\n\t  }\r\n\t\r\n\t  // specific event\r\n\t  var callbacks = this._callbacks['$' + event];\r\n\t  if (!callbacks) return this;\r\n\t\r\n\t  // remove all handlers\r\n\t  if (1 == arguments.length) {\r\n\t    delete this._callbacks['$' + event];\r\n\t    return this;\r\n\t  }\r\n\t\r\n\t  // remove specific handler\r\n\t  var cb;\r\n\t  for (var i = 0; i < callbacks.length; i++) {\r\n\t    cb = callbacks[i];\r\n\t    if (cb === fn || cb.fn === fn) {\r\n\t      callbacks.splice(i, 1);\r\n\t      break;\r\n\t    }\r\n\t  }\r\n\t  return this;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Emit `event` with the given args.\r\n\t *\r\n\t * @param {String} event\r\n\t * @param {Mixed} ...\r\n\t * @return {Emitter}\r\n\t */\r\n\t\r\n\tEmitter.prototype.emit = function(event){\r\n\t  this._callbacks = this._callbacks || {};\r\n\t  var args = [].slice.call(arguments, 1)\r\n\t    , callbacks = this._callbacks['$' + event];\r\n\t\r\n\t  if (callbacks) {\r\n\t    callbacks = callbacks.slice(0);\r\n\t    for (var i = 0, len = callbacks.length; i < len; ++i) {\r\n\t      callbacks[i].apply(this, args);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  return this;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Return array of callbacks for `event`.\r\n\t *\r\n\t * @param {String} event\r\n\t * @return {Array}\r\n\t * @api public\r\n\t */\r\n\t\r\n\tEmitter.prototype.listeners = function(event){\r\n\t  this._callbacks = this._callbacks || {};\r\n\t  return this._callbacks['$' + event] || [];\r\n\t};\r\n\t\r\n\t/**\r\n\t * Check if this emitter has `event` handlers.\r\n\t *\r\n\t * @param {String} event\r\n\t * @return {Boolean}\r\n\t * @api public\r\n\t */\r\n\t\r\n\tEmitter.prototype.hasListeners = function(event){\r\n\t  return !! this.listeners(event).length;\r\n\t};\r\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Module of mixed-in functions shared between node and client code\n\t */\n\tvar isObject = __webpack_require__(23);\n\t\n\t/**\n\t * Clear previous timeout.\n\t *\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\texports.clearTimeout = function _clearTimeout(){\n\t  this._timeout = 0;\n\t  clearTimeout(this._timer);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Override default response body parser\n\t *\n\t * This function will be called to convert incoming data into request.body\n\t *\n\t * @param {Function}\n\t * @api public\n\t */\n\t\n\texports.parse = function parse(fn){\n\t  this._parser = fn;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Override default request body serializer\n\t *\n\t * This function will be called to convert data set via .send or .attach into payload to send\n\t *\n\t * @param {Function}\n\t * @api public\n\t */\n\t\n\texports.serialize = function serialize(fn){\n\t  this._serializer = fn;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set timeout to `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\texports.timeout = function timeout(ms){\n\t  this._timeout = ms;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Promise support\n\t *\n\t * @param {Function} resolve\n\t * @param {Function} reject\n\t * @return {Request}\n\t */\n\t\n\texports.then = function then(resolve, reject) {\n\t  if (!this._fullfilledPromise) {\n\t    var self = this;\n\t    this._fullfilledPromise = new Promise(function(innerResolve, innerReject){\n\t      self.end(function(err, res){\n\t        if (err) innerReject(err); else innerResolve(res);\n\t      });\n\t    });\n\t  }\n\t  return this._fullfilledPromise.then(resolve, reject);\n\t}\n\t\n\texports.catch = function(cb) {\n\t  return this.then(undefined, cb);\n\t};\n\t\n\t/**\n\t * Allow for extension\n\t */\n\t\n\texports.use = function use(fn) {\n\t  fn(this);\n\t  return this;\n\t}\n\t\n\t\n\t/**\n\t * Get request header `field`.\n\t * Case-insensitive.\n\t *\n\t * @param {String} field\n\t * @return {String}\n\t * @api public\n\t */\n\t\n\texports.get = function(field){\n\t  return this._header[field.toLowerCase()];\n\t};\n\t\n\t/**\n\t * Get case-insensitive header `field` value.\n\t * This is a deprecated internal API. Use `.get(field)` instead.\n\t *\n\t * (getHeader is no longer used internally by the superagent code base)\n\t *\n\t * @param {String} field\n\t * @return {String}\n\t * @api private\n\t * @deprecated\n\t */\n\t\n\texports.getHeader = exports.get;\n\t\n\t/**\n\t * Set header `field` to `val`, or multiple fields with one object.\n\t * Case-insensitive.\n\t *\n\t * Examples:\n\t *\n\t *      req.get('/')\n\t *        .set('Accept', 'application/json')\n\t *        .set('X-API-Key', 'foobar')\n\t *        .end(callback);\n\t *\n\t *      req.get('/')\n\t *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })\n\t *        .end(callback);\n\t *\n\t * @param {String|Object} field\n\t * @param {String} val\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\texports.set = function(field, val){\n\t  if (isObject(field)) {\n\t    for (var key in field) {\n\t      this.set(key, field[key]);\n\t    }\n\t    return this;\n\t  }\n\t  this._header[field.toLowerCase()] = val;\n\t  this.header[field] = val;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove header `field`.\n\t * Case-insensitive.\n\t *\n\t * Example:\n\t *\n\t *      req.get('/')\n\t *        .unset('User-Agent')\n\t *        .end(callback);\n\t *\n\t * @param {String} field\n\t */\n\texports.unset = function(field){\n\t  delete this._header[field.toLowerCase()];\n\t  delete this.header[field];\n\t  return this;\n\t};\n\t\n\t/**\n\t * Write the field `name` and `val`, or multiple fields with one object\n\t * for \"multipart/form-data\" request bodies.\n\t *\n\t * ``` js\n\t * request.post('/upload')\n\t *   .field('foo', 'bar')\n\t *   .end(callback);\n\t *\n\t * request.post('/upload')\n\t *   .field({ foo: 'bar', baz: 'qux' })\n\t *   .end(callback);\n\t * ```\n\t *\n\t * @param {String|Object} name\n\t * @param {String|Blob|File|Buffer|fs.ReadStream} val\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\texports.field = function(name, val) {\n\t\n\t  // name should be either a string or an object.\n\t  if (null === name ||  undefined === name) {\n\t    throw new Error('.field(name, val) name can not be empty');\n\t  }\n\t\n\t  if (isObject(name)) {\n\t    for (var key in name) {\n\t      this.field(key, name[key]);\n\t    }\n\t    return this;\n\t  }\n\t\n\t  // val should be defined now\n\t  if (null === val || undefined === val) {\n\t    throw new Error('.field(name, val) val can not be empty');\n\t  }\n\t  this._getFormData().append(name, val);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Abort the request, and clear potential timeout.\n\t *\n\t * @return {Request}\n\t * @api public\n\t */\n\texports.abort = function(){\n\t  if (this._aborted) {\n\t    return this;\n\t  }\n\t  this._aborted = true;\n\t  this.xhr && this.xhr.abort(); // browser\n\t  this.req && this.req.abort(); // node\n\t  this.clearTimeout();\n\t  this.emit('abort');\n\t  return this;\n\t};\n\t\n\t/**\n\t * Enable transmission of cookies with x-domain requests.\n\t *\n\t * Note that for this to work the origin must not be\n\t * using \"Access-Control-Allow-Origin\" with a wildcard,\n\t * and also must set \"Access-Control-Allow-Credentials\"\n\t * to \"true\".\n\t *\n\t * @api public\n\t */\n\t\n\texports.withCredentials = function(){\n\t  // This is browser-only functionality. Node side is no-op.\n\t  this._withCredentials = true;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set the max redirects to `n`. Does noting in browser XHR implementation.\n\t *\n\t * @param {Number} n\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\texports.redirects = function(n){\n\t  this._maxRedirects = n;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Convert to a plain javascript object (not JSON string) of scalar properties.\n\t * Note as this method is designed to return a useful non-this value,\n\t * it cannot be chained.\n\t *\n\t * @return {Object} describing method, url, and data of this request\n\t * @api public\n\t */\n\t\n\texports.toJSON = function(){\n\t  return {\n\t    method: this.method,\n\t    url: this.url,\n\t    data: this._data,\n\t    headers: this._header\n\t  };\n\t};\n\t\n\t/**\n\t * Check if `obj` is a host object,\n\t * we don't want to serialize these :)\n\t *\n\t * TODO: future proof, move to compoent land\n\t *\n\t * @param {Object} obj\n\t * @return {Boolean}\n\t * @api private\n\t */\n\t\n\texports._isHost = function _isHost(obj) {\n\t  var str = {}.toString.call(obj);\n\t\n\t  switch (str) {\n\t    case '[object File]':\n\t    case '[object Blob]':\n\t    case '[object FormData]':\n\t      return true;\n\t    default:\n\t      return false;\n\t  }\n\t}\n\t\n\t/**\n\t * Send `data` as the request body, defaulting the `.type()` to \"json\" when\n\t * an object is given.\n\t *\n\t * Examples:\n\t *\n\t *       // manual json\n\t *       request.post('/user')\n\t *         .type('json')\n\t *         .send('{\"name\":\"tj\"}')\n\t *         .end(callback)\n\t *\n\t *       // auto json\n\t *       request.post('/user')\n\t *         .send({ name: 'tj' })\n\t *         .end(callback)\n\t *\n\t *       // manual x-www-form-urlencoded\n\t *       request.post('/user')\n\t *         .type('form')\n\t *         .send('name=tj')\n\t *         .end(callback)\n\t *\n\t *       // auto x-www-form-urlencoded\n\t *       request.post('/user')\n\t *         .type('form')\n\t *         .send({ name: 'tj' })\n\t *         .end(callback)\n\t *\n\t *       // defaults to x-www-form-urlencoded\n\t *      request.post('/user')\n\t *        .send('name=tobi')\n\t *        .send('species=ferret')\n\t *        .end(callback)\n\t *\n\t * @param {String|Object} data\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\texports.send = function(data){\n\t  var obj = isObject(data);\n\t  var type = this._header['content-type'];\n\t\n\t  // merge\n\t  if (obj && isObject(this._data)) {\n\t    for (var key in data) {\n\t      this._data[key] = data[key];\n\t    }\n\t  } else if ('string' == typeof data) {\n\t    // default to x-www-form-urlencoded\n\t    if (!type) this.type('form');\n\t    type = this._header['content-type'];\n\t    if ('application/x-www-form-urlencoded' == type) {\n\t      this._data = this._data\n\t        ? this._data + '&' + data\n\t        : data;\n\t    } else {\n\t      this._data = (this._data || '') + data;\n\t    }\n\t  } else {\n\t    this._data = data;\n\t  }\n\t\n\t  if (!obj || this._isHost(data)) return this;\n\t\n\t  // default to json\n\t  if (!type) this.type('json');\n\t  return this;\n\t};\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Check if `obj` is an object.\n\t *\n\t * @param {Object} obj\n\t * @return {Boolean}\n\t * @api private\n\t */\n\t\n\tfunction isObject(obj) {\n\t  return null !== obj && 'object' === typeof obj;\n\t}\n\t\n\tmodule.exports = isObject;\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\t// The node and browser modules expose versions of this with the\n\t// appropriate constructor function bound as first argument\n\t/**\n\t * Issue a request:\n\t *\n\t * Examples:\n\t *\n\t *    request('GET', '/users').end(callback)\n\t *    request('/users').end(callback)\n\t *    request('/users', callback)\n\t *\n\t * @param {String} method\n\t * @param {String|Function} url or callback\n\t * @return {Request}\n\t * @api public\n\t */\n\t\n\tfunction request(RequestConstructor, method, url) {\n\t  // callback\n\t  if ('function' == typeof url) {\n\t    return new RequestConstructor('GET', method).end(url);\n\t  }\n\t\n\t  // url first\n\t  if (2 == arguments.length) {\n\t    return new RequestConstructor('GET', method);\n\t  }\n\t\n\t  return new RequestConstructor(method, url);\n\t}\n\t\n\tmodule.exports = request;\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t;(function (root, factory) {\n\t\tif (true) {\n\t\t\t// CommonJS\n\t\t\tmodule.exports = exports = factory(__webpack_require__(26));\n\t\t}\n\t\telse if (typeof define === \"function\" && define.amd) {\n\t\t\t// AMD\n\t\t\tdefine([\"./core\"], factory);\n\t\t}\n\t\telse {\n\t\t\t// Global (browser)\n\t\t\tfactory(root.CryptoJS);\n\t\t}\n\t}(this, function (CryptoJS) {\n\t\n\t\t(function (Math) {\n\t\t    // Shortcuts\n\t\t    var C = CryptoJS;\n\t\t    var C_lib = C.lib;\n\t\t    var WordArray = C_lib.WordArray;\n\t\t    var Hasher = C_lib.Hasher;\n\t\t    var C_algo = C.algo;\n\t\n\t\t    // Initialization and round constants tables\n\t\t    var H = [];\n\t\t    var K = [];\n\t\n\t\t    // Compute constants\n\t\t    (function () {\n\t\t        function isPrime(n) {\n\t\t            var sqrtN = Math.sqrt(n);\n\t\t            for (var factor = 2; factor <= sqrtN; factor++) {\n\t\t                if (!(n % factor)) {\n\t\t                    return false;\n\t\t                }\n\t\t            }\n\t\n\t\t            return true;\n\t\t        }\n\t\n\t\t        function getFractionalBits(n) {\n\t\t            return ((n - (n | 0)) * 0x100000000) | 0;\n\t\t        }\n\t\n\t\t        var n = 2;\n\t\t        var nPrime = 0;\n\t\t        while (nPrime < 64) {\n\t\t            if (isPrime(n)) {\n\t\t                if (nPrime < 8) {\n\t\t                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n\t\t                }\n\t\t                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\t\n\t\t                nPrime++;\n\t\t            }\n\t\n\t\t            n++;\n\t\t        }\n\t\t    }());\n\t\n\t\t    // Reusable object\n\t\t    var W = [];\n\t\n\t\t    /**\n\t\t     * SHA-256 hash algorithm.\n\t\t     */\n\t\t    var SHA256 = C_algo.SHA256 = Hasher.extend({\n\t\t        _doReset: function () {\n\t\t            this._hash = new WordArray.init(H.slice(0));\n\t\t        },\n\t\n\t\t        _doProcessBlock: function (M, offset) {\n\t\t            // Shortcut\n\t\t            var H = this._hash.words;\n\t\n\t\t            // Working variables\n\t\t            var a = H[0];\n\t\t            var b = H[1];\n\t\t            var c = H[2];\n\t\t            var d = H[3];\n\t\t            var e = H[4];\n\t\t            var f = H[5];\n\t\t            var g = H[6];\n\t\t            var h = H[7];\n\t\n\t\t            // Computation\n\t\t            for (var i = 0; i < 64; i++) {\n\t\t                if (i < 16) {\n\t\t                    W[i] = M[offset + i] | 0;\n\t\t                } else {\n\t\t                    var gamma0x = W[i - 15];\n\t\t                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n\t\t                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n\t\t                                   (gamma0x >>> 3);\n\t\n\t\t                    var gamma1x = W[i - 2];\n\t\t                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n\t\t                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n\t\t                                   (gamma1x >>> 10);\n\t\n\t\t                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n\t\t                }\n\t\n\t\t                var ch  = (e & f) ^ (~e & g);\n\t\t                var maj = (a & b) ^ (a & c) ^ (b & c);\n\t\n\t\t                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n\t\t                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\t\n\t\t                var t1 = h + sigma1 + ch + K[i] + W[i];\n\t\t                var t2 = sigma0 + maj;\n\t\n\t\t                h = g;\n\t\t                g = f;\n\t\t                f = e;\n\t\t                e = (d + t1) | 0;\n\t\t                d = c;\n\t\t                c = b;\n\t\t                b = a;\n\t\t                a = (t1 + t2) | 0;\n\t\t            }\n\t\n\t\t            // Intermediate hash value\n\t\t            H[0] = (H[0] + a) | 0;\n\t\t            H[1] = (H[1] + b) | 0;\n\t\t            H[2] = (H[2] + c) | 0;\n\t\t            H[3] = (H[3] + d) | 0;\n\t\t            H[4] = (H[4] + e) | 0;\n\t\t            H[5] = (H[5] + f) | 0;\n\t\t            H[6] = (H[6] + g) | 0;\n\t\t            H[7] = (H[7] + h) | 0;\n\t\t        },\n\t\n\t\t        _doFinalize: function () {\n\t\t            // Shortcuts\n\t\t            var data = this._data;\n\t\t            var dataWords = data.words;\n\t\n\t\t            var nBitsTotal = this._nDataBytes * 8;\n\t\t            var nBitsLeft = data.sigBytes * 8;\n\t\n\t\t            // Add padding\n\t\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n\t\t            data.sigBytes = dataWords.length * 4;\n\t\n\t\t            // Hash final blocks\n\t\t            this._process();\n\t\n\t\t            // Return final computed hash\n\t\t            return this._hash;\n\t\t        },\n\t\n\t\t        clone: function () {\n\t\t            var clone = Hasher.clone.call(this);\n\t\t            clone._hash = this._hash.clone();\n\t\n\t\t            return clone;\n\t\t        }\n\t\t    });\n\t\n\t\t    /**\n\t\t     * Shortcut function to the hasher's object interface.\n\t\t     *\n\t\t     * @param {WordArray|string} message The message to hash.\n\t\t     *\n\t\t     * @return {WordArray} The hash.\n\t\t     *\n\t\t     * @static\n\t\t     *\n\t\t     * @example\n\t\t     *\n\t\t     *     var hash = CryptoJS.SHA256('message');\n\t\t     *     var hash = CryptoJS.SHA256(wordArray);\n\t\t     */\n\t\t    C.SHA256 = Hasher._createHelper(SHA256);\n\t\n\t\t    /**\n\t\t     * Shortcut function to the HMAC's object interface.\n\t\t     *\n\t\t     * @param {WordArray|string} message The message to hash.\n\t\t     * @param {WordArray|string} key The secret key.\n\t\t     *\n\t\t     * @return {WordArray} The HMAC.\n\t\t     *\n\t\t     * @static\n\t\t     *\n\t\t     * @example\n\t\t     *\n\t\t     *     var hmac = CryptoJS.HmacSHA256(message, key);\n\t\t     */\n\t\t    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n\t\t}(Math));\n\t\n\t\n\t\treturn CryptoJS.SHA256;\n\t\n\t}));\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t;(function (root, factory) {\n\t\tif (true) {\n\t\t\t// CommonJS\n\t\t\tmodule.exports = exports = factory();\n\t\t}\n\t\telse if (typeof define === \"function\" && define.amd) {\n\t\t\t// AMD\n\t\t\tdefine([], factory);\n\t\t}\n\t\telse {\n\t\t\t// Global (browser)\n\t\t\troot.CryptoJS = factory();\n\t\t}\n\t}(this, function () {\n\t\n\t\t/**\n\t\t * CryptoJS core components.\n\t\t */\n\t\tvar CryptoJS = CryptoJS || (function (Math, undefined) {\n\t\t    /*\n\t\t     * Local polyfil of Object.create\n\t\t     */\n\t\t    var create = Object.create || (function () {\n\t\t        function F() {};\n\t\n\t\t        return function (obj) {\n\t\t            var subtype;\n\t\n\t\t            F.prototype = obj;\n\t\n\t\t            subtype = new F();\n\t\n\t\t            F.prototype = null;\n\t\n\t\t            return subtype;\n\t\t        };\n\t\t    }())\n\t\n\t\t    /**\n\t\t     * CryptoJS namespace.\n\t\t     */\n\t\t    var C = {};\n\t\n\t\t    /**\n\t\t     * Library namespace.\n\t\t     */\n\t\t    var C_lib = C.lib = {};\n\t\n\t\t    /**\n\t\t     * Base object for prototypal inheritance.\n\t\t     */\n\t\t    var Base = C_lib.Base = (function () {\n\t\n\t\n\t\t        return {\n\t\t            /**\n\t\t             * Creates a new object that inherits from this object.\n\t\t             *\n\t\t             * @param {Object} overrides Properties to copy into the new object.\n\t\t             *\n\t\t             * @return {Object} The new object.\n\t\t             *\n\t\t             * @static\n\t\t             *\n\t\t             * @example\n\t\t             *\n\t\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t\t             *         field: 'value',\n\t\t             *\n\t\t             *         method: function () {\n\t\t             *         }\n\t\t             *     });\n\t\t             */\n\t\t            extend: function (overrides) {\n\t\t                // Spawn\n\t\t                var subtype = create(this);\n\t\n\t\t                // Augment\n\t\t                if (overrides) {\n\t\t                    subtype.mixIn(overrides);\n\t\t                }\n\t\n\t\t                // Create default initializer\n\t\t                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {\n\t\t                    subtype.init = function () {\n\t\t                        subtype.$super.init.apply(this, arguments);\n\t\t                    };\n\t\t                }\n\t\n\t\t                // Initializer's prototype is the subtype object\n\t\t                subtype.init.prototype = subtype;\n\t\n\t\t                // Reference supertype\n\t\t                subtype.$super = this;\n\t\n\t\t                return subtype;\n\t\t            },\n\t\n\t\t            /**\n\t\t             * Extends this object and runs the init method.\n\t\t             * Arguments to create() will be passed to init().\n\t\t             *\n\t\t             * @return {Object} The new object.\n\t\t             *\n\t\t             * @static\n\t\t             *\n\t\t             * @example\n\t\t             *\n\t\t             *     var instance = MyType.create();\n\t\t             */\n\t\t            create: function () {\n\t\t                var instance = this.extend();\n\t\t                instance.init.apply(instance, arguments);\n\t\n\t\t                return instance;\n\t\t            },\n\t\n\t\t            /**\n\t\t             * Initializes a newly created object.\n\t\t             * Override this method to add some logic when your objects are created.\n\t\t             *\n\t\t             * @example\n\t\t             *\n\t\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t\t             *         init: function () {\n\t\t             *             // ...\n\t\t             *         }\n\t\t             *     });\n\t\t             */\n\t\t            init: function () {\n\t\t            },\n\t\n\t\t            /**\n\t\t             * Copies properties into this object.\n\t\t             *\n\t\t             * @param {Object} properties The properties to mix in.\n\t\t             *\n\t\t             * @example\n\t\t             *\n\t\t             *     MyType.mixIn({\n\t\t             *         field: 'value'\n\t\t             *     });\n\t\t             */\n\t\t            mixIn: function (properties) {\n\t\t                for (var propertyName in properties) {\n\t\t                    if (properties.hasOwnProperty(propertyName)) {\n\t\t                        this[propertyName] = properties[propertyName];\n\t\t                    }\n\t\t                }\n\t\n\t\t                // IE won't copy toString using the loop above\n\t\t                if (properties.hasOwnProperty('toString')) {\n\t\t                    this.toString = properties.toString;\n\t\t                }\n\t\t            },\n\t\n\t\t            /**\n\t\t             * Creates a copy of this object.\n\t\t             *\n\t\t             * @return {Object} The clone.\n\t\t             *\n\t\t             * @example\n\t\t             *\n\t\t             *     var clone = instance.clone();\n\t\t             */\n\t\t            clone: function () {\n\t\t                return this.init.prototype.extend(this);\n\t\t            }\n\t\t        };\n\t\t    }());\n\t\n\t\t    /**\n\t\t     * An array of 32-bit words.\n\t\t     *\n\t\t     * @property {Array} words The array of 32-bit words.\n\t\t     * @property {number} sigBytes The number of significant bytes in this word array.\n\t\t     */\n\t\t    var WordArray = C_lib.WordArray = Base.extend({\n\t\t        /**\n\t\t         * Initializes a newly created word array.\n\t\t         *\n\t\t         * @param {Array} words (Optional) An array of 32-bit words.\n\t\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var wordArray = CryptoJS.lib.WordArray.create();\n\t\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n\t\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n\t\t         */\n\t\t        init: function (words, sigBytes) {\n\t\t            words = this.words = words || [];\n\t\n\t\t            if (sigBytes != undefined) {\n\t\t                this.sigBytes = sigBytes;\n\t\t            } else {\n\t\t                this.sigBytes = words.length * 4;\n\t\t            }\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Converts this word array to a string.\n\t\t         *\n\t\t         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n\t\t         *\n\t\t         * @return {string} The stringified word array.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var string = wordArray + '';\n\t\t         *     var string = wordArray.toString();\n\t\t         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n\t\t         */\n\t\t        toString: function (encoder) {\n\t\t            return (encoder || Hex).stringify(this);\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Concatenates a word array to this word array.\n\t\t         *\n\t\t         * @param {WordArray} wordArray The word array to append.\n\t\t         *\n\t\t         * @return {WordArray} This word array.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     wordArray1.concat(wordArray2);\n\t\t         */\n\t\t        concat: function (wordArray) {\n\t\t            // Shortcuts\n\t\t            var thisWords = this.words;\n\t\t            var thatWords = wordArray.words;\n\t\t            var thisSigBytes = this.sigBytes;\n\t\t            var thatSigBytes = wordArray.sigBytes;\n\t\n\t\t            // Clamp excess bits\n\t\t            this.clamp();\n\t\n\t\t            // Concat\n\t\t            if (thisSigBytes % 4) {\n\t\t                // Copy one byte at a time\n\t\t                for (var i = 0; i < thatSigBytes; i++) {\n\t\t                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t\t                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n\t\t                }\n\t\t            } else {\n\t\t                // Copy one word at a time\n\t\t                for (var i = 0; i < thatSigBytes; i += 4) {\n\t\t                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n\t\t                }\n\t\t            }\n\t\t            this.sigBytes += thatSigBytes;\n\t\n\t\t            // Chainable\n\t\t            return this;\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Removes insignificant bits.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     wordArray.clamp();\n\t\t         */\n\t\t        clamp: function () {\n\t\t            // Shortcuts\n\t\t            var words = this.words;\n\t\t            var sigBytes = this.sigBytes;\n\t\n\t\t            // Clamp\n\t\t            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n\t\t            words.length = Math.ceil(sigBytes / 4);\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Creates a copy of this word array.\n\t\t         *\n\t\t         * @return {WordArray} The clone.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var clone = wordArray.clone();\n\t\t         */\n\t\t        clone: function () {\n\t\t            var clone = Base.clone.call(this);\n\t\t            clone.words = this.words.slice(0);\n\t\n\t\t            return clone;\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Creates a word array filled with random bytes.\n\t\t         *\n\t\t         * @param {number} nBytes The number of random bytes to generate.\n\t\t         *\n\t\t         * @return {WordArray} The random word array.\n\t\t         *\n\t\t         * @static\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n\t\t         */\n\t\t        random: function (nBytes) {\n\t\t            var words = [];\n\t\n\t\t            var r = (function (m_w) {\n\t\t                var m_w = m_w;\n\t\t                var m_z = 0x3ade68b1;\n\t\t                var mask = 0xffffffff;\n\t\n\t\t                return function () {\n\t\t                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;\n\t\t                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;\n\t\t                    var result = ((m_z << 0x10) + m_w) & mask;\n\t\t                    result /= 0x100000000;\n\t\t                    result += 0.5;\n\t\t                    return result * (Math.random() > .5 ? 1 : -1);\n\t\t                }\n\t\t            });\n\t\n\t\t            for (var i = 0, rcache; i < nBytes; i += 4) {\n\t\t                var _r = r((rcache || Math.random()) * 0x100000000);\n\t\n\t\t                rcache = _r() * 0x3ade67b7;\n\t\t                words.push((_r() * 0x100000000) | 0);\n\t\t            }\n\t\n\t\t            return new WordArray.init(words, nBytes);\n\t\t        }\n\t\t    });\n\t\n\t\t    /**\n\t\t     * Encoder namespace.\n\t\t     */\n\t\t    var C_enc = C.enc = {};\n\t\n\t\t    /**\n\t\t     * Hex encoding strategy.\n\t\t     */\n\t\t    var Hex = C_enc.Hex = {\n\t\t        /**\n\t\t         * Converts a word array to a hex string.\n\t\t         *\n\t\t         * @param {WordArray} wordArray The word array.\n\t\t         *\n\t\t         * @return {string} The hex string.\n\t\t         *\n\t\t         * @static\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n\t\t         */\n\t\t        stringify: function (wordArray) {\n\t\t            // Shortcuts\n\t\t            var words = wordArray.words;\n\t\t            var sigBytes = wordArray.sigBytes;\n\t\n\t\t            // Convert\n\t\t            var hexChars = [];\n\t\t            for (var i = 0; i < sigBytes; i++) {\n\t\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t\t                hexChars.push((bite >>> 4).toString(16));\n\t\t                hexChars.push((bite & 0x0f).toString(16));\n\t\t            }\n\t\n\t\t            return hexChars.join('');\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Converts a hex string to a word array.\n\t\t         *\n\t\t         * @param {string} hexStr The hex string.\n\t\t         *\n\t\t         * @return {WordArray} The word array.\n\t\t         *\n\t\t         * @static\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n\t\t         */\n\t\t        parse: function (hexStr) {\n\t\t            // Shortcut\n\t\t            var hexStrLength = hexStr.length;\n\t\n\t\t            // Convert\n\t\t            var words = [];\n\t\t            for (var i = 0; i < hexStrLength; i += 2) {\n\t\t                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n\t\t            }\n\t\n\t\t            return new WordArray.init(words, hexStrLength / 2);\n\t\t        }\n\t\t    };\n\t\n\t\t    /**\n\t\t     * Latin1 encoding strategy.\n\t\t     */\n\t\t    var Latin1 = C_enc.Latin1 = {\n\t\t        /**\n\t\t         * Converts a word array to a Latin1 string.\n\t\t         *\n\t\t         * @param {WordArray} wordArray The word array.\n\t\t         *\n\t\t         * @return {string} The Latin1 string.\n\t\t         *\n\t\t         * @static\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n\t\t         */\n\t\t        stringify: function (wordArray) {\n\t\t            // Shortcuts\n\t\t            var words = wordArray.words;\n\t\t            var sigBytes = wordArray.sigBytes;\n\t\n\t\t            // Convert\n\t\t            var latin1Chars = [];\n\t\t            for (var i = 0; i < sigBytes; i++) {\n\t\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t\t                latin1Chars.push(String.fromCharCode(bite));\n\t\t            }\n\t\n\t\t            return latin1Chars.join('');\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Converts a Latin1 string to a word array.\n\t\t         *\n\t\t         * @param {string} latin1Str The Latin1 string.\n\t\t         *\n\t\t         * @return {WordArray} The word array.\n\t\t         *\n\t\t         * @static\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n\t\t         */\n\t\t        parse: function (latin1Str) {\n\t\t            // Shortcut\n\t\t            var latin1StrLength = latin1Str.length;\n\t\n\t\t            // Convert\n\t\t            var words = [];\n\t\t            for (var i = 0; i < latin1StrLength; i++) {\n\t\t                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n\t\t            }\n\t\n\t\t            return new WordArray.init(words, latin1StrLength);\n\t\t        }\n\t\t    };\n\t\n\t\t    /**\n\t\t     * UTF-8 encoding strategy.\n\t\t     */\n\t\t    var Utf8 = C_enc.Utf8 = {\n\t\t        /**\n\t\t         * Converts a word array to a UTF-8 string.\n\t\t         *\n\t\t         * @param {WordArray} wordArray The word array.\n\t\t         *\n\t\t         * @return {string} The UTF-8 string.\n\t\t         *\n\t\t         * @static\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n\t\t         */\n\t\t        stringify: function (wordArray) {\n\t\t            try {\n\t\t                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n\t\t            } catch (e) {\n\t\t                throw new Error('Malformed UTF-8 data');\n\t\t            }\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Converts a UTF-8 string to a word array.\n\t\t         *\n\t\t         * @param {string} utf8Str The UTF-8 string.\n\t\t         *\n\t\t         * @return {WordArray} The word array.\n\t\t         *\n\t\t         * @static\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n\t\t         */\n\t\t        parse: function (utf8Str) {\n\t\t            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n\t\t        }\n\t\t    };\n\t\n\t\t    /**\n\t\t     * Abstract buffered block algorithm template.\n\t\t     *\n\t\t     * The property blockSize must be implemented in a concrete subtype.\n\t\t     *\n\t\t     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n\t\t     */\n\t\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n\t\t        /**\n\t\t         * Resets this block algorithm's data buffer to its initial state.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     bufferedBlockAlgorithm.reset();\n\t\t         */\n\t\t        reset: function () {\n\t\t            // Initial values\n\t\t            this._data = new WordArray.init();\n\t\t            this._nDataBytes = 0;\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Adds new data to this block algorithm's buffer.\n\t\t         *\n\t\t         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     bufferedBlockAlgorithm._append('data');\n\t\t         *     bufferedBlockAlgorithm._append(wordArray);\n\t\t         */\n\t\t        _append: function (data) {\n\t\t            // Convert string to WordArray, else assume WordArray already\n\t\t            if (typeof data == 'string') {\n\t\t                data = Utf8.parse(data);\n\t\t            }\n\t\n\t\t            // Append\n\t\t            this._data.concat(data);\n\t\t            this._nDataBytes += data.sigBytes;\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Processes available data blocks.\n\t\t         *\n\t\t         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n\t\t         *\n\t\t         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n\t\t         *\n\t\t         * @return {WordArray} The processed data.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var processedData = bufferedBlockAlgorithm._process();\n\t\t         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n\t\t         */\n\t\t        _process: function (doFlush) {\n\t\t            // Shortcuts\n\t\t            var data = this._data;\n\t\t            var dataWords = data.words;\n\t\t            var dataSigBytes = data.sigBytes;\n\t\t            var blockSize = this.blockSize;\n\t\t            var blockSizeBytes = blockSize * 4;\n\t\n\t\t            // Count blocks ready\n\t\t            var nBlocksReady = dataSigBytes / blockSizeBytes;\n\t\t            if (doFlush) {\n\t\t                // Round up to include partial blocks\n\t\t                nBlocksReady = Math.ceil(nBlocksReady);\n\t\t            } else {\n\t\t                // Round down to include only full blocks,\n\t\t                // less the number of blocks that must remain in the buffer\n\t\t                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n\t\t            }\n\t\n\t\t            // Count words ready\n\t\t            var nWordsReady = nBlocksReady * blockSize;\n\t\n\t\t            // Count bytes ready\n\t\t            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\t\n\t\t            // Process blocks\n\t\t            if (nWordsReady) {\n\t\t                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n\t\t                    // Perform concrete-algorithm logic\n\t\t                    this._doProcessBlock(dataWords, offset);\n\t\t                }\n\t\n\t\t                // Remove processed words\n\t\t                var processedWords = dataWords.splice(0, nWordsReady);\n\t\t                data.sigBytes -= nBytesReady;\n\t\t            }\n\t\n\t\t            // Return processed words\n\t\t            return new WordArray.init(processedWords, nBytesReady);\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Creates a copy of this object.\n\t\t         *\n\t\t         * @return {Object} The clone.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var clone = bufferedBlockAlgorithm.clone();\n\t\t         */\n\t\t        clone: function () {\n\t\t            var clone = Base.clone.call(this);\n\t\t            clone._data = this._data.clone();\n\t\n\t\t            return clone;\n\t\t        },\n\t\n\t\t        _minBufferSize: 0\n\t\t    });\n\t\n\t\t    /**\n\t\t     * Abstract hasher template.\n\t\t     *\n\t\t     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n\t\t     */\n\t\t    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n\t\t        /**\n\t\t         * Configuration options.\n\t\t         */\n\t\t        cfg: Base.extend(),\n\t\n\t\t        /**\n\t\t         * Initializes a newly created hasher.\n\t\t         *\n\t\t         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var hasher = CryptoJS.algo.SHA256.create();\n\t\t         */\n\t\t        init: function (cfg) {\n\t\t            // Apply config defaults\n\t\t            this.cfg = this.cfg.extend(cfg);\n\t\n\t\t            // Set initial values\n\t\t            this.reset();\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Resets this hasher to its initial state.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     hasher.reset();\n\t\t         */\n\t\t        reset: function () {\n\t\t            // Reset data buffer\n\t\t            BufferedBlockAlgorithm.reset.call(this);\n\t\n\t\t            // Perform concrete-hasher logic\n\t\t            this._doReset();\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Updates this hasher with a message.\n\t\t         *\n\t\t         * @param {WordArray|string} messageUpdate The message to append.\n\t\t         *\n\t\t         * @return {Hasher} This hasher.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     hasher.update('message');\n\t\t         *     hasher.update(wordArray);\n\t\t         */\n\t\t        update: function (messageUpdate) {\n\t\t            // Append\n\t\t            this._append(messageUpdate);\n\t\n\t\t            // Update the hash\n\t\t            this._process();\n\t\n\t\t            // Chainable\n\t\t            return this;\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Finalizes the hash computation.\n\t\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t\t         *\n\t\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t\t         *\n\t\t         * @return {WordArray} The hash.\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var hash = hasher.finalize();\n\t\t         *     var hash = hasher.finalize('message');\n\t\t         *     var hash = hasher.finalize(wordArray);\n\t\t         */\n\t\t        finalize: function (messageUpdate) {\n\t\t            // Final message update\n\t\t            if (messageUpdate) {\n\t\t                this._append(messageUpdate);\n\t\t            }\n\t\n\t\t            // Perform concrete-hasher logic\n\t\t            var hash = this._doFinalize();\n\t\n\t\t            return hash;\n\t\t        },\n\t\n\t\t        blockSize: 512/32,\n\t\n\t\t        /**\n\t\t         * Creates a shortcut function to a hasher's object interface.\n\t\t         *\n\t\t         * @param {Hasher} hasher The hasher to create a helper for.\n\t\t         *\n\t\t         * @return {Function} The shortcut function.\n\t\t         *\n\t\t         * @static\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n\t\t         */\n\t\t        _createHelper: function (hasher) {\n\t\t            return function (message, cfg) {\n\t\t                return new hasher.init(cfg).finalize(message);\n\t\t            };\n\t\t        },\n\t\n\t\t        /**\n\t\t         * Creates a shortcut function to the HMAC's object interface.\n\t\t         *\n\t\t         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n\t\t         *\n\t\t         * @return {Function} The shortcut function.\n\t\t         *\n\t\t         * @static\n\t\t         *\n\t\t         * @example\n\t\t         *\n\t\t         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n\t\t         */\n\t\t        _createHmacHelper: function (hasher) {\n\t\t            return function (message, key) {\n\t\t                return new C_algo.HMAC.init(hasher, key).finalize(message);\n\t\t            };\n\t\t        }\n\t\t    });\n\t\n\t\t    /**\n\t\t     * Algorithm namespace.\n\t\t     */\n\t\t    var C_algo = C.algo = {};\n\t\n\t\t    return C;\n\t\t}(Math));\n\t\n\t\n\t\treturn CryptoJS;\n\t\n\t}));\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _loglevel = __webpack_require__(28);\n\t\n\tvar _loglevel2 = _interopRequireDefault(_loglevel);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar originalFactory = _loglevel2.default.methodFactory;\n\t\n\t_loglevel2.default.methodFactory = function (methodName, logLevel) {\n\t  var rawMethod = originalFactory(methodName, logLevel);\n\t\n\t  return function (message) {\n\t    rawMethod('Telepat: ' + message);\n\t  };\n\t};\n\t_loglevel2.default.setLevel('warn');\n\t\n\texports.default = _loglevel2.default;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n\t* loglevel - https://github.com/pimterry/loglevel\n\t*\n\t* Copyright (c) 2013 Tim Perry\n\t* Licensed under the MIT license.\n\t*/\n\t(function (root, definition) {\n\t    \"use strict\";\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof module === 'object' && module.exports) {\n\t        module.exports = definition();\n\t    } else {\n\t        root.log = definition();\n\t    }\n\t}(this, function () {\n\t    \"use strict\";\n\t    var noop = function() {};\n\t    var undefinedType = \"undefined\";\n\t\n\t    function realMethod(methodName) {\n\t        if (typeof console === undefinedType) {\n\t            return false; // We can't build a real method without a console to log to\n\t        } else if (console[methodName] !== undefined) {\n\t            return bindMethod(console, methodName);\n\t        } else if (console.log !== undefined) {\n\t            return bindMethod(console, 'log');\n\t        } else {\n\t            return noop;\n\t        }\n\t    }\n\t\n\t    function bindMethod(obj, methodName) {\n\t        var method = obj[methodName];\n\t        if (typeof method.bind === 'function') {\n\t            return method.bind(obj);\n\t        } else {\n\t            try {\n\t                return Function.prototype.bind.call(method, obj);\n\t            } catch (e) {\n\t                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n\t                return function() {\n\t                    return Function.prototype.apply.apply(method, [obj, arguments]);\n\t                };\n\t            }\n\t        }\n\t    }\n\t\n\t    // these private functions always need `this` to be set properly\n\t\n\t    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n\t        return function () {\n\t            if (typeof console !== undefinedType) {\n\t                replaceLoggingMethods.call(this, level, loggerName);\n\t                this[methodName].apply(this, arguments);\n\t            }\n\t        };\n\t    }\n\t\n\t    function replaceLoggingMethods(level, loggerName) {\n\t        /*jshint validthis:true */\n\t        for (var i = 0; i < logMethods.length; i++) {\n\t            var methodName = logMethods[i];\n\t            this[methodName] = (i < level) ?\n\t                noop :\n\t                this.methodFactory(methodName, level, loggerName);\n\t        }\n\t    }\n\t\n\t    function defaultMethodFactory(methodName, level, loggerName) {\n\t        /*jshint validthis:true */\n\t        return realMethod(methodName) ||\n\t               enableLoggingWhenConsoleArrives.apply(this, arguments);\n\t    }\n\t\n\t    var logMethods = [\n\t        \"trace\",\n\t        \"debug\",\n\t        \"info\",\n\t        \"warn\",\n\t        \"error\"\n\t    ];\n\t\n\t    function Logger(name, defaultLevel, factory) {\n\t      var self = this;\n\t      var currentLevel;\n\t      var storageKey = \"loglevel\";\n\t      if (name) {\n\t        storageKey += \":\" + name;\n\t      }\n\t\n\t      function persistLevelIfPossible(levelNum) {\n\t          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\t\n\t          // Use localStorage if available\n\t          try {\n\t              window.localStorage[storageKey] = levelName;\n\t              return;\n\t          } catch (ignore) {}\n\t\n\t          // Use session cookie as fallback\n\t          try {\n\t              window.document.cookie =\n\t                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n\t          } catch (ignore) {}\n\t      }\n\t\n\t      function getPersistedLevel() {\n\t          var storedLevel;\n\t\n\t          try {\n\t              storedLevel = window.localStorage[storageKey];\n\t          } catch (ignore) {}\n\t\n\t          if (typeof storedLevel === undefinedType) {\n\t              try {\n\t                  var cookie = window.document.cookie;\n\t                  var location = cookie.indexOf(\n\t                      encodeURIComponent(storageKey) + \"=\");\n\t                  if (location) {\n\t                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n\t                  }\n\t              } catch (ignore) {}\n\t          }\n\t\n\t          // If the stored level is not valid, treat it as if nothing was stored.\n\t          if (self.levels[storedLevel] === undefined) {\n\t              storedLevel = undefined;\n\t          }\n\t\n\t          return storedLevel;\n\t      }\n\t\n\t      /*\n\t       *\n\t       * Public API\n\t       *\n\t       */\n\t\n\t      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n\t          \"ERROR\": 4, \"SILENT\": 5};\n\t\n\t      self.methodFactory = factory || defaultMethodFactory;\n\t\n\t      self.getLevel = function () {\n\t          return currentLevel;\n\t      };\n\t\n\t      self.setLevel = function (level, persist) {\n\t          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n\t              level = self.levels[level.toUpperCase()];\n\t          }\n\t          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n\t              currentLevel = level;\n\t              if (persist !== false) {  // defaults to true\n\t                  persistLevelIfPossible(level);\n\t              }\n\t              replaceLoggingMethods.call(self, level, name);\n\t              if (typeof console === undefinedType && level < self.levels.SILENT) {\n\t                  return \"No console available for logging\";\n\t              }\n\t          } else {\n\t              throw \"log.setLevel() called with invalid level: \" + level;\n\t          }\n\t      };\n\t\n\t      self.setDefaultLevel = function (level) {\n\t          if (!getPersistedLevel()) {\n\t              self.setLevel(level, false);\n\t          }\n\t      };\n\t\n\t      self.enableAll = function(persist) {\n\t          self.setLevel(self.levels.TRACE, persist);\n\t      };\n\t\n\t      self.disableAll = function(persist) {\n\t          self.setLevel(self.levels.SILENT, persist);\n\t      };\n\t\n\t      // Initialize with the right level\n\t      var initialLevel = getPersistedLevel();\n\t      if (initialLevel == null) {\n\t          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n\t      }\n\t      self.setLevel(initialLevel, false);\n\t    }\n\t\n\t    /*\n\t     *\n\t     * Package-level API\n\t     *\n\t     */\n\t\n\t    var defaultLogger = new Logger();\n\t\n\t    var _loggersByName = {};\n\t    defaultLogger.getLogger = function getLogger(name) {\n\t        if (typeof name !== \"string\" || name === \"\") {\n\t          throw new TypeError(\"You must supply a name when creating a logger.\");\n\t        }\n\t\n\t        var logger = _loggersByName[name];\n\t        if (!logger) {\n\t          logger = _loggersByName[name] = new Logger(\n\t            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n\t        }\n\t        return logger;\n\t    };\n\t\n\t    // Grab the current global log variable in case of overwrite\n\t    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n\t    defaultLogger.noConflict = function() {\n\t        if (typeof window !== undefinedType &&\n\t               window.log === defaultLogger) {\n\t            window.log = _log;\n\t        }\n\t\n\t        return defaultLogger;\n\t    };\n\t\n\t    return defaultLogger;\n\t}));\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = error;\n\t\n\tvar _logger = __webpack_require__(27);\n\t\n\tvar _logger2 = _interopRequireDefault(_logger);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction error(string) {\n\t  _logger2.default.error(string);\n\t  return new Error(string);\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _logger = __webpack_require__(27);\n\t\n\tvar _logger2 = _interopRequireDefault(_logger);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Event = function () {\n\t  function Event() {\n\t    _classCallCheck(this, Event);\n\t\n\t    this.eventFunctions = {};\n\t  }\n\t\n\t  _createClass(Event, [{\n\t    key: 'on',\n\t    value: function on(name, callback) {\n\t      if (_typeof(this.eventFunctions[name]) !== 'object') {\n\t        this.eventFunctions[name] = {};\n\t      }\n\t\n\t      var index = Date.now() + Object.keys(this.eventFunctions[name]).length;\n\t\n\t      this.eventFunctions[name][index] = callback;\n\t      return index;\n\t    }\n\t  }, {\n\t    key: 'removeCallback',\n\t    value: function removeCallback(name, index) {\n\t      delete this.eventFunctions[name][index];\n\t    }\n\t  }, {\n\t    key: 'emit',\n\t    value: function emit(args) {\n\t      _logger2.default.debug('Emitting ' + arguments[0] + ' event');\n\t      var params = Array.prototype.slice.call(arguments);\n\t\n\t      params.shift();\n\t      if (typeof this.eventFunctions[arguments[0]] !== 'undefined') {\n\t        var callbacks = this.eventFunctions[arguments[0]];\n\t\n\t        for (var index in callbacks) {\n\t          callbacks[index].apply(this, params);\n\t        }\n\t      }\n\t    }\n\t  }]);\n\t\n\t  return Event;\n\t}();\n\t\n\texports.default = Event;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _event = __webpack_require__(30);\n\t\n\tvar _event2 = _interopRequireDefault(_event);\n\t\n\tvar _api = __webpack_require__(19);\n\t\n\tvar _api2 = _interopRequireDefault(_api);\n\t\n\tvar _logger = __webpack_require__(27);\n\t\n\tvar _logger2 = _interopRequireDefault(_logger);\n\t\n\tvar _error = __webpack_require__(29);\n\t\n\tvar _error2 = _interopRequireDefault(_error);\n\t\n\tvar _jsondiffpatch = __webpack_require__(36);\n\t\n\tvar _jsondiffpatch2 = _interopRequireDefault(_jsondiffpatch);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar jsondiffpatch = _jsondiffpatch2.default.create({\n\t  objectHash: function objectHash(obj) {\n\t    if (obj.id) {\n\t      return obj.id;\n\t    }\n\t    return JSON.stringify(obj);\n\t  }, textDiff: {\n\t    minLength: 10000\n\t  }\n\t});\n\t\n\tvar Monitor = function () {\n\t  function Monitor() {\n\t    var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 150;\n\t\n\t    _classCallCheck(this, Monitor);\n\t\n\t    function objectPropertyTrimFilter(context) {\n\t      function trimObject(obj) {\n\t        var trimmedObject = {};\n\t\n\t        for (var name in obj) {\n\t          if (name.slice(0, 2) !== '$$' && typeof obj[name] !== 'function') {\n\t            trimmedObject[name] = obj[name];\n\t          }\n\t        }\n\t        return trimmedObject;\n\t      }\n\t      if (!context.leftIsArray && context.leftType === 'object') {\n\t        context.left = trimObject(context.left);\n\t      }\n\t      if (!context.rightIsArray && context.rightType === 'object') {\n\t        context.right = trimObject(context.right);\n\t      }\n\t    }\n\t\n\t    jsondiffpatch.processor.pipes.diff.before('objects', objectPropertyTrimFilter);\n\t\n\t    this._updateRunning = false;\n\t    this._processingPatch = false;\n\t    this._timer = null;\n\t    this._lastObjects = {};\n\t    this._events = {};\n\t\n\t    this.objects = {};\n\t    this.options = {};\n\t    this.callbacks = {};\n\t    this.timerInterval = interval;\n\t  }\n\t\n\t  _createClass(Monitor, [{\n\t    key: 'remove',\n\t    value: function remove(subscriptionOptions) {\n\t      var subscriptionKey = Monitor.subscriptionKeyForOptions(subscriptionOptions);\n\t\n\t      delete this.objects[subscriptionKey];\n\t      delete this._lastObjects[subscriptionKey];\n\t      delete this.options[subscriptionKey];\n\t      delete this.callbacks[subscriptionKey];\n\t      delete this._events[subscriptionKey];\n\t    }\n\t  }, {\n\t    key: 'add',\n\t    value: function add(subscriptionOptions, objects, event, addCallback, removeCallback, updateCallback) {\n\t      var _this = this;\n\t\n\t      var processDeltaObject = function processDeltaObject(object) {\n\t        if (Array.isArray(object) || object['_t'] === 'a') {\n\t          return true;\n\t        }\n\t        for (var key in object) {\n\t          if (_typeof(object[key]) === 'object' && processDeltaObject(object[key])) {\n\t            delete object[key];\n\t          }\n\t        }\n\t        if (Object.keys(object).length === 0) {\n\t          return true;\n\t        }\n\t        return false;\n\t      };\n\t\n\t      var timerFunction = function timerFunction() {\n\t        if (_this._processingPatch || _this._updateRunning) {\n\t          return;\n\t        }\n\t        var totalDiff = jsondiffpatch.diff(_this._lastObjects, _this.objects);\n\t\n\t        if (totalDiff !== undefined) {\n\t          _logger2.default.debug('Found diff: ' + JSON.stringify(totalDiff));\n\t          for (var subKey in totalDiff) {\n\t            var root = _this._lastObjects[subKey];\n\t            var diff = totalDiff[subKey];\n\t            var options = _this.options[subKey];\n\t            var callbacks = _this.callbacks[subKey];\n\t            var diffKeys = Object.keys(diff);\n\t\n\t            for (var i = 0; i < diffKeys.length; i++) {\n\t              var key = diffKeys[i];\n\t\n\t              if (key !== '_t') {\n\t                var obj = diff[key];\n\t\n\t                if (Array.isArray(obj)) {\n\t                  if (obj.length === 1) {\n\t                    callbacks.add(_this.objects[subKey][key]);\n\t                    delete root[key];\n\t                    delete _this.objects[subKey][key];\n\t                    _logger2.default.debug('Adding object to ' + subKey + ' channel');\n\t                  } else if (obj.length === 3) {\n\t                    callbacks.remove(key);\n\t                    delete root[key];\n\t                    _logger2.default.debug('Removing object from ' + subKey + ' channel');\n\t                  }\n\t                } else {\n\t                  var objKeys = Object.keys(obj);\n\t                  var patch = [];\n\t                  var publicKey = key;\n\t\n\t                  if (Array.isArray(_this.objects[subKey]) && _this.objects[subKey][key].id) {\n\t                    publicKey = _this.objects[subKey][key].id;\n\t                  }\n\t\n\t                  for (var j = 0; j < objKeys.length; j++) {\n\t                    var objKey = objKeys[j];\n\t                    var delta = obj[objKey];\n\t\n\t                    if (!processDeltaObject(delta)) {\n\t                      if ((typeof delta === 'undefined' ? 'undefined' : _typeof(delta)) === 'object') {\n\t                        patch.push({ 'op': 'replace', 'path': options.channel.model + '/' + publicKey + '/' + objKey, 'value': _this.objects[subKey][key][objKey] });\n\t                        _logger2.default.debug('Modified ' + objKey + ' property on object ' + key + ', ' + options.channel.model + ' channel');\n\t                      } else if (delta.length === 1) {\n\t                        patch.push({ 'op': 'replace', 'path': options.channel.model + '/' + publicKey + '/' + objKey, 'value': delta[0] });\n\t                        _logger2.default.debug('Added ' + objKey + ' property to object ' + key + ', ' + options.channel.model + ' channel');\n\t                      } else if (delta.length === 2) {\n\t                        patch.push({ 'op': 'replace', 'path': options.channel.model + '/' + publicKey + '/' + objKey, 'value': delta[1] });\n\t                        _logger2.default.debug('Modified ' + objKey + ' property on object ' + key + ', ' + options.channel.model + ' channel');\n\t                      } else if (delta.length === 3) {\n\t                        _logger2.default.info('Removing object properties is not supported in this version. Try setting to an empty value instead.');\n\t                      }\n\t                    } else {\n\t                      patch.push({ 'op': 'replace', 'path': options.channel.model + '/' + publicKey + '/' + objKey, 'value': _this.objects[subKey][key][objKey] });\n\t                      _logger2.default.debug('Modified ' + objKey + ' property on object ' + key + ', ' + options.channel.model + ' channel');\n\t                    }\n\t\n\t                    root[key][objKey] = JSON.parse(JSON.stringify(_this.objects[subKey][key][objKey]));\n\t                  }\n\t\n\t                  if (patch.length) {\n\t                    callbacks.update(publicKey, patch);\n\t                  }\n\t                  _logger2.default.debug('Sending patch to object ' + key + ' on ' + options.channel.model + ' channel: ' + JSON.stringify(patch));\n\t                }\n\t              }\n\t            }\n\t          }\n\t        }\n\t      };\n\t\n\t      var subscriptionKey = Monitor.subscriptionKeyForOptions(subscriptionOptions);\n\t\n\t      this.objects[subscriptionKey] = objects;\n\t      this.options[subscriptionKey] = subscriptionOptions;\n\t      this.callbacks[subscriptionKey] = {\n\t        add: addCallback,\n\t        remove: removeCallback,\n\t        update: updateCallback\n\t      };\n\t      this._events[subscriptionKey] = event;\n\t      this._lastObjects[subscriptionKey] = JSON.parse(JSON.stringify(this.objects[subscriptionKey]));\n\t\n\t      if (this._timer === null) {\n\t        this._timer = setInterval(timerFunction, this.timerInterval);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'processMessage',\n\t\n\t\n\t    // ## Getting notified of object modifications\n\t    // Use the `Channel.on('update', ...)` function to subscribe to object updates.\n\t    //  This will only notify you of changes received from the 'outside' - you'll only see events when the backend\n\t    //  notifies the client that there are updates available, either made by you or by someone else.\n\t    //\n\t    //     Channel.on('update', function(operation, parentId, parentObject, delta) {\n\t    //       // operation can be one of 'replace', 'delete' or 'add'.\n\t    //       // parentId is the id of the Telepat object being modified.\n\t    //       // parentObject is the Telepat object being modified.\n\t    //       // delta is available just for the 'replace' operation, and is an object that contains two properties:\n\t    //  'path' (the name of the modified property on the object) and 'oldValue'.\n\t    //     });\n\t\n\t    value: function processMessage(message) {\n\t      var _this2 = this;\n\t\n\t      var process = function process(operation) {\n\t        for (var _i = 0; _i < operation.subscriptions.length; _i++) {\n\t          var subscription = operation.subscriptions[_i];\n\t\n\t          var subscriptionComponents = subscription.split(':');\n\t\n\t          // Handle collection updates\n\t          if (subscriptionComponents[2] === 'context' && subscriptionComponents.length === 4) {\n\t            subscriptionComponents.pop();\n\t            subscription = subscriptionComponents.join(':');\n\t          }\n\t\n\t          var root = _this2.objects[subscription];\n\t          var lastRoot = _this2._lastObjects[subscription];\n\t          var event = _this2._events[subscription];\n\t\n\t          if (root) {\n\t            if (operation.op === 'new') {\n\t              if (!root.hasOwnProperty(operation.object.id)) {\n\t                operation.object.$$event = new _event2.default(_logger2.default);\n\t                root[operation.object.id] = operation.object;\n\t                lastRoot[operation.object.id] = JSON.parse(JSON.stringify(operation.object));\n\t                event.emit('update', 'add', operation.object.id, operation.object);\n\t                _logger2.default.debug('Added object with id ' + operation.object.id);\n\t              } else {\n\t                event.emit('error', (0, _error2.default)('Object id already exists ' + operation.object.id), operation.object.id, root[operation.object.id]);\n\t              }\n\t            } else if (operation.op === 'update') {\n\t              var pathComponents = operation.patch.path.split('/');\n\t              var objectId = pathComponents[1];\n\t              var changedProperty = pathComponents[2];\n\t              var newValue = operation.patch.value;\n\t\n\t              if (!root.hasOwnProperty(objectId)) {\n\t                event.emit('error', (0, _error2.default)('Object id doesn\\'t exist ' + objectId), objectId, changedProperty, newValue);\n\t              } else if (typeof newValue !== 'undefined') {\n\t                var parent = root[objectId];\n\t                var oldValue = void 0;\n\t\n\t                if (typeof parent[changedProperty] !== 'undefined') {\n\t                  oldValue = JSON.parse(JSON.stringify(parent[changedProperty]));\n\t                }\n\t\n\t                parent[changedProperty] = newValue;\n\t                lastRoot[objectId][changedProperty] = JSON.parse(JSON.stringify(newValue));\n\t                event.emit('update', 'replace', objectId, parent, { path: changedProperty, oldValue: oldValue });\n\t                _logger2.default.debug('Replaced property ' + changedProperty + ' of object id ' + objectId + ' with  value ' + newValue);\n\t              } else {\n\t                event.emit('error', (0, _error2.default)('Invalid operation ' + JSON.stringify(operation)));\n\t              }\n\t            } else {\n\t              var _oldValue = root[operation.object.id];\n\t\n\t              delete root[operation.object.id];\n\t              delete lastRoot[operation.object.id];\n\t              event.emit('update', 'delete', operation.object.id, _oldValue);\n\t              _logger2.default.debug('Removed object id ' + operation.object.id);\n\t            }\n\t          } else {\n\t            _logger2.default.warn('Subscription not found ' + subscription);\n\t          }\n\t        }\n\t      };\n\t\n\t      this._processingPatch = true;\n\t      _logger2.default.debug('Received update: ' + JSON.stringify(message));\n\t      var i, operation;\n\t\n\t      for (i = 0; i < message.data.new.length; i++) {\n\t        operation = message.data.new[i];\n\t        operation.op = 'new';\n\t        process(operation);\n\t      }\n\t      for (i = 0; i < message.data.updated.length; i++) {\n\t        operation = message.data.updated[i];\n\t        operation.op = 'update';\n\t        process(operation);\n\t      }\n\t      for (i = 0; i < message.data.deleted.length; i++) {\n\t        operation = message.data.deleted[i];\n\t        operation.op = 'remove';\n\t        process(operation);\n\t      }\n\t      this._processingPatch = false;\n\t    }\n\t  }], [{\n\t    key: 'subscriptionKeyForOptions',\n\t    value: function subscriptionKeyForOptions(options) {\n\t      var key = 'blg:' + _api2.default.appId;\n\t\n\t      if (!options.channel.id && options.channel.context) {\n\t        key += ':context:' + options.channel.context;\n\t      }\n\t      if (options.channel.parent) {\n\t        key += ':' + options.channel.parent.model + ':' + options.channel.parent.id;\n\t      }\n\t      if (options.channel.user) {\n\t        key += ':users:' + options.channel.user;\n\t      }\n\t      key += ':' + options.channel.model;\n\t      if (options.channel.id) {\n\t        key += ':' + options.channel.id;\n\t      }\n\t      if (options.filters) {\n\t        key += ':filter:' + new Buffer(JSON.stringify(options.filters)).toString('base64');\n\t      }\n\t      return key;\n\t    }\n\t  }]);\n\t\n\t  return Monitor;\n\t}();\n\t\n\texports.default = Monitor;\n\t;\n\tmodule.exports = exports['default'];\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32).Buffer))\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!\n\t * The buffer module from node.js, for the browser.\n\t *\n\t * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n\t * @license  MIT\n\t */\n\t/* eslint-disable no-proto */\n\t\n\t'use strict'\n\t\n\tvar base64 = __webpack_require__(33)\n\tvar ieee754 = __webpack_require__(34)\n\tvar isArray = __webpack_require__(35)\n\t\n\texports.Buffer = Buffer\n\texports.SlowBuffer = SlowBuffer\n\texports.INSPECT_MAX_BYTES = 50\n\t\n\t/**\n\t * If `Buffer.TYPED_ARRAY_SUPPORT`:\n\t *   === true    Use Uint8Array implementation (fastest)\n\t *   === false   Use Object implementation (most compatible, even IE6)\n\t *\n\t * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n\t * Opera 11.6+, iOS 4.2+.\n\t *\n\t * Due to various browser bugs, sometimes the Object implementation will be used even\n\t * when the browser supports typed arrays.\n\t *\n\t * Note:\n\t *\n\t *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n\t *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n\t *\n\t *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n\t *\n\t *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n\t *     incorrect length in some situations.\n\t\n\t * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n\t * get the Object implementation, which is slower but behaves correctly.\n\t */\n\tBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n\t  ? global.TYPED_ARRAY_SUPPORT\n\t  : typedArraySupport()\n\t\n\t/*\n\t * Export kMaxLength after typed array support is determined.\n\t */\n\texports.kMaxLength = kMaxLength()\n\t\n\tfunction typedArraySupport () {\n\t  try {\n\t    var arr = new Uint8Array(1)\n\t    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n\t    return arr.foo() === 42 && // typed array instances can be augmented\n\t        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n\t        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n\t  } catch (e) {\n\t    return false\n\t  }\n\t}\n\t\n\tfunction kMaxLength () {\n\t  return Buffer.TYPED_ARRAY_SUPPORT\n\t    ? 0x7fffffff\n\t    : 0x3fffffff\n\t}\n\t\n\tfunction createBuffer (that, length) {\n\t  if (kMaxLength() < length) {\n\t    throw new RangeError('Invalid typed array length')\n\t  }\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = new Uint8Array(length)\n\t    that.__proto__ = Buffer.prototype\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    if (that === null) {\n\t      that = new Buffer(length)\n\t    }\n\t    that.length = length\n\t  }\n\t\n\t  return that\n\t}\n\t\n\t/**\n\t * The Buffer constructor returns instances of `Uint8Array` that have their\n\t * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n\t * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n\t * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n\t * returns a single octet.\n\t *\n\t * The `Uint8Array` prototype remains unmodified.\n\t */\n\t\n\tfunction Buffer (arg, encodingOrOffset, length) {\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n\t    return new Buffer(arg, encodingOrOffset, length)\n\t  }\n\t\n\t  // Common case.\n\t  if (typeof arg === 'number') {\n\t    if (typeof encodingOrOffset === 'string') {\n\t      throw new Error(\n\t        'If encoding is specified then the first argument must be a string'\n\t      )\n\t    }\n\t    return allocUnsafe(this, arg)\n\t  }\n\t  return from(this, arg, encodingOrOffset, length)\n\t}\n\t\n\tBuffer.poolSize = 8192 // not used by this implementation\n\t\n\t// TODO: Legacy, not needed anymore. Remove in next major version.\n\tBuffer._augment = function (arr) {\n\t  arr.__proto__ = Buffer.prototype\n\t  return arr\n\t}\n\t\n\tfunction from (that, value, encodingOrOffset, length) {\n\t  if (typeof value === 'number') {\n\t    throw new TypeError('\"value\" argument must not be a number')\n\t  }\n\t\n\t  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n\t    return fromArrayBuffer(that, value, encodingOrOffset, length)\n\t  }\n\t\n\t  if (typeof value === 'string') {\n\t    return fromString(that, value, encodingOrOffset)\n\t  }\n\t\n\t  return fromObject(that, value)\n\t}\n\t\n\t/**\n\t * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n\t * if value is a number.\n\t * Buffer.from(str[, encoding])\n\t * Buffer.from(array)\n\t * Buffer.from(buffer)\n\t * Buffer.from(arrayBuffer[, byteOffset[, length]])\n\t **/\n\tBuffer.from = function (value, encodingOrOffset, length) {\n\t  return from(null, value, encodingOrOffset, length)\n\t}\n\t\n\tif (Buffer.TYPED_ARRAY_SUPPORT) {\n\t  Buffer.prototype.__proto__ = Uint8Array.prototype\n\t  Buffer.__proto__ = Uint8Array\n\t  if (typeof Symbol !== 'undefined' && Symbol.species &&\n\t      Buffer[Symbol.species] === Buffer) {\n\t    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n\t    Object.defineProperty(Buffer, Symbol.species, {\n\t      value: null,\n\t      configurable: true\n\t    })\n\t  }\n\t}\n\t\n\tfunction assertSize (size) {\n\t  if (typeof size !== 'number') {\n\t    throw new TypeError('\"size\" argument must be a number')\n\t  } else if (size < 0) {\n\t    throw new RangeError('\"size\" argument must not be negative')\n\t  }\n\t}\n\t\n\tfunction alloc (that, size, fill, encoding) {\n\t  assertSize(size)\n\t  if (size <= 0) {\n\t    return createBuffer(that, size)\n\t  }\n\t  if (fill !== undefined) {\n\t    // Only pay attention to encoding if it's a string. This\n\t    // prevents accidentally sending in a number that would\n\t    // be interpretted as a start offset.\n\t    return typeof encoding === 'string'\n\t      ? createBuffer(that, size).fill(fill, encoding)\n\t      : createBuffer(that, size).fill(fill)\n\t  }\n\t  return createBuffer(that, size)\n\t}\n\t\n\t/**\n\t * Creates a new filled Buffer instance.\n\t * alloc(size[, fill[, encoding]])\n\t **/\n\tBuffer.alloc = function (size, fill, encoding) {\n\t  return alloc(null, size, fill, encoding)\n\t}\n\t\n\tfunction allocUnsafe (that, size) {\n\t  assertSize(size)\n\t  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n\t    for (var i = 0; i < size; ++i) {\n\t      that[i] = 0\n\t    }\n\t  }\n\t  return that\n\t}\n\t\n\t/**\n\t * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n\t * */\n\tBuffer.allocUnsafe = function (size) {\n\t  return allocUnsafe(null, size)\n\t}\n\t/**\n\t * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n\t */\n\tBuffer.allocUnsafeSlow = function (size) {\n\t  return allocUnsafe(null, size)\n\t}\n\t\n\tfunction fromString (that, string, encoding) {\n\t  if (typeof encoding !== 'string' || encoding === '') {\n\t    encoding = 'utf8'\n\t  }\n\t\n\t  if (!Buffer.isEncoding(encoding)) {\n\t    throw new TypeError('\"encoding\" must be a valid string encoding')\n\t  }\n\t\n\t  var length = byteLength(string, encoding) | 0\n\t  that = createBuffer(that, length)\n\t\n\t  var actual = that.write(string, encoding)\n\t\n\t  if (actual !== length) {\n\t    // Writing a hex string, for example, that contains invalid characters will\n\t    // cause everything after the first invalid character to be ignored. (e.g.\n\t    // 'abxxcd' will be treated as 'ab')\n\t    that = that.slice(0, actual)\n\t  }\n\t\n\t  return that\n\t}\n\t\n\tfunction fromArrayLike (that, array) {\n\t  var length = array.length < 0 ? 0 : checked(array.length) | 0\n\t  that = createBuffer(that, length)\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromArrayBuffer (that, array, byteOffset, length) {\n\t  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\t\n\t  if (byteOffset < 0 || array.byteLength < byteOffset) {\n\t    throw new RangeError('\\'offset\\' is out of bounds')\n\t  }\n\t\n\t  if (array.byteLength < byteOffset + (length || 0)) {\n\t    throw new RangeError('\\'length\\' is out of bounds')\n\t  }\n\t\n\t  if (byteOffset === undefined && length === undefined) {\n\t    array = new Uint8Array(array)\n\t  } else if (length === undefined) {\n\t    array = new Uint8Array(array, byteOffset)\n\t  } else {\n\t    array = new Uint8Array(array, byteOffset, length)\n\t  }\n\t\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = array\n\t    that.__proto__ = Buffer.prototype\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    that = fromArrayLike(that, array)\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromObject (that, obj) {\n\t  if (Buffer.isBuffer(obj)) {\n\t    var len = checked(obj.length) | 0\n\t    that = createBuffer(that, len)\n\t\n\t    if (that.length === 0) {\n\t      return that\n\t    }\n\t\n\t    obj.copy(that, 0, 0, len)\n\t    return that\n\t  }\n\t\n\t  if (obj) {\n\t    if ((typeof ArrayBuffer !== 'undefined' &&\n\t        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n\t      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n\t        return createBuffer(that, 0)\n\t      }\n\t      return fromArrayLike(that, obj)\n\t    }\n\t\n\t    if (obj.type === 'Buffer' && isArray(obj.data)) {\n\t      return fromArrayLike(that, obj.data)\n\t    }\n\t  }\n\t\n\t  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n\t}\n\t\n\tfunction checked (length) {\n\t  // Note: cannot use `length < kMaxLength()` here because that fails when\n\t  // length is NaN (which is otherwise coerced to zero.)\n\t  if (length >= kMaxLength()) {\n\t    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n\t                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n\t  }\n\t  return length | 0\n\t}\n\t\n\tfunction SlowBuffer (length) {\n\t  if (+length != length) { // eslint-disable-line eqeqeq\n\t    length = 0\n\t  }\n\t  return Buffer.alloc(+length)\n\t}\n\t\n\tBuffer.isBuffer = function isBuffer (b) {\n\t  return !!(b != null && b._isBuffer)\n\t}\n\t\n\tBuffer.compare = function compare (a, b) {\n\t  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n\t    throw new TypeError('Arguments must be Buffers')\n\t  }\n\t\n\t  if (a === b) return 0\n\t\n\t  var x = a.length\n\t  var y = b.length\n\t\n\t  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n\t    if (a[i] !== b[i]) {\n\t      x = a[i]\n\t      y = b[i]\n\t      break\n\t    }\n\t  }\n\t\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t}\n\t\n\tBuffer.isEncoding = function isEncoding (encoding) {\n\t  switch (String(encoding).toLowerCase()) {\n\t    case 'hex':\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case 'ascii':\n\t    case 'latin1':\n\t    case 'binary':\n\t    case 'base64':\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return true\n\t    default:\n\t      return false\n\t  }\n\t}\n\t\n\tBuffer.concat = function concat (list, length) {\n\t  if (!isArray(list)) {\n\t    throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t  }\n\t\n\t  if (list.length === 0) {\n\t    return Buffer.alloc(0)\n\t  }\n\t\n\t  var i\n\t  if (length === undefined) {\n\t    length = 0\n\t    for (i = 0; i < list.length; ++i) {\n\t      length += list[i].length\n\t    }\n\t  }\n\t\n\t  var buffer = Buffer.allocUnsafe(length)\n\t  var pos = 0\n\t  for (i = 0; i < list.length; ++i) {\n\t    var buf = list[i]\n\t    if (!Buffer.isBuffer(buf)) {\n\t      throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t    }\n\t    buf.copy(buffer, pos)\n\t    pos += buf.length\n\t  }\n\t  return buffer\n\t}\n\t\n\tfunction byteLength (string, encoding) {\n\t  if (Buffer.isBuffer(string)) {\n\t    return string.length\n\t  }\n\t  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n\t      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n\t    return string.byteLength\n\t  }\n\t  if (typeof string !== 'string') {\n\t    string = '' + string\n\t  }\n\t\n\t  var len = string.length\n\t  if (len === 0) return 0\n\t\n\t  // Use a for loop to avoid recursion\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'ascii':\n\t      case 'latin1':\n\t      case 'binary':\n\t        return len\n\t      case 'utf8':\n\t      case 'utf-8':\n\t      case undefined:\n\t        return utf8ToBytes(string).length\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return len * 2\n\t      case 'hex':\n\t        return len >>> 1\n\t      case 'base64':\n\t        return base64ToBytes(string).length\n\t      default:\n\t        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\tBuffer.byteLength = byteLength\n\t\n\tfunction slowToString (encoding, start, end) {\n\t  var loweredCase = false\n\t\n\t  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n\t  // property of a typed array.\n\t\n\t  // This behaves neither like String nor Uint8Array in that we set start/end\n\t  // to their upper/lower bounds if the value passed is out of range.\n\t  // undefined is handled specially as per ECMA-262 6th Edition,\n\t  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\t  if (start === undefined || start < 0) {\n\t    start = 0\n\t  }\n\t  // Return early if start > this.length. Done here to prevent potential uint32\n\t  // coercion fail below.\n\t  if (start > this.length) {\n\t    return ''\n\t  }\n\t\n\t  if (end === undefined || end > this.length) {\n\t    end = this.length\n\t  }\n\t\n\t  if (end <= 0) {\n\t    return ''\n\t  }\n\t\n\t  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n\t  end >>>= 0\n\t  start >>>= 0\n\t\n\t  if (end <= start) {\n\t    return ''\n\t  }\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t\n\t  while (true) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexSlice(this, start, end)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Slice(this, start, end)\n\t\n\t      case 'ascii':\n\t        return asciiSlice(this, start, end)\n\t\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Slice(this, start, end)\n\t\n\t      case 'base64':\n\t        return base64Slice(this, start, end)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return utf16leSlice(this, start, end)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = (encoding + '').toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\t// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n\t// Buffer instances.\n\tBuffer.prototype._isBuffer = true\n\t\n\tfunction swap (b, n, m) {\n\t  var i = b[n]\n\t  b[n] = b[m]\n\t  b[m] = i\n\t}\n\t\n\tBuffer.prototype.swap16 = function swap16 () {\n\t  var len = this.length\n\t  if (len % 2 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 16-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 2) {\n\t    swap(this, i, i + 1)\n\t  }\n\t  return this\n\t}\n\t\n\tBuffer.prototype.swap32 = function swap32 () {\n\t  var len = this.length\n\t  if (len % 4 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 32-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 4) {\n\t    swap(this, i, i + 3)\n\t    swap(this, i + 1, i + 2)\n\t  }\n\t  return this\n\t}\n\t\n\tBuffer.prototype.swap64 = function swap64 () {\n\t  var len = this.length\n\t  if (len % 8 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 64-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 8) {\n\t    swap(this, i, i + 7)\n\t    swap(this, i + 1, i + 6)\n\t    swap(this, i + 2, i + 5)\n\t    swap(this, i + 3, i + 4)\n\t  }\n\t  return this\n\t}\n\t\n\tBuffer.prototype.toString = function toString () {\n\t  var length = this.length | 0\n\t  if (length === 0) return ''\n\t  if (arguments.length === 0) return utf8Slice(this, 0, length)\n\t  return slowToString.apply(this, arguments)\n\t}\n\t\n\tBuffer.prototype.equals = function equals (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return true\n\t  return Buffer.compare(this, b) === 0\n\t}\n\t\n\tBuffer.prototype.inspect = function inspect () {\n\t  var str = ''\n\t  var max = exports.INSPECT_MAX_BYTES\n\t  if (this.length > 0) {\n\t    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n\t    if (this.length > max) str += ' ... '\n\t  }\n\t  return '<Buffer ' + str + '>'\n\t}\n\t\n\tBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n\t  if (!Buffer.isBuffer(target)) {\n\t    throw new TypeError('Argument must be a Buffer')\n\t  }\n\t\n\t  if (start === undefined) {\n\t    start = 0\n\t  }\n\t  if (end === undefined) {\n\t    end = target ? target.length : 0\n\t  }\n\t  if (thisStart === undefined) {\n\t    thisStart = 0\n\t  }\n\t  if (thisEnd === undefined) {\n\t    thisEnd = this.length\n\t  }\n\t\n\t  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n\t    throw new RangeError('out of range index')\n\t  }\n\t\n\t  if (thisStart >= thisEnd && start >= end) {\n\t    return 0\n\t  }\n\t  if (thisStart >= thisEnd) {\n\t    return -1\n\t  }\n\t  if (start >= end) {\n\t    return 1\n\t  }\n\t\n\t  start >>>= 0\n\t  end >>>= 0\n\t  thisStart >>>= 0\n\t  thisEnd >>>= 0\n\t\n\t  if (this === target) return 0\n\t\n\t  var x = thisEnd - thisStart\n\t  var y = end - start\n\t  var len = Math.min(x, y)\n\t\n\t  var thisCopy = this.slice(thisStart, thisEnd)\n\t  var targetCopy = target.slice(start, end)\n\t\n\t  for (var i = 0; i < len; ++i) {\n\t    if (thisCopy[i] !== targetCopy[i]) {\n\t      x = thisCopy[i]\n\t      y = targetCopy[i]\n\t      break\n\t    }\n\t  }\n\t\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t}\n\t\n\t// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n\t// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n\t//\n\t// Arguments:\n\t// - buffer - a Buffer to search\n\t// - val - a string, Buffer, or number\n\t// - byteOffset - an index into `buffer`; will be clamped to an int32\n\t// - encoding - an optional encoding, relevant is val is a string\n\t// - dir - true for indexOf, false for lastIndexOf\n\tfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n\t  // Empty buffer means no match\n\t  if (buffer.length === 0) return -1\n\t\n\t  // Normalize byteOffset\n\t  if (typeof byteOffset === 'string') {\n\t    encoding = byteOffset\n\t    byteOffset = 0\n\t  } else if (byteOffset > 0x7fffffff) {\n\t    byteOffset = 0x7fffffff\n\t  } else if (byteOffset < -0x80000000) {\n\t    byteOffset = -0x80000000\n\t  }\n\t  byteOffset = +byteOffset  // Coerce to Number.\n\t  if (isNaN(byteOffset)) {\n\t    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n\t    byteOffset = dir ? 0 : (buffer.length - 1)\n\t  }\n\t\n\t  // Normalize byteOffset: negative offsets start from the end of the buffer\n\t  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n\t  if (byteOffset >= buffer.length) {\n\t    if (dir) return -1\n\t    else byteOffset = buffer.length - 1\n\t  } else if (byteOffset < 0) {\n\t    if (dir) byteOffset = 0\n\t    else return -1\n\t  }\n\t\n\t  // Normalize val\n\t  if (typeof val === 'string') {\n\t    val = Buffer.from(val, encoding)\n\t  }\n\t\n\t  // Finally, search either indexOf (if dir is true) or lastIndexOf\n\t  if (Buffer.isBuffer(val)) {\n\t    // Special case: looking for empty string/buffer always fails\n\t    if (val.length === 0) {\n\t      return -1\n\t    }\n\t    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n\t  } else if (typeof val === 'number') {\n\t    val = val & 0xFF // Search for a byte value [0-255]\n\t    if (Buffer.TYPED_ARRAY_SUPPORT &&\n\t        typeof Uint8Array.prototype.indexOf === 'function') {\n\t      if (dir) {\n\t        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n\t      } else {\n\t        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n\t      }\n\t    }\n\t    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n\t  }\n\t\n\t  throw new TypeError('val must be string, number or Buffer')\n\t}\n\t\n\tfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n\t  var indexSize = 1\n\t  var arrLength = arr.length\n\t  var valLength = val.length\n\t\n\t  if (encoding !== undefined) {\n\t    encoding = String(encoding).toLowerCase()\n\t    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n\t        encoding === 'utf16le' || encoding === 'utf-16le') {\n\t      if (arr.length < 2 || val.length < 2) {\n\t        return -1\n\t      }\n\t      indexSize = 2\n\t      arrLength /= 2\n\t      valLength /= 2\n\t      byteOffset /= 2\n\t    }\n\t  }\n\t\n\t  function read (buf, i) {\n\t    if (indexSize === 1) {\n\t      return buf[i]\n\t    } else {\n\t      return buf.readUInt16BE(i * indexSize)\n\t    }\n\t  }\n\t\n\t  var i\n\t  if (dir) {\n\t    var foundIndex = -1\n\t    for (i = byteOffset; i < arrLength; i++) {\n\t      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n\t        if (foundIndex === -1) foundIndex = i\n\t        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n\t      } else {\n\t        if (foundIndex !== -1) i -= i - foundIndex\n\t        foundIndex = -1\n\t      }\n\t    }\n\t  } else {\n\t    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n\t    for (i = byteOffset; i >= 0; i--) {\n\t      var found = true\n\t      for (var j = 0; j < valLength; j++) {\n\t        if (read(arr, i + j) !== read(val, j)) {\n\t          found = false\n\t          break\n\t        }\n\t      }\n\t      if (found) return i\n\t    }\n\t  }\n\t\n\t  return -1\n\t}\n\t\n\tBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n\t  return this.indexOf(val, byteOffset, encoding) !== -1\n\t}\n\t\n\tBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n\t}\n\t\n\tBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n\t}\n\t\n\tfunction hexWrite (buf, string, offset, length) {\n\t  offset = Number(offset) || 0\n\t  var remaining = buf.length - offset\n\t  if (!length) {\n\t    length = remaining\n\t  } else {\n\t    length = Number(length)\n\t    if (length > remaining) {\n\t      length = remaining\n\t    }\n\t  }\n\t\n\t  // must be an even number of digits\n\t  var strLen = string.length\n\t  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\t\n\t  if (length > strLen / 2) {\n\t    length = strLen / 2\n\t  }\n\t  for (var i = 0; i < length; ++i) {\n\t    var parsed = parseInt(string.substr(i * 2, 2), 16)\n\t    if (isNaN(parsed)) return i\n\t    buf[offset + i] = parsed\n\t  }\n\t  return i\n\t}\n\t\n\tfunction utf8Write (buf, string, offset, length) {\n\t  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tfunction asciiWrite (buf, string, offset, length) {\n\t  return blitBuffer(asciiToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction latin1Write (buf, string, offset, length) {\n\t  return asciiWrite(buf, string, offset, length)\n\t}\n\t\n\tfunction base64Write (buf, string, offset, length) {\n\t  return blitBuffer(base64ToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction ucs2Write (buf, string, offset, length) {\n\t  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tBuffer.prototype.write = function write (string, offset, length, encoding) {\n\t  // Buffer#write(string)\n\t  if (offset === undefined) {\n\t    encoding = 'utf8'\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, encoding)\n\t  } else if (length === undefined && typeof offset === 'string') {\n\t    encoding = offset\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, offset[, length][, encoding])\n\t  } else if (isFinite(offset)) {\n\t    offset = offset | 0\n\t    if (isFinite(length)) {\n\t      length = length | 0\n\t      if (encoding === undefined) encoding = 'utf8'\n\t    } else {\n\t      encoding = length\n\t      length = undefined\n\t    }\n\t  // legacy write(string, encoding, offset, length) - remove in v0.13\n\t  } else {\n\t    throw new Error(\n\t      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n\t    )\n\t  }\n\t\n\t  var remaining = this.length - offset\n\t  if (length === undefined || length > remaining) length = remaining\n\t\n\t  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n\t    throw new RangeError('Attempt to write outside buffer bounds')\n\t  }\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexWrite(this, string, offset, length)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Write(this, string, offset, length)\n\t\n\t      case 'ascii':\n\t        return asciiWrite(this, string, offset, length)\n\t\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Write(this, string, offset, length)\n\t\n\t      case 'base64':\n\t        // Warning: maxLength not taken into account in base64Write\n\t        return base64Write(this, string, offset, length)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return ucs2Write(this, string, offset, length)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\tBuffer.prototype.toJSON = function toJSON () {\n\t  return {\n\t    type: 'Buffer',\n\t    data: Array.prototype.slice.call(this._arr || this, 0)\n\t  }\n\t}\n\t\n\tfunction base64Slice (buf, start, end) {\n\t  if (start === 0 && end === buf.length) {\n\t    return base64.fromByteArray(buf)\n\t  } else {\n\t    return base64.fromByteArray(buf.slice(start, end))\n\t  }\n\t}\n\t\n\tfunction utf8Slice (buf, start, end) {\n\t  end = Math.min(buf.length, end)\n\t  var res = []\n\t\n\t  var i = start\n\t  while (i < end) {\n\t    var firstByte = buf[i]\n\t    var codePoint = null\n\t    var bytesPerSequence = (firstByte > 0xEF) ? 4\n\t      : (firstByte > 0xDF) ? 3\n\t      : (firstByte > 0xBF) ? 2\n\t      : 1\n\t\n\t    if (i + bytesPerSequence <= end) {\n\t      var secondByte, thirdByte, fourthByte, tempCodePoint\n\t\n\t      switch (bytesPerSequence) {\n\t        case 1:\n\t          if (firstByte < 0x80) {\n\t            codePoint = firstByte\n\t          }\n\t          break\n\t        case 2:\n\t          secondByte = buf[i + 1]\n\t          if ((secondByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n\t            if (tempCodePoint > 0x7F) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 3:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n\t            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 4:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          fourthByte = buf[i + 3]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n\t            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t      }\n\t    }\n\t\n\t    if (codePoint === null) {\n\t      // we did not generate a valid codePoint so insert a\n\t      // replacement char (U+FFFD) and advance only 1 byte\n\t      codePoint = 0xFFFD\n\t      bytesPerSequence = 1\n\t    } else if (codePoint > 0xFFFF) {\n\t      // encode to utf16 (surrogate pair dance)\n\t      codePoint -= 0x10000\n\t      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n\t      codePoint = 0xDC00 | codePoint & 0x3FF\n\t    }\n\t\n\t    res.push(codePoint)\n\t    i += bytesPerSequence\n\t  }\n\t\n\t  return decodeCodePointsArray(res)\n\t}\n\t\n\t// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n\t// the lowest limit is Chrome, with 0x10000 args.\n\t// We go 1 magnitude less, for safety\n\tvar MAX_ARGUMENTS_LENGTH = 0x1000\n\t\n\tfunction decodeCodePointsArray (codePoints) {\n\t  var len = codePoints.length\n\t  if (len <= MAX_ARGUMENTS_LENGTH) {\n\t    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n\t  }\n\t\n\t  // Decode in chunks to avoid \"call stack size exceeded\".\n\t  var res = ''\n\t  var i = 0\n\t  while (i < len) {\n\t    res += String.fromCharCode.apply(\n\t      String,\n\t      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n\t    )\n\t  }\n\t  return res\n\t}\n\t\n\tfunction asciiSlice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i] & 0x7F)\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction latin1Slice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i])\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction hexSlice (buf, start, end) {\n\t  var len = buf.length\n\t\n\t  if (!start || start < 0) start = 0\n\t  if (!end || end < 0 || end > len) end = len\n\t\n\t  var out = ''\n\t  for (var i = start; i < end; ++i) {\n\t    out += toHex(buf[i])\n\t  }\n\t  return out\n\t}\n\t\n\tfunction utf16leSlice (buf, start, end) {\n\t  var bytes = buf.slice(start, end)\n\t  var res = ''\n\t  for (var i = 0; i < bytes.length; i += 2) {\n\t    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n\t  }\n\t  return res\n\t}\n\t\n\tBuffer.prototype.slice = function slice (start, end) {\n\t  var len = this.length\n\t  start = ~~start\n\t  end = end === undefined ? len : ~~end\n\t\n\t  if (start < 0) {\n\t    start += len\n\t    if (start < 0) start = 0\n\t  } else if (start > len) {\n\t    start = len\n\t  }\n\t\n\t  if (end < 0) {\n\t    end += len\n\t    if (end < 0) end = 0\n\t  } else if (end > len) {\n\t    end = len\n\t  }\n\t\n\t  if (end < start) end = start\n\t\n\t  var newBuf\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    newBuf = this.subarray(start, end)\n\t    newBuf.__proto__ = Buffer.prototype\n\t  } else {\n\t    var sliceLen = end - start\n\t    newBuf = new Buffer(sliceLen, undefined)\n\t    for (var i = 0; i < sliceLen; ++i) {\n\t      newBuf[i] = this[i + start]\n\t    }\n\t  }\n\t\n\t  return newBuf\n\t}\n\t\n\t/*\n\t * Need to make sure that buffer isn't trying to write out of bounds.\n\t */\n\tfunction checkOffset (offset, ext, length) {\n\t  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n\t  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n\t}\n\t\n\tBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    checkOffset(offset, byteLength, this.length)\n\t  }\n\t\n\t  var val = this[offset + --byteLength]\n\t  var mul = 1\n\t  while (byteLength > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --byteLength] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  return this[offset]\n\t}\n\t\n\tBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return this[offset] | (this[offset + 1] << 8)\n\t}\n\t\n\tBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return (this[offset] << 8) | this[offset + 1]\n\t}\n\t\n\tBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return ((this[offset]) |\n\t      (this[offset + 1] << 8) |\n\t      (this[offset + 2] << 16)) +\n\t      (this[offset + 3] * 0x1000000)\n\t}\n\t\n\tBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] * 0x1000000) +\n\t    ((this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var i = byteLength\n\t  var mul = 1\n\t  var val = this[offset + --i]\n\t  while (i > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  if (!(this[offset] & 0x80)) return (this[offset])\n\t  return ((0xff - this[offset] + 1) * -1)\n\t}\n\t\n\tBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset] | (this[offset + 1] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset + 1] | (this[offset] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset]) |\n\t    (this[offset + 1] << 8) |\n\t    (this[offset + 2] << 16) |\n\t    (this[offset + 3] << 24)\n\t}\n\t\n\tBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] << 24) |\n\t    (this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    (this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, true, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, false, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, true, 52, 8)\n\t}\n\t\n\tBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, false, 52, 8)\n\t}\n\t\n\tfunction checkInt (buf, value, offset, ext, max, min) {\n\t  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n\t  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t}\n\t\n\tBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0)\n\t  }\n\t\n\t  var mul = 1\n\t  var i = 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0)\n\t  }\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n\t    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n\t      (littleEndian ? i : 1 - i) * 8\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n\t    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset + 3] = (value >>> 24)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = 0\n\t  var mul = 1\n\t  var sub = 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n\t      sub = 1\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  var sub = 0\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n\t      sub = 1\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  if (value < 0) value = 0xff + value + 1\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 3] = (value >>> 24)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t  if (offset < 0) throw new RangeError('Index out of range')\n\t}\n\t\n\tfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, false, noAssert)\n\t}\n\t\n\tfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n\t  return offset + 8\n\t}\n\t\n\tBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, false, noAssert)\n\t}\n\t\n\t// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\tBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n\t  if (!start) start = 0\n\t  if (!end && end !== 0) end = this.length\n\t  if (targetStart >= target.length) targetStart = target.length\n\t  if (!targetStart) targetStart = 0\n\t  if (end > 0 && end < start) end = start\n\t\n\t  // Copy 0 bytes; we're done\n\t  if (end === start) return 0\n\t  if (target.length === 0 || this.length === 0) return 0\n\t\n\t  // Fatal error conditions\n\t  if (targetStart < 0) {\n\t    throw new RangeError('targetStart out of bounds')\n\t  }\n\t  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n\t  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\t\n\t  // Are we oob?\n\t  if (end > this.length) end = this.length\n\t  if (target.length - targetStart < end - start) {\n\t    end = target.length - targetStart + start\n\t  }\n\t\n\t  var len = end - start\n\t  var i\n\t\n\t  if (this === target && start < targetStart && targetStart < end) {\n\t    // descending copy from end\n\t    for (i = len - 1; i >= 0; --i) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // ascending copy from start\n\t    for (i = 0; i < len; ++i) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else {\n\t    Uint8Array.prototype.set.call(\n\t      target,\n\t      this.subarray(start, start + len),\n\t      targetStart\n\t    )\n\t  }\n\t\n\t  return len\n\t}\n\t\n\t// Usage:\n\t//    buffer.fill(number[, offset[, end]])\n\t//    buffer.fill(buffer[, offset[, end]])\n\t//    buffer.fill(string[, offset[, end]][, encoding])\n\tBuffer.prototype.fill = function fill (val, start, end, encoding) {\n\t  // Handle string cases:\n\t  if (typeof val === 'string') {\n\t    if (typeof start === 'string') {\n\t      encoding = start\n\t      start = 0\n\t      end = this.length\n\t    } else if (typeof end === 'string') {\n\t      encoding = end\n\t      end = this.length\n\t    }\n\t    if (val.length === 1) {\n\t      var code = val.charCodeAt(0)\n\t      if (code < 256) {\n\t        val = code\n\t      }\n\t    }\n\t    if (encoding !== undefined && typeof encoding !== 'string') {\n\t      throw new TypeError('encoding must be a string')\n\t    }\n\t    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n\t      throw new TypeError('Unknown encoding: ' + encoding)\n\t    }\n\t  } else if (typeof val === 'number') {\n\t    val = val & 255\n\t  }\n\t\n\t  // Invalid ranges are not set to a default, so can range check early.\n\t  if (start < 0 || this.length < start || this.length < end) {\n\t    throw new RangeError('Out of range index')\n\t  }\n\t\n\t  if (end <= start) {\n\t    return this\n\t  }\n\t\n\t  start = start >>> 0\n\t  end = end === undefined ? this.length : end >>> 0\n\t\n\t  if (!val) val = 0\n\t\n\t  var i\n\t  if (typeof val === 'number') {\n\t    for (i = start; i < end; ++i) {\n\t      this[i] = val\n\t    }\n\t  } else {\n\t    var bytes = Buffer.isBuffer(val)\n\t      ? val\n\t      : utf8ToBytes(new Buffer(val, encoding).toString())\n\t    var len = bytes.length\n\t    for (i = 0; i < end - start; ++i) {\n\t      this[i + start] = bytes[i % len]\n\t    }\n\t  }\n\t\n\t  return this\n\t}\n\t\n\t// HELPER FUNCTIONS\n\t// ================\n\t\n\tvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\t\n\tfunction base64clean (str) {\n\t  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\t  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n\t  // Node converts strings with length < 2 to ''\n\t  if (str.length < 2) return ''\n\t  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\t  while (str.length % 4 !== 0) {\n\t    str = str + '='\n\t  }\n\t  return str\n\t}\n\t\n\tfunction stringtrim (str) {\n\t  if (str.trim) return str.trim()\n\t  return str.replace(/^\\s+|\\s+$/g, '')\n\t}\n\t\n\tfunction toHex (n) {\n\t  if (n < 16) return '0' + n.toString(16)\n\t  return n.toString(16)\n\t}\n\t\n\tfunction utf8ToBytes (string, units) {\n\t  units = units || Infinity\n\t  var codePoint\n\t  var length = string.length\n\t  var leadSurrogate = null\n\t  var bytes = []\n\t\n\t  for (var i = 0; i < length; ++i) {\n\t    codePoint = string.charCodeAt(i)\n\t\n\t    // is surrogate component\n\t    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n\t      // last char was a lead\n\t      if (!leadSurrogate) {\n\t        // no lead yet\n\t        if (codePoint > 0xDBFF) {\n\t          // unexpected trail\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        } else if (i + 1 === length) {\n\t          // unpaired lead\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        }\n\t\n\t        // valid lead\n\t        leadSurrogate = codePoint\n\t\n\t        continue\n\t      }\n\t\n\t      // 2 leads in a row\n\t      if (codePoint < 0xDC00) {\n\t        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t        leadSurrogate = codePoint\n\t        continue\n\t      }\n\t\n\t      // valid surrogate pair\n\t      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n\t    } else if (leadSurrogate) {\n\t      // valid bmp char, but last char was a lead\n\t      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t    }\n\t\n\t    leadSurrogate = null\n\t\n\t    // encode utf8\n\t    if (codePoint < 0x80) {\n\t      if ((units -= 1) < 0) break\n\t      bytes.push(codePoint)\n\t    } else if (codePoint < 0x800) {\n\t      if ((units -= 2) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x6 | 0xC0,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x10000) {\n\t      if ((units -= 3) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0xC | 0xE0,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x110000) {\n\t      if ((units -= 4) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x12 | 0xF0,\n\t        codePoint >> 0xC & 0x3F | 0x80,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else {\n\t      throw new Error('Invalid code point')\n\t    }\n\t  }\n\t\n\t  return bytes\n\t}\n\t\n\tfunction asciiToBytes (str) {\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; ++i) {\n\t    // Node's code seems to be doing this and not & 0x7F..\n\t    byteArray.push(str.charCodeAt(i) & 0xFF)\n\t  }\n\t  return byteArray\n\t}\n\t\n\tfunction utf16leToBytes (str, units) {\n\t  var c, hi, lo\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; ++i) {\n\t    if ((units -= 2) < 0) break\n\t\n\t    c = str.charCodeAt(i)\n\t    hi = c >> 8\n\t    lo = c % 256\n\t    byteArray.push(lo)\n\t    byteArray.push(hi)\n\t  }\n\t\n\t  return byteArray\n\t}\n\t\n\tfunction base64ToBytes (str) {\n\t  return base64.toByteArray(base64clean(str))\n\t}\n\t\n\tfunction blitBuffer (src, dst, offset, length) {\n\t  for (var i = 0; i < length; ++i) {\n\t    if ((i + offset >= dst.length) || (i >= src.length)) break\n\t    dst[i + offset] = src[i]\n\t  }\n\t  return i\n\t}\n\t\n\tfunction isnan (val) {\n\t  return val !== val // eslint-disable-line no-self-compare\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32).Buffer, (function() { return this; }())))\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n\t'use strict'\n\t\n\texports.byteLength = byteLength\n\texports.toByteArray = toByteArray\n\texports.fromByteArray = fromByteArray\n\t\n\tvar lookup = []\n\tvar revLookup = []\n\tvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\t\n\tvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n\tfor (var i = 0, len = code.length; i < len; ++i) {\n\t  lookup[i] = code[i]\n\t  revLookup[code.charCodeAt(i)] = i\n\t}\n\t\n\trevLookup['-'.charCodeAt(0)] = 62\n\trevLookup['_'.charCodeAt(0)] = 63\n\t\n\tfunction placeHoldersCount (b64) {\n\t  var len = b64.length\n\t  if (len % 4 > 0) {\n\t    throw new Error('Invalid string. Length must be a multiple of 4')\n\t  }\n\t\n\t  // the number of equal signs (place holders)\n\t  // if there are two placeholders, than the two characters before it\n\t  // represent one byte\n\t  // if there is only one, then the three characters before it represent 2 bytes\n\t  // this is just a cheap hack to not do indexOf twice\n\t  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n\t}\n\t\n\tfunction byteLength (b64) {\n\t  // base64 is 4/3 + up to two characters of the original data\n\t  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n\t}\n\t\n\tfunction toByteArray (b64) {\n\t  var i, l, tmp, placeHolders, arr\n\t  var len = b64.length\n\t  placeHolders = placeHoldersCount(b64)\n\t\n\t  arr = new Arr((len * 3 / 4) - placeHolders)\n\t\n\t  // if there are placeholders, only get up to the last complete 4 chars\n\t  l = placeHolders > 0 ? len - 4 : len\n\t\n\t  var L = 0\n\t\n\t  for (i = 0; i < l; i += 4) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n\t    arr[L++] = (tmp >> 16) & 0xFF\n\t    arr[L++] = (tmp >> 8) & 0xFF\n\t    arr[L++] = tmp & 0xFF\n\t  }\n\t\n\t  if (placeHolders === 2) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n\t    arr[L++] = tmp & 0xFF\n\t  } else if (placeHolders === 1) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n\t    arr[L++] = (tmp >> 8) & 0xFF\n\t    arr[L++] = tmp & 0xFF\n\t  }\n\t\n\t  return arr\n\t}\n\t\n\tfunction tripletToBase64 (num) {\n\t  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n\t}\n\t\n\tfunction encodeChunk (uint8, start, end) {\n\t  var tmp\n\t  var output = []\n\t  for (var i = start; i < end; i += 3) {\n\t    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t    output.push(tripletToBase64(tmp))\n\t  }\n\t  return output.join('')\n\t}\n\t\n\tfunction fromByteArray (uint8) {\n\t  var tmp\n\t  var len = uint8.length\n\t  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n\t  var output = ''\n\t  var parts = []\n\t  var maxChunkLength = 16383 // must be multiple of 3\n\t\n\t  // go through the array every three bytes, we'll deal with trailing stuff later\n\t  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n\t    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n\t  }\n\t\n\t  // pad the end with zeros, but make sure to not forget the extra bytes\n\t  if (extraBytes === 1) {\n\t    tmp = uint8[len - 1]\n\t    output += lookup[tmp >> 2]\n\t    output += lookup[(tmp << 4) & 0x3F]\n\t    output += '=='\n\t  } else if (extraBytes === 2) {\n\t    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n\t    output += lookup[tmp >> 10]\n\t    output += lookup[(tmp >> 4) & 0x3F]\n\t    output += lookup[(tmp << 2) & 0x3F]\n\t    output += '='\n\t  }\n\t\n\t  parts.push(output)\n\t\n\t  return parts.join('')\n\t}\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\n\texports.read = function (buffer, offset, isLE, mLen, nBytes) {\n\t  var e, m\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var nBits = -7\n\t  var i = isLE ? (nBytes - 1) : 0\n\t  var d = isLE ? -1 : 1\n\t  var s = buffer[offset + i]\n\t\n\t  i += d\n\t\n\t  e = s & ((1 << (-nBits)) - 1)\n\t  s >>= (-nBits)\n\t  nBits += eLen\n\t  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  m = e & ((1 << (-nBits)) - 1)\n\t  e >>= (-nBits)\n\t  nBits += mLen\n\t  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  if (e === 0) {\n\t    e = 1 - eBias\n\t  } else if (e === eMax) {\n\t    return m ? NaN : ((s ? -1 : 1) * Infinity)\n\t  } else {\n\t    m = m + Math.pow(2, mLen)\n\t    e = e - eBias\n\t  }\n\t  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n\t}\n\t\n\texports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n\t  var e, m, c\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n\t  var i = isLE ? 0 : (nBytes - 1)\n\t  var d = isLE ? 1 : -1\n\t  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\t\n\t  value = Math.abs(value)\n\t\n\t  if (isNaN(value) || value === Infinity) {\n\t    m = isNaN(value) ? 1 : 0\n\t    e = eMax\n\t  } else {\n\t    e = Math.floor(Math.log(value) / Math.LN2)\n\t    if (value * (c = Math.pow(2, -e)) < 1) {\n\t      e--\n\t      c *= 2\n\t    }\n\t    if (e + eBias >= 1) {\n\t      value += rt / c\n\t    } else {\n\t      value += rt * Math.pow(2, 1 - eBias)\n\t    }\n\t    if (value * c >= 2) {\n\t      e++\n\t      c /= 2\n\t    }\n\t\n\t    if (e + eBias >= eMax) {\n\t      m = 0\n\t      e = eMax\n\t    } else if (e + eBias >= 1) {\n\t      m = (value * c - 1) * Math.pow(2, mLen)\n\t      e = e + eBias\n\t    } else {\n\t      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n\t      e = 0\n\t    }\n\t  }\n\t\n\t  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\t\n\t  e = (e << mLen) | m\n\t  eLen += mLen\n\t  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\t\n\t  buffer[offset + i - d] |= s * 128\n\t}\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = Array.isArray || function (arr) {\n\t  return toString.call(arr) == '[object Array]';\n\t};\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tvar environment = __webpack_require__(37);\n\t\n\tvar DiffPatcher = __webpack_require__(38).DiffPatcher;\n\texports.DiffPatcher = DiffPatcher;\n\t\n\texports.create = function(options){\n\t  return new DiffPatcher(options);\n\t};\n\t\n\texports.dateReviver = __webpack_require__(67);\n\t\n\tvar defaultInstance;\n\t\n\texports.diff = function() {\n\t  if (!defaultInstance) {\n\t    defaultInstance = new DiffPatcher();\n\t  }\n\t  return defaultInstance.diff.apply(defaultInstance, arguments);\n\t};\n\t\n\texports.patch = function() {\n\t  if (!defaultInstance) {\n\t    defaultInstance = new DiffPatcher();\n\t  }\n\t  return defaultInstance.patch.apply(defaultInstance, arguments);\n\t};\n\t\n\texports.unpatch = function() {\n\t  if (!defaultInstance) {\n\t    defaultInstance = new DiffPatcher();\n\t  }\n\t  return defaultInstance.unpatch.apply(defaultInstance, arguments);\n\t};\n\t\n\texports.reverse = function() {\n\t  if (!defaultInstance) {\n\t    defaultInstance = new DiffPatcher();\n\t  }\n\t  return defaultInstance.reverse.apply(defaultInstance, arguments);\n\t};\n\t\n\texports.clone = function() {\n\t  if (!defaultInstance) {\n\t    defaultInstance = new DiffPatcher();\n\t  }\n\t  return defaultInstance.clone.apply(defaultInstance, arguments);\n\t};\n\t\n\t\n\tif (environment.isBrowser) {\n\t  exports.homepage = '{{package-homepage}}';\n\t  exports.version = '{{package-version}}';\n\t} else {\n\t  var packageInfoModuleName = '../package.json';\n\t  var packageInfo = __webpack_require__(52)(packageInfoModuleName);\n\t  exports.homepage = packageInfo.homepage;\n\t  exports.version = packageInfo.version;\n\t\n\t  var formatterModuleName = './formatters';\n\t  var formatters = __webpack_require__(52)(formatterModuleName);\n\t  exports.formatters = formatters;\n\t  // shortcut for console\n\t  exports.console = formatters.console;\n\t}\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports) {\n\n\t\n\texports.isBrowser = typeof window !== 'undefined';\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Processor = __webpack_require__(39).Processor;\n\tvar Pipe = __webpack_require__(40).Pipe;\n\tvar DiffContext = __webpack_require__(41).DiffContext;\n\tvar PatchContext = __webpack_require__(44).PatchContext;\n\tvar ReverseContext = __webpack_require__(45).ReverseContext;\n\t\n\tvar clone = __webpack_require__(43);\n\t\n\tvar trivial = __webpack_require__(46);\n\tvar nested = __webpack_require__(47);\n\tvar arrays = __webpack_require__(48);\n\tvar dates = __webpack_require__(50);\n\tvar texts = __webpack_require__(51);\n\t\n\tvar DiffPatcher = function DiffPatcher(options) {\n\t  this.processor = new Processor(options);\n\t  this.processor.pipe(new Pipe('diff').append(\n\t    nested.collectChildrenDiffFilter,\n\t    trivial.diffFilter,\n\t    dates.diffFilter,\n\t    texts.diffFilter,\n\t    nested.objectsDiffFilter,\n\t    arrays.diffFilter\n\t  ).shouldHaveResult());\n\t  this.processor.pipe(new Pipe('patch').append(\n\t    nested.collectChildrenPatchFilter,\n\t    arrays.collectChildrenPatchFilter,\n\t    trivial.patchFilter,\n\t    texts.patchFilter,\n\t    nested.patchFilter,\n\t    arrays.patchFilter\n\t  ).shouldHaveResult());\n\t  this.processor.pipe(new Pipe('reverse').append(\n\t    nested.collectChildrenReverseFilter,\n\t    arrays.collectChildrenReverseFilter,\n\t    trivial.reverseFilter,\n\t    texts.reverseFilter,\n\t    nested.reverseFilter,\n\t    arrays.reverseFilter\n\t  ).shouldHaveResult());\n\t};\n\t\n\tDiffPatcher.prototype.options = function() {\n\t  return this.processor.options.apply(this.processor, arguments);\n\t};\n\t\n\tDiffPatcher.prototype.diff = function(left, right) {\n\t  return this.processor.process(new DiffContext(left, right));\n\t};\n\t\n\tDiffPatcher.prototype.patch = function(left, delta) {\n\t  return this.processor.process(new PatchContext(left, delta));\n\t};\n\t\n\tDiffPatcher.prototype.reverse = function(delta) {\n\t  return this.processor.process(new ReverseContext(delta));\n\t};\n\t\n\tDiffPatcher.prototype.unpatch = function(right, delta) {\n\t  return this.patch(right, this.reverse(delta));\n\t};\n\t\n\tDiffPatcher.prototype.clone = function(value) {\n\t  return clone(value);\n\t};\n\t\n\texports.DiffPatcher = DiffPatcher;\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports) {\n\n\t\n\tvar Processor = function Processor(options){\n\t  this.selfOptions = options || {};\n\t  this.pipes = {};\n\t};\n\t\n\tProcessor.prototype.options = function(options) {\n\t  if (options) {\n\t    this.selfOptions = options;\n\t  }\n\t  return this.selfOptions;\n\t};\n\t\n\tProcessor.prototype.pipe = function(name, pipe) {\n\t  if (typeof name === 'string') {\n\t    if (typeof pipe === 'undefined') {\n\t      return this.pipes[name];\n\t    } else {\n\t      this.pipes[name] = pipe;\n\t    }\n\t  }\n\t  if (name && name.name) {\n\t    pipe = name;\n\t    if (pipe.processor === this) { return pipe; }\n\t    this.pipes[pipe.name] = pipe;\n\t  }\n\t  pipe.processor = this;\n\t  return pipe;\n\t};\n\t\n\tProcessor.prototype.process = function(input, pipe) {\n\t  var context = input;\n\t  context.options = this.options();\n\t  var nextPipe = pipe || input.pipe || 'default';\n\t  var lastPipe, lastContext;\n\t  while (nextPipe) {\n\t    if (typeof context.nextAfterChildren !== 'undefined') {\n\t      // children processed and coming back to parent\n\t      context.next = context.nextAfterChildren;\n\t      context.nextAfterChildren = null;\n\t    }\n\t\n\t    if (typeof nextPipe === 'string') {\n\t      nextPipe = this.pipe(nextPipe);\n\t    }\n\t    nextPipe.process(context);\n\t    lastContext = context;\n\t    lastPipe = nextPipe;\n\t    nextPipe = null;\n\t    if (context) {\n\t      if (context.next) {\n\t        context = context.next;\n\t        nextPipe = lastContext.nextPipe || context.pipe || lastPipe;\n\t      }\n\t    }\n\t  }\n\t  return context.hasResult ? context.result : undefined;\n\t};\n\t\n\texports.Processor = Processor;\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports) {\n\n\tvar Pipe = function Pipe(name) {\n\t  this.name = name;\n\t  this.filters = [];\n\t};\n\t\n\tPipe.prototype.process = function(input) {\n\t  if (!this.processor) {\n\t    throw new Error('add this pipe to a processor before using it');\n\t  }\n\t  var debug = this.debug;\n\t  var length = this.filters.length;\n\t  var context = input;\n\t  for (var index = 0; index < length; index++) {\n\t    var filter = this.filters[index];\n\t    if (debug) {\n\t      this.log('filter: ' + filter.filterName);\n\t    }\n\t    filter(context);\n\t    if (typeof context === 'object' && context.exiting) {\n\t      context.exiting = false;\n\t      break;\n\t    }\n\t  }\n\t  if (!context.next && this.resultCheck) {\n\t    this.resultCheck(context);\n\t  }\n\t};\n\t\n\tPipe.prototype.log = function(msg) {\n\t  console.log('[jsondiffpatch] ' + this.name + ' pipe, ' + msg);\n\t};\n\t\n\tPipe.prototype.append = function() {\n\t  this.filters.push.apply(this.filters, arguments);\n\t  return this;\n\t};\n\t\n\tPipe.prototype.prepend = function() {\n\t  this.filters.unshift.apply(this.filters, arguments);\n\t  return this;\n\t};\n\t\n\tPipe.prototype.indexOf = function(filterName) {\n\t  if (!filterName) {\n\t    throw new Error('a filter name is required');\n\t  }\n\t  for (var index = 0; index < this.filters.length; index++) {\n\t    var filter = this.filters[index];\n\t    if (filter.filterName === filterName) {\n\t      return index;\n\t    }\n\t  }\n\t  throw new Error('filter not found: ' + filterName);\n\t};\n\t\n\tPipe.prototype.list = function() {\n\t  var names = [];\n\t  for (var index = 0; index < this.filters.length; index++) {\n\t    var filter = this.filters[index];\n\t    names.push(filter.filterName);\n\t  }\n\t  return names;\n\t};\n\t\n\tPipe.prototype.after = function(filterName) {\n\t  var index = this.indexOf(filterName);\n\t  var params = Array.prototype.slice.call(arguments, 1);\n\t  if (!params.length) {\n\t    throw new Error('a filter is required');\n\t  }\n\t  params.unshift(index + 1, 0);\n\t  Array.prototype.splice.apply(this.filters, params);\n\t  return this;\n\t};\n\t\n\tPipe.prototype.before = function(filterName) {\n\t  var index = this.indexOf(filterName);\n\t  var params = Array.prototype.slice.call(arguments, 1);\n\t  if (!params.length) {\n\t    throw new Error('a filter is required');\n\t  }\n\t  params.unshift(index, 0);\n\t  Array.prototype.splice.apply(this.filters, params);\n\t  return this;\n\t};\n\t\n\tPipe.prototype.clear = function() {\n\t  this.filters.length = 0;\n\t  return this;\n\t};\n\t\n\tPipe.prototype.shouldHaveResult = function(should) {\n\t  if (should === false) {\n\t    this.resultCheck = null;\n\t    return;\n\t  }\n\t  if (this.resultCheck) {\n\t    return;\n\t  }\n\t  var pipe = this;\n\t  this.resultCheck = function(context) {\n\t    if (!context.hasResult) {\n\t      console.log(context);\n\t      var error = new Error(pipe.name + ' failed');\n\t      error.noResult = true;\n\t      throw error;\n\t    }\n\t  };\n\t  return this;\n\t};\n\t\n\texports.Pipe = Pipe;\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Context = __webpack_require__(42).Context;\n\tvar defaultClone = __webpack_require__(43);\n\t\n\tvar DiffContext = function DiffContext(left, right) {\n\t  this.left = left;\n\t  this.right = right;\n\t  this.pipe = 'diff';\n\t};\n\t\n\tDiffContext.prototype = new Context();\n\t\n\tDiffContext.prototype.setResult = function(result) {\n\t  if (this.options.cloneDiffValues && typeof result === 'object') {\n\t    var clone = typeof this.options.cloneDiffValues === 'function' ?\n\t      this.options.cloneDiffValues : defaultClone;\n\t    if (typeof result[0] === 'object') {\n\t      result[0] = clone(result[0]);\n\t    }\n\t    if (typeof result[1] === 'object') {\n\t      result[1] = clone(result[1]);\n\t    }\n\t  }\n\t  return Context.prototype.setResult.apply(this, arguments);\n\t};\n\t\n\texports.DiffContext = DiffContext;\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tvar Pipe = __webpack_require__(40).Pipe;\n\t\n\tvar Context = function Context(){\n\t};\n\t\n\tContext.prototype.setResult = function(result) {\n\t\tthis.result = result;\n\t\tthis.hasResult = true;\n\t\treturn this;\n\t};\n\t\n\tContext.prototype.exit = function() {\n\t\tthis.exiting = true;\n\t\treturn this;\n\t};\n\t\n\tContext.prototype.switchTo = function(next, pipe) {\n\t\tif (typeof next === 'string' || next instanceof Pipe) {\n\t\t\tthis.nextPipe = next;\n\t\t} else {\n\t\t\tthis.next = next;\n\t\t\tif (pipe) {\n\t\t\t\tthis.nextPipe = pipe;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t};\n\t\n\tContext.prototype.push = function(child, name) {\n\t\tchild.parent = this;\n\t\tif (typeof name !== 'undefined') {\n\t\t\tchild.childName = name;\n\t\t}\n\t\tchild.root = this.root || this;\n\t\tchild.options = child.options || this.options;\n\t\tif (!this.children) {\n\t\t\tthis.children = [child];\n\t\t\tthis.nextAfterChildren = this.next || null;\n\t\t\tthis.next = child;\n\t\t} else {\n\t\t\tthis.children[this.children.length - 1].next = child;\n\t\t\tthis.children.push(child);\n\t\t}\n\t\tchild.next = this;\n\t\treturn this;\n\t};\n\t\n\texports.Context = Context;\n\n\n/***/ },\n/* 43 */\n/***/ function(module, exports) {\n\n\t\n\tvar isArray = (typeof Array.isArray === 'function') ?\n\t  // use native function\n\t  Array.isArray :\n\t  // use instanceof operator\n\t  function(a) {\n\t    return a instanceof Array;\n\t  };\n\t\n\tfunction cloneRegExp(re) {\n\t  var regexMatch = /^\\/(.*)\\/([gimyu]*)$/.exec(re.toString());\n\t  return new RegExp(regexMatch[1], regexMatch[2]);\n\t}\n\t\n\tfunction clone(arg) {\n\t  if (typeof arg !== 'object') {\n\t    return arg;\n\t  }\n\t  if (arg === null) {\n\t    return null;\n\t  }\n\t  if (isArray(arg)) {\n\t    return arg.map(clone);\n\t  }\n\t  if (arg instanceof Date) {\n\t    return new Date(arg.getTime());\n\t  }\n\t  if (arg instanceof RegExp) {\n\t    return cloneRegExp(arg);\n\t  }\n\t  var cloned = {};\n\t  for (var name in arg) {\n\t    if (Object.prototype.hasOwnProperty.call(arg, name)) {\n\t      cloned[name] = clone(arg[name]);\n\t    }\n\t  }\n\t  return cloned;\n\t}\n\t\n\tmodule.exports = clone;\n\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Context = __webpack_require__(42).Context;\n\t\n\tvar PatchContext = function PatchContext(left, delta) {\n\t  this.left = left;\n\t  this.delta = delta;\n\t  this.pipe = 'patch';\n\t};\n\t\n\tPatchContext.prototype = new Context();\n\t\n\texports.PatchContext = PatchContext;\n\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Context = __webpack_require__(42).Context;\n\t\n\tvar ReverseContext = function ReverseContext(delta) {\n\t  this.delta = delta;\n\t  this.pipe = 'reverse';\n\t};\n\t\n\tReverseContext.prototype = new Context();\n\t\n\texports.ReverseContext = ReverseContext;\n\n\n/***/ },\n/* 46 */\n/***/ function(module, exports) {\n\n\tvar isArray = (typeof Array.isArray === 'function') ?\n\t  // use native function\n\t  Array.isArray :\n\t  // use instanceof operator\n\t  function(a) {\n\t    return a instanceof Array;\n\t  };\n\t\n\tvar diffFilter = function trivialMatchesDiffFilter(context) {\n\t  if (context.left === context.right) {\n\t    context.setResult(undefined).exit();\n\t    return;\n\t  }\n\t  if (typeof context.left === 'undefined') {\n\t    if (typeof context.right === 'function') {\n\t      throw new Error('functions are not supported');\n\t    }\n\t    context.setResult([context.right]).exit();\n\t    return;\n\t  }\n\t  if (typeof context.right === 'undefined') {\n\t    context.setResult([context.left, 0, 0]).exit();\n\t    return;\n\t  }\n\t  if (typeof context.left === 'function' || typeof context.right === 'function') {\n\t    throw new Error('functions are not supported');\n\t  }\n\t  context.leftType = context.left === null ? 'null' : typeof context.left;\n\t  context.rightType = context.right === null ? 'null' : typeof context.right;\n\t  if (context.leftType !== context.rightType) {\n\t    context.setResult([context.left, context.right]).exit();\n\t    return;\n\t  }\n\t  if (context.leftType === 'boolean' || context.leftType === 'number') {\n\t    context.setResult([context.left, context.right]).exit();\n\t    return;\n\t  }\n\t  if (context.leftType === 'object') {\n\t    context.leftIsArray = isArray(context.left);\n\t  }\n\t  if (context.rightType === 'object') {\n\t    context.rightIsArray = isArray(context.right);\n\t  }\n\t  if (context.leftIsArray !== context.rightIsArray) {\n\t    context.setResult([context.left, context.right]).exit();\n\t    return;\n\t  }\n\t\n\t  if (context.left instanceof RegExp) {\n\t    if (context.right instanceof RegExp) {\n\t      context.setResult([context.left.toString(), context.right.toString()]).exit();\n\t    } else {\n\t      context.setResult([context.left, context.right]).exit();\n\t      return;\n\t    }\n\t  }\n\t};\n\tdiffFilter.filterName = 'trivial';\n\t\n\tvar patchFilter = function trivialMatchesPatchFilter(context) {\n\t  if (typeof context.delta === 'undefined') {\n\t    context.setResult(context.left).exit();\n\t    return;\n\t  }\n\t  context.nested = !isArray(context.delta);\n\t  if (context.nested) {\n\t    return;\n\t  }\n\t  if (context.delta.length === 1) {\n\t    context.setResult(context.delta[0]).exit();\n\t    return;\n\t  }\n\t  if (context.delta.length === 2) {\n\t    if (context.left instanceof RegExp) {\n\t      var regexArgs = /^\\/(.*)\\/([gimyu]+)$/.exec(context.delta[1]);\n\t      if (regexArgs) {\n\t        context.setResult(new RegExp(regexArgs[1], regexArgs[2])).exit();\n\t        return;\n\t      }\n\t    }\n\t    context.setResult(context.delta[1]).exit();\n\t    return;\n\t  }\n\t  if (context.delta.length === 3 && context.delta[2] === 0) {\n\t    context.setResult(undefined).exit();\n\t    return;\n\t  }\n\t};\n\tpatchFilter.filterName = 'trivial';\n\t\n\tvar reverseFilter = function trivialReferseFilter(context) {\n\t  if (typeof context.delta === 'undefined') {\n\t    context.setResult(context.delta).exit();\n\t    return;\n\t  }\n\t  context.nested = !isArray(context.delta);\n\t  if (context.nested) {\n\t    return;\n\t  }\n\t  if (context.delta.length === 1) {\n\t    context.setResult([context.delta[0], 0, 0]).exit();\n\t    return;\n\t  }\n\t  if (context.delta.length === 2) {\n\t    context.setResult([context.delta[1], context.delta[0]]).exit();\n\t    return;\n\t  }\n\t  if (context.delta.length === 3 && context.delta[2] === 0) {\n\t    context.setResult([context.delta[0]]).exit();\n\t    return;\n\t  }\n\t};\n\treverseFilter.filterName = 'trivial';\n\t\n\texports.diffFilter = diffFilter;\n\texports.patchFilter = patchFilter;\n\texports.reverseFilter = reverseFilter;\n\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar DiffContext = __webpack_require__(41).DiffContext;\n\tvar PatchContext = __webpack_require__(44).PatchContext;\n\tvar ReverseContext = __webpack_require__(45).ReverseContext;\n\t\n\tvar collectChildrenDiffFilter = function collectChildrenDiffFilter(context) {\n\t  if (!context || !context.children) {\n\t    return;\n\t  }\n\t  var length = context.children.length;\n\t  var child;\n\t  var result = context.result;\n\t  for (var index = 0; index < length; index++) {\n\t    child = context.children[index];\n\t    if (typeof child.result === 'undefined') {\n\t      continue;\n\t    }\n\t    result = result || {};\n\t    result[child.childName] = child.result;\n\t  }\n\t  if (result && context.leftIsArray) {\n\t    result._t = 'a';\n\t  }\n\t  context.setResult(result).exit();\n\t};\n\tcollectChildrenDiffFilter.filterName = 'collectChildren';\n\t\n\tvar objectsDiffFilter = function objectsDiffFilter(context) {\n\t  if (context.leftIsArray || context.leftType !== 'object') {\n\t    return;\n\t  }\n\t\n\t  var name, child, propertyFilter = context.options.propertyFilter;\n\t  for (name in context.left) {\n\t    if (!Object.prototype.hasOwnProperty.call(context.left, name)) {\n\t      continue;\n\t    }\n\t    if (propertyFilter && !propertyFilter(name, context)) {\n\t      continue;\n\t    }\n\t    child = new DiffContext(context.left[name], context.right[name]);\n\t    context.push(child, name);\n\t  }\n\t  for (name in context.right) {\n\t    if (!Object.prototype.hasOwnProperty.call(context.right, name)) {\n\t      continue;\n\t    }\n\t    if (propertyFilter && !propertyFilter(name, context)) {\n\t      continue;\n\t    }\n\t    if (typeof context.left[name] === 'undefined') {\n\t      child = new DiffContext(undefined, context.right[name]);\n\t      context.push(child, name);\n\t    }\n\t  }\n\t\n\t  if (!context.children || context.children.length === 0) {\n\t    context.setResult(undefined).exit();\n\t    return;\n\t  }\n\t  context.exit();\n\t};\n\tobjectsDiffFilter.filterName = 'objects';\n\t\n\tvar patchFilter = function nestedPatchFilter(context) {\n\t  if (!context.nested) {\n\t    return;\n\t  }\n\t  if (context.delta._t) {\n\t    return;\n\t  }\n\t  var name, child;\n\t  for (name in context.delta) {\n\t    child = new PatchContext(context.left[name], context.delta[name]);\n\t    context.push(child, name);\n\t  }\n\t  context.exit();\n\t};\n\tpatchFilter.filterName = 'objects';\n\t\n\tvar collectChildrenPatchFilter = function collectChildrenPatchFilter(context) {\n\t  if (!context || !context.children) {\n\t    return;\n\t  }\n\t  if (context.delta._t) {\n\t    return;\n\t  }\n\t  var length = context.children.length;\n\t  var child;\n\t  for (var index = 0; index < length; index++) {\n\t    child = context.children[index];\n\t    if (Object.prototype.hasOwnProperty.call(context.left, child.childName) && child.result === undefined) {\n\t      delete context.left[child.childName];\n\t    } else if (context.left[child.childName] !== child.result) {\n\t      context.left[child.childName] = child.result;\n\t    }\n\t  }\n\t  context.setResult(context.left).exit();\n\t};\n\tcollectChildrenPatchFilter.filterName = 'collectChildren';\n\t\n\tvar reverseFilter = function nestedReverseFilter(context) {\n\t  if (!context.nested) {\n\t    return;\n\t  }\n\t  if (context.delta._t) {\n\t    return;\n\t  }\n\t  var name, child;\n\t  for (name in context.delta) {\n\t    child = new ReverseContext(context.delta[name]);\n\t    context.push(child, name);\n\t  }\n\t  context.exit();\n\t};\n\treverseFilter.filterName = 'objects';\n\t\n\tvar collectChildrenReverseFilter = function collectChildrenReverseFilter(context) {\n\t  if (!context || !context.children) {\n\t    return;\n\t  }\n\t  if (context.delta._t) {\n\t    return;\n\t  }\n\t  var length = context.children.length;\n\t  var child;\n\t  var delta = {};\n\t  for (var index = 0; index < length; index++) {\n\t    child = context.children[index];\n\t    if (delta[child.childName] !== child.result) {\n\t      delta[child.childName] = child.result;\n\t    }\n\t  }\n\t  context.setResult(delta).exit();\n\t};\n\tcollectChildrenReverseFilter.filterName = 'collectChildren';\n\t\n\texports.collectChildrenDiffFilter = collectChildrenDiffFilter;\n\texports.objectsDiffFilter = objectsDiffFilter;\n\texports.patchFilter = patchFilter;\n\texports.collectChildrenPatchFilter = collectChildrenPatchFilter;\n\texports.reverseFilter = reverseFilter;\n\texports.collectChildrenReverseFilter = collectChildrenReverseFilter;\n\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar DiffContext = __webpack_require__(41).DiffContext;\n\tvar PatchContext = __webpack_require__(44).PatchContext;\n\tvar ReverseContext = __webpack_require__(45).ReverseContext;\n\t\n\tvar lcs = __webpack_require__(49);\n\t\n\tvar ARRAY_MOVE = 3;\n\t\n\tvar isArray = (typeof Array.isArray === 'function') ?\n\t  // use native function\n\t  Array.isArray :\n\t  // use instanceof operator\n\t  function(a) {\n\t    return a instanceof Array;\n\t  };\n\t\n\tvar arrayIndexOf = typeof Array.prototype.indexOf === 'function' ?\n\t  function(array, item) {\n\t    return array.indexOf(item);\n\t  } : function(array, item) {\n\t    var length = array.length;\n\t    for (var i = 0; i < length; i++) {\n\t      if (array[i] === item) {\n\t        return i;\n\t      }\n\t    }\n\t    return -1;\n\t  };\n\t\n\tfunction arraysHaveMatchByRef(array1, array2, len1, len2) {\n\t  for (var index1 = 0; index1 < len1; index1++) {\n\t    var val1 = array1[index1];\n\t    for (var index2 = 0; index2 < len2; index2++) {\n\t      var val2 = array2[index2];\n\t      if (index1 !== index2 && val1 === val2) {\n\t        return true;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction matchItems(array1, array2, index1, index2, context) {\n\t  var value1 = array1[index1];\n\t  var value2 = array2[index2];\n\t  if (value1 === value2) {\n\t    return true;\n\t  }\n\t  if (typeof value1 !== 'object' || typeof value2 !== 'object') {\n\t    return false;\n\t  }\n\t  var objectHash = context.objectHash;\n\t  if (!objectHash) {\n\t    // no way to match objects was provided, try match by position\n\t    return context.matchByPosition && index1 === index2;\n\t  }\n\t  var hash1;\n\t  var hash2;\n\t  if (typeof index1 === 'number') {\n\t    context.hashCache1 = context.hashCache1 || [];\n\t    hash1 = context.hashCache1[index1];\n\t    if (typeof hash1 === 'undefined') {\n\t      context.hashCache1[index1] = hash1 = objectHash(value1, index1);\n\t    }\n\t  } else {\n\t    hash1 = objectHash(value1);\n\t  }\n\t  if (typeof hash1 === 'undefined') {\n\t    return false;\n\t  }\n\t  if (typeof index2 === 'number') {\n\t    context.hashCache2 = context.hashCache2 || [];\n\t    hash2 = context.hashCache2[index2];\n\t    if (typeof hash2 === 'undefined') {\n\t      context.hashCache2[index2] = hash2 = objectHash(value2, index2);\n\t    }\n\t  } else {\n\t    hash2 = objectHash(value2);\n\t  }\n\t  if (typeof hash2 === 'undefined') {\n\t    return false;\n\t  }\n\t  return hash1 === hash2;\n\t}\n\t\n\tvar diffFilter = function arraysDiffFilter(context) {\n\t  if (!context.leftIsArray) {\n\t    return;\n\t  }\n\t\n\t  var matchContext = {\n\t    objectHash: context.options && context.options.objectHash,\n\t    matchByPosition: context.options && context.options.matchByPosition\n\t  };\n\t  var commonHead = 0;\n\t  var commonTail = 0;\n\t  var index;\n\t  var index1;\n\t  var index2;\n\t  var array1 = context.left;\n\t  var array2 = context.right;\n\t  var len1 = array1.length;\n\t  var len2 = array2.length;\n\t\n\t  var child;\n\t\n\t  if (len1 > 0 && len2 > 0 && !matchContext.objectHash &&\n\t    typeof matchContext.matchByPosition !== 'boolean') {\n\t    matchContext.matchByPosition = !arraysHaveMatchByRef(array1, array2, len1, len2);\n\t  }\n\t\n\t  // separate common head\n\t  while (commonHead < len1 && commonHead < len2 &&\n\t    matchItems(array1, array2, commonHead, commonHead, matchContext)) {\n\t    index = commonHead;\n\t    child = new DiffContext(context.left[index], context.right[index]);\n\t    context.push(child, index);\n\t    commonHead++;\n\t  }\n\t  // separate common tail\n\t  while (commonTail + commonHead < len1 && commonTail + commonHead < len2 &&\n\t    matchItems(array1, array2, len1 - 1 - commonTail, len2 - 1 - commonTail, matchContext)) {\n\t    index1 = len1 - 1 - commonTail;\n\t    index2 = len2 - 1 - commonTail;\n\t    child = new DiffContext(context.left[index1], context.right[index2]);\n\t    context.push(child, index2);\n\t    commonTail++;\n\t  }\n\t  var result;\n\t  if (commonHead + commonTail === len1) {\n\t    if (len1 === len2) {\n\t      // arrays are identical\n\t      context.setResult(undefined).exit();\n\t      return;\n\t    }\n\t    // trivial case, a block (1 or more consecutive items) was added\n\t    result = result || {\n\t      _t: 'a'\n\t    };\n\t    for (index = commonHead; index < len2 - commonTail; index++) {\n\t      result[index] = [array2[index]];\n\t    }\n\t    context.setResult(result).exit();\n\t    return;\n\t  }\n\t  if (commonHead + commonTail === len2) {\n\t    // trivial case, a block (1 or more consecutive items) was removed\n\t    result = result || {\n\t      _t: 'a'\n\t    };\n\t    for (index = commonHead; index < len1 - commonTail; index++) {\n\t      result['_' + index] = [array1[index], 0, 0];\n\t    }\n\t    context.setResult(result).exit();\n\t    return;\n\t  }\n\t  // reset hash cache\n\t  delete matchContext.hashCache1;\n\t  delete matchContext.hashCache2;\n\t\n\t  // diff is not trivial, find the LCS (Longest Common Subsequence)\n\t  var trimmed1 = array1.slice(commonHead, len1 - commonTail);\n\t  var trimmed2 = array2.slice(commonHead, len2 - commonTail);\n\t  var seq = lcs.get(\n\t    trimmed1, trimmed2,\n\t    matchItems,\n\t    matchContext\n\t  );\n\t  var removedItems = [];\n\t  result = result || {\n\t    _t: 'a'\n\t  };\n\t  for (index = commonHead; index < len1 - commonTail; index++) {\n\t    if (arrayIndexOf(seq.indices1, index - commonHead) < 0) {\n\t      // removed\n\t      result['_' + index] = [array1[index], 0, 0];\n\t      removedItems.push(index);\n\t    }\n\t  }\n\t\n\t  var detectMove = true;\n\t  if (context.options && context.options.arrays && context.options.arrays.detectMove === false) {\n\t    detectMove = false;\n\t  }\n\t  var includeValueOnMove = false;\n\t  if (context.options && context.options.arrays && context.options.arrays.includeValueOnMove) {\n\t    includeValueOnMove = true;\n\t  }\n\t\n\t  var removedItemsLength = removedItems.length;\n\t  for (index = commonHead; index < len2 - commonTail; index++) {\n\t    var indexOnArray2 = arrayIndexOf(seq.indices2, index - commonHead);\n\t    if (indexOnArray2 < 0) {\n\t      // added, try to match with a removed item and register as position move\n\t      var isMove = false;\n\t      if (detectMove && removedItemsLength > 0) {\n\t        for (var removeItemIndex1 = 0; removeItemIndex1 < removedItemsLength; removeItemIndex1++) {\n\t          index1 = removedItems[removeItemIndex1];\n\t          if (matchItems(trimmed1, trimmed2, index1 - commonHead,\n\t            index - commonHead, matchContext)) {\n\t            // store position move as: [originalValue, newPosition, ARRAY_MOVE]\n\t            result['_' + index1].splice(1, 2, index, ARRAY_MOVE);\n\t            if (!includeValueOnMove) {\n\t              // don't include moved value on diff, to save bytes\n\t              result['_' + index1][0] = '';\n\t            }\n\t\n\t            index2 = index;\n\t            child = new DiffContext(context.left[index1], context.right[index2]);\n\t            context.push(child, index2);\n\t            removedItems.splice(removeItemIndex1, 1);\n\t            isMove = true;\n\t            break;\n\t          }\n\t        }\n\t      }\n\t      if (!isMove) {\n\t        // added\n\t        result[index] = [array2[index]];\n\t      }\n\t    } else {\n\t      // match, do inner diff\n\t      index1 = seq.indices1[indexOnArray2] + commonHead;\n\t      index2 = seq.indices2[indexOnArray2] + commonHead;\n\t      child = new DiffContext(context.left[index1], context.right[index2]);\n\t      context.push(child, index2);\n\t    }\n\t  }\n\t\n\t  context.setResult(result).exit();\n\t\n\t};\n\tdiffFilter.filterName = 'arrays';\n\t\n\tvar compare = {\n\t  numerically: function(a, b) {\n\t    return a - b;\n\t  },\n\t  numericallyBy: function(name) {\n\t    return function(a, b) {\n\t      return a[name] - b[name];\n\t    };\n\t  }\n\t};\n\t\n\tvar patchFilter = function nestedPatchFilter(context) {\n\t  if (!context.nested) {\n\t    return;\n\t  }\n\t  if (context.delta._t !== 'a') {\n\t    return;\n\t  }\n\t  var index, index1;\n\t\n\t  var delta = context.delta;\n\t  var array = context.left;\n\t\n\t  // first, separate removals, insertions and modifications\n\t  var toRemove = [];\n\t  var toInsert = [];\n\t  var toModify = [];\n\t  for (index in delta) {\n\t    if (index !== '_t') {\n\t      if (index[0] === '_') {\n\t        // removed item from original array\n\t        if (delta[index][2] === 0 || delta[index][2] === ARRAY_MOVE) {\n\t          toRemove.push(parseInt(index.slice(1), 10));\n\t        } else {\n\t          throw new Error('only removal or move can be applied at original array indices' +\n\t            ', invalid diff type: ' + delta[index][2]);\n\t        }\n\t      } else {\n\t        if (delta[index].length === 1) {\n\t          // added item at new array\n\t          toInsert.push({\n\t            index: parseInt(index, 10),\n\t            value: delta[index][0]\n\t          });\n\t        } else {\n\t          // modified item at new array\n\t          toModify.push({\n\t            index: parseInt(index, 10),\n\t            delta: delta[index]\n\t          });\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  // remove items, in reverse order to avoid sawing our own floor\n\t  toRemove = toRemove.sort(compare.numerically);\n\t  for (index = toRemove.length - 1; index >= 0; index--) {\n\t    index1 = toRemove[index];\n\t    var indexDiff = delta['_' + index1];\n\t    var removedValue = array.splice(index1, 1)[0];\n\t    if (indexDiff[2] === ARRAY_MOVE) {\n\t      // reinsert later\n\t      toInsert.push({\n\t        index: indexDiff[1],\n\t        value: removedValue\n\t      });\n\t    }\n\t  }\n\t\n\t  // insert items, in reverse order to avoid moving our own floor\n\t  toInsert = toInsert.sort(compare.numericallyBy('index'));\n\t  var toInsertLength = toInsert.length;\n\t  for (index = 0; index < toInsertLength; index++) {\n\t    var insertion = toInsert[index];\n\t    array.splice(insertion.index, 0, insertion.value);\n\t  }\n\t\n\t  // apply modifications\n\t  var toModifyLength = toModify.length;\n\t  var child;\n\t  if (toModifyLength > 0) {\n\t    for (index = 0; index < toModifyLength; index++) {\n\t      var modification = toModify[index];\n\t      child = new PatchContext(context.left[modification.index], modification.delta);\n\t      context.push(child, modification.index);\n\t    }\n\t  }\n\t\n\t  if (!context.children) {\n\t    context.setResult(context.left).exit();\n\t    return;\n\t  }\n\t  context.exit();\n\t};\n\tpatchFilter.filterName = 'arrays';\n\t\n\tvar collectChildrenPatchFilter = function collectChildrenPatchFilter(context) {\n\t  if (!context || !context.children) {\n\t    return;\n\t  }\n\t  if (context.delta._t !== 'a') {\n\t    return;\n\t  }\n\t  var length = context.children.length;\n\t  var child;\n\t  for (var index = 0; index < length; index++) {\n\t    child = context.children[index];\n\t    context.left[child.childName] = child.result;\n\t  }\n\t  context.setResult(context.left).exit();\n\t};\n\tcollectChildrenPatchFilter.filterName = 'arraysCollectChildren';\n\t\n\tvar reverseFilter = function arraysReverseFilter(context) {\n\t  if (!context.nested) {\n\t    if (context.delta[2] === ARRAY_MOVE) {\n\t      context.newName = '_' + context.delta[1];\n\t      context.setResult([context.delta[0], parseInt(context.childName.substr(1), 10), ARRAY_MOVE]).exit();\n\t    }\n\t    return;\n\t  }\n\t  if (context.delta._t !== 'a') {\n\t    return;\n\t  }\n\t  var name, child;\n\t  for (name in context.delta) {\n\t    if (name === '_t') {\n\t      continue;\n\t    }\n\t    child = new ReverseContext(context.delta[name]);\n\t    context.push(child, name);\n\t  }\n\t  context.exit();\n\t};\n\treverseFilter.filterName = 'arrays';\n\t\n\tvar reverseArrayDeltaIndex = function(delta, index, itemDelta) {\n\t  if (typeof index === 'string' && index[0] === '_') {\n\t    return parseInt(index.substr(1), 10);\n\t  } else if (isArray(itemDelta) && itemDelta[2] === 0) {\n\t    return '_' + index;\n\t  }\n\t\n\t  var reverseIndex = +index;\n\t  for (var deltaIndex in delta) {\n\t    var deltaItem = delta[deltaIndex];\n\t    if (isArray(deltaItem)) {\n\t      if (deltaItem[2] === ARRAY_MOVE) {\n\t        var moveFromIndex = parseInt(deltaIndex.substr(1), 10);\n\t        var moveToIndex = deltaItem[1];\n\t        if (moveToIndex === +index) {\n\t          return moveFromIndex;\n\t        }\n\t        if (moveFromIndex <= reverseIndex && moveToIndex > reverseIndex) {\n\t          reverseIndex++;\n\t        } else if (moveFromIndex >= reverseIndex && moveToIndex < reverseIndex) {\n\t          reverseIndex--;\n\t        }\n\t      } else if (deltaItem[2] === 0) {\n\t        var deleteIndex = parseInt(deltaIndex.substr(1), 10);\n\t        if (deleteIndex <= reverseIndex) {\n\t          reverseIndex++;\n\t        }\n\t      } else if (deltaItem.length === 1 && deltaIndex <= reverseIndex) {\n\t        reverseIndex--;\n\t      }\n\t    }\n\t  }\n\t\n\t  return reverseIndex;\n\t};\n\t\n\tvar collectChildrenReverseFilter = function collectChildrenReverseFilter(context) {\n\t  if (!context || !context.children) {\n\t    return;\n\t  }\n\t  if (context.delta._t !== 'a') {\n\t    return;\n\t  }\n\t  var length = context.children.length;\n\t  var child;\n\t  var delta = {\n\t    _t: 'a'\n\t  };\n\t\n\t  for (var index = 0; index < length; index++) {\n\t    child = context.children[index];\n\t    var name = child.newName;\n\t    if (typeof name === 'undefined') {\n\t      name = reverseArrayDeltaIndex(context.delta, child.childName, child.result);\n\t    }\n\t    if (delta[name] !== child.result) {\n\t      delta[name] = child.result;\n\t    }\n\t  }\n\t  context.setResult(delta).exit();\n\t};\n\tcollectChildrenReverseFilter.filterName = 'arraysCollectChildren';\n\t\n\texports.diffFilter = diffFilter;\n\texports.patchFilter = patchFilter;\n\texports.collectChildrenPatchFilter = collectChildrenPatchFilter;\n\texports.reverseFilter = reverseFilter;\n\texports.collectChildrenReverseFilter = collectChildrenReverseFilter;\n\n\n/***/ },\n/* 49 */\n/***/ function(module, exports) {\n\n\t/*\n\t\n\tLCS implementation that supports arrays or strings\n\t\n\treference: http://en.wikipedia.org/wiki/Longest_common_subsequence_problem\n\t\n\t*/\n\t\n\tvar defaultMatch = function(array1, array2, index1, index2) {\n\t  return array1[index1] === array2[index2];\n\t};\n\t\n\tvar lengthMatrix = function(array1, array2, match, context) {\n\t  var len1 = array1.length;\n\t  var len2 = array2.length;\n\t  var x, y;\n\t\n\t  // initialize empty matrix of len1+1 x len2+1\n\t  var matrix = [len1 + 1];\n\t  for (x = 0; x < len1 + 1; x++) {\n\t    matrix[x] = [len2 + 1];\n\t    for (y = 0; y < len2 + 1; y++) {\n\t      matrix[x][y] = 0;\n\t    }\n\t  }\n\t  matrix.match = match;\n\t  // save sequence lengths for each coordinate\n\t  for (x = 1; x < len1 + 1; x++) {\n\t    for (y = 1; y < len2 + 1; y++) {\n\t      if (match(array1, array2, x - 1, y - 1, context)) {\n\t        matrix[x][y] = matrix[x - 1][y - 1] + 1;\n\t      } else {\n\t        matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1]);\n\t      }\n\t    }\n\t  }\n\t  return matrix;\n\t};\n\t\n\tvar backtrack = function(matrix, array1, array2, index1, index2, context) {\n\t  if (index1 === 0 || index2 === 0) {\n\t    return {\n\t      sequence: [],\n\t      indices1: [],\n\t      indices2: []\n\t    };\n\t  }\n\t\n\t  if (matrix.match(array1, array2, index1 - 1, index2 - 1, context)) {\n\t    var subsequence = backtrack(matrix, array1, array2, index1 - 1, index2 - 1, context);\n\t    subsequence.sequence.push(array1[index1 - 1]);\n\t    subsequence.indices1.push(index1 - 1);\n\t    subsequence.indices2.push(index2 - 1);\n\t    return subsequence;\n\t  }\n\t\n\t  if (matrix[index1][index2 - 1] > matrix[index1 - 1][index2]) {\n\t    return backtrack(matrix, array1, array2, index1, index2 - 1, context);\n\t  } else {\n\t    return backtrack(matrix, array1, array2, index1 - 1, index2, context);\n\t  }\n\t};\n\t\n\tvar get = function(array1, array2, match, context) {\n\t  context = context || {};\n\t  var matrix = lengthMatrix(array1, array2, match || defaultMatch, context);\n\t  var result = backtrack(matrix, array1, array2, array1.length, array2.length, context);\n\t  if (typeof array1 === 'string' && typeof array2 === 'string') {\n\t    result.sequence = result.sequence.join('');\n\t  }\n\t  return result;\n\t};\n\t\n\texports.get = get;\n\n\n/***/ },\n/* 50 */\n/***/ function(module, exports) {\n\n\tvar diffFilter = function datesDiffFilter(context) {\n\t  if (context.left instanceof Date) {\n\t    if (context.right instanceof Date) {\n\t      if (context.left.getTime() !== context.right.getTime()) {\n\t        context.setResult([context.left, context.right]);\n\t      } else {\n\t        context.setResult(undefined);\n\t      }\n\t    } else {\n\t      context.setResult([context.left, context.right]);\n\t    }\n\t    context.exit();\n\t  } else if (context.right instanceof Date) {\n\t    context.setResult([context.left, context.right]).exit();\n\t  }\n\t};\n\tdiffFilter.filterName = 'dates';\n\t\n\texports.diffFilter = diffFilter;\n\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* global diff_match_patch */\n\tvar TEXT_DIFF = 2;\n\tvar DEFAULT_MIN_LENGTH = 60;\n\tvar cachedDiffPatch = null;\n\t\n\tvar getDiffMatchPatch = function(required) {\n\t  /*jshint camelcase: false */\n\t\n\t  if (!cachedDiffPatch) {\n\t    var instance;\n\t    if (typeof diff_match_patch !== 'undefined') {\n\t      // already loaded, probably a browser\n\t      instance = typeof diff_match_patch === 'function' ?\n\t        new diff_match_patch() : new diff_match_patch.diff_match_patch();\n\t    } else if (true) {\n\t      try {\n\t        var dmpModuleName = 'diff_match_patch_uncompressed';\n\t        var dmp = __webpack_require__(52)(\"./\" + dmpModuleName);\n\t        instance = new dmp.diff_match_patch();\n\t      } catch (err) {\n\t        instance = null;\n\t      }\n\t    }\n\t    if (!instance) {\n\t      if (!required) {\n\t        return null;\n\t      }\n\t      var error = new Error('text diff_match_patch library not found');\n\t      error.diff_match_patch_not_found = true;\n\t      throw error;\n\t    }\n\t    cachedDiffPatch = {\n\t      diff: function(txt1, txt2) {\n\t        return instance.patch_toText(instance.patch_make(txt1, txt2));\n\t      },\n\t      patch: function(txt1, patch) {\n\t        var results = instance.patch_apply(instance.patch_fromText(patch), txt1);\n\t        for (var i = 0; i < results[1].length; i++) {\n\t          if (!results[1][i]) {\n\t            var error = new Error('text patch failed');\n\t            error.textPatchFailed = true;\n\t          }\n\t        }\n\t        return results[0];\n\t      }\n\t    };\n\t  }\n\t  return cachedDiffPatch;\n\t};\n\t\n\tvar diffFilter = function textsDiffFilter(context) {\n\t  if (context.leftType !== 'string') {\n\t    return;\n\t  }\n\t  var minLength = (context.options && context.options.textDiff &&\n\t    context.options.textDiff.minLength) || DEFAULT_MIN_LENGTH;\n\t  if (context.left.length < minLength ||\n\t    context.right.length < minLength) {\n\t    context.setResult([context.left, context.right]).exit();\n\t    return;\n\t  }\n\t  // large text, try to use a text-diff algorithm\n\t  var diffMatchPatch = getDiffMatchPatch();\n\t  if (!diffMatchPatch) {\n\t    // diff-match-patch library not available, fallback to regular string replace\n\t    context.setResult([context.left, context.right]).exit();\n\t    return;\n\t  }\n\t  var diff = diffMatchPatch.diff;\n\t  context.setResult([diff(context.left, context.right), 0, TEXT_DIFF]).exit();\n\t};\n\tdiffFilter.filterName = 'texts';\n\t\n\tvar patchFilter = function textsPatchFilter(context) {\n\t  if (context.nested) {\n\t    return;\n\t  }\n\t  if (context.delta[2] !== TEXT_DIFF) {\n\t    return;\n\t  }\n\t\n\t  // text-diff, use a text-patch algorithm\n\t  var patch = getDiffMatchPatch(true).patch;\n\t  context.setResult(patch(context.left, context.delta[0])).exit();\n\t};\n\tpatchFilter.filterName = 'texts';\n\t\n\tvar textDeltaReverse = function(delta) {\n\t  var i, l, lines, line, lineTmp, header = null,\n\t    headerRegex = /^@@ +\\-(\\d+),(\\d+) +\\+(\\d+),(\\d+) +@@$/,\n\t    lineHeader, lineAdd, lineRemove;\n\t  lines = delta.split('\\n');\n\t  for (i = 0, l = lines.length; i < l; i++) {\n\t    line = lines[i];\n\t    var lineStart = line.slice(0, 1);\n\t    if (lineStart === '@') {\n\t      header = headerRegex.exec(line);\n\t      lineHeader = i;\n\t      lineAdd = null;\n\t      lineRemove = null;\n\t\n\t      // fix header\n\t      lines[lineHeader] = '@@ -' + header[3] + ',' + header[4] + ' +' + header[1] + ',' + header[2] + ' @@';\n\t    } else if (lineStart === '+') {\n\t      lineAdd = i;\n\t      lines[i] = '-' + lines[i].slice(1);\n\t      if (lines[i - 1].slice(0, 1) === '+') {\n\t        // swap lines to keep default order (-+)\n\t        lineTmp = lines[i];\n\t        lines[i] = lines[i - 1];\n\t        lines[i - 1] = lineTmp;\n\t      }\n\t    } else if (lineStart === '-') {\n\t      lineRemove = i;\n\t      lines[i] = '+' + lines[i].slice(1);\n\t    }\n\t  }\n\t  return lines.join('\\n');\n\t};\n\t\n\tvar reverseFilter = function textsReverseFilter(context) {\n\t  if (context.nested) {\n\t    return;\n\t  }\n\t  if (context.delta[2] !== TEXT_DIFF) {\n\t    return;\n\t  }\n\t\n\t  // text-diff, use a text-diff algorithm\n\t  context.setResult([textDeltaReverse(context.delta[0]), 0, TEXT_DIFF]).exit();\n\t};\n\treverseFilter.filterName = 'texts';\n\t\n\texports.diffFilter = diffFilter;\n\texports.patchFilter = patchFilter;\n\texports.reverseFilter = reverseFilter;\n\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar map = {\n\t\t\"../package.json\": 53,\n\t\t\"./console\": 54,\n\t\t\"./formatters\": 63\n\t};\n\tfunction webpackContext(req) {\n\t\treturn __webpack_require__(webpackContextResolve(req));\n\t};\n\tfunction webpackContextResolve(req) {\n\t\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n\t};\n\twebpackContext.keys = function webpackContextKeys() {\n\t\treturn Object.keys(map);\n\t};\n\twebpackContext.resolve = webpackContextResolve;\n\tmodule.exports = webpackContext;\n\twebpackContext.id = 52;\n\n\n/***/ },\n/* 53 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\"_args\":[[\"jsondiffpatch@0.2.4\",\"/home/adelina/telepat-js\"]],\"_from\":\"jsondiffpatch@0.2.4\",\"_id\":\"jsondiffpatch@0.2.4\",\"_inBundle\":false,\"_integrity\":\"sha1-1LbFOz/H2htLkcHCrsi5MrdRHVw=\",\"_location\":\"/jsondiffpatch\",\"_phantomChildren\":{},\"_requested\":{\"type\":\"version\",\"registry\":true,\"raw\":\"jsondiffpatch@0.2.4\",\"name\":\"jsondiffpatch\",\"escapedName\":\"jsondiffpatch\",\"rawSpec\":\"0.2.4\",\"saveSpec\":null,\"fetchSpec\":\"0.2.4\"},\"_requiredBy\":[\"/\"],\"_resolved\":\"https://registry.npmjs.org/jsondiffpatch/-/jsondiffpatch-0.2.4.tgz\",\"_spec\":\"0.2.4\",\"_where\":\"/home/adelina/telepat-js\",\"author\":{\"name\":\"Benjamin Eidelman\",\"email\":\"beneidel@gmail.com\"},\"bin\":{\"jsondiffpatch\":\"./bin/jsondiffpatch\"},\"bugs\":{\"url\":\"https://github.com/benjamine/jsondiffpatch/issues\"},\"bundleDependencies\":[],\"contributors\":[{\"name\":\"Benjamin Eidelman\",\"email\":\"beneidel@gmail.com\"}],\"dependencies\":{\"chalk\":\"^0.5.1\"},\"description\":\"Diff & Patch for Javascript objects\",\"devDependencies\":{\"bulk-require\":\"^0.2.1\",\"codeclimate-test-reporter\":\"0.0.3\",\"expect.js\":\"~0.3.1\",\"fiberglass\":\"0.0.22\",\"gulp\":\"^3.8.8\",\"istanbul\":\"^0.3.2\",\"mocha\":\"^1.21.4\"},\"engine\":{\"node\":\">=0.10\"},\"engines\":{\"node\":\"*\"},\"homepage\":\"https://github.com/benjamine/jsondiffpatch\",\"keywords\":[\"json\",\"diff\",\"patch\"],\"license\":\"MIT\",\"main\":\"./src/main\",\"name\":\"jsondiffpatch\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/benjamine/jsondiffpatch.git\"},\"scripts\":{\"bump\":\"gulp bump\",\"cover\":\"istanbul cover --root src gulp test\",\"cover-publish\":\"istanbul cover _mocha --report lcovonly && codeclimate < coverage/lcov.info\",\"cover-report\":\"open coverage/lcov-report/index.html\",\"test\":\"gulp test && gulp test-browser\"},\"testling\":{\"harness\":\"mocha\",\"files\":\"test/index.js\",\"scripts\":[\"build/jsondiffpatch.js\",\"external/diff_match_patch_uncompressed.js\"],\"browsers\":[\"ie/8..latest\",\"chrome/27..latest\",\"firefox/22..latest\",\"safari/5.1..latest\",\"opera/12..latest\",\"iphone/6..latest\",\"ipad/6..latest\",\"android-browser/4.2..latest\"]},\"version\":\"0.2.4\"}\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar chalk = __webpack_require__(55);\n\tvar base = __webpack_require__(62);\n\tvar BaseFormatter = base.BaseFormatter;\n\t\n\tvar colors = {\n\t  added: chalk.green,\n\t  deleted: chalk.red,\n\t  movedestination: chalk.gray,\n\t  moved: chalk.yellow,\n\t  unchanged: chalk.gray,\n\t  error: chalk.white.bgRed,\n\t  textDiffLine: chalk.gray\n\t};\n\t\n\tvar ConsoleFormatter = function ConsoleFormatter() {\n\t  this.includeMoveDestinations = false;\n\t};\n\t\n\tConsoleFormatter.prototype = new BaseFormatter();\n\t\n\tConsoleFormatter.prototype.prepareContext = function(context) {\n\t  BaseFormatter.prototype.prepareContext.call(this, context);\n\t  context.indent = function(levels) {\n\t    this.indentLevel = (this.indentLevel || 0) +\n\t      (typeof levels === 'undefined' ? 1 : levels);\n\t    this.indentPad = new Array(this.indentLevel + 1).join('  ');\n\t    this.outLine();\n\t  };\n\t  context.outLine = function() {\n\t    this.buffer.push('\\n' + (this.indentPad || ''));\n\t  };\n\t  context.out = function() {\n\t    for (var i = 0, l = arguments.length; i < l; i++) {\n\t      var lines = arguments[i].split('\\n');\n\t      var text = lines.join('\\n' + (this.indentPad || ''));\n\t      if (this.color && this.color[0]) {\n\t        text = this.color[0](text);\n\t      }\n\t      this.buffer.push(text);\n\t    }\n\t  };\n\t  context.pushColor = function(color) {\n\t    this.color = this.color || [];\n\t    this.color.unshift(color);\n\t  };\n\t  context.popColor = function() {\n\t    this.color = this.color || [];\n\t    this.color.shift();\n\t  };\n\t};\n\t\n\tConsoleFormatter.prototype.typeFormattterErrorFormatter = function(context, err) {\n\t  context.pushColor(colors.error);\n\t  context.out('[ERROR]' + err);\n\t  context.popColor();\n\t};\n\t\n\tConsoleFormatter.prototype.formatValue = function(context, value) {\n\t  context.out(JSON.stringify(value, null, 2));\n\t};\n\t\n\tConsoleFormatter.prototype.formatTextDiffString = function(context, value) {\n\t  var lines = this.parseTextDiff(value);\n\t  context.indent();\n\t  for (var i = 0, l = lines.length; i < l; i++) {\n\t    var line = lines[i];\n\t    context.pushColor(colors.textDiffLine);\n\t    context.out(line.location.line + ',' + line.location.chr + ' ');\n\t    context.popColor();\n\t    var pieces = line.pieces;\n\t    for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {\n\t      var piece = pieces[pieceIndex];\n\t      context.pushColor(colors[piece.type]);\n\t      context.out(piece.text);\n\t      context.popColor();\n\t    }\n\t    if (i < l - 1) {\n\t      context.outLine();\n\t    }\n\t  }\n\t  context.indent(-1);\n\t};\n\t\n\tConsoleFormatter.prototype.rootBegin = function(context, type, nodeType) {\n\t  context.pushColor(colors[type]);\n\t  if (type === 'node') {\n\t    context.out(nodeType === 'array' ? '[' : '{');\n\t    context.indent();\n\t  }\n\t};\n\t\n\tConsoleFormatter.prototype.rootEnd = function(context, type, nodeType) {\n\t  if (type === 'node') {\n\t    context.indent(-1);\n\t    context.out(nodeType === 'array' ? ']' : '}');\n\t  }\n\t  context.popColor();\n\t};\n\t\n\tConsoleFormatter.prototype.nodeBegin = function(context, key, leftKey, type, nodeType) {\n\t  context.pushColor(colors[type]);\n\t  context.out(leftKey + ': ');\n\t  if (type === 'node') {\n\t    context.out(nodeType === 'array' ? '[' : '{');\n\t    context.indent();\n\t  }\n\t};\n\t\n\tConsoleFormatter.prototype.nodeEnd = function(context, key, leftKey, type, nodeType, isLast) {\n\t  if (type === 'node') {\n\t    context.indent(-1);\n\t    context.out(nodeType === 'array' ? ']' : '}' +\n\t      (isLast ? '' : ','));\n\t  }\n\t  if (!isLast) {\n\t    context.outLine();\n\t  }\n\t  context.popColor();\n\t};\n\t\n\t/* jshint camelcase: false */\n\t\n\tConsoleFormatter.prototype.format_unchanged = function(context, delta, left) {\n\t  if (typeof left === 'undefined') {\n\t    return;\n\t  }\n\t  this.formatValue(context, left);\n\t};\n\t\n\tConsoleFormatter.prototype.format_movedestination = function(context, delta, left) {\n\t  if (typeof left === 'undefined') {\n\t    return;\n\t  }\n\t  this.formatValue(context, left);\n\t};\n\t\n\tConsoleFormatter.prototype.format_node = function(context, delta, left) {\n\t  // recurse\n\t  this.formatDeltaChildren(context, delta, left);\n\t};\n\t\n\tConsoleFormatter.prototype.format_added = function(context, delta) {\n\t  this.formatValue(context, delta[0]);\n\t};\n\t\n\tConsoleFormatter.prototype.format_modified = function(context, delta) {\n\t  context.pushColor(colors.deleted);\n\t  this.formatValue(context, delta[0]);\n\t  context.popColor();\n\t  context.out(' => ');\n\t  context.pushColor(colors.added);\n\t  this.formatValue(context, delta[1]);\n\t  context.popColor();\n\t};\n\t\n\tConsoleFormatter.prototype.format_deleted = function(context, delta) {\n\t  this.formatValue(context, delta[0]);\n\t};\n\t\n\tConsoleFormatter.prototype.format_moved = function(context, delta) {\n\t  context.out('==> ' + delta[1]);\n\t};\n\t\n\tConsoleFormatter.prototype.format_textdiff = function(context, delta) {\n\t  this.formatTextDiffString(context, delta[0]);\n\t};\n\t\n\t/* jshint camelcase: true */\n\t\n\texports.ConsoleFormatter = ConsoleFormatter;\n\t\n\tvar defaultInstance;\n\t\n\tvar format = function(delta, left) {\n\t  if (!defaultInstance) {\n\t    defaultInstance = new ConsoleFormatter();\n\t  }\n\t  return defaultInstance.format(delta, left);\n\t};\n\t\n\texports.log = function(delta, left) {\n\t  console.log(format(delta, left));\n\t};\n\t\n\texports.format = format;\n\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar escapeStringRegexp = __webpack_require__(56);\n\tvar ansiStyles = __webpack_require__(57);\n\tvar stripAnsi = __webpack_require__(58);\n\tvar hasAnsi = __webpack_require__(60);\n\tvar supportsColor = __webpack_require__(61);\n\tvar defineProps = Object.defineProperties;\n\tvar chalk = module.exports;\n\t\n\tfunction build(_styles) {\n\t\tvar builder = function builder() {\n\t\t\treturn applyStyle.apply(builder, arguments);\n\t\t};\n\t\tbuilder._styles = _styles;\n\t\t// __proto__ is used because we must return a function, but there is\n\t\t// no way to create a function with a different prototype.\n\t\tbuilder.__proto__ = proto;\n\t\treturn builder;\n\t}\n\t\n\tvar styles = (function () {\n\t\tvar ret = {};\n\t\n\t\tansiStyles.grey = ansiStyles.gray;\n\t\n\t\tObject.keys(ansiStyles).forEach(function (key) {\n\t\t\tansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');\n\t\n\t\t\tret[key] = {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn build(this._styles.concat(key));\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t\n\t\treturn ret;\n\t})();\n\t\n\tvar proto = defineProps(function chalk() {}, styles);\n\t\n\tfunction applyStyle() {\n\t\t// support varags, but simply cast to string in case there's only one arg\n\t\tvar args = arguments;\n\t\tvar argsLen = args.length;\n\t\tvar str = argsLen !== 0 && String(arguments[0]);\n\t\tif (argsLen > 1) {\n\t\t\t// don't slice `arguments`, it prevents v8 optimizations\n\t\t\tfor (var a = 1; a < argsLen; a++) {\n\t\t\t\tstr += ' ' + args[a];\n\t\t\t}\n\t\t}\n\t\n\t\tif (!chalk.enabled || !str) {\n\t\t\treturn str;\n\t\t}\n\t\n\t\t/*jshint validthis: true*/\n\t\tvar nestedStyles = this._styles;\n\t\n\t\tfor (var i = 0; i < nestedStyles.length; i++) {\n\t\t\tvar code = ansiStyles[nestedStyles[i]];\n\t\t\t// Replace any instances already present with a re-opening code\n\t\t\t// otherwise only the part of the string until said closing code\n\t\t\t// will be colored, and the rest will simply be 'plain'.\n\t\t\tstr = code.open + str.replace(code.closeRe, code.open) + code.close;\n\t\t}\n\t\n\t\treturn str;\n\t}\n\t\n\tfunction init() {\n\t\tvar ret = {};\n\t\n\t\tObject.keys(styles).forEach(function (name) {\n\t\t\tret[name] = {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn build([name]);\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t\n\t\treturn ret;\n\t}\n\t\n\tdefineProps(chalk, init());\n\t\n\tchalk.styles = ansiStyles;\n\tchalk.hasColor = hasAnsi;\n\tchalk.stripColor = stripAnsi;\n\tchalk.supportsColor = supportsColor;\n\t\n\t// detect mode if not set manually\n\tif (chalk.enabled === undefined) {\n\t\tchalk.enabled = chalk.supportsColor;\n\t}\n\n\n/***/ },\n/* 56 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\t\n\tmodule.exports = function (str) {\n\t\tif (typeof str !== 'string') {\n\t\t\tthrow new TypeError('Expected a string');\n\t\t}\n\t\n\t\treturn str.replace(matchOperatorsRe, '\\\\$&');\n\t};\n\n\n/***/ },\n/* 57 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\tvar styles = module.exports;\n\t\n\tvar codes = {\n\t\treset: [0, 0],\n\t\n\t\tbold: [1, 22], // 21 isn't widely supported and 22 does the same thing\n\t\tdim: [2, 22],\n\t\titalic: [3, 23],\n\t\tunderline: [4, 24],\n\t\tinverse: [7, 27],\n\t\thidden: [8, 28],\n\t\tstrikethrough: [9, 29],\n\t\n\t\tblack: [30, 39],\n\t\tred: [31, 39],\n\t\tgreen: [32, 39],\n\t\tyellow: [33, 39],\n\t\tblue: [34, 39],\n\t\tmagenta: [35, 39],\n\t\tcyan: [36, 39],\n\t\twhite: [37, 39],\n\t\tgray: [90, 39],\n\t\n\t\tbgBlack: [40, 49],\n\t\tbgRed: [41, 49],\n\t\tbgGreen: [42, 49],\n\t\tbgYellow: [43, 49],\n\t\tbgBlue: [44, 49],\n\t\tbgMagenta: [45, 49],\n\t\tbgCyan: [46, 49],\n\t\tbgWhite: [47, 49]\n\t};\n\t\n\tObject.keys(codes).forEach(function (key) {\n\t\tvar val = codes[key];\n\t\tvar style = styles[key] = {};\n\t\tstyle.open = '\\u001b[' + val[0] + 'm';\n\t\tstyle.close = '\\u001b[' + val[1] + 'm';\n\t});\n\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar ansiRegex = __webpack_require__(59)();\n\t\n\tmodule.exports = function (str) {\n\t\treturn typeof str === 'string' ? str.replace(ansiRegex, '') : str;\n\t};\n\n\n/***/ },\n/* 59 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\tmodule.exports = function () {\n\t\treturn /\\u001b\\[(?:[0-9]{1,3}(?:;[0-9]{1,3})*)?[m|K]/g;\n\t};\n\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar ansiRegex = __webpack_require__(59);\n\tvar re = new RegExp(ansiRegex().source); // remove the `g` flag\n\tmodule.exports = re.test.bind(re);\n\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\tmodule.exports = (function () {\n\t\tif (process.argv.indexOf('--no-color') !== -1) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tif (process.argv.indexOf('--color') !== -1) {\n\t\t\treturn true;\n\t\t}\n\t\n\t\tif (process.stdout && !process.stdout.isTTY) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tif (process.platform === 'win32') {\n\t\t\treturn true;\n\t\t}\n\t\n\t\tif ('COLORTERM' in process.env) {\n\t\t\treturn true;\n\t\t}\n\t\n\t\tif (process.env.TERM === 'dumb') {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tif (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {\n\t\t\treturn true;\n\t\t}\n\t\n\t\treturn false;\n\t})();\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 62 */\n/***/ function(module, exports) {\n\n\tvar isArray = (typeof Array.isArray === 'function') ?\n\t  // use native function\n\t  Array.isArray :\n\t  // use instanceof operator\n\t  function(a) {\n\t    return a instanceof Array;\n\t  };\n\t\n\tvar getObjectKeys = typeof Object.keys === 'function' ?\n\t  function(obj) {\n\t    return Object.keys(obj);\n\t  } : function(obj) {\n\t    var names = [];\n\t    for (var property in obj) {\n\t      if (Object.prototype.hasOwnProperty.call(obj, property)) {\n\t        names.push(property);\n\t      }\n\t    }\n\t    return names;\n\t  };\n\t\n\tvar trimUnderscore = function(str) {\n\t  if (str.substr(0, 1) === '_') {\n\t    return str.slice(1);\n\t  }\n\t  return str;\n\t};\n\t\n\tvar arrayKeyToSortNumber = function(key) {\n\t  if (key === '_t') {\n\t    return -1;\n\t  } else {\n\t    if (key.substr(0, 1) === '_') {\n\t      return parseInt(key.slice(1), 10);\n\t    } else {\n\t      return parseInt(key, 10) + 0.1;\n\t    }\n\t  }\n\t};\n\t\n\tvar arrayKeyComparer = function(key1, key2) {\n\t  return arrayKeyToSortNumber(key1) - arrayKeyToSortNumber(key2);\n\t};\n\t\n\tvar BaseFormatter = function BaseFormatter() {};\n\t\n\tBaseFormatter.prototype.format = function(delta, left) {\n\t  var context = {};\n\t  this.prepareContext(context);\n\t  this.recurse(context, delta, left);\n\t  return this.finalize(context);\n\t};\n\t\n\tBaseFormatter.prototype.prepareContext = function(context) {\n\t  context.buffer = [];\n\t  context.out = function() {\n\t    this.buffer.push.apply(this.buffer, arguments);\n\t  };\n\t};\n\t\n\tBaseFormatter.prototype.typeFormattterNotFound = function(context, deltaType) {\n\t  throw new Error('cannot format delta type: ' + deltaType);\n\t};\n\t\n\tBaseFormatter.prototype.typeFormattterErrorFormatter = function(context, err) {\n\t  return err.toString();\n\t};\n\t\n\tBaseFormatter.prototype.finalize = function(context) {\n\t  if (isArray(context.buffer)) {\n\t    return context.buffer.join('');\n\t  }\n\t};\n\t\n\tBaseFormatter.prototype.recurse = function(context, delta, left, key, leftKey, movedFrom, isLast) {\n\t\n\t  var useMoveOriginHere = delta && movedFrom;\n\t  var leftValue = useMoveOriginHere ? movedFrom.value : left;\n\t\n\t  if (typeof delta === 'undefined' && typeof key === 'undefined') {\n\t    return undefined;\n\t  }\n\t\n\t  var type = this.getDeltaType(delta, movedFrom);\n\t  var nodeType = type === 'node' ? (delta._t === 'a' ? 'array' : 'object') : '';\n\t\n\t  if (typeof key !== 'undefined') {\n\t    this.nodeBegin(context, key, leftKey, type, nodeType, isLast);\n\t  } else {\n\t    this.rootBegin(context, type, nodeType);\n\t  }\n\t\n\t  var typeFormattter;\n\t  try {\n\t    typeFormattter = this['format_' + type] || this.typeFormattterNotFound(context, type);\n\t    typeFormattter.call(this, context, delta, leftValue, key, leftKey, movedFrom);\n\t  } catch (err) {\n\t    this.typeFormattterErrorFormatter(context, err, delta, leftValue, key, leftKey, movedFrom);\n\t    if (typeof console !== 'undefined' && console.error) {\n\t      console.error(err.stack);\n\t    }\n\t  }\n\t\n\t  if (typeof key !== 'undefined') {\n\t    this.nodeEnd(context, key, leftKey, type, nodeType, isLast);\n\t  } else {\n\t    this.rootEnd(context, type, nodeType);\n\t  }\n\t};\n\t\n\tBaseFormatter.prototype.formatDeltaChildren = function(context, delta, left) {\n\t  var self = this;\n\t  this.forEachDeltaKey(delta, left, function(key, leftKey, movedFrom, isLast) {\n\t    self.recurse(context, delta[key], left ? left[leftKey] : undefined,\n\t      key, leftKey, movedFrom, isLast);\n\t  });\n\t};\n\t\n\tBaseFormatter.prototype.forEachDeltaKey = function(delta, left, fn) {\n\t  var keys = getObjectKeys(delta);\n\t  var arrayKeys = delta._t === 'a';\n\t  var moveDestinations = {};\n\t  var name;\n\t  if (typeof left !== 'undefined') {\n\t    for (name in left) {\n\t      if (Object.prototype.hasOwnProperty.call(left, name)) {\n\t        if (typeof delta[name] === 'undefined' &&\n\t          ((!arrayKeys) || typeof delta['_' + name] === 'undefined')) {\n\t          keys.push(name);\n\t        }\n\t      }\n\t    }\n\t  }\n\t  // look for move destinations\n\t  for (name in delta) {\n\t    if (Object.prototype.hasOwnProperty.call(delta, name)) {\n\t      var value = delta[name];\n\t      if (isArray(value) && value[2] === 3) {\n\t        moveDestinations[value[1].toString()] = {\n\t          key: name,\n\t          value: left && left[parseInt(name.substr(1))]\n\t        };\n\t        if (this.includeMoveDestinations !== false) {\n\t          if ((typeof left === 'undefined') &&\n\t            (typeof delta[value[1]] === 'undefined')) {\n\t            keys.push(value[1].toString());\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\t  if (arrayKeys) {\n\t    keys.sort(arrayKeyComparer);\n\t  } else {\n\t    keys.sort();\n\t  }\n\t  for (var index = 0, length = keys.length; index < length; index++) {\n\t    var key = keys[index];\n\t    if (arrayKeys && key === '_t') {\n\t      continue;\n\t    }\n\t    var leftKey = arrayKeys ?\n\t      (typeof key === 'number' ? key : parseInt(trimUnderscore(key), 10)) :\n\t      key;\n\t    var isLast = (index === length - 1);\n\t    fn(key, leftKey, moveDestinations[leftKey], isLast);\n\t  }\n\t};\n\t\n\tBaseFormatter.prototype.getDeltaType = function(delta, movedFrom) {\n\t  if (typeof delta === 'undefined') {\n\t    if (typeof movedFrom !== 'undefined') {\n\t      return 'movedestination';\n\t    }\n\t    return 'unchanged';\n\t  }\n\t  if (isArray(delta)) {\n\t    if (delta.length === 1) {\n\t      return 'added';\n\t    }\n\t    if (delta.length === 2) {\n\t      return 'modified';\n\t    }\n\t    if (delta.length === 3 && delta[2] === 0) {\n\t      return 'deleted';\n\t    }\n\t    if (delta.length === 3 && delta[2] === 2) {\n\t      return 'textdiff';\n\t    }\n\t    if (delta.length === 3 && delta[2] === 3) {\n\t      return 'moved';\n\t    }\n\t  } else if (typeof delta === 'object') {\n\t    return 'node';\n\t  }\n\t  return 'unknown';\n\t};\n\t\n\tBaseFormatter.prototype.parseTextDiff = function(value) {\n\t  var output = [];\n\t  var lines = value.split('\\n@@ ');\n\t  for (var i = 0, l = lines.length; i < l; i++) {\n\t    var line = lines[i];\n\t    var lineOutput = {\n\t      pieces: []\n\t    };\n\t    var location = /^(?:@@ )?[-+]?(\\d+),(\\d+)/.exec(line).slice(1);\n\t    lineOutput.location = {\n\t      line: location[0],\n\t      chr: location[1]\n\t    };\n\t    var pieces = line.split('\\n').slice(1);\n\t    for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {\n\t      var piece = pieces[pieceIndex];\n\t      if (!piece.length) {\n\t        continue;\n\t      }\n\t      var pieceOutput = {\n\t        type: 'context'\n\t      };\n\t      if (piece.substr(0, 1) === '+') {\n\t        pieceOutput.type = 'added';\n\t      } else if (piece.substr(0, 1) === '-') {\n\t        pieceOutput.type = 'deleted';\n\t      }\n\t      pieceOutput.text = piece.slice(1);\n\t      lineOutput.pieces.push(pieceOutput);\n\t    }\n\t    output.push(lineOutput);\n\t  }\n\t  return output;\n\t};\n\t\n\texports.BaseFormatter = BaseFormatter;\n\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar environment = __webpack_require__(37);\n\t\n\texports.base = __webpack_require__(62);\n\texports.html = __webpack_require__(64);\n\texports.annotated = __webpack_require__(65);\n\texports.jsonpatch = __webpack_require__(66);\n\t\n\tif (!environment.isBrowser) {\n\t  var consoleModuleName = './console';\n\t  exports.console = __webpack_require__(52)(consoleModuleName);\n\t}\n\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar base = __webpack_require__(62);\n\tvar BaseFormatter = base.BaseFormatter;\n\t\n\tvar HtmlFormatter = function HtmlFormatter() {};\n\t\n\tHtmlFormatter.prototype = new BaseFormatter();\n\t\n\tfunction htmlEscape(text) {\n\t  var html = text;\n\t  var replacements = [\n\t    [/&/g, '&amp;'],\n\t    [/</g, '&lt;'],\n\t    [/>/g, '&gt;'],\n\t    [/'/g, '&apos;'],\n\t    [/\"/g, '&quot;']\n\t  ];\n\t  for (var i = 0; i < replacements.length; i++) {\n\t    html = html.replace(replacements[i][0], replacements[i][1]);\n\t  }\n\t  return html;\n\t}\n\t\n\tHtmlFormatter.prototype.typeFormattterErrorFormatter = function(context, err) {\n\t  context.out('<pre class=\"jsondiffpatch-error\">' + err + '</pre>');\n\t};\n\t\n\tHtmlFormatter.prototype.formatValue = function(context, value) {\n\t  context.out('<pre>' + htmlEscape(JSON.stringify(value, null, 2)) + '</pre>');\n\t};\n\t\n\tHtmlFormatter.prototype.formatTextDiffString = function(context, value) {\n\t  var lines = this.parseTextDiff(value);\n\t  context.out('<ul class=\"jsondiffpatch-textdiff\">');\n\t  for (var i = 0, l = lines.length; i < l; i++) {\n\t    var line = lines[i];\n\t    context.out('<li>' +\n\t      '<div class=\"jsondiffpatch-textdiff-location\">' +\n\t      '<span class=\"jsondiffpatch-textdiff-line-number\">' +\n\t      line.location.line +\n\t      '</span>' +\n\t      '<span class=\"jsondiffpatch-textdiff-char\">' +\n\t      line.location.chr +\n\t      '</span>' +\n\t      '</div>' +\n\t      '<div class=\"jsondiffpatch-textdiff-line\">');\n\t    var pieces = line.pieces;\n\t    for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {\n\t      /* global unescape */\n\t      var piece = pieces[pieceIndex];\n\t      context.out('<span class=\"jsondiffpatch-textdiff-' + piece.type + '\">' +\n\t        htmlEscape(unescape(piece.text)) + '</span>');\n\t    }\n\t    context.out('</div></li>');\n\t  }\n\t  context.out('</ul>');\n\t};\n\t\n\tvar adjustArrows = function jsondiffpatchHtmlFormatterAdjustArrows(node) {\n\t  node = node || document;\n\t  var getElementText = function(el) {\n\t    return el.textContent || el.innerText;\n\t  };\n\t  var eachByQuery = function(el, query, fn) {\n\t    var elems = el.querySelectorAll(query);\n\t    for (var i = 0, l = elems.length; i < l; i++) {\n\t      fn(elems[i]);\n\t    }\n\t  };\n\t  var eachChildren = function(el, fn) {\n\t    for (var i = 0, l = el.children.length; i < l; i++) {\n\t      fn(el.children[i], i);\n\t    }\n\t  };\n\t  eachByQuery(node, '.jsondiffpatch-arrow', function(arrow) {\n\t    var arrowParent = arrow.parentNode;\n\t    var svg = arrow.children[0],\n\t      path = svg.children[1];\n\t    svg.style.display = 'none';\n\t    var destination = getElementText(arrowParent.querySelector('.jsondiffpatch-moved-destination'));\n\t    var container = arrowParent.parentNode;\n\t    var destinationElem;\n\t    eachChildren(container, function(child) {\n\t      if (child.getAttribute('data-key') === destination) {\n\t        destinationElem = child;\n\t      }\n\t    });\n\t    if (!destinationElem) {\n\t      return;\n\t    }\n\t    try {\n\t      var distance = destinationElem.offsetTop - arrowParent.offsetTop;\n\t      svg.setAttribute('height', Math.abs(distance) + 6);\n\t      arrow.style.top = (-8 + (distance > 0 ? 0 : distance)) + 'px';\n\t      var curve = distance > 0 ?\n\t        'M30,0 Q-10,' + Math.round(distance / 2) + ' 26,' + (distance - 4) :\n\t        'M30,' + (-distance) + ' Q-10,' + Math.round(-distance / 2) + ' 26,4';\n\t      path.setAttribute('d', curve);\n\t      svg.style.display = '';\n\t    } catch (err) {\n\t      return;\n\t    }\n\t  });\n\t};\n\t\n\tHtmlFormatter.prototype.rootBegin = function(context, type, nodeType) {\n\t  var nodeClass = 'jsondiffpatch-' + type +\n\t    (nodeType ? ' jsondiffpatch-child-node-type-' + nodeType : '');\n\t  context.out('<div class=\"jsondiffpatch-delta ' + nodeClass + '\">');\n\t};\n\t\n\tHtmlFormatter.prototype.rootEnd = function(context) {\n\t  context.out('</div>' + (context.hasArrows ?\n\t    ('<script type=\"text/javascript\">setTimeout(' +\n\t      adjustArrows.toString() +\n\t      ',10);</script>') : ''));\n\t};\n\t\n\tHtmlFormatter.prototype.nodeBegin = function(context, key, leftKey, type, nodeType) {\n\t  var nodeClass = 'jsondiffpatch-' + type +\n\t    (nodeType ? ' jsondiffpatch-child-node-type-' + nodeType : '');\n\t  context.out('<li class=\"' + nodeClass + '\" data-key=\"' + leftKey + '\">' +\n\t    '<div class=\"jsondiffpatch-property-name\">' + leftKey + '</div>');\n\t};\n\t\n\t\n\tHtmlFormatter.prototype.nodeEnd = function(context) {\n\t  context.out('</li>');\n\t};\n\t\n\t/* jshint camelcase: false */\n\t\n\tHtmlFormatter.prototype.format_unchanged = function(context, delta, left) {\n\t  if (typeof left === 'undefined') {\n\t    return;\n\t  }\n\t  context.out('<div class=\"jsondiffpatch-value\">');\n\t  this.formatValue(context, left);\n\t  context.out('</div>');\n\t};\n\t\n\tHtmlFormatter.prototype.format_movedestination = function(context, delta, left) {\n\t  if (typeof left === 'undefined') {\n\t    return;\n\t  }\n\t  context.out('<div class=\"jsondiffpatch-value\">');\n\t  this.formatValue(context, left);\n\t  context.out('</div>');\n\t};\n\t\n\tHtmlFormatter.prototype.format_node = function(context, delta, left) {\n\t  // recurse\n\t  var nodeType = (delta._t === 'a') ? 'array' : 'object';\n\t  context.out('<ul class=\"jsondiffpatch-node jsondiffpatch-node-type-' + nodeType + '\">');\n\t  this.formatDeltaChildren(context, delta, left);\n\t  context.out('</ul>');\n\t};\n\t\n\tHtmlFormatter.prototype.format_added = function(context, delta) {\n\t  context.out('<div class=\"jsondiffpatch-value\">');\n\t  this.formatValue(context, delta[0]);\n\t  context.out('</div>');\n\t};\n\t\n\tHtmlFormatter.prototype.format_modified = function(context, delta) {\n\t  context.out('<div class=\"jsondiffpatch-value jsondiffpatch-left-value\">');\n\t  this.formatValue(context, delta[0]);\n\t  context.out('</div>' +\n\t    '<div class=\"jsondiffpatch-value jsondiffpatch-right-value\">');\n\t  this.formatValue(context, delta[1]);\n\t  context.out('</div>');\n\t};\n\t\n\tHtmlFormatter.prototype.format_deleted = function(context, delta) {\n\t  context.out('<div class=\"jsondiffpatch-value\">');\n\t  this.formatValue(context, delta[0]);\n\t  context.out('</div>');\n\t};\n\t\n\tHtmlFormatter.prototype.format_moved = function(context, delta) {\n\t  context.out('<div class=\"jsondiffpatch-value\">');\n\t  this.formatValue(context, delta[0]);\n\t  context.out('</div><div class=\"jsondiffpatch-moved-destination\">' + delta[1] + '</div>');\n\t\n\t  // draw an SVG arrow from here to move destination\n\t  context.out(\n\t    /*jshint multistr: true */\n\t    '<div class=\"jsondiffpatch-arrow\" style=\"position: relative; left: -34px;\">\\\n\t        <svg width=\"30\" height=\"60\" style=\"position: absolute; display: none;\">\\\n\t        <defs>\\\n\t            <marker id=\"markerArrow\" markerWidth=\"8\" markerHeight=\"8\" refx=\"2\" refy=\"4\"\\\n\t                   orient=\"auto\" markerUnits=\"userSpaceOnUse\">\\\n\t                <path d=\"M1,1 L1,7 L7,4 L1,1\" style=\"fill: #339;\" />\\\n\t            </marker>\\\n\t        </defs>\\\n\t        <path d=\"M30,0 Q-10,25 26,50\" style=\"stroke: #88f; stroke-width: 2px; fill: none;\\\n\t        stroke-opacity: 0.5; marker-end: url(#markerArrow);\"></path>\\\n\t        </svg>\\\n\t        </div>');\n\t  context.hasArrows = true;\n\t};\n\t\n\tHtmlFormatter.prototype.format_textdiff = function(context, delta) {\n\t  context.out('<div class=\"jsondiffpatch-value\">');\n\t  this.formatTextDiffString(context, delta[0]);\n\t  context.out('</div>');\n\t};\n\t\n\t/* jshint camelcase: true */\n\t\n\tvar showUnchanged = function(show, node, delay) {\n\t  var el = node || document.body;\n\t  var prefix = 'jsondiffpatch-unchanged-';\n\t  var classes = {\n\t    showing: prefix + 'showing',\n\t    hiding: prefix + 'hiding',\n\t    visible: prefix + 'visible',\n\t    hidden: prefix + 'hidden',\n\t  };\n\t  var list = el.classList;\n\t  if (!list) {\n\t    return;\n\t  }\n\t  if (!delay) {\n\t    list.remove(classes.showing);\n\t    list.remove(classes.hiding);\n\t    list.remove(classes.visible);\n\t    list.remove(classes.hidden);\n\t    if (show === false) {\n\t      list.add(classes.hidden);\n\t    }\n\t    return;\n\t  }\n\t  if (show === false) {\n\t    list.remove(classes.showing);\n\t    list.add(classes.visible);\n\t    setTimeout(function() {\n\t      list.add(classes.hiding);\n\t    }, 10);\n\t  } else {\n\t    list.remove(classes.hiding);\n\t    list.add(classes.showing);\n\t    list.remove(classes.hidden);\n\t  }\n\t  var intervalId = setInterval(function() {\n\t    adjustArrows(el);\n\t  }, 100);\n\t  setTimeout(function() {\n\t    list.remove(classes.showing);\n\t    list.remove(classes.hiding);\n\t    if (show === false) {\n\t      list.add(classes.hidden);\n\t      list.remove(classes.visible);\n\t    } else {\n\t      list.add(classes.visible);\n\t      list.remove(classes.hidden);\n\t    }\n\t    setTimeout(function() {\n\t      list.remove(classes.visible);\n\t      clearInterval(intervalId);\n\t    }, delay + 400);\n\t  }, delay);\n\t};\n\t\n\tvar hideUnchanged = function(node, delay) {\n\t  return showUnchanged(false, node, delay);\n\t};\n\t\n\texports.HtmlFormatter = HtmlFormatter;\n\t\n\texports.showUnchanged = showUnchanged;\n\t\n\texports.hideUnchanged = hideUnchanged;\n\t\n\tvar defaultInstance;\n\t\n\texports.format = function(delta, left) {\n\t  if (!defaultInstance) {\n\t    defaultInstance = new HtmlFormatter();\n\t  }\n\t  return defaultInstance.format(delta, left);\n\t};\n\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar base = __webpack_require__(62);\n\tvar BaseFormatter = base.BaseFormatter;\n\t\n\tvar AnnotatedFormatter = function AnnotatedFormatter() {\n\t  this.includeMoveDestinations = false;\n\t};\n\t\n\tAnnotatedFormatter.prototype = new BaseFormatter();\n\t\n\tAnnotatedFormatter.prototype.prepareContext = function(context) {\n\t  BaseFormatter.prototype.prepareContext.call(this, context);\n\t  context.indent = function(levels) {\n\t    this.indentLevel = (this.indentLevel || 0) +\n\t      (typeof levels === 'undefined' ? 1 : levels);\n\t    this.indentPad = new Array(this.indentLevel + 1).join('&nbsp;&nbsp;');\n\t  };\n\t  context.row = function(json, htmlNote) {\n\t    context.out('<tr><td style=\"white-space: nowrap;\">' +\n\t      '<pre class=\"jsondiffpatch-annotated-indent\" style=\"display: inline-block\">');\n\t    context.out(context.indentPad);\n\t    context.out('</pre><pre style=\"display: inline-block\">');\n\t    context.out(json);\n\t    context.out('</pre></td><td class=\"jsondiffpatch-delta-note\"><div>');\n\t    context.out(htmlNote);\n\t    context.out('</div></td></tr>');\n\t  };\n\t};\n\t\n\tAnnotatedFormatter.prototype.typeFormattterErrorFormatter = function(context, err) {\n\t  context.row('', '<pre class=\"jsondiffpatch-error\">' + err + '</pre>');\n\t};\n\t\n\tAnnotatedFormatter.prototype.formatTextDiffString = function(context, value) {\n\t  var lines = this.parseTextDiff(value);\n\t  context.out('<ul class=\"jsondiffpatch-textdiff\">');\n\t  for (var i = 0, l = lines.length; i < l; i++) {\n\t    var line = lines[i];\n\t    context.out('<li>' +\n\t      '<div class=\"jsondiffpatch-textdiff-location\">' +\n\t      '<span class=\"jsondiffpatch-textdiff-line-number\">' +\n\t      line.location.line +\n\t      '</span>' +\n\t      '<span class=\"jsondiffpatch-textdiff-char\">' +\n\t      line.location.chr +\n\t      '</span>' +\n\t      '</div>' +\n\t      '<div class=\"jsondiffpatch-textdiff-line\">');\n\t    var pieces = line.pieces;\n\t    for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {\n\t      var piece = pieces[pieceIndex];\n\t      context.out('<span class=\"jsondiffpatch-textdiff-' + piece.type + '\">' +\n\t        piece.text + '</span>');\n\t    }\n\t    context.out('</div></li>');\n\t  }\n\t  context.out('</ul>');\n\t};\n\t\n\tAnnotatedFormatter.prototype.rootBegin = function(context, type, nodeType) {\n\t  context.out('<table class=\"jsondiffpatch-annotated-delta\">');\n\t  if (type === 'node') {\n\t    context.row('{');\n\t    context.indent();\n\t  }\n\t  if (nodeType === 'array') {\n\t    context.row('\"_t\": \"a\",', 'Array delta (member names indicate array indices)');\n\t  }\n\t};\n\t\n\tAnnotatedFormatter.prototype.rootEnd = function(context, type) {\n\t  if (type === 'node') {\n\t    context.indent(-1);\n\t    context.row('}');\n\t  }\n\t  context.out('</table>');\n\t};\n\t\n\tAnnotatedFormatter.prototype.nodeBegin = function(context, key, leftKey, type, nodeType) {\n\t  context.row('&quot;' + key + '&quot;: {');\n\t  if (type === 'node') {\n\t    context.indent();\n\t  }\n\t  if (nodeType === 'array') {\n\t    context.row('\"_t\": \"a\",', 'Array delta (member names indicate array indices)');\n\t  }\n\t};\n\t\n\tAnnotatedFormatter.prototype.nodeEnd = function(context, key, leftKey, type, nodeType, isLast) {\n\t  if (type === 'node') {\n\t    context.indent(-1);\n\t  }\n\t  context.row('}' + (isLast ? '' : ','));\n\t};\n\t\n\t/* jshint camelcase: false */\n\t\n\tAnnotatedFormatter.prototype.format_unchanged = function() {\n\t  return;\n\t};\n\t\n\tAnnotatedFormatter.prototype.format_movedestination = function() {\n\t  return;\n\t};\n\t\n\t\n\tAnnotatedFormatter.prototype.format_node = function(context, delta, left) {\n\t  // recurse\n\t  this.formatDeltaChildren(context, delta, left);\n\t};\n\t\n\tvar wrapPropertyName = function(name) {\n\t  return '<pre style=\"display:inline-block\">&quot;' + name + '&quot;</pre>';\n\t};\n\t\n\tvar deltaAnnotations = {\n\t  added: function(delta, left, key, leftKey) {\n\t    var formatLegend = ' <pre>([newValue])</pre>';\n\t    if (typeof leftKey === 'undefined') {\n\t      return 'new value' + formatLegend;\n\t    }\n\t    if (typeof leftKey === 'number') {\n\t      return 'insert at index ' + leftKey + formatLegend;\n\t    }\n\t    return 'add property ' + wrapPropertyName(leftKey) + formatLegend;\n\t  },\n\t  modified: function(delta, left, key, leftKey) {\n\t    var formatLegend = ' <pre>([previousValue, newValue])</pre>';\n\t    if (typeof leftKey === 'undefined') {\n\t      return 'modify value' + formatLegend;\n\t    }\n\t    if (typeof leftKey === 'number') {\n\t      return 'modify at index ' + leftKey + formatLegend;\n\t    }\n\t    return 'modify property ' + wrapPropertyName(leftKey) + formatLegend;\n\t  },\n\t  deleted: function(delta, left, key, leftKey) {\n\t    var formatLegend = ' <pre>([previousValue, 0, 0])</pre>';\n\t    if (typeof leftKey === 'undefined') {\n\t      return 'delete value' + formatLegend;\n\t    }\n\t    if (typeof leftKey === 'number') {\n\t      return 'remove index ' + leftKey + formatLegend;\n\t    }\n\t    return 'delete property ' + wrapPropertyName(leftKey) + formatLegend;\n\t  },\n\t  moved: function(delta, left, key, leftKey) {\n\t    return 'move from <span title=\"(position to remove at original state)\">index ' +\n\t      leftKey + '</span> to ' +\n\t      '<span title=\"(position to insert at final state)\">index ' +\n\t      delta[1] + '</span>';\n\t  },\n\t  textdiff: function(delta, left, key, leftKey) {\n\t    var location = (typeof leftKey === 'undefined') ?\n\t      '' : (\n\t        (typeof leftKey === 'number') ?\n\t        ' at index ' + leftKey :\n\t        ' at property ' + wrapPropertyName(leftKey)\n\t      );\n\t    return 'text diff' + location + ', format is ' +\n\t      '<a href=\"https://code.google.com/p/google-diff-match-patch/wiki/Unidiff\">' +\n\t      'a variation of Unidiff</a>';\n\t  }\n\t};\n\t\n\tvar formatAnyChange = function(context, delta) {\n\t  var deltaType = this.getDeltaType(delta);\n\t  var annotator = deltaAnnotations[deltaType];\n\t  var htmlNote = annotator && annotator.apply(annotator,\n\t    Array.prototype.slice.call(arguments, 1));\n\t  var json = JSON.stringify(delta, null, 2);\n\t  if (deltaType === 'textdiff') {\n\t    // split text diffs lines\n\t    json = json.split('\\\\n').join('\\\\n\"+\\n   \"');\n\t  }\n\t  context.indent();\n\t  context.row(json, htmlNote);\n\t  context.indent(-1);\n\t};\n\t\n\tAnnotatedFormatter.prototype.format_added = formatAnyChange;\n\tAnnotatedFormatter.prototype.format_modified = formatAnyChange;\n\tAnnotatedFormatter.prototype.format_deleted = formatAnyChange;\n\tAnnotatedFormatter.prototype.format_moved = formatAnyChange;\n\tAnnotatedFormatter.prototype.format_textdiff = formatAnyChange;\n\t\n\t/* jshint camelcase: true */\n\t\n\texports.AnnotatedFormatter = AnnotatedFormatter;\n\t\n\tvar defaultInstance;\n\t\n\texports.format = function(delta, left) {\n\t  if (!defaultInstance) {\n\t    defaultInstance = new AnnotatedFormatter();\n\t  }\n\t  return defaultInstance.format(delta, left);\n\t};\n\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function () {\n\t  var base = __webpack_require__(62);\n\t  var BaseFormatter = base.BaseFormatter;\n\t\n\t  var named = {\n\t    added: 'add',\n\t    deleted: 'remove',\n\t    modified: 'replace',\n\t    moved: 'moved',\n\t    movedestination: 'movedestination',\n\t    unchanged: 'unchanged',\n\t    error: 'error',\n\t    textDiffLine: 'textDiffLine'\n\t  };\n\t\n\t  function JSONFormatter() {\n\t    this.includeMoveDestinations = false;\n\t  }\n\t\n\t  JSONFormatter.prototype = new BaseFormatter();\n\t\n\t  JSONFormatter.prototype.prepareContext = function (context) {\n\t    BaseFormatter.prototype.prepareContext.call(this, context);\n\t    context.result = [];\n\t    context.path = [];\n\t    context.pushCurrentOp = function (op, value) {\n\t      var val = {\n\t        op: op,\n\t        path: this.currentPath()\n\t      };\n\t      if (typeof value !== 'undefined') {\n\t        val.value = value;\n\t      }\n\t      this.result.push(val);\n\t    };\n\t\n\t    context.currentPath = function () {\n\t      return '/' + this.path.join('/');\n\t    };\n\t  };\n\t\n\t  JSONFormatter.prototype.typeFormattterErrorFormatter = function (context, err) {\n\t    context.out('[ERROR]' + err);\n\t  };\n\t\n\t  JSONFormatter.prototype.rootBegin = function () {\n\t  };\n\t\n\t  JSONFormatter.prototype.rootEnd = function () {\n\t  };\n\t\n\t  JSONFormatter.prototype.nodeBegin = function (context, key, leftKey) {\n\t    context.path.push(leftKey);\n\t  };\n\t\n\t  JSONFormatter.prototype.nodeEnd = function (context) {\n\t    context.path.pop();\n\t  };\n\t\n\t  /* jshint camelcase: false */\n\t\n\t  JSONFormatter.prototype.format_unchanged = function (context, delta, left) {\n\t    if (typeof left === 'undefined') {\n\t      return;\n\t    }\n\t    context.pushCurrentOp(named.unchanged, left);\n\t  };\n\t\n\t  JSONFormatter.prototype.format_movedestination = function (context, delta, left) {\n\t    if (typeof left === 'undefined') {\n\t      return;\n\t    }\n\t    context.pushCurrentOp(named.movedestination, left);\n\t  };\n\t\n\t  JSONFormatter.prototype.format_node = function (context, delta, left) {\n\t    this.formatDeltaChildren(context, delta, left);\n\t  };\n\t\n\t  JSONFormatter.prototype.format_added = function (context, delta) {\n\t    context.pushCurrentOp(named.added, delta[0]);\n\t  };\n\t\n\t  JSONFormatter.prototype.format_modified = function (context, delta) {\n\t    context.pushCurrentOp(named.modified, delta[1]);\n\t  };\n\t\n\t  JSONFormatter.prototype.format_deleted = function (context) {\n\t    context.pushCurrentOp(named.deleted);\n\t  };\n\t\n\t  JSONFormatter.prototype.format_moved = function (context, delta) {\n\t    context.pushCurrentOp(named.moved, delta[1]);\n\t  };\n\t\n\t  JSONFormatter.prototype.format_textdiff = function () {\n\t    throw 'not implimented';\n\t  };\n\t\n\t  JSONFormatter.prototype.format = function (delta, left) {\n\t    var context = {};\n\t    this.prepareContext(context);\n\t    this.recurse(context, delta, left);\n\t    return context.result;\n\t  };\n\t  /* jshint camelcase: true */\n\t\n\t  exports.JSONFormatter = JSONFormatter;\n\t\n\t  var defaultInstance;\n\t\n\t  function last(arr) {\n\t    return arr[arr.length - 1];\n\t  }\n\t\n\t  function sortBy(arr, pred) {\n\t    arr.sort(pred);\n\t    return arr;\n\t  }\n\t\n\t  var compareByIndexDesc = function (indexA, indexB) {\n\t    var lastA = parseInt(indexA, 10);\n\t    var lastB = parseInt(indexB, 10);\n\t    if (!(isNaN(lastA) || isNaN(lastB))) {\n\t      return lastB - lastA;\n\t    } else {\n\t      return 0;\n\t    }\n\t  };\n\t\n\t  function opsByDescendingOrder(removeOps) {\n\t    return sortBy(removeOps, function (a, b) {\n\t      var splitA = a.path.split('/');\n\t      var splitB = b.path.split('/');\n\t      if (splitA.length !== splitB.length) {\n\t        return splitA.length - splitB.length;\n\t      } else {\n\t        return compareByIndexDesc(last(splitA), last(splitB));\n\t      }\n\t    });\n\t  }\n\t\n\t  function partition(arr, pred) {\n\t    var left = [];\n\t    var right = [];\n\t\n\t    arr.forEach(function (el) {\n\t      var coll = pred(el) ? left : right;\n\t      coll.push(el);\n\t    });\n\t    return [left, right];\n\t  }\n\t\n\t  function reorderOps(jsonFormattedDiff) {\n\t    var removeOpsOtherOps = partition(jsonFormattedDiff, function (operation) {\n\t      return operation.op === 'remove';\n\t    });\n\t    var removeOps = removeOpsOtherOps[0];\n\t    var otherOps = removeOpsOtherOps[1];\n\t\n\t    var removeOpsReverse = opsByDescendingOrder(removeOps);\n\t    return removeOpsReverse.concat(otherOps);\n\t  }\n\t\n\t\n\t  var format = function (delta, left) {\n\t    if (!defaultInstance) {\n\t      defaultInstance = new JSONFormatter();\n\t    }\n\t    return reorderOps(defaultInstance.format(delta, left));\n\t  };\n\t\n\t  exports.log = function (delta, left) {\n\t    console.log(format(delta, left));\n\t  };\n\t\n\t  exports.format = format;\n\t})();\n\n\n/***/ },\n/* 67 */\n/***/ function(module, exports) {\n\n\t// use as 2nd parameter for JSON.parse to revive Date instances\n\tmodule.exports = function dateReviver(key, value) {\n\t  var parts;\n\t  if (typeof value === 'string') {\n\t    parts = /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d*))?(Z|([+\\-])(\\d{2}):(\\d{2}))$/.exec(value);\n\t    if (parts) {\n\t      return new Date(Date.UTC(+parts[1], +parts[2] - 1, +parts[3], +parts[4], +parts[5], +parts[6], +(parts[7] || 0)));\n\t    }\n\t  }\n\t  return value;\n\t};\n\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _event = __webpack_require__(30);\n\t\n\tvar _event2 = _interopRequireDefault(_event);\n\t\n\tvar _api = __webpack_require__(19);\n\t\n\tvar _api2 = _interopRequireDefault(_api);\n\t\n\tvar _logger = __webpack_require__(27);\n\t\n\tvar _logger2 = _interopRequireDefault(_logger);\n\t\n\tvar _error = __webpack_require__(29);\n\t\n\tvar _error2 = _interopRequireDefault(_error);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * Use Channels to create, update and remove Telepat objects. You can create new Channels using the {@link #Telepat#subscribe subscribe}\n\t * or the {@link #Telepat#getChannel getChannel} methods of the main {@link Telepat} object.\n\t *\n\t * @class Channel\n\t *\n\t * @example\n\t * let articleChannel = telepat.subscribe({\n\t *  channel: {\n\t *    context: 'context-unique-identifier',\n\t *    model: 'article'\n\t *  }\n\t * }, () => {\n\t *  console.log(articleChannel.objectsArray);\n\t *\n\t *  // Create a new article object\n\t *  articleChannel.objects['new'] = {\n\t *    title: 'New article',\n\t *    text: 'Article body'\n\t *  };\n\t *\n\t *  // Update a specific article\n\t *  articleChannel.objects['article-unique-id'].title = 'New title';\n\t *\n\t *  // Delete a specific article\n\t *  delete articleChannel.objects['article-unique-id'];\n\t *\n\t *  // React to object updates\n\t *  articleChannel.on('update', (operationType, objectId, object, oldObject) => {\n\t *    console.log(`Received article update of type ${operationType}, for object with id ${objectId}`);\n\t *    // Objects are already updated\n\t *    console.log(articleChannel.objects);\n\t *  });\n\t *\n\t *  // Unsubscribe and clear objects\n\t *  articleChannel.unsubscribe();\n\t * });\n\t */\n\tvar Channel = function () {\n\t  function Channel(monitor, options) {\n\t    var addCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\n\t    var _this = this;\n\t\n\t    var updateCallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\t    var removeCallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\t\n\t    _classCallCheck(this, Channel);\n\t\n\t    this._event = new _event2.default(_logger2.default);\n\t    this._monitor = monitor;\n\t    this._options = options;\n\t    this._addCallback = addCallback;\n\t    this._updateCallback = updateCallback;\n\t    this._removeCallback = removeCallback;\n\t    this._subscribed = false;\n\t\n\t    /**\n\t     * A container object referencing all of the objects retrieved via subscription. Each object is stored on a key equal to its own unique id.\n\t     * @type {Object}\n\t     * @memberof Channel\n\t     * @instance\n\t     */\n\t    this.objects = {};\n\t    /**\n\t     * A container array referencing all of the objects retrieved via subscription. The order of the objects reflects the sorting options set for the channel.\n\t     * @type {Array<Object>}\n\t     * @memberof Channel\n\t     * @instance\n\t     */\n\t    this.objectsArray = [];\n\t    /**\n\t     * The current object count.\n\t     * @type {number|null}\n\t     * @memberof Channel\n\t     * @instance\n\t     */\n\t    this.objectsCount = null;\n\t\n\t    this._event.on('update', function (operation, parentId, parentObject, delta) {\n\t      if (operation === 'add') {\n\t        _this.objectsArray.push(parentObject);\n\t        _this._sortObjectArray();\n\t        if (_this.objectsCount) {\n\t          _this.objectsCount++;\n\t        }\n\t      } else if (operation === 'delete') {\n\t        _this.objectsArray = _this.objectsArray.filter(function (object) {\n\t          return object.id !== parentId;\n\t        });\n\t        _this._sortObjectArray();\n\t        if (_this.objectsCount) {\n\t          _this.objectsCount--;\n\t        }\n\t      }\n\t    });\n\t  }\n\t\n\t  _createClass(Channel, [{\n\t    key: '_sortObjectArray',\n\t    value: function _sortObjectArray() {\n\t      var _this2 = this;\n\t\n\t      if (this._options.sort) {\n\t        this.objectsArray.sort(function (a, b) {\n\t          var result = null;\n\t\n\t          Object.keys(_this2._options.sort).map(function (key) {\n\t            var order = _this2._options.sort[key];\n\t            var factor = order === 'asc' ? 1 : -1;\n\t\n\t            if (a[key] && !b[key]) {\n\t              result = factor;\n\t            }\n\t            if (!a[key] && b[key]) {\n\t              result = -factor;\n\t            }\n\t            if (a[key] && b[key]) {\n\t              if (a[key] < b[key]) {\n\t                result = -factor;\n\t              }\n\t              if (a[key] > b[key]) {\n\t                result = factor;\n\t              }\n\t            }\n\t          });\n\t\n\t          if (!result) {\n\t            return 0;\n\t          }\n\t          return result;\n\t        });\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Call this function to perform the actual subscribe for the configured channel. This is usually invoked by the\n\t     * {@link #Telepat#subscribe subscribe} method on the main {@link Telepat} object.\n\t     *\n\t     * @param {TelepatCallback} callback Callback invoked after subscribe is finished\n\t     */\n\t\n\t  }, {\n\t    key: 'subscribe',\n\t    value: function subscribe() {\n\t      var _this3 = this;\n\t\n\t      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n\t\n\t      _api2.default.call('object/subscribe', this._options, function (err, res) {\n\t        if (err) {\n\t          _this3._event.emit('error', (0, _error2.default)('Subscribe failed with error: ' + err));\n\t          callback(err, null);\n\t        } else {\n\t          var i = void 0;\n\t\n\t          _this3.objects = {};\n\t          _this3.objectsArray = [];\n\t          _this3.objectsCount = 0;\n\t\n\t          for (i = 0; i < res.body.content.length; i++) {\n\t            _this3.objects[res.body.content[i].id] = res.body.content[i];\n\t          }\n\t          _this3.objectsArray = res.body.content;\n\t          _this3._sortObjectArray();\n\t          var objectKeys = Object.keys(_this3.objects);\n\t\n\t          for (i = 0; i < objectKeys.length; i++) {\n\t            _this3.objects[objectKeys[i]].$$event = new _event2.default(_logger2.default);\n\t          }\n\t          _this3._monitor.add(_this3._options, _this3.objects, _this3._event, _this3._addCallback || _this3.add.bind(_this3), _this3._removeCallback || _this3.remove.bind(_this3), _this3._updateCallback || _this3.update.bind(_this3));\n\t\n\t          if (_this3._subscribed) {\n\t            _this3._event.emit('update', 'resync');\n\t          } else {\n\t            _this3._event.emit('subscribe');\n\t          }\n\t\n\t          _this3._subscribed = true;\n\t          callback(null, _this3);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Call this function to unsubscribe from the configured channel. All channel properties will be reset to original values.\n\t     *\n\t     * @param {TelepatCallback} callback Callback invoked after unsubscribe is finished\n\t     */\n\t\n\t  }, {\n\t    key: 'unsubscribe',\n\t    value: function unsubscribe() {\n\t      var _this4 = this;\n\t\n\t      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n\t\n\t      _api2.default.call('object/unsubscribe', this._options, function (err) {\n\t        if (err) {\n\t          _this4._event.emit('error', (0, _error2.default)('Unsubscribe failed with error: ' + err));\n\t          callback(err, null);\n\t        } else {\n\t          _this4.objects = {};\n\t          _this4.objectsArray = [];\n\t          _this4.objectsCount = null;\n\t          _this4._monitor.remove(_this4._options);\n\t          _this4._event.emit('unsubscribe');\n\t          _this4._event.emit('_unsubscribe');\n\t          _this4._subscribed = false;\n\t          callback(null, _this4);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Call this to retrieve the number of objects available for this channel. Value will be available on the {@link #ChannelobjectsCount objectsCount} property.\n\t     *\n\t     * @param  {TelepatCallback} callback Callback invoked after getting object count is finished\n\t     */\n\t\n\t  }, {\n\t    key: 'getCount',\n\t    value: function getCount() {\n\t      var _this5 = this;\n\t\n\t      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n\t\n\t      _api2.default.call('object/count', this._options, function (err, res) {\n\t        if (err) {\n\t          _this5._event.emit('error', (0, _error2.default)('Get object count failed with error: ' + err));\n\t          callback(err, null);\n\t        } else {\n\t          _this5.objectsCount = res.body.content.count;\n\t          callback(null, _this5.objectsCount);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Add a new Telepat object to the current channel.\n\t     * Instead of using this function, you can also add the object to {@link #Channelobjects Channel.objects}, on any new key.\n\t     * The key will be automatically replaced with the new object id after the backend processes the operation.\n\t     *\n\t     * @param {Object} object The new object to add\n\t     * @param {TelepatCallback} callback Callback invoked after notifying the Telepat backend of the new object\n\t     *\n\t     * @example\n\t     * // This is one way of adding a new object using the channel instance.\n\t     * // The new key will be picked up by the monitoring system, which will signal the new event creation\n\t     * //   to the Telepat backend, and then delete the new key you just set from the objects property.\n\t     * // After processing the request, Telepat will signal the change back to the client, and the new object will be\n\t     * //   re-added to the objects property, but this time on the right key (equal to the new object's assigned id).\n\t     * //   This is when the 'update' event will get triggered on the channel.\n\t     * channel.objects['new'] = newObject;\n\t     *\n\t     * // Alternatively, you can call the add method:\n\t     * channel.add(newObject, err => {\n\t     *  if (err) {\n\t     *    // There's been a server error, check err. The object will not be added.\n\t     *  } else {\n\t     *    // We've successfully signaled that we want to add the object.\n\t     *    // Keep in mind that this is not a sync process, so we still have to wait for the 'update'\n\t     *    //   event on the channel, signaling the availability of the new object on the channel.objects property.\n\t     *  }\n\t     * });\n\t     */\n\t\n\t  }, {\n\t    key: 'add',\n\t    value: function add(object) {\n\t      var _this6 = this;\n\t\n\t      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\t\n\t      _api2.default.call('object/create', {\n\t        model: this._options.channel.model,\n\t        context: this._options.channel.context || object.context_id,\n\t        content: object\n\t      }, function (err) {\n\t        if (err) {\n\t          _this6._event.emit('error', (0, _error2.default)('Adding object failed with error: ' + err));\n\t          callback(err, null);\n\t        } else {\n\t          callback(null, object);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Remove a Telepat object from the current channel.\n\t     * Instead of using this function, you can also delete the object from {@link #Channelobjects Channel.objects}.\n\t     *\n\t     * @param {string} id The id of the object to delete\n\t     * @param {TelepatCallback} callback Callback invoked after notifying the Telepat backend of the deleted object\n\t     *\n\t     * @example\n\t     * // This is one way of deleting an object using the channel instance.\n\t     * // The deleted key will be picked up by the monitoring system, which will signal the object removal\n\t     * //   to the Telepat backend. The change will be then signaled back to the client as confirmation, triggering\n\t     * //   the channel's 'update' event.\n\t     * // This is the optimistic way of doing a delete, as the removed object will be instantly gone from the local\n\t     * //   state, before the 'update' event is triggered (and even if it is not).\n\t     * delete channel.objects[objectId];\n\t     *\n\t     * // Alternatively, the pessimistic approach is to call the remove method:\n\t     * channel.remove(objectId, err => {\n\t     *  if (err) {\n\t     *    // There's been a server error, check err. The object will not be deleted.\n\t     *  } else {\n\t     *    // We've successfully signaled that we want to delete the object.\n\t     *    // Keep in mind that this is not a sync process, so we still have to wait for the 'update'\n\t     *    //   event on the channel, signaling that the object has been removed from the channel.objects property.\n\t     *  }\n\t     * });\n\t     */\n\t\n\t  }, {\n\t    key: 'remove',\n\t    value: function remove(id) {\n\t      var _this7 = this;\n\t\n\t      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\t\n\t      _api2.default.del('object/delete', {\n\t        model: this._options.channel.model,\n\t        context: this._options.channel.context || this.objects[id].context_id,\n\t        id: id\n\t      }, function (err) {\n\t        if (err) {\n\t          _this7._event.emit('error', (0, _error2.default)('Removing object failed with error: ' + err));\n\t          callback(err, null);\n\t        } else {\n\t          callback(null, id);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Updates a Telepat object from the current channel.\n\t     * To call this function, you need to create an  array containing 'patch' objects, representing the\n\t      modifications that need to be persisted. The structure of a patch object is:\n\t     *\n\t     * `{'op': 'replace', 'path': channel + '/' + object_id + '/' + object_property, 'value': modified_value}`\n\t     *\n\t     * Instead of using this function, you can also update the object directly from {@link #Channelobjects Channel.objects}.\n\t     *\n\t     * @param {number} id The id of the object to update\n\t     * @param {Array<Object>} patches The array of patches representing the modifications that need to be persisted.\n\t     * @param {TelepatCallback} callback Callback invoked after notifying the Telepat backend of the updated object\n\t     *\n\t     * @example\n\t     * // This is one way of updating an object using the channel instance.\n\t     * // The updated key will be picked up by the monitoring system, which will signal the object update\n\t     * //   to the Telepat backend. The change will be then signaled back to the client as confirmation, triggering\n\t     * //   the channel's 'update' event.\n\t     * // This is the optimistic way of doing a delete, as the updated object will be instantly modified within the local\n\t     * //   state, before the 'update' event is triggered (and even if it is not).\n\t     * channel.objects[objectId].title = \"New title\";\n\t     *\n\t     * // Alternatively, the pessimistic approach is to call the update method:\n\t     * channel.update(objectId, [\n\t     *  {\n\t     *    'op': 'replace',\n\t     *    'path': `article/${objectId}/title`,\n\t     *    'value': 'New title'\n\t     *  }\n\t     * ], err => {\n\t     *  if (err) {\n\t     *    // There's been a server error, check err. The object will not be updated.\n\t     *  } else {\n\t     *    // We've successfully signaled that we want to update the object.\n\t     *    // Keep in mind that this is not a sync process, so we still have to wait for the 'update'\n\t     *    //   event on the channel, signaling that the object has been updated within the channel.objects property.\n\t     *  }\n\t     * });\n\t     */\n\t\n\t  }, {\n\t    key: 'update',\n\t    value: function update(id, patches) {\n\t      var _this8 = this;\n\t\n\t      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n\t\n\t      _api2.default.call('object/update', {\n\t        model: this._options.channel.model,\n\t        context: this._options.channel.context || this.objects[id].context_id,\n\t        id: id,\n\t        patches: patches\n\t      }, function (err) {\n\t        if (err) {\n\t          _this8._event.emit('error', (0, _error2.default)('Updating object failed with error: ' + err));\n\t        } else {}\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Invoked when there was an error processing the requested operation.\n\t     *\n\t     * @event error\n\t     * @type {Error}\n\t     */\n\t    /**\n\t     * Invoked when channel subscription is successful.\n\t     *\n\t     * @event subscribe\n\t     */\n\t    /**\n\t     * Invoked when channel unsubscription is successful.\n\t     *\n\t     * @event unsubscribe\n\t     */\n\t    /**\n\t     * Invoked when objects in the subscription have been modified (there was an update of an existing object, a new object has been added or an object has been deleted).\n\t     * Also invoked when all objects in the subscription have been resync'd with the server. This can happen\n\t     * when the volatile transport is reconnected (after an offline period), or on manual re-calls of the `subscribe` method.\n\t     *\n\t     * @event update\n\t     * @param {string} eventType One of 'add', 'delete', 'replace', 'resync'\n\t     * @param {string} objectId The id of the affected object\n\t     * @param {Object} object The affected object itself\n\t     * @param {Object} oldObject Present only for the 'replace' eventType, the old state of the affected object\n\t     */\n\t\n\t    /**\n\t     * Call this function to add callbacks to be invoked on event triggers.\n\t     * Available callbacks:\n\t     *\n\t     * | Name                                               | Description           |\n\t     * | -------------------------------------------------- | --------------------- |\n\t     * | {@link #Channel.event:error error}                 | Invoked when there was an error processing the requested operation |\n\t     * | {@link #Channel.event:subscribe subscribe}         | Invoked when channel subscription is successful |\n\t     * | {@link #Channel.event:resync resync}               | Invoked when channel objects are resync'd with server |\n\t     * | {@link #Channel.event:unsubscribe unsubscribe}     | Invoked when channel unsubscription is successful |\n\t     * | {@link #Channel.event:update update}               | Invoked when objects in the subscription have been modified (update of an existing object, new object or deleted object) |\n\t     *\n\t     * @param {string} name The name of the event to associate the callback with\n\t     * @param {function} callback The callback to be executed\n\t     * @return {number} A callback id. Save this in order to later remove the callback from the event (using {@link #Channel#removeCallback removeCallback})\n\t     * @example\n\t     * // React to object updates\n\t     *  articleChannel.on('update', (operationType, objectId, object, oldObject) => {\n\t     *    console.log(`Received article update of type ${operationType}, for object with id ${objectId}`);\n\t     *    // Objects are already updated\n\t     *    console.log(articleChannel.objects);\n\t     *  });\n\t     */\n\t\n\t  }, {\n\t    key: 'on',\n\t    value: function on(name, callback) {\n\t      return this._event.on(name, callback);\n\t    }\n\t\n\t    /**\n\t     * Call this function to remove callbacks that have been set using {@link #Channel#on on}.\n\t     *\n\t     * @param {string} name The name of the event the callback was associated with\n\t     * @param {number} callbackId The callback id returned by calling {@link #Channel#on on}\n\t     * @example\n\t     * let updateCallbackId = channel.on('update', () => {\n\t     *  // Remove the callback after the first update event\n\t     *  channel.removeCallback(updateCallbackId);\n\t     * });\n\t     */\n\t\n\t  }, {\n\t    key: 'removeCallback',\n\t    value: function removeCallback(name, index) {\n\t      return this._event.removeCallback(name, index);\n\t    }\n\t  }]);\n\t\n\t  return Channel;\n\t}();\n\t\n\texports.default = Channel;\n\t;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _api = __webpack_require__(19);\n\t\n\tvar _api2 = _interopRequireDefault(_api);\n\t\n\tvar _logger = __webpack_require__(27);\n\t\n\tvar _logger2 = _interopRequireDefault(_logger);\n\t\n\tvar _error = __webpack_require__(29);\n\t\n\tvar _error2 = _interopRequireDefault(_error);\n\t\n\tvar _admin = __webpack_require__(70);\n\t\n\tvar _admin2 = _interopRequireDefault(_admin);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * You can access an instance of this class using the {@link #Telepatuser user} property of the Telepat object.\n\t *\n\t * @class User\n\t *\n\t * @example\n\t * telepat.user.login('email', 'password', (err) => {\n\t *  if (err) {\n\t *    // Treat login error\n\t *  } else {\n\t *    // Treat successful login\n\t *    console.log(telepat.user.data);\n\t *\n\t *    // Update user data\n\t *    telepat.user.data.points++;\n\t *  }\n\t * });\n\t */\n\tvar User = function () {\n\t  function User(db, event, monitor, setAdmin) {\n\t    var _this = this;\n\t\n\t    var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {};\n\t\n\t    _classCallCheck(this, User);\n\t\n\t    this._event = event;\n\t    this._monitor = monitor;\n\t    this._setAdmin = setAdmin;\n\t    this._db = db;\n\t    this._customProperties = [];\n\t    this._userChannel = null;\n\t\n\t    /**\n\t     * Indicates if the currently logged in user is an admin\n\t     * @type {boolean}\n\t     * @memberof User\n\t     * @instance\n\t     */\n\t    this.isAdmin = false;\n\t    /**\n\t     * Indicates if there's a saved authentication token that can be used to re-login\n\t     * @type {boolean}\n\t     * @memberof User\n\t     * @instance\n\t     */\n\t    this.canReauth = null;\n\t    /**\n\t     * Object that holds all key-value data about the currently logged in user\n\t     * @type {Object}\n\t     * @memberof User\n\t     * @instance\n\t     */\n\t    this.data = {};\n\t\n\t    /**\n\t     * Indicates if there is a currently logged-in user\n\t     */\n\t    this.isLoggedIn = false;\n\t\n\t    _api2.default.tokenUpdateCallback = function (newToken) {\n\t      _this._saveToken(newToken);\n\t    };\n\t\n\t    this._db.get(':userToken').then(function (doc) {\n\t      _this.canReauth = true;\n\t      callback();\n\t    }).catch(function () {\n\t      _this.canReauth = false;\n\t      callback();\n\t    });\n\t  }\n\t\n\t  _createClass(User, [{\n\t    key: '_saveToken',\n\t    value: function _saveToken(token) {\n\t      var _this2 = this;\n\t\n\t      var newObject = {\n\t        _id: ':userToken',\n\t        value: {\n\t          token: token,\n\t          admin: this.isAdmin\n\t        }\n\t      };\n\t\n\t      this._db.get(':userToken').then(function (doc) {\n\t        newObject._rev = doc._rev;\n\t        _logger2.default.info('Replacing existing authentication token');\n\t        _this2._db.put(newObject).then(function (doc) {\n\t          _this2.canReauth = true;\n\t        }).catch(function (err) {\n\t          _this2.canReauth = false;\n\t          _logger2.default.warn('Could not persist authentication token. Error: ' + err);\n\t        });\n\t      }).catch(function () {\n\t        _this2._db.put(newObject).then(function (doc) {\n\t          _this2.canReauth = true;\n\t        }).catch(function (err) {\n\t          _this2.canReauth = false;\n\t          _logger2.default.warn('Could not persist authentication token. Error: ' + err);\n\t        });\n\t      });\n\t    }\n\t  }, {\n\t    key: '_login',\n\t    value: function _login(endpoint, options, isAdmin) {\n\t      var _this3 = this;\n\t\n\t      var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {};\n\t\n\t      var success = function success(res) {\n\t        var userContainer = {};\n\t\n\t        _this3.isLoggedIn = true;\n\t\n\t        for (var k in res.body.content.user) {\n\t          _this3.data[k] = res.body.content.user[k];\n\t          _this3._customProperties.push(k);\n\t        }\n\t        if (isAdmin) {\n\t          _this3.isAdmin = true;\n\t          _this3._setAdmin(new _admin2.default(_this3));\n\t        }\n\t\n\t        userContainer[_this3.data.id] = _this3.data;\n\t        _this3._monitor.add({ channel: { model: _this3.isAdmin ? 'admin' : 'user' } }, userContainer, null, function () {}, function () {}, _this3.update.bind(_this3));\n\t\n\t        _api2.default.authenticationToken = res.body.content.token;\n\t        _this3._saveToken(_api2.default.authenticationToken);\n\t        _this3._event.emit('login');\n\t        callback(null, _this3);\n\t      };\n\t\n\t      _api2.default.call(endpoint, options, function (err, res) {\n\t        if (err) {\n\t          if (err.status === 404 && options.hasOwnProperty('access_token')) {\n\t            _logger2.default.info('Got 404 on Facebook login, registering user first');\n\t            _api2.default.call('user/register-facebook', options, function (err, res) {\n\t              if (err) {\n\t                _logger2.default.error('Failed to login with Facebook. Could not register or login user.');\n\t                _this3._event.emit('login_error', (0, _error2.default)('Login failed with error: ' + err));\n\t              } else {\n\t                _api2.default.call(endpoint, options, function (err, res) {\n\t                  if (err) {\n\t                    _logger2.default.error('Failed to login with Facebook. User registration was successful, but login failed.');\n\t                    this._event.emit('login_error', (0, _error2.default)('Login failed with error: ' + err));\n\t                  } else {\n\t                    success(res);\n\t                  }\n\t                });\n\t              }\n\t            });\n\t          } else {\n\t            _this3._event.emit('login_error', (0, _error2.default)('Login failed with error: ' + err));\n\t            callback(err, null);\n\t          }\n\t        } else {\n\t          success(res);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * If there is a saved authentication token from previous connections, try to use it to login again.\n\t     * You can call this method if the {@link #UsercanReauth canReauth} property is true.\n\t     *\n\t     * @param  {TelepatCallback} callback Callback invoked after reauth operation is finished\n\t     */\n\t\n\t  }, {\n\t    key: 'reauth',\n\t    value: function reauth() {\n\t      var _this4 = this;\n\t\n\t      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n\t\n\t      this._db.get(':userToken').then(function (doc) {\n\t        _logger2.default.info('Retrieved saved authentication token');\n\t        _api2.default.authenticationToken = doc.value.token;\n\t        _api2.default.get(doc.value.admin ? 'admin/me' : 'user/me', '', function (err, res) {\n\t          if (err) {\n\t            _api2.default.authenticationToken = null;\n\t            this._setAdmin(null);\n\t            this._db.remove(doc._id, doc._rev);\n\t            this.canReauth = false;\n\t            callback((0, _error2.default)('Saved authentication token expired'), null);\n\t            this._customProperties = [];\n\t            this.data = {};\n\t            this.isLoggedIn = false;\n\t            this._event.emit('logout');\n\t          } else {\n\t            var userContainer = {};\n\t\n\t            this.isLoggedIn = true;\n\t\n\t            for (var k in res.body.content) {\n\t              this.data[k] = res.body.content[k];\n\t              this._customProperties.push(k);\n\t            }\n\t            if (res.body.content.type === 'admin') {\n\t              this.isAdmin = true;\n\t              this._saveToken(_api2.default.authenticationToken);\n\t              this._setAdmin(new _admin2.default(this));\n\t            }\n\t\n\t            userContainer[this.data.id] = this.data;\n\t            this._monitor.add({ channel: { model: this.isAdmin ? 'admin' : 'user' } }, userContainer, null, function () {}, function () {}, this.update.bind(this));\n\t            callback(null, res);\n\t            this._event.emit('login');\n\t          }\n\t        }.bind(_this4));\n\t      }).catch(function (err) {\n\t        callback((0, _error2.default)('Error retrieving authentication token: ' + err), null);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Call this to update your profile.\n\t     *\n\t     * To call this method, you need to create an  array containing 'patch' objects, representing the\n\t     * modifications that need to be persisted. The structure of a patch object is:\n\t     *\n\t     * `{'op': 'replace', 'path': user or admin + '/' + user_id + '/' + property, 'value': modified_value}`\n\t     *\n\t     * Instead of using this function, you can also update the user directly from {@link #Userdata User.data}.\n\t     *\n\t     * @param {string} id The user id of the updated user profile\n\t     * @param  {Array<Object>} patches The array of patches representing the modifications that need to be persisted\n\t     * @param {TelepatCallback} callback Callback invoked after operation is finished\n\t     */\n\t\n\t  }, {\n\t    key: 'update',\n\t    value: function update(id, patches) {\n\t      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n\t\n\t      _api2.default.call(this.isAdmin ? 'admin/update' : 'user/update', { patches: patches }, function (err, res) {\n\t        if (err) {\n\t          callback((0, _error2.default)('Failed updating user: ' + res.body.message));\n\t        } else {\n\t          callback();\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Call this to request a password reset for the logged in user.\n\t     * The process involves a confirmation email, with a link that needs to be clicked on in order to get a unique pass reset token.\n\t     * You then use that token to call the {@link #User#resetPassword resetPassword} method that finishes the process by setting a new password.\n\t     *\n\t     * @param  {string} email The email/username of the user to reset the pass for\n\t     * @param  {string} callbackURL The URL the user will be pointed to after verifying the request by clicking the link in the sent email\n\t     * @param  {TelepatCallback} callback Callback invoked after the operation is finished\n\t     */\n\t\n\t  }, {\n\t    key: 'requestPasswordReset',\n\t    value: function requestPasswordReset(email, callbackURL) {\n\t      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n\t\n\t      if (!email) {\n\t        if (this.email) {\n\t          email = this.email;\n\t        } else {\n\t          callback((0, _error2.default)('You must provide a valid email address for the account that needs the password reset'), null);\n\t          return;\n\t        }\n\t      }\n\t\n\t      _api2.default.call('user/request_password_reset', {\n\t        callbackUrl: callbackURL,\n\t        username: email\n\t      }, function (err, res) {\n\t        if (err) {\n\t          callback((0, _error2.default)('Password reset request failed with error: ' + err), null);\n\t        } else {\n\t          callback(null, res.body.content);\n\t        }\n\t      });\n\t    }\n\t  }, {\n\t    key: 'resetPassword',\n\t\n\t\n\t    /**\n\t     * @param  {string} userId The id of the user that needs the password reset\n\t     * @param  {string} token The token obtained from the redirect generated by calling {@link #User#requestPasswordReset requestPasswordReset}.\n\t     * @param  {string} newPassword The new password\n\t     * @param  {TelepatCallback} callback Callback invoked after the operation is finished\n\t     */\n\t    value: function resetPassword(id, token, newPassword) {\n\t      var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {};\n\t\n\t      if (!id || !token || !newPassword) {\n\t        callback((0, _error2.default)('You must provide a valid user-id, pass reset token and new password for the account that needs the password reset'), null);\n\t        return;\n\t      }\n\t\n\t      _api2.default.call('user/password_reset', {\n\t        'token': token,\n\t        'user_id': id,\n\t        'password': newPassword\n\t      }, function (err, res) {\n\t        if (err) {\n\t          callback((0, _error2.default)('Password reset request failed with error: ' + err), null);\n\t        } else {\n\t          callback(null, res.body.content);\n\t        }\n\t      });\n\t    }\n\t  }, {\n\t    key: 'register',\n\t\n\t\n\t    /**\n\t     * This function creates a new user profile.\n\t     *\n\t     * @param {Object} user The object representing the new user profile\n\t     * @param {TelepatCallback} callback Callback invoked after the operation is finished\n\t     */\n\t    value: function register(user) {\n\t      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\t\n\t      _api2.default.call('user/register-username', user, callback);\n\t    }\n\t  }, {\n\t    key: 'registerAdmin',\n\t\n\t\n\t    /**\n\t     * This function creates a new admin profile.\n\t     *\n\t     * @param {Object} admin The object representing the new admin profile\n\t     * @param {TelepatCallback} callback Callback invoked after the operation is finished\n\t     */\n\t    value: function registerAdmin(admin) {\n\t      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\t\n\t      _api2.default.call('admin/add', admin, function (err, res) {\n\t        if (err) {\n\t          callback((0, _error2.default)('Register failed with error: ' + res.body.message || ''), null);\n\t        } else {\n\t          callback(null, res.body.content);\n\t        }\n\t      });\n\t    }\n\t  }, {\n\t    key: 'loginWithFacebook',\n\t\n\t\n\t    /**\n\t     * This function associates the current anonymous device to a Telepat user profile, using a Facebook\n\t      account for authentication.\n\t     *\n\t     * @param {string} facebookToken The user token obtained from Facebook after login\n\t     * @param {TelepatCallback} callback Callback invoked after the operation is finished\n\t     */\n\t    value: function loginWithFacebook(facebookToken) {\n\t      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\t\n\t      return this._login('user/login-facebook', { 'access_token': facebookToken }, false, callback);\n\t    }\n\t  }, {\n\t    key: 'login',\n\t\n\t\n\t    /**\n\t     * This function associates the current anonymous device to a Telepat user profile, using a password for authentication.\n\t     *\n\t     * @param {string} email The user's email address\n\t     * @param {string} password The user's password\n\t     * @param {TelepatCallback} callback Callback invoked after the operation is finished\n\t     * @example\n\t     * telepat.user.login('email', 'password', (err) => {\n\t     *  if (err) {\n\t     *    // Treat login error\n\t     *  } else {\n\t     *    // Treat successful login\n\t     *    console.log(telepat.user.data);\n\t     *  }\n\t     * });\n\t     */\n\t    value: function login(email, password) {\n\t      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n\t\n\t      return this._login('user/login_password', { username: email, password: password }, false, callback);\n\t    }\n\t  }, {\n\t    key: 'loginAdmin',\n\t\n\t\n\t    /**\n\t     * This function associates the current anonymous device to a Telepat administrator profile, using a password for authentication.\n\t     *\n\t     * @param {string} email The admin email address\n\t     * @param {string} password The admin password\n\t     * @param {TelepatCallback} callback Callback invoked after the operation is finished\n\t     * @example\n\t     * telepat.user.loginAdmin('admin@email.com', 'password', (err) => {\n\t     *  if (err) {\n\t     *    // Treat login error\n\t     *  } else {\n\t     *    telepat.admin.getAppUsers((err) => {\n\t     *      if (err) {\n\t     *        // Treat error\n\t     *      } else {\n\t     *        // Treat success\n\t     *        console.log(telepat.admin.users);\n\t     *      }\n\t     *    })\n\t     *  }\n\t     * });\n\t     */\n\t    value: function loginAdmin(email, password) {\n\t      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n\t\n\t      return this._login('admin/login', { email: email, password: password }, true, callback);\n\t    }\n\t  }, {\n\t    key: 'get',\n\t\n\t\n\t    /**\n\t     * Call this to retrieve a specific application user object.\n\t     * Results will be sent as a callback argument.\n\t     *\n\t     * @param {string} userId The id of the requested user\n\t     * @param {TelepatCallback} callback Callback invoked after operation is finished\n\t     */\n\t    value: function get(userId) {\n\t      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\t\n\t      _api2.default.get('user/get', 'user_id=' + encodeURIComponent(userId), function (err, res) {\n\t        if (err) {\n\t          callback((0, _error2.default)('Retrieving user failed with error: ' + err), null);\n\t        } else {\n\t          callback(null, res.body.content);\n\t        }\n\t      });\n\t    }\n\t  }, {\n\t    key: 'me',\n\t\n\t\n\t    /**\n\t     * This function retrieves the currently logged in user's information.\n\t     *\n\t     * @param {TelepatCallback} callback Callback invoked after the operation is finished\n\t     */\n\t    value: function me() {\n\t      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n\t\n\t      _api2.default.get(this.isAdmin ? 'admin/me' : 'user/me', '', function (err, res) {\n\t        if (err) {\n\t          callback(console.error('Request failed with error: ' + err), null);\n\t        } else {\n\t          callback(null, JSON.parse(res.text).content);\n\t        }\n\t      });\n\t    }\n\t  }, {\n\t    key: 'logout',\n\t\n\t\n\t    /**\n\t     * Logs the current user out.\n\t     *\n\t     * @param {TelepatCallback} callback Callback invoked after the operation is finished\n\t     */\n\t    value: function logout() {\n\t      var _this5 = this;\n\t\n\t      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n\t\n\t      this._db.get(':userToken').then(function (doc) {\n\t        _this5._db.remove(doc._id, doc._rev);\n\t      }).catch(function () {});\n\t      this._setAdmin(null);\n\t      this.isAdmin = false;\n\t      this.isLoggedIn = false;\n\t      this.canReauth = false;\n\t      this._customProperties = [];\n\t      this.data = {};\n\t\n\t      _api2.default.get('user/logout', '', function (err) {\n\t        _api2.default.authenticationToken = null;\n\t        if (err) {\n\t          _this5._event.emit('logout_error', (0, _error2.default)('Logout failed with error: ' + err));\n\t          callback(err);\n\t        } else {\n\t          _this5._event.emit('logout');\n\t          callback();\n\t        }\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return User;\n\t}();\n\t\n\texports.default = User;\n\t;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _api = __webpack_require__(19);\n\t\n\tvar _api2 = _interopRequireDefault(_api);\n\t\n\tvar _error = __webpack_require__(29);\n\t\n\tvar _error2 = _interopRequireDefault(_error);\n\t\n\tvar _event = __webpack_require__(30);\n\t\n\tvar _event2 = _interopRequireDefault(_event);\n\t\n\tvar _logger = __webpack_require__(27);\n\t\n\tvar _logger2 = _interopRequireDefault(_logger);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * You can access an instance of this class using the {@link #Telepatadmin admin} property of the Telepat object.\n\t * This instance becomes available after successfully logging in as an administrator.\n\t *\n\t * @class Admin\n\t *\n\t * @example\n\t * telepat.user.loginAdmin('admin@email.com', 'password', (err) => {\n\t *  if (err) {\n\t *    // Treat login error\n\t *  } else {\n\t *    telepat.admin.getAppUsers((err) => {\n\t *      if (err) {\n\t *        // Treat error\n\t *      } else {\n\t *        // Treat success\n\t *        console.log(telepat.admin.users);\n\t *\n\t *        // Update users\n\t *        telepat.admin.users[goodUserId].isAwesome = true;\n\t *        delete telepat.admin.users[badUserId];\n\t *\n\t *        // Update collection metadata\n\t *        telepat.collections[currentCollectionId].topic = 'Cats';\n\t *      }\n\t *    })\n\t *  }\n\t * });\n\t */\n\tvar Admin = function () {\n\t  function Admin(user) {\n\t    _classCallCheck(this, Admin);\n\t\n\t    this._user = user;\n\t    this._monitor = user._monitor;\n\t    this._event = user._event;\n\t\n\t    /**\n\t     * This {@link Channel} instance allows registering callbacks for 'update' events on user data.\n\t     * @type {Object}\n\t     * @memberof Admin\n\t     * @instance\n\t     */\n\t    this.userChannel = null;\n\t    /**\n\t     * This object contains data about all of the applications the current administrator can access.\n\t     * Each app data is stored using a key equal to the application unique identifier.\n\t     * You can access this after calling {@link #Admin#getApps getApps}.\n\t     * Modifications to app objects stored within will be automatically synchronized with the Telepat backend.\n\t     * @type {Object}\n\t     * @memberof Admin\n\t     * @instance\n\t     */\n\t    this.apps = null;\n\t    /**\n\t     * This object contains data about the currently connected app.\n\t     * You can access this after calling {@link #Admin#getApps getApps}.\n\t     * Modifications to this object will be automatically synchronized with the Telepat backend.\n\t     * @type {Object}\n\t     * @memberof Admin\n\t     * @instance\n\t     */\n\t    this.app = null;\n\t    /**\n\t     * This object contains data about all of the users of the current app.\n\t     * Each user data is stored using a key equal to the user unique identifier.\n\t     * You can access this after calling {@link #Admin#getAppUsers getAppUsers}.\n\t     * Modifications to user objects stored within will be automatically synchronized with the Telepat backend.\n\t     * @type {Object}\n\t     * @memberof Admin\n\t     * @instance\n\t     */\n\t    this.users = null;\n\t  }\n\t\n\t  /**\n\t   * Call this to retrieve all the application objects the current administrator can access.\n\t   * Results will be sent as a callback argument, and persisted on the {@link #Adminapps apps} property.\n\t   * The object belonging to the currently connected app will also be made available, on the {@link #Adminapp app} property.\n\t   *\n\t   * @param {TelepatCallback} callback Callback invoked after operation is finished\n\t   */\n\t\n\t\n\t  _createClass(Admin, [{\n\t    key: 'getApps',\n\t    value: function getApps() {\n\t      var _this = this;\n\t\n\t      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n\t\n\t      _api2.default.call('admin/apps', '', function (err, res) {\n\t        if (err) {\n\t          callback((0, _error2.default)('Retrieving apps failed with error: ' + err), null);\n\t        } else {\n\t          _this.apps = {};\n\t          for (var index in res.body.content) {\n\t            var app = res.body.content[index];\n\t\n\t            _this.apps[app.id] = app;\n\t          }\n\t          _this.app = _this.apps[_api2.default.appId];\n\t          _this._monitor.add({ channel: { model: 'application' } }, _this.apps, new _event2.default(_logger2.default), function () {}, function () {}, _this.updateApp);\n\t          callback(null, res.body.content);\n\t        }\n\t      }, 'get');\n\t    }\n\t\n\t    /**\n\t     * Call this to create a new application.\n\t     *\n\t     * @param {Object} properties Data about the new application. Can hold any key-value data.\n\t     * Must contain at least a 'keys' key, with an array of string values that will be used as valid API keys for the app.\n\t     * @param {TelepatCallback} callback Callback invoked after operation is finished\n\t     */\n\t\n\t  }, {\n\t    key: 'addApp',\n\t    value: function addApp(properties) {\n\t      var _this2 = this;\n\t\n\t      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\t\n\t      _api2.default.call('admin/app/add', properties, function (err, res) {\n\t        if (err) {\n\t          callback((0, _error2.default)('Adding application failed with error: ' + err), null);\n\t        } else {\n\t          _this2._monitor.processMessage({\n\t            'data': {\n\t              'new': [{\n\t                'op': 'create',\n\t                'object': res.body.content,\n\t                'subscriptions': ['blg:null:application']\n\t              }],\n\t              'updated': [],\n\t              'deleted': []\n\t            }\n\t          });\n\t          callback(null, res.body.content);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Updates key-value data within an application object.\n\t     *\n\t     * To call this method, you need to create an  array containing 'patch' objects, representing the\n\t     * modifications that need to be persisted. The structure of a patch object is:\n\t     *\n\t     * `{'op': 'replace', 'path': application + '/' + app_id + '/' + property, 'value': modified_value}`\n\t     *\n\t     * Instead of using this function, you can also update the app directly from {@link #Adminapps Admin.apps}.\n\t     *\n\t     * @param  {string} id The application id\n\t     * @param  {Array<Object>} patches The array of patches representing the modifications that need to be persisted\n\t     * @param  {TelepatCallback} callback Callback invoked after operation is finished\n\t     */\n\t\n\t  }, {\n\t    key: 'updateApp',\n\t    value: function updateApp(id, patches) {\n\t      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n\t\n\t      if (id !== _api2.default.appId) {\n\t        callback((0, _error2.default)('Cannot update an app that is not active. Please reconnect to that specific app id to make updates.'));\n\t      }\n\t      _api2.default.call('admin/app/update', { id: id, patches: patches }, function (err, res) {\n\t        if (err) {\n\t          callback((0, _error2.default)('Updating application failed with error: ' + err));\n\t        } else {\n\t          callback();\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Call this to delete an application.\n\t     * Instead of using this function, you can also delete the app directly from {@link #Adminapps Admin.apps}.\n\t     *\n\t     * @param {string} id The application id\n\t     * @param {TelepatCallback} callback Callback invoked after operation is finished\n\t     */\n\t\n\t  }, {\n\t    key: 'deleteApp',\n\t    value: function deleteApp(id) {\n\t      var _this3 = this;\n\t\n\t      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\t\n\t      _api2.default.del('admin/app/remove', { id: id }, function (err, res) {\n\t        if (err) {\n\t          callback((0, _error2.default)('Removing application failed with error: ' + err), null);\n\t        } else {\n\t          _this3._monitor.processMessage({\n\t            'data': {\n\t              'deleted': [{\n\t                'op': 'delete',\n\t                'object': {\n\t                  id: id\n\t                },\n\t                'subscriptions': ['blg:null:application']\n\t              }],\n\t              'updated': [],\n\t              'new': []\n\t            }\n\t          });\n\t          callback();\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Call this to create a new collection.\n\t     *\n\t     * @param {Object} collection Data about the new application. Can hold any key-value data. May be empty object.\n\t     * @param {TelepatCallback} callback Callback invoked after operation is finished\n\t     */\n\t\n\t  }, {\n\t    key: 'addCollection',\n\t    value: function addCollection(collection) {\n\t      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\t\n\t      _api2.default.call('admin/context/add', collection, function (err, res) {\n\t        if (err) {\n\t          callback((0, _error2.default)('Creating collection failed with error: ' + err));\n\t        } else {\n\t          callback(null, res);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Updates key-value data within a collection object.\n\t     *\n\t     * To call this method, you need to create an  array containing 'patch' objects, representing the\n\t     * modifications that need to be persisted. The structure of a patch object is:\n\t     *\n\t     * `{'op': 'replace', 'path': context + '/' + collection_id + '/' + property, 'value': modified_value}`\n\t     *\n\t     * Instead of using this function, you can also update the collection directly from {@link #Telepatcollections Telepat.collections}.\n\t     *\n\t     * @param  {string} id The collection id\n\t     * @param  {Array<Object>} patches The array of patches representing the modifications that need to be persisted\n\t     * @param  {TelepatCallback} callback Callback invoked after operation is finished\n\t     */\n\t\n\t  }, {\n\t    key: 'updateCollection',\n\t    value: function updateCollection(id, patches) {\n\t      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n\t\n\t      _api2.default.call('admin/context/update', { id: id, patches: patches }, function (err, res) {\n\t        if (err) {\n\t          callback((0, _error2.default)('Updating collection failed with error: ' + err));\n\t        } else {\n\t          callback();\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Call this to delete a collection.\n\t     * Instead of using this function, you can also delete the collection directly from {@link #Telepatcollections Telepat.collections}.\n\t     *\n\t     * @param {string} id The collection id\n\t     * @param {TelepatCallback} callback Callback invoked after operation is finished\n\t     */\n\t\n\t  }, {\n\t    key: 'deleteCollection',\n\t    value: function deleteCollection(id) {\n\t      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\t\n\t      _api2.default.del('admin/context/remove', { id: id }, function (err, res) {\n\t        if (err) {\n\t          callback((0, _error2.default)('Deleting collection failed with error: ' + err));\n\t        } else {\n\t          callback();\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Call this to remove a model from the schema, together with all objects of that specific type.\n\t     *\n\t     * @param {string} type The model name\n\t     * @param {TelepatCallback} callback Callback invoked after operation is finished\n\t     */\n\t\n\t  }, {\n\t    key: 'deleteModel',\n\t    value: function deleteModel(type, callback) {\n\t      _api2.default.del('admin/schema/remove_model', {\n\t        'model_name': type\n\t      }, function (err, res) {\n\t        if (err) {\n\t          callback((0, _error2.default)('Deleting model failed with error: ' + err));\n\t        } else {\n\t          callback();\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Call this to retrieve all the current application user objects.\n\t     * Results will be sent as a callback argument, and persisted on the {@link #Adminusers users} property.\n\t     *\n\t     * @param {TelepatCallback} callback Callback invoked after operation is finished\n\t     */\n\t\n\t  }, {\n\t    key: 'getAppUsers',\n\t    value: function getAppUsers() {\n\t      var _this4 = this;\n\t\n\t      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n\t\n\t      _api2.default.call('admin/users', {}, function (err, res) {\n\t        if (err) {\n\t          callback((0, _error2.default)('Retrieving users failed with error: ' + err), null);\n\t        } else {\n\t          _this4.users = {};\n\t          for (var index in res.body.content) {\n\t            _this4.users[res.body.content[index].id] = res.body.content[index];\n\t          }\n\t          _this4.userChannel = new _event2.default(_logger2.default);\n\t          _this4._monitor.add({ channel: { model: 'user' } }, _this4.users, _this4.userChannel, _this4.addUser.bind(_this4), _this4.deleteUser, _this4.updateUser);\n\t          callback(null, _this4.users);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * This is an alias for {@link #User#register}.\n\t     *\n\t     *  @param {Object} user The object representing the new user profile\n\t     *  @param {TelepatCallback} callback Callback invoked after operation is finished\n\t     */\n\t\n\t  }, {\n\t    key: 'addUser',\n\t    value: function addUser(user) {\n\t      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\t\n\t      this._user.register(user, callback);\n\t    }\n\t  }, {\n\t    key: 'deleteUser',\n\t\n\t\n\t    /**\n\t     * Call this to delete a user profile.\n\t     * Instead of using this function, you can also delete the user directly from {@link #Adminusers Admin.users}.\n\t     *\n\t     *  @param {string} username The email address of the user profile to delete\n\t     *  @param {TelepatCallback} callback Callback invoked after operation is finished\n\t     */\n\t    value: function deleteUser(id) {\n\t      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\t\n\t      _api2.default.del('admin/user/delete', { id: id }, function (err, res) {\n\t        if (err) {\n\t          callback((0, _error2.default)('Removing user failed with error: ' + err), null);\n\t        } else {\n\t          callback();\n\t        }\n\t      });\n\t    }\n\t  }, {\n\t    key: 'updateUser',\n\t\n\t\n\t    /**\n\t     * Call this to update a user profile.\n\t     *\n\t     * To call this method, you need to create an  array containing 'patch' objects, representing the\n\t     * modifications that need to be persisted. The structure of a patch object is:\n\t     *\n\t     * `{'op': 'replace', 'path': user + '/' + user_id + '/' + property, 'value': modified_value}`\n\t     *\n\t     * Instead of using this function, you can also update the user directly from {@link #Adminusers Admin.users}.\n\t     *\n\t     * @param {string} id The id of the user to be updated\n\t     * @param  {Array<Object>} patches The array of patches representing the modifications that need to be persisted\n\t     * @param {TelepatCallback} callback Callback invoked after operation is finished\n\t     */\n\t    value: function updateUser(id, patches) {\n\t      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n\t\n\t      _api2.default.call('admin/user/update', {\n\t        patches: patches\n\t      }, function (err, res) {\n\t        if (err) {\n\t          callback((0, _error2.default)('Updating user failed with error: ' + err), null);\n\t        } else {\n\t          callback();\n\t        }\n\t      });\n\t    }\n\t  }, {\n\t    key: 'authorize',\n\t\n\t\n\t    /**\n\t     * Call this to authorize access to the current app for another administrator account\n\t     * within the same Telepat instance.\n\t     *\n\t     * @param {string} user The email associated with the account of the new administrator\n\t     * @param {TelepatCallback} callback Callback invoked after operation is finished\n\t     */\n\t    value: function authorize(user, callback) {\n\t      _api2.default.call('/admin/app/authorize', {\n\t        email: user\n\t      }, function (err, res) {\n\t        if (err) {\n\t          callback((0, _error2.default)('Authorizing admin failed with error: ' + err), null);\n\t        } else {\n\t          callback();\n\t        }\n\t      });\n\t    }\n\t  }, {\n\t    key: 'deauthorize',\n\t\n\t\n\t    /**\n\t     * Call this to deauthorize access to the current app for another administrator account\n\t     * within the same Telepat instance.\n\t     *\n\t     * @param {string} user The email associated with the account of the administrator to be removed\n\t     * @param {TelepatCallback} callback Callback invoked after operation is finished\n\t     */\n\t    value: function deauthorize(user, callback) {\n\t      _api2.default.call('/admin/app/deauthorize', {\n\t        email: user\n\t      }, function (err, res) {\n\t        if (err) {\n\t          callback((0, _error2.default)('Deauthorizing admin failed with error: ' + err), null);\n\t        } else {\n\t          callback();\n\t        }\n\t      });\n\t    }\n\t  }, {\n\t    key: 'unhook',\n\t    value: function unhook() {\n\t      this._monitor.remove({ channel: { model: 'application' } });\n\t      this._monitor.remove({ channel: { model: 'user' } });\n\t    }\n\t  }]);\n\t\n\t  return Admin;\n\t}();\n\t\n\texports.default = Admin;\n\t;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * Module dependencies.\n\t */\n\t\n\tvar url = __webpack_require__(72);\n\tvar parser = __webpack_require__(77);\n\tvar Manager = __webpack_require__(88);\n\tvar debug = __webpack_require__(74)('socket.io-client');\n\t\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = exports = lookup;\n\t\n\t/**\n\t * Managers cache.\n\t */\n\t\n\tvar cache = exports.managers = {};\n\t\n\t/**\n\t * Looks up an existing `Manager` for multiplexing.\n\t * If the user summons:\n\t *\n\t *   `io('http://localhost/a');`\n\t *   `io('http://localhost/b');`\n\t *\n\t * We reuse the existing instance based on same scheme/port/host,\n\t * and we initialize sockets for each namespace.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction lookup (uri, opts) {\n\t  if (typeof uri === 'object') {\n\t    opts = uri;\n\t    uri = undefined;\n\t  }\n\t\n\t  opts = opts || {};\n\t\n\t  var parsed = url(uri);\n\t  var source = parsed.source;\n\t  var id = parsed.id;\n\t  var path = parsed.path;\n\t  var sameNamespace = cache[id] && path in cache[id].nsps;\n\t  var newConnection = opts.forceNew || opts['force new connection'] ||\n\t                      false === opts.multiplex || sameNamespace;\n\t\n\t  var io;\n\t\n\t  if (newConnection) {\n\t    debug('ignoring socket cache for %s', source);\n\t    io = Manager(source, opts);\n\t  } else {\n\t    if (!cache[id]) {\n\t      debug('new io instance for %s', source);\n\t      cache[id] = Manager(source, opts);\n\t    }\n\t    io = cache[id];\n\t  }\n\t  if (parsed.query && !opts.query) {\n\t    opts.query = parsed.query;\n\t  } else if (opts && 'object' === typeof opts.query) {\n\t    opts.query = encodeQueryString(opts.query);\n\t  }\n\t  return io.socket(parsed.path, opts);\n\t}\n\t/**\n\t *  Helper method to parse query objects to string.\n\t * @param {object} query\n\t * @returns {string}\n\t */\n\tfunction encodeQueryString (obj) {\n\t  var str = [];\n\t  for (var p in obj) {\n\t    if (obj.hasOwnProperty(p)) {\n\t      str.push(encodeURIComponent(p) + '=' + encodeURIComponent(obj[p]));\n\t    }\n\t  }\n\t  return str.join('&');\n\t}\n\t/**\n\t * Protocol version.\n\t *\n\t * @api public\n\t */\n\t\n\texports.protocol = parser.protocol;\n\t\n\t/**\n\t * `connect`.\n\t *\n\t * @param {String} uri\n\t * @api public\n\t */\n\t\n\texports.connect = lookup;\n\t\n\t/**\n\t * Expose constructors for standalone build.\n\t *\n\t * @api public\n\t */\n\t\n\texports.Manager = __webpack_require__(88);\n\texports.Socket = __webpack_require__(118);\n\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\n\t/**\n\t * Module dependencies.\n\t */\n\t\n\tvar parseuri = __webpack_require__(73);\n\tvar debug = __webpack_require__(74)('socket.io-client:url');\n\t\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = url;\n\t\n\t/**\n\t * URL parser.\n\t *\n\t * @param {String} url\n\t * @param {Object} An object meant to mimic window.location.\n\t *                 Defaults to window.location.\n\t * @api public\n\t */\n\t\n\tfunction url (uri, loc) {\n\t  var obj = uri;\n\t\n\t  // default to window.location\n\t  loc = loc || global.location;\n\t  if (null == uri) uri = loc.protocol + '//' + loc.host;\n\t\n\t  // relative path support\n\t  if ('string' === typeof uri) {\n\t    if ('/' === uri.charAt(0)) {\n\t      if ('/' === uri.charAt(1)) {\n\t        uri = loc.protocol + uri;\n\t      } else {\n\t        uri = loc.host + uri;\n\t      }\n\t    }\n\t\n\t    if (!/^(https?|wss?):\\/\\//.test(uri)) {\n\t      debug('protocol-less url %s', uri);\n\t      if ('undefined' !== typeof loc) {\n\t        uri = loc.protocol + '//' + uri;\n\t      } else {\n\t        uri = 'https://' + uri;\n\t      }\n\t    }\n\t\n\t    // parse\n\t    debug('parse %s', uri);\n\t    obj = parseuri(uri);\n\t  }\n\t\n\t  // make sure we treat `localhost:80` and `localhost` equally\n\t  if (!obj.port) {\n\t    if (/^(http|ws)$/.test(obj.protocol)) {\n\t      obj.port = '80';\n\t    } else if (/^(http|ws)s$/.test(obj.protocol)) {\n\t      obj.port = '443';\n\t    }\n\t  }\n\t\n\t  obj.path = obj.path || '/';\n\t\n\t  var ipv6 = obj.host.indexOf(':') !== -1;\n\t  var host = ipv6 ? '[' + obj.host + ']' : obj.host;\n\t\n\t  // define unique id\n\t  obj.id = obj.protocol + '://' + host + ':' + obj.port;\n\t  // define href\n\t  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));\n\t\n\t  return obj;\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 73 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * Parses an URI\r\n\t *\r\n\t * @author Steven Levithan <stevenlevithan.com> (MIT license)\r\n\t * @api private\r\n\t */\r\n\t\r\n\tvar re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\r\n\t\r\n\tvar parts = [\r\n\t    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\r\n\t];\r\n\t\r\n\tmodule.exports = function parseuri(str) {\r\n\t    var src = str,\r\n\t        b = str.indexOf('['),\r\n\t        e = str.indexOf(']');\r\n\t\r\n\t    if (b != -1 && e != -1) {\r\n\t        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\r\n\t    }\r\n\t\r\n\t    var m = re.exec(str || ''),\r\n\t        uri = {},\r\n\t        i = 14;\r\n\t\r\n\t    while (i--) {\r\n\t        uri[parts[i]] = m[i] || '';\r\n\t    }\r\n\t\r\n\t    if (b != -1 && e != -1) {\r\n\t        uri.source = src;\r\n\t        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\r\n\t        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\r\n\t        uri.ipv6uri = true;\r\n\t    }\r\n\t\r\n\t    return uri;\r\n\t};\r\n\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {\n\t/**\n\t * This is the web browser implementation of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = __webpack_require__(75);\n\texports.log = log;\n\texports.formatArgs = formatArgs;\n\texports.save = save;\n\texports.load = load;\n\texports.useColors = useColors;\n\texports.storage = 'undefined' != typeof chrome\n\t               && 'undefined' != typeof chrome.storage\n\t                  ? chrome.storage.local\n\t                  : localstorage();\n\t\n\t/**\n\t * Colors.\n\t */\n\t\n\texports.colors = [\n\t  'lightseagreen',\n\t  'forestgreen',\n\t  'goldenrod',\n\t  'dodgerblue',\n\t  'darkorchid',\n\t  'crimson'\n\t];\n\t\n\t/**\n\t * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n\t * and the Firebug extension (any Firefox version) are known\n\t * to support \"%c\" CSS customizations.\n\t *\n\t * TODO: add a `localStorage` variable to explicitly enable/disable colors\n\t */\n\t\n\tfunction useColors() {\n\t  // is webkit? http://stackoverflow.com/a/16459606/376773\n\t  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\t  return (typeof document !== 'undefined' && 'WebkitAppearance' in document.documentElement.style) ||\n\t    // is firebug? http://stackoverflow.com/a/398120/376773\n\t    (window.console && (console.firebug || (console.exception && console.table))) ||\n\t    // is firefox >= v31?\n\t    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n\t}\n\t\n\t/**\n\t * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n\t */\n\t\n\texports.formatters.j = function(v) {\n\t  try {\n\t    return JSON.stringify(v);\n\t  } catch (err) {\n\t    return '[UnexpectedJSONParseError]: ' + err.message;\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Colorize log arguments if enabled.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction formatArgs() {\n\t  var args = arguments;\n\t  var useColors = this.useColors;\n\t\n\t  args[0] = (useColors ? '%c' : '')\n\t    + this.namespace\n\t    + (useColors ? ' %c' : ' ')\n\t    + args[0]\n\t    + (useColors ? '%c ' : ' ')\n\t    + '+' + exports.humanize(this.diff);\n\t\n\t  if (!useColors) return args;\n\t\n\t  var c = 'color: ' + this.color;\n\t  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\t\n\t  // the final \"%c\" is somewhat tricky, because there could be other\n\t  // arguments passed either before or after the %c, so we need to\n\t  // figure out the correct index to insert the CSS into\n\t  var index = 0;\n\t  var lastC = 0;\n\t  args[0].replace(/%[a-z%]/g, function(match) {\n\t    if ('%%' === match) return;\n\t    index++;\n\t    if ('%c' === match) {\n\t      // we only are interested in the *last* %c\n\t      // (the user may have provided their own)\n\t      lastC = index;\n\t    }\n\t  });\n\t\n\t  args.splice(lastC, 0, c);\n\t  return args;\n\t}\n\t\n\t/**\n\t * Invokes `console.log()` when available.\n\t * No-op when `console.log` is not a \"function\".\n\t *\n\t * @api public\n\t */\n\t\n\tfunction log() {\n\t  // this hackery is required for IE8/9, where\n\t  // the `console.log` function doesn't have 'apply'\n\t  return 'object' === typeof console\n\t    && console.log\n\t    && Function.prototype.apply.call(console.log, console, arguments);\n\t}\n\t\n\t/**\n\t * Save `namespaces`.\n\t *\n\t * @param {String} namespaces\n\t * @api private\n\t */\n\t\n\tfunction save(namespaces) {\n\t  try {\n\t    if (null == namespaces) {\n\t      exports.storage.removeItem('debug');\n\t    } else {\n\t      exports.storage.debug = namespaces;\n\t    }\n\t  } catch(e) {}\n\t}\n\t\n\t/**\n\t * Load `namespaces`.\n\t *\n\t * @return {String} returns the previously persisted debug modes\n\t * @api private\n\t */\n\t\n\tfunction load() {\n\t  var r;\n\t  try {\n\t    return exports.storage.debug;\n\t  } catch(e) {}\n\t\n\t  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\t  if (typeof process !== 'undefined' && 'env' in process) {\n\t    return process.env.DEBUG;\n\t  }\n\t}\n\t\n\t/**\n\t * Enable namespaces listed in `localStorage.debug` initially.\n\t */\n\t\n\texports.enable(load());\n\t\n\t/**\n\t * Localstorage attempts to return the localstorage.\n\t *\n\t * This is necessary because safari throws\n\t * when a user disables cookies/localstorage\n\t * and you attempt to access it.\n\t *\n\t * @return {LocalStorage}\n\t * @api private\n\t */\n\t\n\tfunction localstorage(){\n\t  try {\n\t    return window.localStorage;\n\t  } catch (e) {}\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * This is the common logic for both the Node.js and web browser\n\t * implementations of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = debug.debug = debug;\n\texports.coerce = coerce;\n\texports.disable = disable;\n\texports.enable = enable;\n\texports.enabled = enabled;\n\texports.humanize = __webpack_require__(76);\n\t\n\t/**\n\t * The currently active debug mode names, and names to skip.\n\t */\n\t\n\texports.names = [];\n\texports.skips = [];\n\t\n\t/**\n\t * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t *\n\t * Valid key names are a single, lowercased letter, i.e. \"n\".\n\t */\n\t\n\texports.formatters = {};\n\t\n\t/**\n\t * Previously assigned color.\n\t */\n\t\n\tvar prevColor = 0;\n\t\n\t/**\n\t * Previous log timestamp.\n\t */\n\t\n\tvar prevTime;\n\t\n\t/**\n\t * Select a color.\n\t *\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction selectColor() {\n\t  return exports.colors[prevColor++ % exports.colors.length];\n\t}\n\t\n\t/**\n\t * Create a debugger with the given `namespace`.\n\t *\n\t * @param {String} namespace\n\t * @return {Function}\n\t * @api public\n\t */\n\t\n\tfunction debug(namespace) {\n\t\n\t  // define the `disabled` version\n\t  function disabled() {\n\t  }\n\t  disabled.enabled = false;\n\t\n\t  // define the `enabled` version\n\t  function enabled() {\n\t\n\t    var self = enabled;\n\t\n\t    // set `diff` timestamp\n\t    var curr = +new Date();\n\t    var ms = curr - (prevTime || curr);\n\t    self.diff = ms;\n\t    self.prev = prevTime;\n\t    self.curr = curr;\n\t    prevTime = curr;\n\t\n\t    // add the `color` if not set\n\t    if (null == self.useColors) self.useColors = exports.useColors();\n\t    if (null == self.color && self.useColors) self.color = selectColor();\n\t\n\t    var args = new Array(arguments.length);\n\t    for (var i = 0; i < args.length; i++) {\n\t      args[i] = arguments[i];\n\t    }\n\t\n\t    args[0] = exports.coerce(args[0]);\n\t\n\t    if ('string' !== typeof args[0]) {\n\t      // anything else let's inspect with %o\n\t      args = ['%o'].concat(args);\n\t    }\n\t\n\t    // apply any `formatters` transformations\n\t    var index = 0;\n\t    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n\t      // if we encounter an escaped % then don't increase the array index\n\t      if (match === '%%') return match;\n\t      index++;\n\t      var formatter = exports.formatters[format];\n\t      if ('function' === typeof formatter) {\n\t        var val = args[index];\n\t        match = formatter.call(self, val);\n\t\n\t        // now we need to remove `args[index]` since it's inlined in the `format`\n\t        args.splice(index, 1);\n\t        index--;\n\t      }\n\t      return match;\n\t    });\n\t\n\t    // apply env-specific formatting\n\t    args = exports.formatArgs.apply(self, args);\n\t\n\t    var logFn = enabled.log || exports.log || console.log.bind(console);\n\t    logFn.apply(self, args);\n\t  }\n\t  enabled.enabled = true;\n\t\n\t  var fn = exports.enabled(namespace) ? enabled : disabled;\n\t\n\t  fn.namespace = namespace;\n\t\n\t  return fn;\n\t}\n\t\n\t/**\n\t * Enables a debug mode by namespaces. This can include modes\n\t * separated by a colon and wildcards.\n\t *\n\t * @param {String} namespaces\n\t * @api public\n\t */\n\t\n\tfunction enable(namespaces) {\n\t  exports.save(namespaces);\n\t\n\t  var split = (namespaces || '').split(/[\\s,]+/);\n\t  var len = split.length;\n\t\n\t  for (var i = 0; i < len; i++) {\n\t    if (!split[i]) continue; // ignore empty strings\n\t    namespaces = split[i].replace(/[\\\\^$+?.()|[\\]{}]/g, '\\\\$&').replace(/\\*/g, '.*?');\n\t    if (namespaces[0] === '-') {\n\t      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t    } else {\n\t      exports.names.push(new RegExp('^' + namespaces + '$'));\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Disable debug output.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction disable() {\n\t  exports.enable('');\n\t}\n\t\n\t/**\n\t * Returns true if the given mode name is enabled, false otherwise.\n\t *\n\t * @param {String} name\n\t * @return {Boolean}\n\t * @api public\n\t */\n\t\n\tfunction enabled(name) {\n\t  var i, len;\n\t  for (i = 0, len = exports.skips.length; i < len; i++) {\n\t    if (exports.skips[i].test(name)) {\n\t      return false;\n\t    }\n\t  }\n\t  for (i = 0, len = exports.names.length; i < len; i++) {\n\t    if (exports.names[i].test(name)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t * Coerce `val`.\n\t *\n\t * @param {Mixed} val\n\t * @return {Mixed}\n\t * @api private\n\t */\n\t\n\tfunction coerce(val) {\n\t  if (val instanceof Error) return val.stack || val.message;\n\t  return val;\n\t}\n\n\n/***/ },\n/* 76 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Helpers.\n\t */\n\t\n\tvar s = 1000\n\tvar m = s * 60\n\tvar h = m * 60\n\tvar d = h * 24\n\tvar y = d * 365.25\n\t\n\t/**\n\t * Parse or format the given `val`.\n\t *\n\t * Options:\n\t *\n\t *  - `long` verbose formatting [false]\n\t *\n\t * @param {String|Number} val\n\t * @param {Object} options\n\t * @throws {Error} throw an error if val is not a non-empty string or a number\n\t * @return {String|Number}\n\t * @api public\n\t */\n\t\n\tmodule.exports = function (val, options) {\n\t  options = options || {}\n\t  var type = typeof val\n\t  if (type === 'string' && val.length > 0) {\n\t    return parse(val)\n\t  } else if (type === 'number' && isNaN(val) === false) {\n\t    return options.long ?\n\t\t\t\tfmtLong(val) :\n\t\t\t\tfmtShort(val)\n\t  }\n\t  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))\n\t}\n\t\n\t/**\n\t * Parse the given `str` and return milliseconds.\n\t *\n\t * @param {String} str\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction parse(str) {\n\t  str = String(str)\n\t  if (str.length > 10000) {\n\t    return\n\t  }\n\t  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)\n\t  if (!match) {\n\t    return\n\t  }\n\t  var n = parseFloat(match[1])\n\t  var type = (match[2] || 'ms').toLowerCase()\n\t  switch (type) {\n\t    case 'years':\n\t    case 'year':\n\t    case 'yrs':\n\t    case 'yr':\n\t    case 'y':\n\t      return n * y\n\t    case 'days':\n\t    case 'day':\n\t    case 'd':\n\t      return n * d\n\t    case 'hours':\n\t    case 'hour':\n\t    case 'hrs':\n\t    case 'hr':\n\t    case 'h':\n\t      return n * h\n\t    case 'minutes':\n\t    case 'minute':\n\t    case 'mins':\n\t    case 'min':\n\t    case 'm':\n\t      return n * m\n\t    case 'seconds':\n\t    case 'second':\n\t    case 'secs':\n\t    case 'sec':\n\t    case 's':\n\t      return n * s\n\t    case 'milliseconds':\n\t    case 'millisecond':\n\t    case 'msecs':\n\t    case 'msec':\n\t    case 'ms':\n\t      return n\n\t    default:\n\t      return undefined\n\t  }\n\t}\n\t\n\t/**\n\t * Short format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction fmtShort(ms) {\n\t  if (ms >= d) {\n\t    return Math.round(ms / d) + 'd'\n\t  }\n\t  if (ms >= h) {\n\t    return Math.round(ms / h) + 'h'\n\t  }\n\t  if (ms >= m) {\n\t    return Math.round(ms / m) + 'm'\n\t  }\n\t  if (ms >= s) {\n\t    return Math.round(ms / s) + 's'\n\t  }\n\t  return ms + 'ms'\n\t}\n\t\n\t/**\n\t * Long format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction fmtLong(ms) {\n\t  return plural(ms, d, 'day') ||\n\t    plural(ms, h, 'hour') ||\n\t    plural(ms, m, 'minute') ||\n\t    plural(ms, s, 'second') ||\n\t    ms + ' ms'\n\t}\n\t\n\t/**\n\t * Pluralization helper.\n\t */\n\t\n\tfunction plural(ms, n, name) {\n\t  if (ms < n) {\n\t    return\n\t  }\n\t  if (ms < n * 1.5) {\n\t    return Math.floor(ms / n) + ' ' + name\n\t  }\n\t  return Math.ceil(ms / n) + ' ' + name + 's'\n\t}\n\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * Module dependencies.\n\t */\n\t\n\tvar debug = __webpack_require__(78)('socket.io-parser');\n\tvar json = __webpack_require__(81);\n\tvar Emitter = __webpack_require__(84);\n\tvar binary = __webpack_require__(85);\n\tvar isBuf = __webpack_require__(87);\n\t\n\t/**\n\t * Protocol version.\n\t *\n\t * @api public\n\t */\n\t\n\texports.protocol = 4;\n\t\n\t/**\n\t * Packet types.\n\t *\n\t * @api public\n\t */\n\t\n\texports.types = [\n\t  'CONNECT',\n\t  'DISCONNECT',\n\t  'EVENT',\n\t  'ACK',\n\t  'ERROR',\n\t  'BINARY_EVENT',\n\t  'BINARY_ACK'\n\t];\n\t\n\t/**\n\t * Packet type `connect`.\n\t *\n\t * @api public\n\t */\n\t\n\texports.CONNECT = 0;\n\t\n\t/**\n\t * Packet type `disconnect`.\n\t *\n\t * @api public\n\t */\n\t\n\texports.DISCONNECT = 1;\n\t\n\t/**\n\t * Packet type `event`.\n\t *\n\t * @api public\n\t */\n\t\n\texports.EVENT = 2;\n\t\n\t/**\n\t * Packet type `ack`.\n\t *\n\t * @api public\n\t */\n\t\n\texports.ACK = 3;\n\t\n\t/**\n\t * Packet type `error`.\n\t *\n\t * @api public\n\t */\n\t\n\texports.ERROR = 4;\n\t\n\t/**\n\t * Packet type 'binary event'\n\t *\n\t * @api public\n\t */\n\t\n\texports.BINARY_EVENT = 5;\n\t\n\t/**\n\t * Packet type `binary ack`. For acks with binary arguments.\n\t *\n\t * @api public\n\t */\n\t\n\texports.BINARY_ACK = 6;\n\t\n\t/**\n\t * Encoder constructor.\n\t *\n\t * @api public\n\t */\n\t\n\texports.Encoder = Encoder;\n\t\n\t/**\n\t * Decoder constructor.\n\t *\n\t * @api public\n\t */\n\t\n\texports.Decoder = Decoder;\n\t\n\t/**\n\t * A socket.io Encoder instance\n\t *\n\t * @api public\n\t */\n\t\n\tfunction Encoder() {}\n\t\n\t/**\n\t * Encode a packet as a single string if non-binary, or as a\n\t * buffer sequence, depending on packet type.\n\t *\n\t * @param {Object} obj - packet object\n\t * @param {Function} callback - function to handle encodings (likely engine.write)\n\t * @return Calls callback with Array of encodings\n\t * @api public\n\t */\n\t\n\tEncoder.prototype.encode = function(obj, callback){\n\t  debug('encoding packet %j', obj);\n\t\n\t  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {\n\t    encodeAsBinary(obj, callback);\n\t  }\n\t  else {\n\t    var encoding = encodeAsString(obj);\n\t    callback([encoding]);\n\t  }\n\t};\n\t\n\t/**\n\t * Encode packet as string.\n\t *\n\t * @param {Object} packet\n\t * @return {String} encoded\n\t * @api private\n\t */\n\t\n\tfunction encodeAsString(obj) {\n\t  var str = '';\n\t  var nsp = false;\n\t\n\t  // first is type\n\t  str += obj.type;\n\t\n\t  // attachments if we have them\n\t  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {\n\t    str += obj.attachments;\n\t    str += '-';\n\t  }\n\t\n\t  // if we have a namespace other than `/`\n\t  // we append it followed by a comma `,`\n\t  if (obj.nsp && '/' != obj.nsp) {\n\t    nsp = true;\n\t    str += obj.nsp;\n\t  }\n\t\n\t  // immediately followed by the id\n\t  if (null != obj.id) {\n\t    if (nsp) {\n\t      str += ',';\n\t      nsp = false;\n\t    }\n\t    str += obj.id;\n\t  }\n\t\n\t  // json data\n\t  if (null != obj.data) {\n\t    if (nsp) str += ',';\n\t    str += json.stringify(obj.data);\n\t  }\n\t\n\t  debug('encoded %j as %s', obj, str);\n\t  return str;\n\t}\n\t\n\t/**\n\t * Encode packet as 'buffer sequence' by removing blobs, and\n\t * deconstructing packet into object with placeholders and\n\t * a list of buffers.\n\t *\n\t * @param {Object} packet\n\t * @return {Buffer} encoded\n\t * @api private\n\t */\n\t\n\tfunction encodeAsBinary(obj, callback) {\n\t\n\t  function writeEncoding(bloblessData) {\n\t    var deconstruction = binary.deconstructPacket(bloblessData);\n\t    var pack = encodeAsString(deconstruction.packet);\n\t    var buffers = deconstruction.buffers;\n\t\n\t    buffers.unshift(pack); // add packet info to beginning of data list\n\t    callback(buffers); // write all the buffers\n\t  }\n\t\n\t  binary.removeBlobs(obj, writeEncoding);\n\t}\n\t\n\t/**\n\t * A socket.io Decoder instance\n\t *\n\t * @return {Object} decoder\n\t * @api public\n\t */\n\t\n\tfunction Decoder() {\n\t  this.reconstructor = null;\n\t}\n\t\n\t/**\n\t * Mix in `Emitter` with Decoder.\n\t */\n\t\n\tEmitter(Decoder.prototype);\n\t\n\t/**\n\t * Decodes an ecoded packet string into packet JSON.\n\t *\n\t * @param {String} obj - encoded packet\n\t * @return {Object} packet\n\t * @api public\n\t */\n\t\n\tDecoder.prototype.add = function(obj) {\n\t  var packet;\n\t  if ('string' == typeof obj) {\n\t    packet = decodeString(obj);\n\t    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json\n\t      this.reconstructor = new BinaryReconstructor(packet);\n\t\n\t      // no attachments, labeled binary but no binary data to follow\n\t      if (this.reconstructor.reconPack.attachments === 0) {\n\t        this.emit('decoded', packet);\n\t      }\n\t    } else { // non-binary full packet\n\t      this.emit('decoded', packet);\n\t    }\n\t  }\n\t  else if (isBuf(obj) || obj.base64) { // raw binary data\n\t    if (!this.reconstructor) {\n\t      throw new Error('got binary data when not reconstructing a packet');\n\t    } else {\n\t      packet = this.reconstructor.takeBinaryData(obj);\n\t      if (packet) { // received final buffer\n\t        this.reconstructor = null;\n\t        this.emit('decoded', packet);\n\t      }\n\t    }\n\t  }\n\t  else {\n\t    throw new Error('Unknown type: ' + obj);\n\t  }\n\t};\n\t\n\t/**\n\t * Decode a packet String (JSON data)\n\t *\n\t * @param {String} str\n\t * @return {Object} packet\n\t * @api private\n\t */\n\t\n\tfunction decodeString(str) {\n\t  var p = {};\n\t  var i = 0;\n\t\n\t  // look up type\n\t  p.type = Number(str.charAt(0));\n\t  if (null == exports.types[p.type]) return error();\n\t\n\t  // look up attachments if type binary\n\t  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {\n\t    var buf = '';\n\t    while (str.charAt(++i) != '-') {\n\t      buf += str.charAt(i);\n\t      if (i == str.length) break;\n\t    }\n\t    if (buf != Number(buf) || str.charAt(i) != '-') {\n\t      throw new Error('Illegal attachments');\n\t    }\n\t    p.attachments = Number(buf);\n\t  }\n\t\n\t  // look up namespace (if any)\n\t  if ('/' == str.charAt(i + 1)) {\n\t    p.nsp = '';\n\t    while (++i) {\n\t      var c = str.charAt(i);\n\t      if (',' == c) break;\n\t      p.nsp += c;\n\t      if (i == str.length) break;\n\t    }\n\t  } else {\n\t    p.nsp = '/';\n\t  }\n\t\n\t  // look up id\n\t  var next = str.charAt(i + 1);\n\t  if ('' !== next && Number(next) == next) {\n\t    p.id = '';\n\t    while (++i) {\n\t      var c = str.charAt(i);\n\t      if (null == c || Number(c) != c) {\n\t        --i;\n\t        break;\n\t      }\n\t      p.id += str.charAt(i);\n\t      if (i == str.length) break;\n\t    }\n\t    p.id = Number(p.id);\n\t  }\n\t\n\t  // look up json data\n\t  if (str.charAt(++i)) {\n\t    p = tryParse(p, str.substr(i));\n\t  }\n\t\n\t  debug('decoded %s as %j', str, p);\n\t  return p;\n\t}\n\t\n\tfunction tryParse(p, str) {\n\t  try {\n\t    p.data = json.parse(str);\n\t  } catch(e){\n\t    return error();\n\t  }\n\t  return p; \n\t};\n\t\n\t/**\n\t * Deallocates a parser's resources\n\t *\n\t * @api public\n\t */\n\t\n\tDecoder.prototype.destroy = function() {\n\t  if (this.reconstructor) {\n\t    this.reconstructor.finishedReconstruction();\n\t  }\n\t};\n\t\n\t/**\n\t * A manager of a binary event's 'buffer sequence'. Should\n\t * be constructed whenever a packet of type BINARY_EVENT is\n\t * decoded.\n\t *\n\t * @param {Object} packet\n\t * @return {BinaryReconstructor} initialized reconstructor\n\t * @api private\n\t */\n\t\n\tfunction BinaryReconstructor(packet) {\n\t  this.reconPack = packet;\n\t  this.buffers = [];\n\t}\n\t\n\t/**\n\t * Method to be called when binary data received from connection\n\t * after a BINARY_EVENT packet.\n\t *\n\t * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n\t * @return {null | Object} returns null if more binary data is expected or\n\t *   a reconstructed packet object if all buffers have been received.\n\t * @api private\n\t */\n\t\n\tBinaryReconstructor.prototype.takeBinaryData = function(binData) {\n\t  this.buffers.push(binData);\n\t  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list\n\t    var packet = binary.reconstructPacket(this.reconPack, this.buffers);\n\t    this.finishedReconstruction();\n\t    return packet;\n\t  }\n\t  return null;\n\t};\n\t\n\t/**\n\t * Cleans up binary packet reconstruction variables.\n\t *\n\t * @api private\n\t */\n\t\n\tBinaryReconstructor.prototype.finishedReconstruction = function() {\n\t  this.reconPack = null;\n\t  this.buffers = [];\n\t};\n\t\n\tfunction error(data){\n\t  return {\n\t    type: exports.ERROR,\n\t    data: 'parser error'\n\t  };\n\t}\n\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * This is the web browser implementation of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = __webpack_require__(79);\n\texports.log = log;\n\texports.formatArgs = formatArgs;\n\texports.save = save;\n\texports.load = load;\n\texports.useColors = useColors;\n\texports.storage = 'undefined' != typeof chrome\n\t               && 'undefined' != typeof chrome.storage\n\t                  ? chrome.storage.local\n\t                  : localstorage();\n\t\n\t/**\n\t * Colors.\n\t */\n\t\n\texports.colors = [\n\t  'lightseagreen',\n\t  'forestgreen',\n\t  'goldenrod',\n\t  'dodgerblue',\n\t  'darkorchid',\n\t  'crimson'\n\t];\n\t\n\t/**\n\t * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n\t * and the Firebug extension (any Firefox version) are known\n\t * to support \"%c\" CSS customizations.\n\t *\n\t * TODO: add a `localStorage` variable to explicitly enable/disable colors\n\t */\n\t\n\tfunction useColors() {\n\t  // is webkit? http://stackoverflow.com/a/16459606/376773\n\t  return ('WebkitAppearance' in document.documentElement.style) ||\n\t    // is firebug? http://stackoverflow.com/a/398120/376773\n\t    (window.console && (console.firebug || (console.exception && console.table))) ||\n\t    // is firefox >= v31?\n\t    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n\t}\n\t\n\t/**\n\t * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n\t */\n\t\n\texports.formatters.j = function(v) {\n\t  return JSON.stringify(v);\n\t};\n\t\n\t\n\t/**\n\t * Colorize log arguments if enabled.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction formatArgs() {\n\t  var args = arguments;\n\t  var useColors = this.useColors;\n\t\n\t  args[0] = (useColors ? '%c' : '')\n\t    + this.namespace\n\t    + (useColors ? ' %c' : ' ')\n\t    + args[0]\n\t    + (useColors ? '%c ' : ' ')\n\t    + '+' + exports.humanize(this.diff);\n\t\n\t  if (!useColors) return args;\n\t\n\t  var c = 'color: ' + this.color;\n\t  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\t\n\t  // the final \"%c\" is somewhat tricky, because there could be other\n\t  // arguments passed either before or after the %c, so we need to\n\t  // figure out the correct index to insert the CSS into\n\t  var index = 0;\n\t  var lastC = 0;\n\t  args[0].replace(/%[a-z%]/g, function(match) {\n\t    if ('%%' === match) return;\n\t    index++;\n\t    if ('%c' === match) {\n\t      // we only are interested in the *last* %c\n\t      // (the user may have provided their own)\n\t      lastC = index;\n\t    }\n\t  });\n\t\n\t  args.splice(lastC, 0, c);\n\t  return args;\n\t}\n\t\n\t/**\n\t * Invokes `console.log()` when available.\n\t * No-op when `console.log` is not a \"function\".\n\t *\n\t * @api public\n\t */\n\t\n\tfunction log() {\n\t  // this hackery is required for IE8/9, where\n\t  // the `console.log` function doesn't have 'apply'\n\t  return 'object' === typeof console\n\t    && console.log\n\t    && Function.prototype.apply.call(console.log, console, arguments);\n\t}\n\t\n\t/**\n\t * Save `namespaces`.\n\t *\n\t * @param {String} namespaces\n\t * @api private\n\t */\n\t\n\tfunction save(namespaces) {\n\t  try {\n\t    if (null == namespaces) {\n\t      exports.storage.removeItem('debug');\n\t    } else {\n\t      exports.storage.debug = namespaces;\n\t    }\n\t  } catch(e) {}\n\t}\n\t\n\t/**\n\t * Load `namespaces`.\n\t *\n\t * @return {String} returns the previously persisted debug modes\n\t * @api private\n\t */\n\t\n\tfunction load() {\n\t  var r;\n\t  try {\n\t    r = exports.storage.debug;\n\t  } catch(e) {}\n\t  return r;\n\t}\n\t\n\t/**\n\t * Enable namespaces listed in `localStorage.debug` initially.\n\t */\n\t\n\texports.enable(load());\n\t\n\t/**\n\t * Localstorage attempts to return the localstorage.\n\t *\n\t * This is necessary because safari throws\n\t * when a user disables cookies/localstorage\n\t * and you attempt to access it.\n\t *\n\t * @return {LocalStorage}\n\t * @api private\n\t */\n\t\n\tfunction localstorage(){\n\t  try {\n\t    return window.localStorage;\n\t  } catch (e) {}\n\t}\n\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * This is the common logic for both the Node.js and web browser\n\t * implementations of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = debug;\n\texports.coerce = coerce;\n\texports.disable = disable;\n\texports.enable = enable;\n\texports.enabled = enabled;\n\texports.humanize = __webpack_require__(80);\n\t\n\t/**\n\t * The currently active debug mode names, and names to skip.\n\t */\n\t\n\texports.names = [];\n\texports.skips = [];\n\t\n\t/**\n\t * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t *\n\t * Valid key names are a single, lowercased letter, i.e. \"n\".\n\t */\n\t\n\texports.formatters = {};\n\t\n\t/**\n\t * Previously assigned color.\n\t */\n\t\n\tvar prevColor = 0;\n\t\n\t/**\n\t * Previous log timestamp.\n\t */\n\t\n\tvar prevTime;\n\t\n\t/**\n\t * Select a color.\n\t *\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction selectColor() {\n\t  return exports.colors[prevColor++ % exports.colors.length];\n\t}\n\t\n\t/**\n\t * Create a debugger with the given `namespace`.\n\t *\n\t * @param {String} namespace\n\t * @return {Function}\n\t * @api public\n\t */\n\t\n\tfunction debug(namespace) {\n\t\n\t  // define the `disabled` version\n\t  function disabled() {\n\t  }\n\t  disabled.enabled = false;\n\t\n\t  // define the `enabled` version\n\t  function enabled() {\n\t\n\t    var self = enabled;\n\t\n\t    // set `diff` timestamp\n\t    var curr = +new Date();\n\t    var ms = curr - (prevTime || curr);\n\t    self.diff = ms;\n\t    self.prev = prevTime;\n\t    self.curr = curr;\n\t    prevTime = curr;\n\t\n\t    // add the `color` if not set\n\t    if (null == self.useColors) self.useColors = exports.useColors();\n\t    if (null == self.color && self.useColors) self.color = selectColor();\n\t\n\t    var args = Array.prototype.slice.call(arguments);\n\t\n\t    args[0] = exports.coerce(args[0]);\n\t\n\t    if ('string' !== typeof args[0]) {\n\t      // anything else let's inspect with %o\n\t      args = ['%o'].concat(args);\n\t    }\n\t\n\t    // apply any `formatters` transformations\n\t    var index = 0;\n\t    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n\t      // if we encounter an escaped % then don't increase the array index\n\t      if (match === '%%') return match;\n\t      index++;\n\t      var formatter = exports.formatters[format];\n\t      if ('function' === typeof formatter) {\n\t        var val = args[index];\n\t        match = formatter.call(self, val);\n\t\n\t        // now we need to remove `args[index]` since it's inlined in the `format`\n\t        args.splice(index, 1);\n\t        index--;\n\t      }\n\t      return match;\n\t    });\n\t\n\t    if ('function' === typeof exports.formatArgs) {\n\t      args = exports.formatArgs.apply(self, args);\n\t    }\n\t    var logFn = enabled.log || exports.log || console.log.bind(console);\n\t    logFn.apply(self, args);\n\t  }\n\t  enabled.enabled = true;\n\t\n\t  var fn = exports.enabled(namespace) ? enabled : disabled;\n\t\n\t  fn.namespace = namespace;\n\t\n\t  return fn;\n\t}\n\t\n\t/**\n\t * Enables a debug mode by namespaces. This can include modes\n\t * separated by a colon and wildcards.\n\t *\n\t * @param {String} namespaces\n\t * @api public\n\t */\n\t\n\tfunction enable(namespaces) {\n\t  exports.save(namespaces);\n\t\n\t  var split = (namespaces || '').split(/[\\s,]+/);\n\t  var len = split.length;\n\t\n\t  for (var i = 0; i < len; i++) {\n\t    if (!split[i]) continue; // ignore empty strings\n\t    namespaces = split[i].replace(/\\*/g, '.*?');\n\t    if (namespaces[0] === '-') {\n\t      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t    } else {\n\t      exports.names.push(new RegExp('^' + namespaces + '$'));\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Disable debug output.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction disable() {\n\t  exports.enable('');\n\t}\n\t\n\t/**\n\t * Returns true if the given mode name is enabled, false otherwise.\n\t *\n\t * @param {String} name\n\t * @return {Boolean}\n\t * @api public\n\t */\n\t\n\tfunction enabled(name) {\n\t  var i, len;\n\t  for (i = 0, len = exports.skips.length; i < len; i++) {\n\t    if (exports.skips[i].test(name)) {\n\t      return false;\n\t    }\n\t  }\n\t  for (i = 0, len = exports.names.length; i < len; i++) {\n\t    if (exports.names[i].test(name)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t * Coerce `val`.\n\t *\n\t * @param {Mixed} val\n\t * @return {Mixed}\n\t * @api private\n\t */\n\t\n\tfunction coerce(val) {\n\t  if (val instanceof Error) return val.stack || val.message;\n\t  return val;\n\t}\n\n\n/***/ },\n/* 80 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Helpers.\n\t */\n\t\n\tvar s = 1000;\n\tvar m = s * 60;\n\tvar h = m * 60;\n\tvar d = h * 24;\n\tvar y = d * 365.25;\n\t\n\t/**\n\t * Parse or format the given `val`.\n\t *\n\t * Options:\n\t *\n\t *  - `long` verbose formatting [false]\n\t *\n\t * @param {String|Number} val\n\t * @param {Object} options\n\t * @return {String|Number}\n\t * @api public\n\t */\n\t\n\tmodule.exports = function(val, options){\n\t  options = options || {};\n\t  if ('string' == typeof val) return parse(val);\n\t  return options.long\n\t    ? long(val)\n\t    : short(val);\n\t};\n\t\n\t/**\n\t * Parse the given `str` and return milliseconds.\n\t *\n\t * @param {String} str\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction parse(str) {\n\t  str = '' + str;\n\t  if (str.length > 10000) return;\n\t  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n\t  if (!match) return;\n\t  var n = parseFloat(match[1]);\n\t  var type = (match[2] || 'ms').toLowerCase();\n\t  switch (type) {\n\t    case 'years':\n\t    case 'year':\n\t    case 'yrs':\n\t    case 'yr':\n\t    case 'y':\n\t      return n * y;\n\t    case 'days':\n\t    case 'day':\n\t    case 'd':\n\t      return n * d;\n\t    case 'hours':\n\t    case 'hour':\n\t    case 'hrs':\n\t    case 'hr':\n\t    case 'h':\n\t      return n * h;\n\t    case 'minutes':\n\t    case 'minute':\n\t    case 'mins':\n\t    case 'min':\n\t    case 'm':\n\t      return n * m;\n\t    case 'seconds':\n\t    case 'second':\n\t    case 'secs':\n\t    case 'sec':\n\t    case 's':\n\t      return n * s;\n\t    case 'milliseconds':\n\t    case 'millisecond':\n\t    case 'msecs':\n\t    case 'msec':\n\t    case 'ms':\n\t      return n;\n\t  }\n\t}\n\t\n\t/**\n\t * Short format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction short(ms) {\n\t  if (ms >= d) return Math.round(ms / d) + 'd';\n\t  if (ms >= h) return Math.round(ms / h) + 'h';\n\t  if (ms >= m) return Math.round(ms / m) + 'm';\n\t  if (ms >= s) return Math.round(ms / s) + 's';\n\t  return ms + 'ms';\n\t}\n\t\n\t/**\n\t * Long format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction long(ms) {\n\t  return plural(ms, d, 'day')\n\t    || plural(ms, h, 'hour')\n\t    || plural(ms, m, 'minute')\n\t    || plural(ms, s, 'second')\n\t    || ms + ' ms';\n\t}\n\t\n\t/**\n\t * Pluralization helper.\n\t */\n\t\n\tfunction plural(ms, n, name) {\n\t  if (ms < n) return;\n\t  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n\t  return Math.ceil(ms / n) + ' ' + name + 's';\n\t}\n\n\n/***/ },\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */\n\t;(function () {\n\t  // Detect the `define` function exposed by asynchronous module loaders. The\n\t  // strict `define` check is necessary for compatibility with `r.js`.\n\t  var isLoader = \"function\" === \"function\" && __webpack_require__(83);\n\t\n\t  // A set of types used to distinguish objects from primitives.\n\t  var objectTypes = {\n\t    \"function\": true,\n\t    \"object\": true\n\t  };\n\t\n\t  // Detect the `exports` object exposed by CommonJS implementations.\n\t  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\t\n\t  // Use the `global` object exposed by Node (including Browserify via\n\t  // `insert-module-globals`), Narwhal, and Ringo as the default context,\n\t  // and the `window` object in browsers. Rhino exports a `global` function\n\t  // instead.\n\t  var root = objectTypes[typeof window] && window || this,\n\t      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == \"object\" && global;\n\t\n\t  if (freeGlobal && (freeGlobal[\"global\"] === freeGlobal || freeGlobal[\"window\"] === freeGlobal || freeGlobal[\"self\"] === freeGlobal)) {\n\t    root = freeGlobal;\n\t  }\n\t\n\t  // Public: Initializes JSON 3 using the given `context` object, attaching the\n\t  // `stringify` and `parse` functions to the specified `exports` object.\n\t  function runInContext(context, exports) {\n\t    context || (context = root[\"Object\"]());\n\t    exports || (exports = root[\"Object\"]());\n\t\n\t    // Native constructor aliases.\n\t    var Number = context[\"Number\"] || root[\"Number\"],\n\t        String = context[\"String\"] || root[\"String\"],\n\t        Object = context[\"Object\"] || root[\"Object\"],\n\t        Date = context[\"Date\"] || root[\"Date\"],\n\t        SyntaxError = context[\"SyntaxError\"] || root[\"SyntaxError\"],\n\t        TypeError = context[\"TypeError\"] || root[\"TypeError\"],\n\t        Math = context[\"Math\"] || root[\"Math\"],\n\t        nativeJSON = context[\"JSON\"] || root[\"JSON\"];\n\t\n\t    // Delegate to the native `stringify` and `parse` implementations.\n\t    if (typeof nativeJSON == \"object\" && nativeJSON) {\n\t      exports.stringify = nativeJSON.stringify;\n\t      exports.parse = nativeJSON.parse;\n\t    }\n\t\n\t    // Convenience aliases.\n\t    var objectProto = Object.prototype,\n\t        getClass = objectProto.toString,\n\t        isProperty, forEach, undef;\n\t\n\t    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\n\t    var isExtended = new Date(-3509827334573292);\n\t    try {\n\t      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\n\t      // results for certain dates in Opera >= 10.53.\n\t      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&\n\t        // Safari < 2.0.2 stores the internal millisecond time value correctly,\n\t        // but clips the values returned by the date methods to the range of\n\t        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\n\t        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\n\t    } catch (exception) {}\n\t\n\t    // Internal: Determines whether the native `JSON.stringify` and `parse`\n\t    // implementations are spec-compliant. Based on work by Ken Snyder.\n\t    function has(name) {\n\t      if (has[name] !== undef) {\n\t        // Return cached feature test result.\n\t        return has[name];\n\t      }\n\t      var isSupported;\n\t      if (name == \"bug-string-char-index\") {\n\t        // IE <= 7 doesn't support accessing string characters using square\n\t        // bracket notation. IE 8 only supports this for primitives.\n\t        isSupported = \"a\"[0] != \"a\";\n\t      } else if (name == \"json\") {\n\t        // Indicates whether both `JSON.stringify` and `JSON.parse` are\n\t        // supported.\n\t        isSupported = has(\"json-stringify\") && has(\"json-parse\");\n\t      } else {\n\t        var value, serialized = '{\"a\":[1,true,false,null,\"\\\\u0000\\\\b\\\\n\\\\f\\\\r\\\\t\"]}';\n\t        // Test `JSON.stringify`.\n\t        if (name == \"json-stringify\") {\n\t          var stringify = exports.stringify, stringifySupported = typeof stringify == \"function\" && isExtended;\n\t          if (stringifySupported) {\n\t            // A test function object with a custom `toJSON` method.\n\t            (value = function () {\n\t              return 1;\n\t            }).toJSON = value;\n\t            try {\n\t              stringifySupported =\n\t                // Firefox 3.1b1 and b2 serialize string, number, and boolean\n\t                // primitives as object literals.\n\t                stringify(0) === \"0\" &&\n\t                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\n\t                // literals.\n\t                stringify(new Number()) === \"0\" &&\n\t                stringify(new String()) == '\"\"' &&\n\t                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\n\t                // does not define a canonical JSON representation (this applies to\n\t                // objects with `toJSON` properties as well, *unless* they are nested\n\t                // within an object or array).\n\t                stringify(getClass) === undef &&\n\t                // IE 8 serializes `undefined` as `\"undefined\"`. Safari <= 5.1.7 and\n\t                // FF 3.1b3 pass this test.\n\t                stringify(undef) === undef &&\n\t                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\n\t                // respectively, if the value is omitted entirely.\n\t                stringify() === undef &&\n\t                // FF 3.1b1, 2 throw an error if the given value is not a number,\n\t                // string, array, object, Boolean, or `null` literal. This applies to\n\t                // objects with custom `toJSON` methods as well, unless they are nested\n\t                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\n\t                // methods entirely.\n\t                stringify(value) === \"1\" &&\n\t                stringify([value]) == \"[1]\" &&\n\t                // Prototype <= 1.6.1 serializes `[undefined]` as `\"[]\"` instead of\n\t                // `\"[null]\"`.\n\t                stringify([undef]) == \"[null]\" &&\n\t                // YUI 3.0.0b1 fails to serialize `null` literals.\n\t                stringify(null) == \"null\" &&\n\t                // FF 3.1b1, 2 halts serialization if an array contains a function:\n\t                // `[1, true, getClass, 1]` serializes as \"[1,true,],\". FF 3.1b3\n\t                // elides non-JSON values from objects and arrays, unless they\n\t                // define custom `toJSON` methods.\n\t                stringify([undef, getClass, null]) == \"[null,null,null]\" &&\n\t                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\n\t                // where character escape codes are expected (e.g., `\\b` => `\\u0008`).\n\t                stringify({ \"a\": [value, true, false, null, \"\\x00\\b\\n\\f\\r\\t\"] }) == serialized &&\n\t                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\n\t                stringify(null, value) === \"1\" &&\n\t                stringify([1, 2], null, 1) == \"[\\n 1,\\n 2\\n]\" &&\n\t                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\n\t                // serialize extended years.\n\t                stringify(new Date(-8.64e15)) == '\"-271821-04-20T00:00:00.000Z\"' &&\n\t                // The milliseconds are optional in ES 5, but required in 5.1.\n\t                stringify(new Date(8.64e15)) == '\"+275760-09-13T00:00:00.000Z\"' &&\n\t                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\n\t                // four-digit years instead of six-digit years. Credits: @Yaffle.\n\t                stringify(new Date(-621987552e5)) == '\"-000001-01-01T00:00:00.000Z\"' &&\n\t                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\n\t                // values less than 1000. Credits: @Yaffle.\n\t                stringify(new Date(-1)) == '\"1969-12-31T23:59:59.999Z\"';\n\t            } catch (exception) {\n\t              stringifySupported = false;\n\t            }\n\t          }\n\t          isSupported = stringifySupported;\n\t        }\n\t        // Test `JSON.parse`.\n\t        if (name == \"json-parse\") {\n\t          var parse = exports.parse;\n\t          if (typeof parse == \"function\") {\n\t            try {\n\t              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\n\t              // Conforming implementations should also coerce the initial argument to\n\t              // a string prior to parsing.\n\t              if (parse(\"0\") === 0 && !parse(false)) {\n\t                // Simple parsing test.\n\t                value = parse(serialized);\n\t                var parseSupported = value[\"a\"].length == 5 && value[\"a\"][0] === 1;\n\t                if (parseSupported) {\n\t                  try {\n\t                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\n\t                    parseSupported = !parse('\"\\t\"');\n\t                  } catch (exception) {}\n\t                  if (parseSupported) {\n\t                    try {\n\t                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading\n\t                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow\n\t                      // certain octal literals.\n\t                      parseSupported = parse(\"01\") !== 1;\n\t                    } catch (exception) {}\n\t                  }\n\t                  if (parseSupported) {\n\t                    try {\n\t                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal\n\t                      // points. These environments, along with FF 3.1b1 and 2,\n\t                      // also allow trailing commas in JSON objects and arrays.\n\t                      parseSupported = parse(\"1.\") !== 1;\n\t                    } catch (exception) {}\n\t                  }\n\t                }\n\t              }\n\t            } catch (exception) {\n\t              parseSupported = false;\n\t            }\n\t          }\n\t          isSupported = parseSupported;\n\t        }\n\t      }\n\t      return has[name] = !!isSupported;\n\t    }\n\t\n\t    if (!has(\"json\")) {\n\t      // Common `[[Class]]` name aliases.\n\t      var functionClass = \"[object Function]\",\n\t          dateClass = \"[object Date]\",\n\t          numberClass = \"[object Number]\",\n\t          stringClass = \"[object String]\",\n\t          arrayClass = \"[object Array]\",\n\t          booleanClass = \"[object Boolean]\";\n\t\n\t      // Detect incomplete support for accessing string characters by index.\n\t      var charIndexBuggy = has(\"bug-string-char-index\");\n\t\n\t      // Define additional utility methods if the `Date` methods are buggy.\n\t      if (!isExtended) {\n\t        var floor = Math.floor;\n\t        // A mapping between the months of the year and the number of days between\n\t        // January 1st and the first of the respective month.\n\t        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n\t        // Internal: Calculates the number of days between the Unix epoch and the\n\t        // first day of the given month.\n\t        var getDay = function (year, month) {\n\t          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\n\t        };\n\t      }\n\t\n\t      // Internal: Determines if a property is a direct property of the given\n\t      // object. Delegates to the native `Object#hasOwnProperty` method.\n\t      if (!(isProperty = objectProto.hasOwnProperty)) {\n\t        isProperty = function (property) {\n\t          var members = {}, constructor;\n\t          if ((members.__proto__ = null, members.__proto__ = {\n\t            // The *proto* property cannot be set multiple times in recent\n\t            // versions of Firefox and SeaMonkey.\n\t            \"toString\": 1\n\t          }, members).toString != getClass) {\n\t            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but\n\t            // supports the mutable *proto* property.\n\t            isProperty = function (property) {\n\t              // Capture and break the object's prototype chain (see section 8.6.2\n\t              // of the ES 5.1 spec). The parenthesized expression prevents an\n\t              // unsafe transformation by the Closure Compiler.\n\t              var original = this.__proto__, result = property in (this.__proto__ = null, this);\n\t              // Restore the original prototype chain.\n\t              this.__proto__ = original;\n\t              return result;\n\t            };\n\t          } else {\n\t            // Capture a reference to the top-level `Object` constructor.\n\t            constructor = members.constructor;\n\t            // Use the `constructor` property to simulate `Object#hasOwnProperty` in\n\t            // other environments.\n\t            isProperty = function (property) {\n\t              var parent = (this.constructor || constructor).prototype;\n\t              return property in this && !(property in parent && this[property] === parent[property]);\n\t            };\n\t          }\n\t          members = null;\n\t          return isProperty.call(this, property);\n\t        };\n\t      }\n\t\n\t      // Internal: Normalizes the `for...in` iteration algorithm across\n\t      // environments. Each enumerated key is yielded to a `callback` function.\n\t      forEach = function (object, callback) {\n\t        var size = 0, Properties, members, property;\n\t\n\t        // Tests for bugs in the current environment's `for...in` algorithm. The\n\t        // `valueOf` property inherits the non-enumerable flag from\n\t        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\n\t        (Properties = function () {\n\t          this.valueOf = 0;\n\t        }).prototype.valueOf = 0;\n\t\n\t        // Iterate over a new instance of the `Properties` class.\n\t        members = new Properties();\n\t        for (property in members) {\n\t          // Ignore all properties inherited from `Object.prototype`.\n\t          if (isProperty.call(members, property)) {\n\t            size++;\n\t          }\n\t        }\n\t        Properties = members = null;\n\t\n\t        // Normalize the iteration algorithm.\n\t        if (!size) {\n\t          // A list of non-enumerable properties inherited from `Object.prototype`.\n\t          members = [\"valueOf\", \"toString\", \"toLocaleString\", \"propertyIsEnumerable\", \"isPrototypeOf\", \"hasOwnProperty\", \"constructor\"];\n\t          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\n\t          // properties.\n\t          forEach = function (object, callback) {\n\t            var isFunction = getClass.call(object) == functionClass, property, length;\n\t            var hasProperty = !isFunction && typeof object.constructor != \"function\" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;\n\t            for (property in object) {\n\t              // Gecko <= 1.0 enumerates the `prototype` property of functions under\n\t              // certain conditions; IE does not.\n\t              if (!(isFunction && property == \"prototype\") && hasProperty.call(object, property)) {\n\t                callback(property);\n\t              }\n\t            }\n\t            // Manually invoke the callback for each non-enumerable property.\n\t            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));\n\t          };\n\t        } else if (size == 2) {\n\t          // Safari <= 2.0.4 enumerates shadowed properties twice.\n\t          forEach = function (object, callback) {\n\t            // Create a set of iterated properties.\n\t            var members = {}, isFunction = getClass.call(object) == functionClass, property;\n\t            for (property in object) {\n\t              // Store each property name to prevent double enumeration. The\n\t              // `prototype` property of functions is not enumerated due to cross-\n\t              // environment inconsistencies.\n\t              if (!(isFunction && property == \"prototype\") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {\n\t                callback(property);\n\t              }\n\t            }\n\t          };\n\t        } else {\n\t          // No bugs detected; use the standard `for...in` algorithm.\n\t          forEach = function (object, callback) {\n\t            var isFunction = getClass.call(object) == functionClass, property, isConstructor;\n\t            for (property in object) {\n\t              if (!(isFunction && property == \"prototype\") && isProperty.call(object, property) && !(isConstructor = property === \"constructor\")) {\n\t                callback(property);\n\t              }\n\t            }\n\t            // Manually invoke the callback for the `constructor` property due to\n\t            // cross-environment inconsistencies.\n\t            if (isConstructor || isProperty.call(object, (property = \"constructor\"))) {\n\t              callback(property);\n\t            }\n\t          };\n\t        }\n\t        return forEach(object, callback);\n\t      };\n\t\n\t      // Public: Serializes a JavaScript `value` as a JSON string. The optional\n\t      // `filter` argument may specify either a function that alters how object and\n\t      // array members are serialized, or an array of strings and numbers that\n\t      // indicates which properties should be serialized. The optional `width`\n\t      // argument may be either a string or number that specifies the indentation\n\t      // level of the output.\n\t      if (!has(\"json-stringify\")) {\n\t        // Internal: A map of control characters and their escaped equivalents.\n\t        var Escapes = {\n\t          92: \"\\\\\\\\\",\n\t          34: '\\\\\"',\n\t          8: \"\\\\b\",\n\t          12: \"\\\\f\",\n\t          10: \"\\\\n\",\n\t          13: \"\\\\r\",\n\t          9: \"\\\\t\"\n\t        };\n\t\n\t        // Internal: Converts `value` into a zero-padded string such that its\n\t        // length is at least equal to `width`. The `width` must be <= 6.\n\t        var leadingZeroes = \"000000\";\n\t        var toPaddedString = function (width, value) {\n\t          // The `|| 0` expression is necessary to work around a bug in\n\t          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== \"0\"`.\n\t          return (leadingZeroes + (value || 0)).slice(-width);\n\t        };\n\t\n\t        // Internal: Double-quotes a string `value`, replacing all ASCII control\n\t        // characters (characters with code unit values between 0 and 31) with\n\t        // their escaped equivalents. This is an implementation of the\n\t        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\n\t        var unicodePrefix = \"\\\\u00\";\n\t        var quote = function (value) {\n\t          var result = '\"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;\n\t          var symbols = useCharIndex && (charIndexBuggy ? value.split(\"\") : value);\n\t          for (; index < length; index++) {\n\t            var charCode = value.charCodeAt(index);\n\t            // If the character is a control character, append its Unicode or\n\t            // shorthand escape sequence; otherwise, append the character as-is.\n\t            switch (charCode) {\n\t              case 8: case 9: case 10: case 12: case 13: case 34: case 92:\n\t                result += Escapes[charCode];\n\t                break;\n\t              default:\n\t                if (charCode < 32) {\n\t                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));\n\t                  break;\n\t                }\n\t                result += useCharIndex ? symbols[index] : value.charAt(index);\n\t            }\n\t          }\n\t          return result + '\"';\n\t        };\n\t\n\t        // Internal: Recursively serializes an object. Implements the\n\t        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\n\t        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {\n\t          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\n\t          try {\n\t            // Necessary for host object support.\n\t            value = object[property];\n\t          } catch (exception) {}\n\t          if (typeof value == \"object\" && value) {\n\t            className = getClass.call(value);\n\t            if (className == dateClass && !isProperty.call(value, \"toJSON\")) {\n\t              if (value > -1 / 0 && value < 1 / 0) {\n\t                // Dates are serialized according to the `Date#toJSON` method\n\t                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\n\t                // for the ISO 8601 date time string format.\n\t                if (getDay) {\n\t                  // Manually compute the year, month, date, hours, minutes,\n\t                  // seconds, and milliseconds if the `getUTC*` methods are\n\t                  // buggy. Adapted from @Yaffle's `date-shim` project.\n\t                  date = floor(value / 864e5);\n\t                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);\n\t                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);\n\t                  date = 1 + date - getDay(year, month);\n\t                  // The `time` value specifies the time within the day (see ES\n\t                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\n\t                  // to compute `A modulo B`, as the `%` operator does not\n\t                  // correspond to the `modulo` operation for negative numbers.\n\t                  time = (value % 864e5 + 864e5) % 864e5;\n\t                  // The hours, minutes, seconds, and milliseconds are obtained by\n\t                  // decomposing the time within the day. See section 15.9.1.10.\n\t                  hours = floor(time / 36e5) % 24;\n\t                  minutes = floor(time / 6e4) % 60;\n\t                  seconds = floor(time / 1e3) % 60;\n\t                  milliseconds = time % 1e3;\n\t                } else {\n\t                  year = value.getUTCFullYear();\n\t                  month = value.getUTCMonth();\n\t                  date = value.getUTCDate();\n\t                  hours = value.getUTCHours();\n\t                  minutes = value.getUTCMinutes();\n\t                  seconds = value.getUTCSeconds();\n\t                  milliseconds = value.getUTCMilliseconds();\n\t                }\n\t                // Serialize extended years correctly.\n\t                value = (year <= 0 || year >= 1e4 ? (year < 0 ? \"-\" : \"+\") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +\n\t                  \"-\" + toPaddedString(2, month + 1) + \"-\" + toPaddedString(2, date) +\n\t                  // Months, dates, hours, minutes, and seconds should have two\n\t                  // digits; milliseconds should have three.\n\t                  \"T\" + toPaddedString(2, hours) + \":\" + toPaddedString(2, minutes) + \":\" + toPaddedString(2, seconds) +\n\t                  // Milliseconds are optional in ES 5.0, but required in 5.1.\n\t                  \".\" + toPaddedString(3, milliseconds) + \"Z\";\n\t              } else {\n\t                value = null;\n\t              }\n\t            } else if (typeof value.toJSON == \"function\" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, \"toJSON\"))) {\n\t              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\n\t              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\n\t              // ignores all `toJSON` methods on these objects unless they are\n\t              // defined directly on an instance.\n\t              value = value.toJSON(property);\n\t            }\n\t          }\n\t          if (callback) {\n\t            // If a replacement function was provided, call it to obtain the value\n\t            // for serialization.\n\t            value = callback.call(object, property, value);\n\t          }\n\t          if (value === null) {\n\t            return \"null\";\n\t          }\n\t          className = getClass.call(value);\n\t          if (className == booleanClass) {\n\t            // Booleans are represented literally.\n\t            return \"\" + value;\n\t          } else if (className == numberClass) {\n\t            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\n\t            // `\"null\"`.\n\t            return value > -1 / 0 && value < 1 / 0 ? \"\" + value : \"null\";\n\t          } else if (className == stringClass) {\n\t            // Strings are double-quoted and escaped.\n\t            return quote(\"\" + value);\n\t          }\n\t          // Recursively serialize objects and arrays.\n\t          if (typeof value == \"object\") {\n\t            // Check for cyclic structures. This is a linear search; performance\n\t            // is inversely proportional to the number of unique nested objects.\n\t            for (length = stack.length; length--;) {\n\t              if (stack[length] === value) {\n\t                // Cyclic structures cannot be serialized by `JSON.stringify`.\n\t                throw TypeError();\n\t              }\n\t            }\n\t            // Add the object to the stack of traversed objects.\n\t            stack.push(value);\n\t            results = [];\n\t            // Save the current indentation level and indent one additional level.\n\t            prefix = indentation;\n\t            indentation += whitespace;\n\t            if (className == arrayClass) {\n\t              // Recursively serialize array elements.\n\t              for (index = 0, length = value.length; index < length; index++) {\n\t                element = serialize(index, value, callback, properties, whitespace, indentation, stack);\n\t                results.push(element === undef ? \"null\" : element);\n\t              }\n\t              result = results.length ? (whitespace ? \"[\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"]\" : (\"[\" + results.join(\",\") + \"]\")) : \"[]\";\n\t            } else {\n\t              // Recursively serialize object members. Members are selected from\n\t              // either a user-specified list of property names, or the object\n\t              // itself.\n\t              forEach(properties || value, function (property) {\n\t                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\n\t                if (element !== undef) {\n\t                  // According to ES 5.1 section 15.12.3: \"If `gap` {whitespace}\n\t                  // is not the empty string, let `member` {quote(property) + \":\"}\n\t                  // be the concatenation of `member` and the `space` character.\"\n\t                  // The \"`space` character\" refers to the literal space\n\t                  // character, not the `space` {width} argument provided to\n\t                  // `JSON.stringify`.\n\t                  results.push(quote(property) + \":\" + (whitespace ? \" \" : \"\") + element);\n\t                }\n\t              });\n\t              result = results.length ? (whitespace ? \"{\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"}\" : (\"{\" + results.join(\",\") + \"}\")) : \"{}\";\n\t            }\n\t            // Remove the object from the traversed object stack.\n\t            stack.pop();\n\t            return result;\n\t          }\n\t        };\n\t\n\t        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\n\t        exports.stringify = function (source, filter, width) {\n\t          var whitespace, callback, properties, className;\n\t          if (objectTypes[typeof filter] && filter) {\n\t            if ((className = getClass.call(filter)) == functionClass) {\n\t              callback = filter;\n\t            } else if (className == arrayClass) {\n\t              // Convert the property names array into a makeshift set.\n\t              properties = {};\n\t              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));\n\t            }\n\t          }\n\t          if (width) {\n\t            if ((className = getClass.call(width)) == numberClass) {\n\t              // Convert the `width` to an integer and create a string containing\n\t              // `width` number of space characters.\n\t              if ((width -= width % 1) > 0) {\n\t                for (whitespace = \"\", width > 10 && (width = 10); whitespace.length < width; whitespace += \" \");\n\t              }\n\t            } else if (className == stringClass) {\n\t              whitespace = width.length <= 10 ? width : width.slice(0, 10);\n\t            }\n\t          }\n\t          // Opera <= 7.54u2 discards the values associated with empty string keys\n\t          // (`\"\"`) only if they are used directly within an object member list\n\t          // (e.g., `!(\"\" in { \"\": 1})`).\n\t          return serialize(\"\", (value = {}, value[\"\"] = source, value), callback, properties, whitespace, \"\", []);\n\t        };\n\t      }\n\t\n\t      // Public: Parses a JSON source string.\n\t      if (!has(\"json-parse\")) {\n\t        var fromCharCode = String.fromCharCode;\n\t\n\t        // Internal: A map of escaped control characters and their unescaped\n\t        // equivalents.\n\t        var Unescapes = {\n\t          92: \"\\\\\",\n\t          34: '\"',\n\t          47: \"/\",\n\t          98: \"\\b\",\n\t          116: \"\\t\",\n\t          110: \"\\n\",\n\t          102: \"\\f\",\n\t          114: \"\\r\"\n\t        };\n\t\n\t        // Internal: Stores the parser state.\n\t        var Index, Source;\n\t\n\t        // Internal: Resets the parser state and throws a `SyntaxError`.\n\t        var abort = function () {\n\t          Index = Source = null;\n\t          throw SyntaxError();\n\t        };\n\t\n\t        // Internal: Returns the next token, or `\"$\"` if the parser has reached\n\t        // the end of the source string. A token may be a string, number, `null`\n\t        // literal, or Boolean literal.\n\t        var lex = function () {\n\t          var source = Source, length = source.length, value, begin, position, isSigned, charCode;\n\t          while (Index < length) {\n\t            charCode = source.charCodeAt(Index);\n\t            switch (charCode) {\n\t              case 9: case 10: case 13: case 32:\n\t                // Skip whitespace tokens, including tabs, carriage returns, line\n\t                // feeds, and space characters.\n\t                Index++;\n\t                break;\n\t              case 123: case 125: case 91: case 93: case 58: case 44:\n\t                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at\n\t                // the current position.\n\t                value = charIndexBuggy ? source.charAt(Index) : source[Index];\n\t                Index++;\n\t                return value;\n\t              case 34:\n\t                // `\"` delimits a JSON string; advance to the next character and\n\t                // begin parsing the string. String tokens are prefixed with the\n\t                // sentinel `@` character to distinguish them from punctuators and\n\t                // end-of-string tokens.\n\t                for (value = \"@\", Index++; Index < length;) {\n\t                  charCode = source.charCodeAt(Index);\n\t                  if (charCode < 32) {\n\t                    // Unescaped ASCII control characters (those with a code unit\n\t                    // less than the space character) are not permitted.\n\t                    abort();\n\t                  } else if (charCode == 92) {\n\t                    // A reverse solidus (`\\`) marks the beginning of an escaped\n\t                    // control character (including `\"`, `\\`, and `/`) or Unicode\n\t                    // escape sequence.\n\t                    charCode = source.charCodeAt(++Index);\n\t                    switch (charCode) {\n\t                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:\n\t                        // Revive escaped control characters.\n\t                        value += Unescapes[charCode];\n\t                        Index++;\n\t                        break;\n\t                      case 117:\n\t                        // `\\u` marks the beginning of a Unicode escape sequence.\n\t                        // Advance to the first character and validate the\n\t                        // four-digit code point.\n\t                        begin = ++Index;\n\t                        for (position = Index + 4; Index < position; Index++) {\n\t                          charCode = source.charCodeAt(Index);\n\t                          // A valid sequence comprises four hexdigits (case-\n\t                          // insensitive) that form a single hexadecimal value.\n\t                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\n\t                            // Invalid Unicode escape sequence.\n\t                            abort();\n\t                          }\n\t                        }\n\t                        // Revive the escaped character.\n\t                        value += fromCharCode(\"0x\" + source.slice(begin, Index));\n\t                        break;\n\t                      default:\n\t                        // Invalid escape sequence.\n\t                        abort();\n\t                    }\n\t                  } else {\n\t                    if (charCode == 34) {\n\t                      // An unescaped double-quote character marks the end of the\n\t                      // string.\n\t                      break;\n\t                    }\n\t                    charCode = source.charCodeAt(Index);\n\t                    begin = Index;\n\t                    // Optimize for the common case where a string is valid.\n\t                    while (charCode >= 32 && charCode != 92 && charCode != 34) {\n\t                      charCode = source.charCodeAt(++Index);\n\t                    }\n\t                    // Append the string as-is.\n\t                    value += source.slice(begin, Index);\n\t                  }\n\t                }\n\t                if (source.charCodeAt(Index) == 34) {\n\t                  // Advance to the next character and return the revived string.\n\t                  Index++;\n\t                  return value;\n\t                }\n\t                // Unterminated string.\n\t                abort();\n\t              default:\n\t                // Parse numbers and literals.\n\t                begin = Index;\n\t                // Advance past the negative sign, if one is specified.\n\t                if (charCode == 45) {\n\t                  isSigned = true;\n\t                  charCode = source.charCodeAt(++Index);\n\t                }\n\t                // Parse an integer or floating-point value.\n\t                if (charCode >= 48 && charCode <= 57) {\n\t                  // Leading zeroes are interpreted as octal literals.\n\t                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {\n\t                    // Illegal octal literal.\n\t                    abort();\n\t                  }\n\t                  isSigned = false;\n\t                  // Parse the integer component.\n\t                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);\n\t                  // Floats cannot contain a leading decimal point; however, this\n\t                  // case is already accounted for by the parser.\n\t                  if (source.charCodeAt(Index) == 46) {\n\t                    position = ++Index;\n\t                    // Parse the decimal component.\n\t                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n\t                    if (position == Index) {\n\t                      // Illegal trailing decimal.\n\t                      abort();\n\t                    }\n\t                    Index = position;\n\t                  }\n\t                  // Parse exponents. The `e` denoting the exponent is\n\t                  // case-insensitive.\n\t                  charCode = source.charCodeAt(Index);\n\t                  if (charCode == 101 || charCode == 69) {\n\t                    charCode = source.charCodeAt(++Index);\n\t                    // Skip past the sign following the exponent, if one is\n\t                    // specified.\n\t                    if (charCode == 43 || charCode == 45) {\n\t                      Index++;\n\t                    }\n\t                    // Parse the exponential component.\n\t                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n\t                    if (position == Index) {\n\t                      // Illegal empty exponent.\n\t                      abort();\n\t                    }\n\t                    Index = position;\n\t                  }\n\t                  // Coerce the parsed value to a JavaScript number.\n\t                  return +source.slice(begin, Index);\n\t                }\n\t                // A negative sign may only precede numbers.\n\t                if (isSigned) {\n\t                  abort();\n\t                }\n\t                // `true`, `false`, and `null` literals.\n\t                if (source.slice(Index, Index + 4) == \"true\") {\n\t                  Index += 4;\n\t                  return true;\n\t                } else if (source.slice(Index, Index + 5) == \"false\") {\n\t                  Index += 5;\n\t                  return false;\n\t                } else if (source.slice(Index, Index + 4) == \"null\") {\n\t                  Index += 4;\n\t                  return null;\n\t                }\n\t                // Unrecognized token.\n\t                abort();\n\t            }\n\t          }\n\t          // Return the sentinel `$` character if the parser has reached the end\n\t          // of the source string.\n\t          return \"$\";\n\t        };\n\t\n\t        // Internal: Parses a JSON `value` token.\n\t        var get = function (value) {\n\t          var results, hasMembers;\n\t          if (value == \"$\") {\n\t            // Unexpected end of input.\n\t            abort();\n\t          }\n\t          if (typeof value == \"string\") {\n\t            if ((charIndexBuggy ? value.charAt(0) : value[0]) == \"@\") {\n\t              // Remove the sentinel `@` character.\n\t              return value.slice(1);\n\t            }\n\t            // Parse object and array literals.\n\t            if (value == \"[\") {\n\t              // Parses a JSON array, returning a new JavaScript array.\n\t              results = [];\n\t              for (;; hasMembers || (hasMembers = true)) {\n\t                value = lex();\n\t                // A closing square bracket marks the end of the array literal.\n\t                if (value == \"]\") {\n\t                  break;\n\t                }\n\t                // If the array literal contains elements, the current token\n\t                // should be a comma separating the previous element from the\n\t                // next.\n\t                if (hasMembers) {\n\t                  if (value == \",\") {\n\t                    value = lex();\n\t                    if (value == \"]\") {\n\t                      // Unexpected trailing `,` in array literal.\n\t                      abort();\n\t                    }\n\t                  } else {\n\t                    // A `,` must separate each array element.\n\t                    abort();\n\t                  }\n\t                }\n\t                // Elisions and leading commas are not permitted.\n\t                if (value == \",\") {\n\t                  abort();\n\t                }\n\t                results.push(get(value));\n\t              }\n\t              return results;\n\t            } else if (value == \"{\") {\n\t              // Parses a JSON object, returning a new JavaScript object.\n\t              results = {};\n\t              for (;; hasMembers || (hasMembers = true)) {\n\t                value = lex();\n\t                // A closing curly brace marks the end of the object literal.\n\t                if (value == \"}\") {\n\t                  break;\n\t                }\n\t                // If the object literal contains members, the current token\n\t                // should be a comma separator.\n\t                if (hasMembers) {\n\t                  if (value == \",\") {\n\t                    value = lex();\n\t                    if (value == \"}\") {\n\t                      // Unexpected trailing `,` in object literal.\n\t                      abort();\n\t                    }\n\t                  } else {\n\t                    // A `,` must separate each object member.\n\t                    abort();\n\t                  }\n\t                }\n\t                // Leading commas are not permitted, object property names must be\n\t                // double-quoted strings, and a `:` must separate each property\n\t                // name and value.\n\t                if (value == \",\" || typeof value != \"string\" || (charIndexBuggy ? value.charAt(0) : value[0]) != \"@\" || lex() != \":\") {\n\t                  abort();\n\t                }\n\t                results[value.slice(1)] = get(lex());\n\t              }\n\t              return results;\n\t            }\n\t            // Unexpected token encountered.\n\t            abort();\n\t          }\n\t          return value;\n\t        };\n\t\n\t        // Internal: Updates a traversed object member.\n\t        var update = function (source, property, callback) {\n\t          var element = walk(source, property, callback);\n\t          if (element === undef) {\n\t            delete source[property];\n\t          } else {\n\t            source[property] = element;\n\t          }\n\t        };\n\t\n\t        // Internal: Recursively traverses a parsed JSON object, invoking the\n\t        // `callback` function for each value. This is an implementation of the\n\t        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\n\t        var walk = function (source, property, callback) {\n\t          var value = source[property], length;\n\t          if (typeof value == \"object\" && value) {\n\t            // `forEach` can't be used to traverse an array in Opera <= 8.54\n\t            // because its `Object#hasOwnProperty` implementation returns `false`\n\t            // for array indices (e.g., `![1, 2, 3].hasOwnProperty(\"0\")`).\n\t            if (getClass.call(value) == arrayClass) {\n\t              for (length = value.length; length--;) {\n\t                update(value, length, callback);\n\t              }\n\t            } else {\n\t              forEach(value, function (property) {\n\t                update(value, property, callback);\n\t              });\n\t            }\n\t          }\n\t          return callback.call(source, property, value);\n\t        };\n\t\n\t        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\n\t        exports.parse = function (source, callback) {\n\t          var result, value;\n\t          Index = 0;\n\t          Source = \"\" + source;\n\t          result = get(lex());\n\t          // If a JSON string contains multiple tokens, it is invalid.\n\t          if (lex() != \"$\") {\n\t            abort();\n\t          }\n\t          // Reset the parser state.\n\t          Index = Source = null;\n\t          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[\"\"] = result, value), \"\", callback) : result;\n\t        };\n\t      }\n\t    }\n\t\n\t    exports[\"runInContext\"] = runInContext;\n\t    return exports;\n\t  }\n\t\n\t  if (freeExports && !isLoader) {\n\t    // Export for CommonJS environments.\n\t    runInContext(root, freeExports);\n\t  } else {\n\t    // Export for web browsers and JavaScript engines.\n\t    var nativeJSON = root.JSON,\n\t        previousJSON = root[\"JSON3\"],\n\t        isRestored = false;\n\t\n\t    var JSON3 = runInContext(root, (root[\"JSON3\"] = {\n\t      // Public: Restores the original value of the global `JSON` object and\n\t      // returns a reference to the `JSON3` object.\n\t      \"noConflict\": function () {\n\t        if (!isRestored) {\n\t          isRestored = true;\n\t          root.JSON = nativeJSON;\n\t          root[\"JSON3\"] = previousJSON;\n\t          nativeJSON = previousJSON = null;\n\t        }\n\t        return JSON3;\n\t      }\n\t    }));\n\t\n\t    root.JSON = {\n\t      \"parse\": JSON3.parse,\n\t      \"stringify\": JSON3.stringify\n\t    };\n\t  }\n\t\n\t  // Export for asynchronous module loaders.\n\t  if (isLoader) {\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t      return JSON3;\n\t    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  }\n\t}).call(this);\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(82)(module), (function() { return this; }())))\n\n/***/ },\n/* 82 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ },\n/* 83 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;\r\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, {}))\n\n/***/ },\n/* 84 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * Expose `Emitter`.\n\t */\n\t\n\tmodule.exports = Emitter;\n\t\n\t/**\n\t * Initialize a new `Emitter`.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction Emitter(obj) {\n\t  if (obj) return mixin(obj);\n\t};\n\t\n\t/**\n\t * Mixin the emitter properties.\n\t *\n\t * @param {Object} obj\n\t * @return {Object}\n\t * @api private\n\t */\n\t\n\tfunction mixin(obj) {\n\t  for (var key in Emitter.prototype) {\n\t    obj[key] = Emitter.prototype[key];\n\t  }\n\t  return obj;\n\t}\n\t\n\t/**\n\t * Listen on the given `event` with `fn`.\n\t *\n\t * @param {String} event\n\t * @param {Function} fn\n\t * @return {Emitter}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.on =\n\tEmitter.prototype.addEventListener = function(event, fn){\n\t  this._callbacks = this._callbacks || {};\n\t  (this._callbacks[event] = this._callbacks[event] || [])\n\t    .push(fn);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Adds an `event` listener that will be invoked a single\n\t * time then automatically removed.\n\t *\n\t * @param {String} event\n\t * @param {Function} fn\n\t * @return {Emitter}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.once = function(event, fn){\n\t  var self = this;\n\t  this._callbacks = this._callbacks || {};\n\t\n\t  function on() {\n\t    self.off(event, on);\n\t    fn.apply(this, arguments);\n\t  }\n\t\n\t  on.fn = fn;\n\t  this.on(event, on);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove the given callback for `event` or all\n\t * registered callbacks.\n\t *\n\t * @param {String} event\n\t * @param {Function} fn\n\t * @return {Emitter}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.off =\n\tEmitter.prototype.removeListener =\n\tEmitter.prototype.removeAllListeners =\n\tEmitter.prototype.removeEventListener = function(event, fn){\n\t  this._callbacks = this._callbacks || {};\n\t\n\t  // all\n\t  if (0 == arguments.length) {\n\t    this._callbacks = {};\n\t    return this;\n\t  }\n\t\n\t  // specific event\n\t  var callbacks = this._callbacks[event];\n\t  if (!callbacks) return this;\n\t\n\t  // remove all handlers\n\t  if (1 == arguments.length) {\n\t    delete this._callbacks[event];\n\t    return this;\n\t  }\n\t\n\t  // remove specific handler\n\t  var cb;\n\t  for (var i = 0; i < callbacks.length; i++) {\n\t    cb = callbacks[i];\n\t    if (cb === fn || cb.fn === fn) {\n\t      callbacks.splice(i, 1);\n\t      break;\n\t    }\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t * Emit `event` with the given args.\n\t *\n\t * @param {String} event\n\t * @param {Mixed} ...\n\t * @return {Emitter}\n\t */\n\t\n\tEmitter.prototype.emit = function(event){\n\t  this._callbacks = this._callbacks || {};\n\t  var args = [].slice.call(arguments, 1)\n\t    , callbacks = this._callbacks[event];\n\t\n\t  if (callbacks) {\n\t    callbacks = callbacks.slice(0);\n\t    for (var i = 0, len = callbacks.length; i < len; ++i) {\n\t      callbacks[i].apply(this, args);\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Return array of callbacks for `event`.\n\t *\n\t * @param {String} event\n\t * @return {Array}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.listeners = function(event){\n\t  this._callbacks = this._callbacks || {};\n\t  return this._callbacks[event] || [];\n\t};\n\t\n\t/**\n\t * Check if this emitter has `event` handlers.\n\t *\n\t * @param {String} event\n\t * @return {Boolean}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.hasListeners = function(event){\n\t  return !! this.listeners(event).length;\n\t};\n\n\n/***/ },\n/* 85 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/*global Blob,File*/\n\t\n\t/**\n\t * Module requirements\n\t */\n\t\n\tvar isArray = __webpack_require__(86);\n\tvar isBuf = __webpack_require__(87);\n\t\n\t/**\n\t * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.\n\t * Anything with blobs or files should be fed through removeBlobs before coming\n\t * here.\n\t *\n\t * @param {Object} packet - socket.io event packet\n\t * @return {Object} with deconstructed packet and list of buffers\n\t * @api public\n\t */\n\t\n\texports.deconstructPacket = function(packet){\n\t  var buffers = [];\n\t  var packetData = packet.data;\n\t\n\t  function _deconstructPacket(data) {\n\t    if (!data) return data;\n\t\n\t    if (isBuf(data)) {\n\t      var placeholder = { _placeholder: true, num: buffers.length };\n\t      buffers.push(data);\n\t      return placeholder;\n\t    } else if (isArray(data)) {\n\t      var newData = new Array(data.length);\n\t      for (var i = 0; i < data.length; i++) {\n\t        newData[i] = _deconstructPacket(data[i]);\n\t      }\n\t      return newData;\n\t    } else if ('object' == typeof data && !(data instanceof Date)) {\n\t      var newData = {};\n\t      for (var key in data) {\n\t        newData[key] = _deconstructPacket(data[key]);\n\t      }\n\t      return newData;\n\t    }\n\t    return data;\n\t  }\n\t\n\t  var pack = packet;\n\t  pack.data = _deconstructPacket(packetData);\n\t  pack.attachments = buffers.length; // number of binary 'attachments'\n\t  return {packet: pack, buffers: buffers};\n\t};\n\t\n\t/**\n\t * Reconstructs a binary packet from its placeholder packet and buffers\n\t *\n\t * @param {Object} packet - event packet with placeholders\n\t * @param {Array} buffers - binary buffers to put in placeholder positions\n\t * @return {Object} reconstructed packet\n\t * @api public\n\t */\n\t\n\texports.reconstructPacket = function(packet, buffers) {\n\t  var curPlaceHolder = 0;\n\t\n\t  function _reconstructPacket(data) {\n\t    if (data && data._placeholder) {\n\t      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)\n\t      return buf;\n\t    } else if (isArray(data)) {\n\t      for (var i = 0; i < data.length; i++) {\n\t        data[i] = _reconstructPacket(data[i]);\n\t      }\n\t      return data;\n\t    } else if (data && 'object' == typeof data) {\n\t      for (var key in data) {\n\t        data[key] = _reconstructPacket(data[key]);\n\t      }\n\t      return data;\n\t    }\n\t    return data;\n\t  }\n\t\n\t  packet.data = _reconstructPacket(packet.data);\n\t  packet.attachments = undefined; // no longer useful\n\t  return packet;\n\t};\n\t\n\t/**\n\t * Asynchronously removes Blobs or Files from data via\n\t * FileReader's readAsArrayBuffer method. Used before encoding\n\t * data as msgpack. Calls callback with the blobless data.\n\t *\n\t * @param {Object} data\n\t * @param {Function} callback\n\t * @api private\n\t */\n\t\n\texports.removeBlobs = function(data, callback) {\n\t  function _removeBlobs(obj, curKey, containingObject) {\n\t    if (!obj) return obj;\n\t\n\t    // convert any blob\n\t    if ((global.Blob && obj instanceof Blob) ||\n\t        (global.File && obj instanceof File)) {\n\t      pendingBlobs++;\n\t\n\t      // async filereader\n\t      var fileReader = new FileReader();\n\t      fileReader.onload = function() { // this.result == arraybuffer\n\t        if (containingObject) {\n\t          containingObject[curKey] = this.result;\n\t        }\n\t        else {\n\t          bloblessData = this.result;\n\t        }\n\t\n\t        // if nothing pending its callback time\n\t        if(! --pendingBlobs) {\n\t          callback(bloblessData);\n\t        }\n\t      };\n\t\n\t      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer\n\t    } else if (isArray(obj)) { // handle array\n\t      for (var i = 0; i < obj.length; i++) {\n\t        _removeBlobs(obj[i], i, obj);\n\t      }\n\t    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object\n\t      for (var key in obj) {\n\t        _removeBlobs(obj[key], key, obj);\n\t      }\n\t    }\n\t  }\n\t\n\t  var pendingBlobs = 0;\n\t  var bloblessData = data;\n\t  _removeBlobs(bloblessData);\n\t  if (!pendingBlobs) {\n\t    callback(bloblessData);\n\t  }\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 86 */\n/***/ function(module, exports) {\n\n\tmodule.exports = Array.isArray || function (arr) {\n\t  return Object.prototype.toString.call(arr) == '[object Array]';\n\t};\n\n\n/***/ },\n/* 87 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\n\tmodule.exports = isBuf;\n\t\n\t/**\n\t * Returns true if obj is a buffer or an arraybuffer.\n\t *\n\t * @api private\n\t */\n\t\n\tfunction isBuf(obj) {\n\t  return (global.Buffer && global.Buffer.isBuffer(obj)) ||\n\t         (global.ArrayBuffer && obj instanceof ArrayBuffer);\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * Module dependencies.\n\t */\n\t\n\tvar eio = __webpack_require__(89);\n\tvar Socket = __webpack_require__(118);\n\tvar Emitter = __webpack_require__(21);\n\tvar parser = __webpack_require__(77);\n\tvar on = __webpack_require__(120);\n\tvar bind = __webpack_require__(121);\n\tvar debug = __webpack_require__(74)('socket.io-client:manager');\n\tvar indexOf = __webpack_require__(116);\n\tvar Backoff = __webpack_require__(122);\n\t\n\t/**\n\t * IE6+ hasOwnProperty\n\t */\n\t\n\tvar has = Object.prototype.hasOwnProperty;\n\t\n\t/**\n\t * Module exports\n\t */\n\t\n\tmodule.exports = Manager;\n\t\n\t/**\n\t * `Manager` constructor.\n\t *\n\t * @param {String} engine instance or engine uri/opts\n\t * @param {Object} options\n\t * @api public\n\t */\n\t\n\tfunction Manager (uri, opts) {\n\t  if (!(this instanceof Manager)) return new Manager(uri, opts);\n\t  if (uri && ('object' === typeof uri)) {\n\t    opts = uri;\n\t    uri = undefined;\n\t  }\n\t  opts = opts || {};\n\t\n\t  opts.path = opts.path || '/socket.io';\n\t  this.nsps = {};\n\t  this.subs = [];\n\t  this.opts = opts;\n\t  this.reconnection(opts.reconnection !== false);\n\t  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n\t  this.reconnectionDelay(opts.reconnectionDelay || 1000);\n\t  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n\t  this.randomizationFactor(opts.randomizationFactor || 0.5);\n\t  this.backoff = new Backoff({\n\t    min: this.reconnectionDelay(),\n\t    max: this.reconnectionDelayMax(),\n\t    jitter: this.randomizationFactor()\n\t  });\n\t  this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n\t  this.readyState = 'closed';\n\t  this.uri = uri;\n\t  this.connecting = [];\n\t  this.lastPing = null;\n\t  this.encoding = false;\n\t  this.packetBuffer = [];\n\t  this.encoder = new parser.Encoder();\n\t  this.decoder = new parser.Decoder();\n\t  this.autoConnect = opts.autoConnect !== false;\n\t  if (this.autoConnect) this.open();\n\t}\n\t\n\t/**\n\t * Propagate given event to sockets and emit on `this`\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.emitAll = function () {\n\t  this.emit.apply(this, arguments);\n\t  for (var nsp in this.nsps) {\n\t    if (has.call(this.nsps, nsp)) {\n\t      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Update `socket.id` of all sockets\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.updateSocketIds = function () {\n\t  for (var nsp in this.nsps) {\n\t    if (has.call(this.nsps, nsp)) {\n\t      this.nsps[nsp].id = this.engine.id;\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Mix in `Emitter`.\n\t */\n\t\n\tEmitter(Manager.prototype);\n\t\n\t/**\n\t * Sets the `reconnection` config.\n\t *\n\t * @param {Boolean} true/false if it should automatically reconnect\n\t * @return {Manager} self or value\n\t * @api public\n\t */\n\t\n\tManager.prototype.reconnection = function (v) {\n\t  if (!arguments.length) return this._reconnection;\n\t  this._reconnection = !!v;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Sets the reconnection attempts config.\n\t *\n\t * @param {Number} max reconnection attempts before giving up\n\t * @return {Manager} self or value\n\t * @api public\n\t */\n\t\n\tManager.prototype.reconnectionAttempts = function (v) {\n\t  if (!arguments.length) return this._reconnectionAttempts;\n\t  this._reconnectionAttempts = v;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Sets the delay between reconnections.\n\t *\n\t * @param {Number} delay\n\t * @return {Manager} self or value\n\t * @api public\n\t */\n\t\n\tManager.prototype.reconnectionDelay = function (v) {\n\t  if (!arguments.length) return this._reconnectionDelay;\n\t  this._reconnectionDelay = v;\n\t  this.backoff && this.backoff.setMin(v);\n\t  return this;\n\t};\n\t\n\tManager.prototype.randomizationFactor = function (v) {\n\t  if (!arguments.length) return this._randomizationFactor;\n\t  this._randomizationFactor = v;\n\t  this.backoff && this.backoff.setJitter(v);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Sets the maximum delay between reconnections.\n\t *\n\t * @param {Number} delay\n\t * @return {Manager} self or value\n\t * @api public\n\t */\n\t\n\tManager.prototype.reconnectionDelayMax = function (v) {\n\t  if (!arguments.length) return this._reconnectionDelayMax;\n\t  this._reconnectionDelayMax = v;\n\t  this.backoff && this.backoff.setMax(v);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Sets the connection timeout. `false` to disable\n\t *\n\t * @return {Manager} self or value\n\t * @api public\n\t */\n\t\n\tManager.prototype.timeout = function (v) {\n\t  if (!arguments.length) return this._timeout;\n\t  this._timeout = v;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Starts trying to reconnect if reconnection is enabled and we have not\n\t * started reconnecting yet\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.maybeReconnectOnOpen = function () {\n\t  // Only try to reconnect if it's the first time we're connecting\n\t  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {\n\t    // keeps reconnection from firing twice for the same reconnection loop\n\t    this.reconnect();\n\t  }\n\t};\n\t\n\t/**\n\t * Sets the current transport `socket`.\n\t *\n\t * @param {Function} optional, callback\n\t * @return {Manager} self\n\t * @api public\n\t */\n\t\n\tManager.prototype.open =\n\tManager.prototype.connect = function (fn, opts) {\n\t  debug('readyState %s', this.readyState);\n\t  if (~this.readyState.indexOf('open')) return this;\n\t\n\t  debug('opening %s', this.uri);\n\t  this.engine = eio(this.uri, this.opts);\n\t  var socket = this.engine;\n\t  var self = this;\n\t  this.readyState = 'opening';\n\t  this.skipReconnect = false;\n\t\n\t  // emit `open`\n\t  var openSub = on(socket, 'open', function () {\n\t    self.onopen();\n\t    fn && fn();\n\t  });\n\t\n\t  // emit `connect_error`\n\t  var errorSub = on(socket, 'error', function (data) {\n\t    debug('connect_error');\n\t    self.cleanup();\n\t    self.readyState = 'closed';\n\t    self.emitAll('connect_error', data);\n\t    if (fn) {\n\t      var err = new Error('Connection error');\n\t      err.data = data;\n\t      fn(err);\n\t    } else {\n\t      // Only do this if there is no fn to handle the error\n\t      self.maybeReconnectOnOpen();\n\t    }\n\t  });\n\t\n\t  // emit `connect_timeout`\n\t  if (false !== this._timeout) {\n\t    var timeout = this._timeout;\n\t    debug('connect attempt will timeout after %d', timeout);\n\t\n\t    // set timer\n\t    var timer = setTimeout(function () {\n\t      debug('connect attempt timed out after %d', timeout);\n\t      openSub.destroy();\n\t      socket.close();\n\t      socket.emit('error', 'timeout');\n\t      self.emitAll('connect_timeout', timeout);\n\t    }, timeout);\n\t\n\t    this.subs.push({\n\t      destroy: function () {\n\t        clearTimeout(timer);\n\t      }\n\t    });\n\t  }\n\t\n\t  this.subs.push(openSub);\n\t  this.subs.push(errorSub);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Called upon transport open.\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.onopen = function () {\n\t  debug('open');\n\t\n\t  // clear old subs\n\t  this.cleanup();\n\t\n\t  // mark as open\n\t  this.readyState = 'open';\n\t  this.emit('open');\n\t\n\t  // add new subs\n\t  var socket = this.engine;\n\t  this.subs.push(on(socket, 'data', bind(this, 'ondata')));\n\t  this.subs.push(on(socket, 'ping', bind(this, 'onping')));\n\t  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));\n\t  this.subs.push(on(socket, 'error', bind(this, 'onerror')));\n\t  this.subs.push(on(socket, 'close', bind(this, 'onclose')));\n\t  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));\n\t};\n\t\n\t/**\n\t * Called upon a ping.\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.onping = function () {\n\t  this.lastPing = new Date();\n\t  this.emitAll('ping');\n\t};\n\t\n\t/**\n\t * Called upon a packet.\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.onpong = function () {\n\t  this.emitAll('pong', new Date() - this.lastPing);\n\t};\n\t\n\t/**\n\t * Called with data.\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.ondata = function (data) {\n\t  this.decoder.add(data);\n\t};\n\t\n\t/**\n\t * Called when parser fully decodes a packet.\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.ondecoded = function (packet) {\n\t  this.emit('packet', packet);\n\t};\n\t\n\t/**\n\t * Called upon socket error.\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.onerror = function (err) {\n\t  debug('error', err);\n\t  this.emitAll('error', err);\n\t};\n\t\n\t/**\n\t * Creates a new socket for the given `nsp`.\n\t *\n\t * @return {Socket}\n\t * @api public\n\t */\n\t\n\tManager.prototype.socket = function (nsp, opts) {\n\t  var socket = this.nsps[nsp];\n\t  if (!socket) {\n\t    socket = new Socket(this, nsp, opts);\n\t    this.nsps[nsp] = socket;\n\t    var self = this;\n\t    socket.on('connecting', onConnecting);\n\t    socket.on('connect', function () {\n\t      socket.id = self.engine.id;\n\t    });\n\t\n\t    if (this.autoConnect) {\n\t      // manually call here since connecting evnet is fired before listening\n\t      onConnecting();\n\t    }\n\t  }\n\t\n\t  function onConnecting () {\n\t    if (!~indexOf(self.connecting, socket)) {\n\t      self.connecting.push(socket);\n\t    }\n\t  }\n\t\n\t  return socket;\n\t};\n\t\n\t/**\n\t * Called upon a socket close.\n\t *\n\t * @param {Socket} socket\n\t */\n\t\n\tManager.prototype.destroy = function (socket) {\n\t  var index = indexOf(this.connecting, socket);\n\t  if (~index) this.connecting.splice(index, 1);\n\t  if (this.connecting.length) return;\n\t\n\t  this.close();\n\t};\n\t\n\t/**\n\t * Writes a packet.\n\t *\n\t * @param {Object} packet\n\t * @api private\n\t */\n\t\n\tManager.prototype.packet = function (packet) {\n\t  debug('writing packet %j', packet);\n\t  var self = this;\n\t  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;\n\t\n\t  if (!self.encoding) {\n\t    // encode, then write to engine with result\n\t    self.encoding = true;\n\t    this.encoder.encode(packet, function (encodedPackets) {\n\t      for (var i = 0; i < encodedPackets.length; i++) {\n\t        self.engine.write(encodedPackets[i], packet.options);\n\t      }\n\t      self.encoding = false;\n\t      self.processPacketQueue();\n\t    });\n\t  } else { // add packet to the queue\n\t    self.packetBuffer.push(packet);\n\t  }\n\t};\n\t\n\t/**\n\t * If packet buffer is non-empty, begins encoding the\n\t * next packet in line.\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.processPacketQueue = function () {\n\t  if (this.packetBuffer.length > 0 && !this.encoding) {\n\t    var pack = this.packetBuffer.shift();\n\t    this.packet(pack);\n\t  }\n\t};\n\t\n\t/**\n\t * Clean up transport subscriptions and packet buffer.\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.cleanup = function () {\n\t  debug('cleanup');\n\t\n\t  var subsLength = this.subs.length;\n\t  for (var i = 0; i < subsLength; i++) {\n\t    var sub = this.subs.shift();\n\t    sub.destroy();\n\t  }\n\t\n\t  this.packetBuffer = [];\n\t  this.encoding = false;\n\t  this.lastPing = null;\n\t\n\t  this.decoder.destroy();\n\t};\n\t\n\t/**\n\t * Close the current socket.\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.close =\n\tManager.prototype.disconnect = function () {\n\t  debug('disconnect');\n\t  this.skipReconnect = true;\n\t  this.reconnecting = false;\n\t  if ('opening' === this.readyState) {\n\t    // `onclose` will not fire because\n\t    // an open event never happened\n\t    this.cleanup();\n\t  }\n\t  this.backoff.reset();\n\t  this.readyState = 'closed';\n\t  if (this.engine) this.engine.close();\n\t};\n\t\n\t/**\n\t * Called upon engine close.\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.onclose = function (reason) {\n\t  debug('onclose');\n\t\n\t  this.cleanup();\n\t  this.backoff.reset();\n\t  this.readyState = 'closed';\n\t  this.emit('close', reason);\n\t\n\t  if (this._reconnection && !this.skipReconnect) {\n\t    this.reconnect();\n\t  }\n\t};\n\t\n\t/**\n\t * Attempt a reconnection.\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.reconnect = function () {\n\t  if (this.reconnecting || this.skipReconnect) return this;\n\t\n\t  var self = this;\n\t\n\t  if (this.backoff.attempts >= this._reconnectionAttempts) {\n\t    debug('reconnect failed');\n\t    this.backoff.reset();\n\t    this.emitAll('reconnect_failed');\n\t    this.reconnecting = false;\n\t  } else {\n\t    var delay = this.backoff.duration();\n\t    debug('will wait %dms before reconnect attempt', delay);\n\t\n\t    this.reconnecting = true;\n\t    var timer = setTimeout(function () {\n\t      if (self.skipReconnect) return;\n\t\n\t      debug('attempting reconnect');\n\t      self.emitAll('reconnect_attempt', self.backoff.attempts);\n\t      self.emitAll('reconnecting', self.backoff.attempts);\n\t\n\t      // check again for the case socket closed in above events\n\t      if (self.skipReconnect) return;\n\t\n\t      self.open(function (err) {\n\t        if (err) {\n\t          debug('reconnect attempt error');\n\t          self.reconnecting = false;\n\t          self.reconnect();\n\t          self.emitAll('reconnect_error', err.data);\n\t        } else {\n\t          debug('reconnect success');\n\t          self.onreconnect();\n\t        }\n\t      });\n\t    }, delay);\n\t\n\t    this.subs.push({\n\t      destroy: function () {\n\t        clearTimeout(timer);\n\t      }\n\t    });\n\t  }\n\t};\n\t\n\t/**\n\t * Called upon successful reconnect.\n\t *\n\t * @api private\n\t */\n\t\n\tManager.prototype.onreconnect = function () {\n\t  var attempt = this.backoff.attempts;\n\t  this.reconnecting = false;\n\t  this.backoff.reset();\n\t  this.updateSocketIds();\n\t  this.emitAll('reconnect', attempt);\n\t};\n\n\n/***/ },\n/* 89 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tmodule.exports = __webpack_require__(90);\n\n\n/***/ },\n/* 90 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tmodule.exports = __webpack_require__(91);\n\t\n\t/**\n\t * Exports parser\n\t *\n\t * @api public\n\t *\n\t */\n\tmodule.exports.parser = __webpack_require__(98);\n\n\n/***/ },\n/* 91 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * Module dependencies.\n\t */\n\t\n\tvar transports = __webpack_require__(92);\n\tvar Emitter = __webpack_require__(21);\n\tvar debug = __webpack_require__(110)('engine.io-client:socket');\n\tvar index = __webpack_require__(116);\n\tvar parser = __webpack_require__(98);\n\tvar parseuri = __webpack_require__(73);\n\tvar parsejson = __webpack_require__(117);\n\tvar parseqs = __webpack_require__(107);\n\t\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = Socket;\n\t\n\t/**\n\t * Socket constructor.\n\t *\n\t * @param {String|Object} uri or options\n\t * @param {Object} options\n\t * @api public\n\t */\n\t\n\tfunction Socket (uri, opts) {\n\t  if (!(this instanceof Socket)) return new Socket(uri, opts);\n\t\n\t  opts = opts || {};\n\t\n\t  if (uri && 'object' === typeof uri) {\n\t    opts = uri;\n\t    uri = null;\n\t  }\n\t\n\t  if (uri) {\n\t    uri = parseuri(uri);\n\t    opts.hostname = uri.host;\n\t    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';\n\t    opts.port = uri.port;\n\t    if (uri.query) opts.query = uri.query;\n\t  } else if (opts.host) {\n\t    opts.hostname = parseuri(opts.host).host;\n\t  }\n\t\n\t  this.secure = null != opts.secure ? opts.secure\n\t    : (global.location && 'https:' === location.protocol);\n\t\n\t  if (opts.hostname && !opts.port) {\n\t    // if no port is specified manually, use the protocol default\n\t    opts.port = this.secure ? '443' : '80';\n\t  }\n\t\n\t  this.agent = opts.agent || false;\n\t  this.hostname = opts.hostname ||\n\t    (global.location ? location.hostname : 'localhost');\n\t  this.port = opts.port || (global.location && location.port\n\t      ? location.port\n\t      : (this.secure ? 443 : 80));\n\t  this.query = opts.query || {};\n\t  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);\n\t  this.upgrade = false !== opts.upgrade;\n\t  this.path = (opts.path || '/engine.io').replace(/\\/$/, '') + '/';\n\t  this.forceJSONP = !!opts.forceJSONP;\n\t  this.jsonp = false !== opts.jsonp;\n\t  this.forceBase64 = !!opts.forceBase64;\n\t  this.enablesXDR = !!opts.enablesXDR;\n\t  this.timestampParam = opts.timestampParam || 't';\n\t  this.timestampRequests = opts.timestampRequests;\n\t  this.transports = opts.transports || ['polling', 'websocket'];\n\t  this.readyState = '';\n\t  this.writeBuffer = [];\n\t  this.prevBufferLen = 0;\n\t  this.policyPort = opts.policyPort || 843;\n\t  this.rememberUpgrade = opts.rememberUpgrade || false;\n\t  this.binaryType = null;\n\t  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;\n\t  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;\n\t\n\t  if (true === this.perMessageDeflate) this.perMessageDeflate = {};\n\t  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {\n\t    this.perMessageDeflate.threshold = 1024;\n\t  }\n\t\n\t  // SSL options for Node.js client\n\t  this.pfx = opts.pfx || null;\n\t  this.key = opts.key || null;\n\t  this.passphrase = opts.passphrase || null;\n\t  this.cert = opts.cert || null;\n\t  this.ca = opts.ca || null;\n\t  this.ciphers = opts.ciphers || null;\n\t  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? null : opts.rejectUnauthorized;\n\t  this.forceNode = !!opts.forceNode;\n\t\n\t  // other options for Node.js client\n\t  var freeGlobal = typeof global === 'object' && global;\n\t  if (freeGlobal.global === freeGlobal) {\n\t    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {\n\t      this.extraHeaders = opts.extraHeaders;\n\t    }\n\t\n\t    if (opts.localAddress) {\n\t      this.localAddress = opts.localAddress;\n\t    }\n\t  }\n\t\n\t  // set on handshake\n\t  this.id = null;\n\t  this.upgrades = null;\n\t  this.pingInterval = null;\n\t  this.pingTimeout = null;\n\t\n\t  // set on heartbeat\n\t  this.pingIntervalTimer = null;\n\t  this.pingTimeoutTimer = null;\n\t\n\t  this.open();\n\t}\n\t\n\tSocket.priorWebsocketSuccess = false;\n\t\n\t/**\n\t * Mix in `Emitter`.\n\t */\n\t\n\tEmitter(Socket.prototype);\n\t\n\t/**\n\t * Protocol version.\n\t *\n\t * @api public\n\t */\n\t\n\tSocket.protocol = parser.protocol; // this is an int\n\t\n\t/**\n\t * Expose deps for legacy compatibility\n\t * and standalone browser access.\n\t */\n\t\n\tSocket.Socket = Socket;\n\tSocket.Transport = __webpack_require__(97);\n\tSocket.transports = __webpack_require__(92);\n\tSocket.parser = __webpack_require__(98);\n\t\n\t/**\n\t * Creates transport of the given type.\n\t *\n\t * @param {String} transport name\n\t * @return {Transport}\n\t * @api private\n\t */\n\t\n\tSocket.prototype.createTransport = function (name) {\n\t  debug('creating transport \"%s\"', name);\n\t  var query = clone(this.query);\n\t\n\t  // append engine.io protocol identifier\n\t  query.EIO = parser.protocol;\n\t\n\t  // transport name\n\t  query.transport = name;\n\t\n\t  // session id if we already have one\n\t  if (this.id) query.sid = this.id;\n\t\n\t  var transport = new transports[name]({\n\t    agent: this.agent,\n\t    hostname: this.hostname,\n\t    port: this.port,\n\t    secure: this.secure,\n\t    path: this.path,\n\t    query: query,\n\t    forceJSONP: this.forceJSONP,\n\t    jsonp: this.jsonp,\n\t    forceBase64: this.forceBase64,\n\t    enablesXDR: this.enablesXDR,\n\t    timestampRequests: this.timestampRequests,\n\t    timestampParam: this.timestampParam,\n\t    policyPort: this.policyPort,\n\t    socket: this,\n\t    pfx: this.pfx,\n\t    key: this.key,\n\t    passphrase: this.passphrase,\n\t    cert: this.cert,\n\t    ca: this.ca,\n\t    ciphers: this.ciphers,\n\t    rejectUnauthorized: this.rejectUnauthorized,\n\t    perMessageDeflate: this.perMessageDeflate,\n\t    extraHeaders: this.extraHeaders,\n\t    forceNode: this.forceNode,\n\t    localAddress: this.localAddress\n\t  });\n\t\n\t  return transport;\n\t};\n\t\n\tfunction clone (obj) {\n\t  var o = {};\n\t  for (var i in obj) {\n\t    if (obj.hasOwnProperty(i)) {\n\t      o[i] = obj[i];\n\t    }\n\t  }\n\t  return o;\n\t}\n\t\n\t/**\n\t * Initializes transport to use and starts probe.\n\t *\n\t * @api private\n\t */\n\tSocket.prototype.open = function () {\n\t  var transport;\n\t  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {\n\t    transport = 'websocket';\n\t  } else if (0 === this.transports.length) {\n\t    // Emit error on next tick so it can be listened to\n\t    var self = this;\n\t    setTimeout(function () {\n\t      self.emit('error', 'No transports available');\n\t    }, 0);\n\t    return;\n\t  } else {\n\t    transport = this.transports[0];\n\t  }\n\t  this.readyState = 'opening';\n\t\n\t  // Retry with the next transport if the transport is disabled (jsonp: false)\n\t  try {\n\t    transport = this.createTransport(transport);\n\t  } catch (e) {\n\t    this.transports.shift();\n\t    this.open();\n\t    return;\n\t  }\n\t\n\t  transport.open();\n\t  this.setTransport(transport);\n\t};\n\t\n\t/**\n\t * Sets the current transport. Disables the existing one (if any).\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.setTransport = function (transport) {\n\t  debug('setting transport %s', transport.name);\n\t  var self = this;\n\t\n\t  if (this.transport) {\n\t    debug('clearing existing transport %s', this.transport.name);\n\t    this.transport.removeAllListeners();\n\t  }\n\t\n\t  // set up transport\n\t  this.transport = transport;\n\t\n\t  // set up transport listeners\n\t  transport\n\t  .on('drain', function () {\n\t    self.onDrain();\n\t  })\n\t  .on('packet', function (packet) {\n\t    self.onPacket(packet);\n\t  })\n\t  .on('error', function (e) {\n\t    self.onError(e);\n\t  })\n\t  .on('close', function () {\n\t    self.onClose('transport close');\n\t  });\n\t};\n\t\n\t/**\n\t * Probes a transport.\n\t *\n\t * @param {String} transport name\n\t * @api private\n\t */\n\t\n\tSocket.prototype.probe = function (name) {\n\t  debug('probing transport \"%s\"', name);\n\t  var transport = this.createTransport(name, { probe: 1 });\n\t  var failed = false;\n\t  var self = this;\n\t\n\t  Socket.priorWebsocketSuccess = false;\n\t\n\t  function onTransportOpen () {\n\t    if (self.onlyBinaryUpgrades) {\n\t      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;\n\t      failed = failed || upgradeLosesBinary;\n\t    }\n\t    if (failed) return;\n\t\n\t    debug('probe transport \"%s\" opened', name);\n\t    transport.send([{ type: 'ping', data: 'probe' }]);\n\t    transport.once('packet', function (msg) {\n\t      if (failed) return;\n\t      if ('pong' === msg.type && 'probe' === msg.data) {\n\t        debug('probe transport \"%s\" pong', name);\n\t        self.upgrading = true;\n\t        self.emit('upgrading', transport);\n\t        if (!transport) return;\n\t        Socket.priorWebsocketSuccess = 'websocket' === transport.name;\n\t\n\t        debug('pausing current transport \"%s\"', self.transport.name);\n\t        self.transport.pause(function () {\n\t          if (failed) return;\n\t          if ('closed' === self.readyState) return;\n\t          debug('changing transport and sending upgrade packet');\n\t\n\t          cleanup();\n\t\n\t          self.setTransport(transport);\n\t          transport.send([{ type: 'upgrade' }]);\n\t          self.emit('upgrade', transport);\n\t          transport = null;\n\t          self.upgrading = false;\n\t          self.flush();\n\t        });\n\t      } else {\n\t        debug('probe transport \"%s\" failed', name);\n\t        var err = new Error('probe error');\n\t        err.transport = transport.name;\n\t        self.emit('upgradeError', err);\n\t      }\n\t    });\n\t  }\n\t\n\t  function freezeTransport () {\n\t    if (failed) return;\n\t\n\t    // Any callback called by transport should be ignored since now\n\t    failed = true;\n\t\n\t    cleanup();\n\t\n\t    transport.close();\n\t    transport = null;\n\t  }\n\t\n\t  // Handle any error that happens while probing\n\t  function onerror (err) {\n\t    var error = new Error('probe error: ' + err);\n\t    error.transport = transport.name;\n\t\n\t    freezeTransport();\n\t\n\t    debug('probe transport \"%s\" failed because of error: %s', name, err);\n\t\n\t    self.emit('upgradeError', error);\n\t  }\n\t\n\t  function onTransportClose () {\n\t    onerror('transport closed');\n\t  }\n\t\n\t  // When the socket is closed while we're probing\n\t  function onclose () {\n\t    onerror('socket closed');\n\t  }\n\t\n\t  // When the socket is upgraded while we're probing\n\t  function onupgrade (to) {\n\t    if (transport && to.name !== transport.name) {\n\t      debug('\"%s\" works - aborting \"%s\"', to.name, transport.name);\n\t      freezeTransport();\n\t    }\n\t  }\n\t\n\t  // Remove all listeners on the transport and on self\n\t  function cleanup () {\n\t    transport.removeListener('open', onTransportOpen);\n\t    transport.removeListener('error', onerror);\n\t    transport.removeListener('close', onTransportClose);\n\t    self.removeListener('close', onclose);\n\t    self.removeListener('upgrading', onupgrade);\n\t  }\n\t\n\t  transport.once('open', onTransportOpen);\n\t  transport.once('error', onerror);\n\t  transport.once('close', onTransportClose);\n\t\n\t  this.once('close', onclose);\n\t  this.once('upgrading', onupgrade);\n\t\n\t  transport.open();\n\t};\n\t\n\t/**\n\t * Called when connection is deemed open.\n\t *\n\t * @api public\n\t */\n\t\n\tSocket.prototype.onOpen = function () {\n\t  debug('socket open');\n\t  this.readyState = 'open';\n\t  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;\n\t  this.emit('open');\n\t  this.flush();\n\t\n\t  // we check for `readyState` in case an `open`\n\t  // listener already closed the socket\n\t  if ('open' === this.readyState && this.upgrade && this.transport.pause) {\n\t    debug('starting upgrade probes');\n\t    for (var i = 0, l = this.upgrades.length; i < l; i++) {\n\t      this.probe(this.upgrades[i]);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Handles a packet.\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.onPacket = function (packet) {\n\t  if ('opening' === this.readyState || 'open' === this.readyState ||\n\t      'closing' === this.readyState) {\n\t    debug('socket receive: type \"%s\", data \"%s\"', packet.type, packet.data);\n\t\n\t    this.emit('packet', packet);\n\t\n\t    // Socket is live - any packet counts\n\t    this.emit('heartbeat');\n\t\n\t    switch (packet.type) {\n\t      case 'open':\n\t        this.onHandshake(parsejson(packet.data));\n\t        break;\n\t\n\t      case 'pong':\n\t        this.setPing();\n\t        this.emit('pong');\n\t        break;\n\t\n\t      case 'error':\n\t        var err = new Error('server error');\n\t        err.code = packet.data;\n\t        this.onError(err);\n\t        break;\n\t\n\t      case 'message':\n\t        this.emit('data', packet.data);\n\t        this.emit('message', packet.data);\n\t        break;\n\t    }\n\t  } else {\n\t    debug('packet received with socket readyState \"%s\"', this.readyState);\n\t  }\n\t};\n\t\n\t/**\n\t * Called upon handshake completion.\n\t *\n\t * @param {Object} handshake obj\n\t * @api private\n\t */\n\t\n\tSocket.prototype.onHandshake = function (data) {\n\t  this.emit('handshake', data);\n\t  this.id = data.sid;\n\t  this.transport.query.sid = data.sid;\n\t  this.upgrades = this.filterUpgrades(data.upgrades);\n\t  this.pingInterval = data.pingInterval;\n\t  this.pingTimeout = data.pingTimeout;\n\t  this.onOpen();\n\t  // In case open handler closes socket\n\t  if ('closed' === this.readyState) return;\n\t  this.setPing();\n\t\n\t  // Prolong liveness of socket on heartbeat\n\t  this.removeListener('heartbeat', this.onHeartbeat);\n\t  this.on('heartbeat', this.onHeartbeat);\n\t};\n\t\n\t/**\n\t * Resets ping timeout.\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.onHeartbeat = function (timeout) {\n\t  clearTimeout(this.pingTimeoutTimer);\n\t  var self = this;\n\t  self.pingTimeoutTimer = setTimeout(function () {\n\t    if ('closed' === self.readyState) return;\n\t    self.onClose('ping timeout');\n\t  }, timeout || (self.pingInterval + self.pingTimeout));\n\t};\n\t\n\t/**\n\t * Pings server every `this.pingInterval` and expects response\n\t * within `this.pingTimeout` or closes connection.\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.setPing = function () {\n\t  var self = this;\n\t  clearTimeout(self.pingIntervalTimer);\n\t  self.pingIntervalTimer = setTimeout(function () {\n\t    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);\n\t    self.ping();\n\t    self.onHeartbeat(self.pingTimeout);\n\t  }, self.pingInterval);\n\t};\n\t\n\t/**\n\t* Sends a ping packet.\n\t*\n\t* @api private\n\t*/\n\t\n\tSocket.prototype.ping = function () {\n\t  var self = this;\n\t  this.sendPacket('ping', function () {\n\t    self.emit('ping');\n\t  });\n\t};\n\t\n\t/**\n\t * Called on `drain` event\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.onDrain = function () {\n\t  this.writeBuffer.splice(0, this.prevBufferLen);\n\t\n\t  // setting prevBufferLen = 0 is very important\n\t  // for example, when upgrading, upgrade packet is sent over,\n\t  // and a nonzero prevBufferLen could cause problems on `drain`\n\t  this.prevBufferLen = 0;\n\t\n\t  if (0 === this.writeBuffer.length) {\n\t    this.emit('drain');\n\t  } else {\n\t    this.flush();\n\t  }\n\t};\n\t\n\t/**\n\t * Flush write buffers.\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.flush = function () {\n\t  if ('closed' !== this.readyState && this.transport.writable &&\n\t    !this.upgrading && this.writeBuffer.length) {\n\t    debug('flushing %d packets in socket', this.writeBuffer.length);\n\t    this.transport.send(this.writeBuffer);\n\t    // keep track of current length of writeBuffer\n\t    // splice writeBuffer and callbackBuffer on `drain`\n\t    this.prevBufferLen = this.writeBuffer.length;\n\t    this.emit('flush');\n\t  }\n\t};\n\t\n\t/**\n\t * Sends a message.\n\t *\n\t * @param {String} message.\n\t * @param {Function} callback function.\n\t * @param {Object} options.\n\t * @return {Socket} for chaining.\n\t * @api public\n\t */\n\t\n\tSocket.prototype.write =\n\tSocket.prototype.send = function (msg, options, fn) {\n\t  this.sendPacket('message', msg, options, fn);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Sends a packet.\n\t *\n\t * @param {String} packet type.\n\t * @param {String} data.\n\t * @param {Object} options.\n\t * @param {Function} callback function.\n\t * @api private\n\t */\n\t\n\tSocket.prototype.sendPacket = function (type, data, options, fn) {\n\t  if ('function' === typeof data) {\n\t    fn = data;\n\t    data = undefined;\n\t  }\n\t\n\t  if ('function' === typeof options) {\n\t    fn = options;\n\t    options = null;\n\t  }\n\t\n\t  if ('closing' === this.readyState || 'closed' === this.readyState) {\n\t    return;\n\t  }\n\t\n\t  options = options || {};\n\t  options.compress = false !== options.compress;\n\t\n\t  var packet = {\n\t    type: type,\n\t    data: data,\n\t    options: options\n\t  };\n\t  this.emit('packetCreate', packet);\n\t  this.writeBuffer.push(packet);\n\t  if (fn) this.once('flush', fn);\n\t  this.flush();\n\t};\n\t\n\t/**\n\t * Closes the connection.\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.close = function () {\n\t  if ('opening' === this.readyState || 'open' === this.readyState) {\n\t    this.readyState = 'closing';\n\t\n\t    var self = this;\n\t\n\t    if (this.writeBuffer.length) {\n\t      this.once('drain', function () {\n\t        if (this.upgrading) {\n\t          waitForUpgrade();\n\t        } else {\n\t          close();\n\t        }\n\t      });\n\t    } else if (this.upgrading) {\n\t      waitForUpgrade();\n\t    } else {\n\t      close();\n\t    }\n\t  }\n\t\n\t  function close () {\n\t    self.onClose('forced close');\n\t    debug('socket closing - telling transport to close');\n\t    self.transport.close();\n\t  }\n\t\n\t  function cleanupAndClose () {\n\t    self.removeListener('upgrade', cleanupAndClose);\n\t    self.removeListener('upgradeError', cleanupAndClose);\n\t    close();\n\t  }\n\t\n\t  function waitForUpgrade () {\n\t    // wait for upgrade to finish since we can't send packets while pausing a transport\n\t    self.once('upgrade', cleanupAndClose);\n\t    self.once('upgradeError', cleanupAndClose);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Called upon transport error\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.onError = function (err) {\n\t  debug('socket error %j', err);\n\t  Socket.priorWebsocketSuccess = false;\n\t  this.emit('error', err);\n\t  this.onClose('transport error', err);\n\t};\n\t\n\t/**\n\t * Called upon transport close.\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.onClose = function (reason, desc) {\n\t  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {\n\t    debug('socket close with reason: \"%s\"', reason);\n\t    var self = this;\n\t\n\t    // clear timers\n\t    clearTimeout(this.pingIntervalTimer);\n\t    clearTimeout(this.pingTimeoutTimer);\n\t\n\t    // stop event from firing again for transport\n\t    this.transport.removeAllListeners('close');\n\t\n\t    // ensure transport won't stay open\n\t    this.transport.close();\n\t\n\t    // ignore further transport communication\n\t    this.transport.removeAllListeners();\n\t\n\t    // set ready state\n\t    this.readyState = 'closed';\n\t\n\t    // clear session id\n\t    this.id = null;\n\t\n\t    // emit close event\n\t    this.emit('close', reason, desc);\n\t\n\t    // clean buffers after, so users can still\n\t    // grab the buffers on `close` event\n\t    self.writeBuffer = [];\n\t    self.prevBufferLen = 0;\n\t  }\n\t};\n\t\n\t/**\n\t * Filters upgrades, returning only those matching client transports.\n\t *\n\t * @param {Array} server upgrades\n\t * @api private\n\t *\n\t */\n\t\n\tSocket.prototype.filterUpgrades = function (upgrades) {\n\t  var filteredUpgrades = [];\n\t  for (var i = 0, j = upgrades.length; i < j; i++) {\n\t    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);\n\t  }\n\t  return filteredUpgrades;\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 92 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * Module dependencies\n\t */\n\t\n\tvar XMLHttpRequest = __webpack_require__(93);\n\tvar XHR = __webpack_require__(95);\n\tvar JSONP = __webpack_require__(113);\n\tvar websocket = __webpack_require__(114);\n\t\n\t/**\n\t * Export transports.\n\t */\n\t\n\texports.polling = polling;\n\texports.websocket = websocket;\n\t\n\t/**\n\t * Polling transport polymorphic constructor.\n\t * Decides on xhr vs jsonp based on feature detection.\n\t *\n\t * @api private\n\t */\n\t\n\tfunction polling (opts) {\n\t  var xhr;\n\t  var xd = false;\n\t  var xs = false;\n\t  var jsonp = false !== opts.jsonp;\n\t\n\t  if (global.location) {\n\t    var isSSL = 'https:' === location.protocol;\n\t    var port = location.port;\n\t\n\t    // some user agents have empty `location.port`\n\t    if (!port) {\n\t      port = isSSL ? 443 : 80;\n\t    }\n\t\n\t    xd = opts.hostname !== location.hostname || port !== opts.port;\n\t    xs = opts.secure !== isSSL;\n\t  }\n\t\n\t  opts.xdomain = xd;\n\t  opts.xscheme = xs;\n\t  xhr = new XMLHttpRequest(opts);\n\t\n\t  if ('open' in xhr && !opts.forceJSONP) {\n\t    return new XHR(opts);\n\t  } else {\n\t    if (!jsonp) throw new Error('JSONP disabled');\n\t    return new JSONP(opts);\n\t  }\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {// browser shim for xmlhttprequest module\n\t\n\tvar hasCORS = __webpack_require__(94);\n\t\n\tmodule.exports = function (opts) {\n\t  var xdomain = opts.xdomain;\n\t\n\t  // scheme must be same when usign XDomainRequest\n\t  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx\n\t  var xscheme = opts.xscheme;\n\t\n\t  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.\n\t  // https://github.com/Automattic/engine.io-client/pull/217\n\t  var enablesXDR = opts.enablesXDR;\n\t\n\t  // XMLHttpRequest can be disabled on IE\n\t  try {\n\t    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {\n\t      return new XMLHttpRequest();\n\t    }\n\t  } catch (e) { }\n\t\n\t  // Use XDomainRequest for IE8 if enablesXDR is true\n\t  // because loading bar keeps flashing when using jsonp-polling\n\t  // https://github.com/yujiosaka/socke.io-ie8-loading-example\n\t  try {\n\t    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {\n\t      return new XDomainRequest();\n\t    }\n\t  } catch (e) { }\n\t\n\t  if (!xdomain) {\n\t    try {\n\t      return new global[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');\n\t    } catch (e) { }\n\t  }\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 94 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * Module exports.\n\t *\n\t * Logic borrowed from Modernizr:\n\t *\n\t *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js\n\t */\n\t\n\ttry {\n\t  module.exports = typeof XMLHttpRequest !== 'undefined' &&\n\t    'withCredentials' in new XMLHttpRequest();\n\t} catch (err) {\n\t  // if XMLHttp support is disabled in IE then it will throw\n\t  // when trying to create\n\t  module.exports = false;\n\t}\n\n\n/***/ },\n/* 95 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * Module requirements.\n\t */\n\t\n\tvar XMLHttpRequest = __webpack_require__(93);\n\tvar Polling = __webpack_require__(96);\n\tvar Emitter = __webpack_require__(21);\n\tvar inherit = __webpack_require__(108);\n\tvar debug = __webpack_require__(110)('engine.io-client:polling-xhr');\n\t\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = XHR;\n\tmodule.exports.Request = Request;\n\t\n\t/**\n\t * Empty function\n\t */\n\t\n\tfunction empty () {}\n\t\n\t/**\n\t * XHR Polling constructor.\n\t *\n\t * @param {Object} opts\n\t * @api public\n\t */\n\t\n\tfunction XHR (opts) {\n\t  Polling.call(this, opts);\n\t  this.requestTimeout = opts.requestTimeout;\n\t\n\t  if (global.location) {\n\t    var isSSL = 'https:' === location.protocol;\n\t    var port = location.port;\n\t\n\t    // some user agents have empty `location.port`\n\t    if (!port) {\n\t      port = isSSL ? 443 : 80;\n\t    }\n\t\n\t    this.xd = opts.hostname !== global.location.hostname ||\n\t      port !== opts.port;\n\t    this.xs = opts.secure !== isSSL;\n\t  } else {\n\t    this.extraHeaders = opts.extraHeaders;\n\t  }\n\t}\n\t\n\t/**\n\t * Inherits from Polling.\n\t */\n\t\n\tinherit(XHR, Polling);\n\t\n\t/**\n\t * XHR supports binary\n\t */\n\t\n\tXHR.prototype.supportsBinary = true;\n\t\n\t/**\n\t * Creates a request.\n\t *\n\t * @param {String} method\n\t * @api private\n\t */\n\t\n\tXHR.prototype.request = function (opts) {\n\t  opts = opts || {};\n\t  opts.uri = this.uri();\n\t  opts.xd = this.xd;\n\t  opts.xs = this.xs;\n\t  opts.agent = this.agent || false;\n\t  opts.supportsBinary = this.supportsBinary;\n\t  opts.enablesXDR = this.enablesXDR;\n\t\n\t  // SSL options for Node.js client\n\t  opts.pfx = this.pfx;\n\t  opts.key = this.key;\n\t  opts.passphrase = this.passphrase;\n\t  opts.cert = this.cert;\n\t  opts.ca = this.ca;\n\t  opts.ciphers = this.ciphers;\n\t  opts.rejectUnauthorized = this.rejectUnauthorized;\n\t  opts.requestTimeout = this.requestTimeout;\n\t\n\t  // other options for Node.js client\n\t  opts.extraHeaders = this.extraHeaders;\n\t\n\t  return new Request(opts);\n\t};\n\t\n\t/**\n\t * Sends data.\n\t *\n\t * @param {String} data to send.\n\t * @param {Function} called upon flush.\n\t * @api private\n\t */\n\t\n\tXHR.prototype.doWrite = function (data, fn) {\n\t  var isBinary = typeof data !== 'string' && data !== undefined;\n\t  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });\n\t  var self = this;\n\t  req.on('success', fn);\n\t  req.on('error', function (err) {\n\t    self.onError('xhr post error', err);\n\t  });\n\t  this.sendXhr = req;\n\t};\n\t\n\t/**\n\t * Starts a poll cycle.\n\t *\n\t * @api private\n\t */\n\t\n\tXHR.prototype.doPoll = function () {\n\t  debug('xhr poll');\n\t  var req = this.request();\n\t  var self = this;\n\t  req.on('data', function (data) {\n\t    self.onData(data);\n\t  });\n\t  req.on('error', function (err) {\n\t    self.onError('xhr poll error', err);\n\t  });\n\t  this.pollXhr = req;\n\t};\n\t\n\t/**\n\t * Request constructor\n\t *\n\t * @param {Object} options\n\t * @api public\n\t */\n\t\n\tfunction Request (opts) {\n\t  this.method = opts.method || 'GET';\n\t  this.uri = opts.uri;\n\t  this.xd = !!opts.xd;\n\t  this.xs = !!opts.xs;\n\t  this.async = false !== opts.async;\n\t  this.data = undefined !== opts.data ? opts.data : null;\n\t  this.agent = opts.agent;\n\t  this.isBinary = opts.isBinary;\n\t  this.supportsBinary = opts.supportsBinary;\n\t  this.enablesXDR = opts.enablesXDR;\n\t  this.requestTimeout = opts.requestTimeout;\n\t\n\t  // SSL options for Node.js client\n\t  this.pfx = opts.pfx;\n\t  this.key = opts.key;\n\t  this.passphrase = opts.passphrase;\n\t  this.cert = opts.cert;\n\t  this.ca = opts.ca;\n\t  this.ciphers = opts.ciphers;\n\t  this.rejectUnauthorized = opts.rejectUnauthorized;\n\t\n\t  // other options for Node.js client\n\t  this.extraHeaders = opts.extraHeaders;\n\t\n\t  this.create();\n\t}\n\t\n\t/**\n\t * Mix in `Emitter`.\n\t */\n\t\n\tEmitter(Request.prototype);\n\t\n\t/**\n\t * Creates the XHR object and sends the request.\n\t *\n\t * @api private\n\t */\n\t\n\tRequest.prototype.create = function () {\n\t  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };\n\t\n\t  // SSL options for Node.js client\n\t  opts.pfx = this.pfx;\n\t  opts.key = this.key;\n\t  opts.passphrase = this.passphrase;\n\t  opts.cert = this.cert;\n\t  opts.ca = this.ca;\n\t  opts.ciphers = this.ciphers;\n\t  opts.rejectUnauthorized = this.rejectUnauthorized;\n\t\n\t  var xhr = this.xhr = new XMLHttpRequest(opts);\n\t  var self = this;\n\t\n\t  try {\n\t    debug('xhr open %s: %s', this.method, this.uri);\n\t    xhr.open(this.method, this.uri, this.async);\n\t    try {\n\t      if (this.extraHeaders) {\n\t        xhr.setDisableHeaderCheck(true);\n\t        for (var i in this.extraHeaders) {\n\t          if (this.extraHeaders.hasOwnProperty(i)) {\n\t            xhr.setRequestHeader(i, this.extraHeaders[i]);\n\t          }\n\t        }\n\t      }\n\t    } catch (e) {}\n\t    if (this.supportsBinary) {\n\t      // This has to be done after open because Firefox is stupid\n\t      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension\n\t      xhr.responseType = 'arraybuffer';\n\t    }\n\t\n\t    if ('POST' === this.method) {\n\t      try {\n\t        if (this.isBinary) {\n\t          xhr.setRequestHeader('Content-type', 'application/octet-stream');\n\t        } else {\n\t          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\n\t        }\n\t      } catch (e) {}\n\t    }\n\t\n\t    try {\n\t      xhr.setRequestHeader('Accept', '*/*');\n\t    } catch (e) {}\n\t\n\t    // ie6 check\n\t    if ('withCredentials' in xhr) {\n\t      xhr.withCredentials = true;\n\t    }\n\t\n\t    if (this.requestTimeout) {\n\t      xhr.timeout = this.requestTimeout;\n\t    }\n\t\n\t    if (this.hasXDR()) {\n\t      xhr.onload = function () {\n\t        self.onLoad();\n\t      };\n\t      xhr.onerror = function () {\n\t        self.onError(xhr.responseText);\n\t      };\n\t    } else {\n\t      xhr.onreadystatechange = function () {\n\t        if (4 !== xhr.readyState) return;\n\t        if (200 === xhr.status || 1223 === xhr.status) {\n\t          self.onLoad();\n\t        } else {\n\t          // make sure the `error` event handler that's user-set\n\t          // does not throw in the same tick and gets caught here\n\t          setTimeout(function () {\n\t            self.onError(xhr.status);\n\t          }, 0);\n\t        }\n\t      };\n\t    }\n\t\n\t    debug('xhr data %s', this.data);\n\t    xhr.send(this.data);\n\t  } catch (e) {\n\t    // Need to defer since .create() is called directly fhrom the constructor\n\t    // and thus the 'error' event can only be only bound *after* this exception\n\t    // occurs.  Therefore, also, we cannot throw here at all.\n\t    setTimeout(function () {\n\t      self.onError(e);\n\t    }, 0);\n\t    return;\n\t  }\n\t\n\t  if (global.document) {\n\t    this.index = Request.requestsCount++;\n\t    Request.requests[this.index] = this;\n\t  }\n\t};\n\t\n\t/**\n\t * Called upon successful response.\n\t *\n\t * @api private\n\t */\n\t\n\tRequest.prototype.onSuccess = function () {\n\t  this.emit('success');\n\t  this.cleanup();\n\t};\n\t\n\t/**\n\t * Called if we have data.\n\t *\n\t * @api private\n\t */\n\t\n\tRequest.prototype.onData = function (data) {\n\t  this.emit('data', data);\n\t  this.onSuccess();\n\t};\n\t\n\t/**\n\t * Called upon error.\n\t *\n\t * @api private\n\t */\n\t\n\tRequest.prototype.onError = function (err) {\n\t  this.emit('error', err);\n\t  this.cleanup(true);\n\t};\n\t\n\t/**\n\t * Cleans up house.\n\t *\n\t * @api private\n\t */\n\t\n\tRequest.prototype.cleanup = function (fromError) {\n\t  if ('undefined' === typeof this.xhr || null === this.xhr) {\n\t    return;\n\t  }\n\t  // xmlhttprequest\n\t  if (this.hasXDR()) {\n\t    this.xhr.onload = this.xhr.onerror = empty;\n\t  } else {\n\t    this.xhr.onreadystatechange = empty;\n\t  }\n\t\n\t  if (fromError) {\n\t    try {\n\t      this.xhr.abort();\n\t    } catch (e) {}\n\t  }\n\t\n\t  if (global.document) {\n\t    delete Request.requests[this.index];\n\t  }\n\t\n\t  this.xhr = null;\n\t};\n\t\n\t/**\n\t * Called upon load.\n\t *\n\t * @api private\n\t */\n\t\n\tRequest.prototype.onLoad = function () {\n\t  var data;\n\t  try {\n\t    var contentType;\n\t    try {\n\t      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];\n\t    } catch (e) {}\n\t    if (contentType === 'application/octet-stream') {\n\t      data = this.xhr.response || this.xhr.responseText;\n\t    } else {\n\t      if (!this.supportsBinary) {\n\t        data = this.xhr.responseText;\n\t      } else {\n\t        try {\n\t          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));\n\t        } catch (e) {\n\t          var ui8Arr = new Uint8Array(this.xhr.response);\n\t          var dataArray = [];\n\t          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {\n\t            dataArray.push(ui8Arr[idx]);\n\t          }\n\t\n\t          data = String.fromCharCode.apply(null, dataArray);\n\t        }\n\t      }\n\t    }\n\t  } catch (e) {\n\t    this.onError(e);\n\t  }\n\t  if (null != data) {\n\t    this.onData(data);\n\t  }\n\t};\n\t\n\t/**\n\t * Check if it has XDomainRequest.\n\t *\n\t * @api private\n\t */\n\t\n\tRequest.prototype.hasXDR = function () {\n\t  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;\n\t};\n\t\n\t/**\n\t * Aborts the request.\n\t *\n\t * @api public\n\t */\n\t\n\tRequest.prototype.abort = function () {\n\t  this.cleanup();\n\t};\n\t\n\t/**\n\t * Aborts pending requests when unloading the window. This is needed to prevent\n\t * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n\t * emitted.\n\t */\n\t\n\tRequest.requestsCount = 0;\n\tRequest.requests = {};\n\t\n\tif (global.document) {\n\t  if (global.attachEvent) {\n\t    global.attachEvent('onunload', unloadHandler);\n\t  } else if (global.addEventListener) {\n\t    global.addEventListener('beforeunload', unloadHandler, false);\n\t  }\n\t}\n\t\n\tfunction unloadHandler () {\n\t  for (var i in Request.requests) {\n\t    if (Request.requests.hasOwnProperty(i)) {\n\t      Request.requests[i].abort();\n\t    }\n\t  }\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 96 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Module dependencies.\n\t */\n\t\n\tvar Transport = __webpack_require__(97);\n\tvar parseqs = __webpack_require__(107);\n\tvar parser = __webpack_require__(98);\n\tvar inherit = __webpack_require__(108);\n\tvar yeast = __webpack_require__(109);\n\tvar debug = __webpack_require__(110)('engine.io-client:polling');\n\t\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = Polling;\n\t\n\t/**\n\t * Is XHR2 supported?\n\t */\n\t\n\tvar hasXHR2 = (function () {\n\t  var XMLHttpRequest = __webpack_require__(93);\n\t  var xhr = new XMLHttpRequest({ xdomain: false });\n\t  return null != xhr.responseType;\n\t})();\n\t\n\t/**\n\t * Polling interface.\n\t *\n\t * @param {Object} opts\n\t * @api private\n\t */\n\t\n\tfunction Polling (opts) {\n\t  var forceBase64 = (opts && opts.forceBase64);\n\t  if (!hasXHR2 || forceBase64) {\n\t    this.supportsBinary = false;\n\t  }\n\t  Transport.call(this, opts);\n\t}\n\t\n\t/**\n\t * Inherits from Transport.\n\t */\n\t\n\tinherit(Polling, Transport);\n\t\n\t/**\n\t * Transport name.\n\t */\n\t\n\tPolling.prototype.name = 'polling';\n\t\n\t/**\n\t * Opens the socket (triggers polling). We write a PING message to determine\n\t * when the transport is open.\n\t *\n\t * @api private\n\t */\n\t\n\tPolling.prototype.doOpen = function () {\n\t  this.poll();\n\t};\n\t\n\t/**\n\t * Pauses polling.\n\t *\n\t * @param {Function} callback upon buffers are flushed and transport is paused\n\t * @api private\n\t */\n\t\n\tPolling.prototype.pause = function (onPause) {\n\t  var self = this;\n\t\n\t  this.readyState = 'pausing';\n\t\n\t  function pause () {\n\t    debug('paused');\n\t    self.readyState = 'paused';\n\t    onPause();\n\t  }\n\t\n\t  if (this.polling || !this.writable) {\n\t    var total = 0;\n\t\n\t    if (this.polling) {\n\t      debug('we are currently polling - waiting to pause');\n\t      total++;\n\t      this.once('pollComplete', function () {\n\t        debug('pre-pause polling complete');\n\t        --total || pause();\n\t      });\n\t    }\n\t\n\t    if (!this.writable) {\n\t      debug('we are currently writing - waiting to pause');\n\t      total++;\n\t      this.once('drain', function () {\n\t        debug('pre-pause writing complete');\n\t        --total || pause();\n\t      });\n\t    }\n\t  } else {\n\t    pause();\n\t  }\n\t};\n\t\n\t/**\n\t * Starts polling cycle.\n\t *\n\t * @api public\n\t */\n\t\n\tPolling.prototype.poll = function () {\n\t  debug('polling');\n\t  this.polling = true;\n\t  this.doPoll();\n\t  this.emit('poll');\n\t};\n\t\n\t/**\n\t * Overloads onData to detect payloads.\n\t *\n\t * @api private\n\t */\n\t\n\tPolling.prototype.onData = function (data) {\n\t  var self = this;\n\t  debug('polling got data %s', data);\n\t  var callback = function (packet, index, total) {\n\t    // if its the first message we consider the transport open\n\t    if ('opening' === self.readyState) {\n\t      self.onOpen();\n\t    }\n\t\n\t    // if its a close packet, we close the ongoing requests\n\t    if ('close' === packet.type) {\n\t      self.onClose();\n\t      return false;\n\t    }\n\t\n\t    // otherwise bypass onData and handle the message\n\t    self.onPacket(packet);\n\t  };\n\t\n\t  // decode payload\n\t  parser.decodePayload(data, this.socket.binaryType, callback);\n\t\n\t  // if an event did not trigger closing\n\t  if ('closed' !== this.readyState) {\n\t    // if we got data we're not polling\n\t    this.polling = false;\n\t    this.emit('pollComplete');\n\t\n\t    if ('open' === this.readyState) {\n\t      this.poll();\n\t    } else {\n\t      debug('ignoring poll - transport state \"%s\"', this.readyState);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * For polling, send a close packet.\n\t *\n\t * @api private\n\t */\n\t\n\tPolling.prototype.doClose = function () {\n\t  var self = this;\n\t\n\t  function close () {\n\t    debug('writing close packet');\n\t    self.write([{ type: 'close' }]);\n\t  }\n\t\n\t  if ('open' === this.readyState) {\n\t    debug('transport open - closing');\n\t    close();\n\t  } else {\n\t    // in case we're trying to close while\n\t    // handshaking is in progress (GH-164)\n\t    debug('transport not open - deferring close');\n\t    this.once('open', close);\n\t  }\n\t};\n\t\n\t/**\n\t * Writes a packets payload.\n\t *\n\t * @param {Array} data packets\n\t * @param {Function} drain callback\n\t * @api private\n\t */\n\t\n\tPolling.prototype.write = function (packets) {\n\t  var self = this;\n\t  this.writable = false;\n\t  var callbackfn = function () {\n\t    self.writable = true;\n\t    self.emit('drain');\n\t  };\n\t\n\t  parser.encodePayload(packets, this.supportsBinary, function (data) {\n\t    self.doWrite(data, callbackfn);\n\t  });\n\t};\n\t\n\t/**\n\t * Generates uri for connection.\n\t *\n\t * @api private\n\t */\n\t\n\tPolling.prototype.uri = function () {\n\t  var query = this.query || {};\n\t  var schema = this.secure ? 'https' : 'http';\n\t  var port = '';\n\t\n\t  // cache busting is forced\n\t  if (false !== this.timestampRequests) {\n\t    query[this.timestampParam] = yeast();\n\t  }\n\t\n\t  if (!this.supportsBinary && !query.sid) {\n\t    query.b64 = 1;\n\t  }\n\t\n\t  query = parseqs.encode(query);\n\t\n\t  // avoid port if default for schema\n\t  if (this.port && (('https' === schema && Number(this.port) !== 443) ||\n\t     ('http' === schema && Number(this.port) !== 80))) {\n\t    port = ':' + this.port;\n\t  }\n\t\n\t  // prepend ? to query\n\t  if (query.length) {\n\t    query = '?' + query;\n\t  }\n\t\n\t  var ipv6 = this.hostname.indexOf(':') !== -1;\n\t  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n\t};\n\n\n/***/ },\n/* 97 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Module dependencies.\n\t */\n\t\n\tvar parser = __webpack_require__(98);\n\tvar Emitter = __webpack_require__(21);\n\t\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = Transport;\n\t\n\t/**\n\t * Transport abstract constructor.\n\t *\n\t * @param {Object} options.\n\t * @api private\n\t */\n\t\n\tfunction Transport (opts) {\n\t  this.path = opts.path;\n\t  this.hostname = opts.hostname;\n\t  this.port = opts.port;\n\t  this.secure = opts.secure;\n\t  this.query = opts.query;\n\t  this.timestampParam = opts.timestampParam;\n\t  this.timestampRequests = opts.timestampRequests;\n\t  this.readyState = '';\n\t  this.agent = opts.agent || false;\n\t  this.socket = opts.socket;\n\t  this.enablesXDR = opts.enablesXDR;\n\t\n\t  // SSL options for Node.js client\n\t  this.pfx = opts.pfx;\n\t  this.key = opts.key;\n\t  this.passphrase = opts.passphrase;\n\t  this.cert = opts.cert;\n\t  this.ca = opts.ca;\n\t  this.ciphers = opts.ciphers;\n\t  this.rejectUnauthorized = opts.rejectUnauthorized;\n\t  this.forceNode = opts.forceNode;\n\t\n\t  // other options for Node.js client\n\t  this.extraHeaders = opts.extraHeaders;\n\t  this.localAddress = opts.localAddress;\n\t}\n\t\n\t/**\n\t * Mix in `Emitter`.\n\t */\n\t\n\tEmitter(Transport.prototype);\n\t\n\t/**\n\t * Emits an error.\n\t *\n\t * @param {String} str\n\t * @return {Transport} for chaining\n\t * @api public\n\t */\n\t\n\tTransport.prototype.onError = function (msg, desc) {\n\t  var err = new Error(msg);\n\t  err.type = 'TransportError';\n\t  err.description = desc;\n\t  this.emit('error', err);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Opens the transport.\n\t *\n\t * @api public\n\t */\n\t\n\tTransport.prototype.open = function () {\n\t  if ('closed' === this.readyState || '' === this.readyState) {\n\t    this.readyState = 'opening';\n\t    this.doOpen();\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Closes the transport.\n\t *\n\t * @api private\n\t */\n\t\n\tTransport.prototype.close = function () {\n\t  if ('opening' === this.readyState || 'open' === this.readyState) {\n\t    this.doClose();\n\t    this.onClose();\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Sends multiple packets.\n\t *\n\t * @param {Array} packets\n\t * @api private\n\t */\n\t\n\tTransport.prototype.send = function (packets) {\n\t  if ('open' === this.readyState) {\n\t    this.write(packets);\n\t  } else {\n\t    throw new Error('Transport not open');\n\t  }\n\t};\n\t\n\t/**\n\t * Called upon open\n\t *\n\t * @api private\n\t */\n\t\n\tTransport.prototype.onOpen = function () {\n\t  this.readyState = 'open';\n\t  this.writable = true;\n\t  this.emit('open');\n\t};\n\t\n\t/**\n\t * Called with data.\n\t *\n\t * @param {String} data\n\t * @api private\n\t */\n\t\n\tTransport.prototype.onData = function (data) {\n\t  var packet = parser.decodePacket(data, this.socket.binaryType);\n\t  this.onPacket(packet);\n\t};\n\t\n\t/**\n\t * Called with a decoded packet.\n\t */\n\t\n\tTransport.prototype.onPacket = function (packet) {\n\t  this.emit('packet', packet);\n\t};\n\t\n\t/**\n\t * Called upon close.\n\t *\n\t * @api private\n\t */\n\t\n\tTransport.prototype.onClose = function () {\n\t  this.readyState = 'closed';\n\t  this.emit('close');\n\t};\n\n\n/***/ },\n/* 98 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * Module dependencies.\n\t */\n\t\n\tvar keys = __webpack_require__(99);\n\tvar hasBinary = __webpack_require__(100);\n\tvar sliceBuffer = __webpack_require__(102);\n\tvar after = __webpack_require__(103);\n\tvar utf8 = __webpack_require__(104);\n\t\n\tvar base64encoder;\n\tif (global && global.ArrayBuffer) {\n\t  base64encoder = __webpack_require__(105);\n\t}\n\t\n\t/**\n\t * Check if we are running an android browser. That requires us to use\n\t * ArrayBuffer with polling transports...\n\t *\n\t * http://ghinda.net/jpeg-blob-ajax-android/\n\t */\n\t\n\tvar isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\n\t\n\t/**\n\t * Check if we are running in PhantomJS.\n\t * Uploading a Blob with PhantomJS does not work correctly, as reported here:\n\t * https://github.com/ariya/phantomjs/issues/11395\n\t * @type boolean\n\t */\n\tvar isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);\n\t\n\t/**\n\t * When true, avoids using Blobs to encode payloads.\n\t * @type boolean\n\t */\n\tvar dontSendBlobs = isAndroid || isPhantomJS;\n\t\n\t/**\n\t * Current protocol version.\n\t */\n\t\n\texports.protocol = 3;\n\t\n\t/**\n\t * Packet types.\n\t */\n\t\n\tvar packets = exports.packets = {\n\t    open:     0    // non-ws\n\t  , close:    1    // non-ws\n\t  , ping:     2\n\t  , pong:     3\n\t  , message:  4\n\t  , upgrade:  5\n\t  , noop:     6\n\t};\n\t\n\tvar packetslist = keys(packets);\n\t\n\t/**\n\t * Premade error packet.\n\t */\n\t\n\tvar err = { type: 'error', data: 'parser error' };\n\t\n\t/**\n\t * Create a blob api even for blob builder when vendor prefixes exist\n\t */\n\t\n\tvar Blob = __webpack_require__(106);\n\t\n\t/**\n\t * Encodes a packet.\n\t *\n\t *     <packet type id> [ <data> ]\n\t *\n\t * Example:\n\t *\n\t *     5hello world\n\t *     3\n\t *     4\n\t *\n\t * Binary is encoded in an identical principle\n\t *\n\t * @api private\n\t */\n\t\n\texports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {\n\t  if ('function' == typeof supportsBinary) {\n\t    callback = supportsBinary;\n\t    supportsBinary = false;\n\t  }\n\t\n\t  if ('function' == typeof utf8encode) {\n\t    callback = utf8encode;\n\t    utf8encode = null;\n\t  }\n\t\n\t  var data = (packet.data === undefined)\n\t    ? undefined\n\t    : packet.data.buffer || packet.data;\n\t\n\t  if (global.ArrayBuffer && data instanceof ArrayBuffer) {\n\t    return encodeArrayBuffer(packet, supportsBinary, callback);\n\t  } else if (Blob && data instanceof global.Blob) {\n\t    return encodeBlob(packet, supportsBinary, callback);\n\t  }\n\t\n\t  // might be an object with { base64: true, data: dataAsBase64String }\n\t  if (data && data.base64) {\n\t    return encodeBase64Object(packet, callback);\n\t  }\n\t\n\t  // Sending data as a utf-8 string\n\t  var encoded = packets[packet.type];\n\t\n\t  // data fragment is optional\n\t  if (undefined !== packet.data) {\n\t    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);\n\t  }\n\t\n\t  return callback('' + encoded);\n\t\n\t};\n\t\n\tfunction encodeBase64Object(packet, callback) {\n\t  // packet data is an object { base64: true, data: dataAsBase64String }\n\t  var message = 'b' + exports.packets[packet.type] + packet.data.data;\n\t  return callback(message);\n\t}\n\t\n\t/**\n\t * Encode packet helpers for binary types\n\t */\n\t\n\tfunction encodeArrayBuffer(packet, supportsBinary, callback) {\n\t  if (!supportsBinary) {\n\t    return exports.encodeBase64Packet(packet, callback);\n\t  }\n\t\n\t  var data = packet.data;\n\t  var contentArray = new Uint8Array(data);\n\t  var resultBuffer = new Uint8Array(1 + data.byteLength);\n\t\n\t  resultBuffer[0] = packets[packet.type];\n\t  for (var i = 0; i < contentArray.length; i++) {\n\t    resultBuffer[i+1] = contentArray[i];\n\t  }\n\t\n\t  return callback(resultBuffer.buffer);\n\t}\n\t\n\tfunction encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {\n\t  if (!supportsBinary) {\n\t    return exports.encodeBase64Packet(packet, callback);\n\t  }\n\t\n\t  var fr = new FileReader();\n\t  fr.onload = function() {\n\t    packet.data = fr.result;\n\t    exports.encodePacket(packet, supportsBinary, true, callback);\n\t  };\n\t  return fr.readAsArrayBuffer(packet.data);\n\t}\n\t\n\tfunction encodeBlob(packet, supportsBinary, callback) {\n\t  if (!supportsBinary) {\n\t    return exports.encodeBase64Packet(packet, callback);\n\t  }\n\t\n\t  if (dontSendBlobs) {\n\t    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);\n\t  }\n\t\n\t  var length = new Uint8Array(1);\n\t  length[0] = packets[packet.type];\n\t  var blob = new Blob([length.buffer, packet.data]);\n\t\n\t  return callback(blob);\n\t}\n\t\n\t/**\n\t * Encodes a packet with binary data in a base64 string\n\t *\n\t * @param {Object} packet, has `type` and `data`\n\t * @return {String} base64 encoded message\n\t */\n\t\n\texports.encodeBase64Packet = function(packet, callback) {\n\t  var message = 'b' + exports.packets[packet.type];\n\t  if (Blob && packet.data instanceof global.Blob) {\n\t    var fr = new FileReader();\n\t    fr.onload = function() {\n\t      var b64 = fr.result.split(',')[1];\n\t      callback(message + b64);\n\t    };\n\t    return fr.readAsDataURL(packet.data);\n\t  }\n\t\n\t  var b64data;\n\t  try {\n\t    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));\n\t  } catch (e) {\n\t    // iPhone Safari doesn't let you apply with typed arrays\n\t    var typed = new Uint8Array(packet.data);\n\t    var basic = new Array(typed.length);\n\t    for (var i = 0; i < typed.length; i++) {\n\t      basic[i] = typed[i];\n\t    }\n\t    b64data = String.fromCharCode.apply(null, basic);\n\t  }\n\t  message += global.btoa(b64data);\n\t  return callback(message);\n\t};\n\t\n\t/**\n\t * Decodes a packet. Changes format to Blob if requested.\n\t *\n\t * @return {Object} with `type` and `data` (if any)\n\t * @api private\n\t */\n\t\n\texports.decodePacket = function (data, binaryType, utf8decode) {\n\t  if (data === undefined) {\n\t    return err;\n\t  }\n\t  // String data\n\t  if (typeof data == 'string') {\n\t    if (data.charAt(0) == 'b') {\n\t      return exports.decodeBase64Packet(data.substr(1), binaryType);\n\t    }\n\t\n\t    if (utf8decode) {\n\t      data = tryDecode(data);\n\t      if (data === false) {\n\t        return err;\n\t      }\n\t    }\n\t    var type = data.charAt(0);\n\t\n\t    if (Number(type) != type || !packetslist[type]) {\n\t      return err;\n\t    }\n\t\n\t    if (data.length > 1) {\n\t      return { type: packetslist[type], data: data.substring(1) };\n\t    } else {\n\t      return { type: packetslist[type] };\n\t    }\n\t  }\n\t\n\t  var asArray = new Uint8Array(data);\n\t  var type = asArray[0];\n\t  var rest = sliceBuffer(data, 1);\n\t  if (Blob && binaryType === 'blob') {\n\t    rest = new Blob([rest]);\n\t  }\n\t  return { type: packetslist[type], data: rest };\n\t};\n\t\n\tfunction tryDecode(data) {\n\t  try {\n\t    data = utf8.decode(data);\n\t  } catch (e) {\n\t    return false;\n\t  }\n\t  return data;\n\t}\n\t\n\t/**\n\t * Decodes a packet encoded in a base64 string\n\t *\n\t * @param {String} base64 encoded message\n\t * @return {Object} with `type` and `data` (if any)\n\t */\n\t\n\texports.decodeBase64Packet = function(msg, binaryType) {\n\t  var type = packetslist[msg.charAt(0)];\n\t  if (!base64encoder) {\n\t    return { type: type, data: { base64: true, data: msg.substr(1) } };\n\t  }\n\t\n\t  var data = base64encoder.decode(msg.substr(1));\n\t\n\t  if (binaryType === 'blob' && Blob) {\n\t    data = new Blob([data]);\n\t  }\n\t\n\t  return { type: type, data: data };\n\t};\n\t\n\t/**\n\t * Encodes multiple messages (payload).\n\t *\n\t *     <length>:data\n\t *\n\t * Example:\n\t *\n\t *     11:hello world2:hi\n\t *\n\t * If any contents are binary, they will be encoded as base64 strings. Base64\n\t * encoded strings are marked with a b before the length specifier\n\t *\n\t * @param {Array} packets\n\t * @api private\n\t */\n\t\n\texports.encodePayload = function (packets, supportsBinary, callback) {\n\t  if (typeof supportsBinary == 'function') {\n\t    callback = supportsBinary;\n\t    supportsBinary = null;\n\t  }\n\t\n\t  var isBinary = hasBinary(packets);\n\t\n\t  if (supportsBinary && isBinary) {\n\t    if (Blob && !dontSendBlobs) {\n\t      return exports.encodePayloadAsBlob(packets, callback);\n\t    }\n\t\n\t    return exports.encodePayloadAsArrayBuffer(packets, callback);\n\t  }\n\t\n\t  if (!packets.length) {\n\t    return callback('0:');\n\t  }\n\t\n\t  function setLengthHeader(message) {\n\t    return message.length + ':' + message;\n\t  }\n\t\n\t  function encodeOne(packet, doneCallback) {\n\t    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {\n\t      doneCallback(null, setLengthHeader(message));\n\t    });\n\t  }\n\t\n\t  map(packets, encodeOne, function(err, results) {\n\t    return callback(results.join(''));\n\t  });\n\t};\n\t\n\t/**\n\t * Async array map using after\n\t */\n\t\n\tfunction map(ary, each, done) {\n\t  var result = new Array(ary.length);\n\t  var next = after(ary.length, done);\n\t\n\t  var eachWithIndex = function(i, el, cb) {\n\t    each(el, function(error, msg) {\n\t      result[i] = msg;\n\t      cb(error, result);\n\t    });\n\t  };\n\t\n\t  for (var i = 0; i < ary.length; i++) {\n\t    eachWithIndex(i, ary[i], next);\n\t  }\n\t}\n\t\n\t/*\n\t * Decodes data when a payload is maybe expected. Possible binary contents are\n\t * decoded from their base64 representation\n\t *\n\t * @param {String} data, callback method\n\t * @api public\n\t */\n\t\n\texports.decodePayload = function (data, binaryType, callback) {\n\t  if (typeof data != 'string') {\n\t    return exports.decodePayloadAsBinary(data, binaryType, callback);\n\t  }\n\t\n\t  if (typeof binaryType === 'function') {\n\t    callback = binaryType;\n\t    binaryType = null;\n\t  }\n\t\n\t  var packet;\n\t  if (data == '') {\n\t    // parser error - ignoring payload\n\t    return callback(err, 0, 1);\n\t  }\n\t\n\t  var length = ''\n\t    , n, msg;\n\t\n\t  for (var i = 0, l = data.length; i < l; i++) {\n\t    var chr = data.charAt(i);\n\t\n\t    if (':' != chr) {\n\t      length += chr;\n\t    } else {\n\t      if ('' == length || (length != (n = Number(length)))) {\n\t        // parser error - ignoring payload\n\t        return callback(err, 0, 1);\n\t      }\n\t\n\t      msg = data.substr(i + 1, n);\n\t\n\t      if (length != msg.length) {\n\t        // parser error - ignoring payload\n\t        return callback(err, 0, 1);\n\t      }\n\t\n\t      if (msg.length) {\n\t        packet = exports.decodePacket(msg, binaryType, true);\n\t\n\t        if (err.type == packet.type && err.data == packet.data) {\n\t          // parser error in individual packet - ignoring payload\n\t          return callback(err, 0, 1);\n\t        }\n\t\n\t        var ret = callback(packet, i + n, l);\n\t        if (false === ret) return;\n\t      }\n\t\n\t      // advance cursor\n\t      i += n;\n\t      length = '';\n\t    }\n\t  }\n\t\n\t  if (length != '') {\n\t    // parser error - ignoring payload\n\t    return callback(err, 0, 1);\n\t  }\n\t\n\t};\n\t\n\t/**\n\t * Encodes multiple messages (payload) as binary.\n\t *\n\t * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n\t * 255><data>\n\t *\n\t * Example:\n\t * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n\t *\n\t * @param {Array} packets\n\t * @return {ArrayBuffer} encoded payload\n\t * @api private\n\t */\n\t\n\texports.encodePayloadAsArrayBuffer = function(packets, callback) {\n\t  if (!packets.length) {\n\t    return callback(new ArrayBuffer(0));\n\t  }\n\t\n\t  function encodeOne(packet, doneCallback) {\n\t    exports.encodePacket(packet, true, true, function(data) {\n\t      return doneCallback(null, data);\n\t    });\n\t  }\n\t\n\t  map(packets, encodeOne, function(err, encodedPackets) {\n\t    var totalLength = encodedPackets.reduce(function(acc, p) {\n\t      var len;\n\t      if (typeof p === 'string'){\n\t        len = p.length;\n\t      } else {\n\t        len = p.byteLength;\n\t      }\n\t      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2\n\t    }, 0);\n\t\n\t    var resultArray = new Uint8Array(totalLength);\n\t\n\t    var bufferIndex = 0;\n\t    encodedPackets.forEach(function(p) {\n\t      var isString = typeof p === 'string';\n\t      var ab = p;\n\t      if (isString) {\n\t        var view = new Uint8Array(p.length);\n\t        for (var i = 0; i < p.length; i++) {\n\t          view[i] = p.charCodeAt(i);\n\t        }\n\t        ab = view.buffer;\n\t      }\n\t\n\t      if (isString) { // not true binary\n\t        resultArray[bufferIndex++] = 0;\n\t      } else { // true binary\n\t        resultArray[bufferIndex++] = 1;\n\t      }\n\t\n\t      var lenStr = ab.byteLength.toString();\n\t      for (var i = 0; i < lenStr.length; i++) {\n\t        resultArray[bufferIndex++] = parseInt(lenStr[i]);\n\t      }\n\t      resultArray[bufferIndex++] = 255;\n\t\n\t      var view = new Uint8Array(ab);\n\t      for (var i = 0; i < view.length; i++) {\n\t        resultArray[bufferIndex++] = view[i];\n\t      }\n\t    });\n\t\n\t    return callback(resultArray.buffer);\n\t  });\n\t};\n\t\n\t/**\n\t * Encode as Blob\n\t */\n\t\n\texports.encodePayloadAsBlob = function(packets, callback) {\n\t  function encodeOne(packet, doneCallback) {\n\t    exports.encodePacket(packet, true, true, function(encoded) {\n\t      var binaryIdentifier = new Uint8Array(1);\n\t      binaryIdentifier[0] = 1;\n\t      if (typeof encoded === 'string') {\n\t        var view = new Uint8Array(encoded.length);\n\t        for (var i = 0; i < encoded.length; i++) {\n\t          view[i] = encoded.charCodeAt(i);\n\t        }\n\t        encoded = view.buffer;\n\t        binaryIdentifier[0] = 0;\n\t      }\n\t\n\t      var len = (encoded instanceof ArrayBuffer)\n\t        ? encoded.byteLength\n\t        : encoded.size;\n\t\n\t      var lenStr = len.toString();\n\t      var lengthAry = new Uint8Array(lenStr.length + 1);\n\t      for (var i = 0; i < lenStr.length; i++) {\n\t        lengthAry[i] = parseInt(lenStr[i]);\n\t      }\n\t      lengthAry[lenStr.length] = 255;\n\t\n\t      if (Blob) {\n\t        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);\n\t        doneCallback(null, blob);\n\t      }\n\t    });\n\t  }\n\t\n\t  map(packets, encodeOne, function(err, results) {\n\t    return callback(new Blob(results));\n\t  });\n\t};\n\t\n\t/*\n\t * Decodes data when a payload is maybe expected. Strings are decoded by\n\t * interpreting each byte as a key code for entries marked to start with 0. See\n\t * description of encodePayloadAsBinary\n\t *\n\t * @param {ArrayBuffer} data, callback method\n\t * @api public\n\t */\n\t\n\texports.decodePayloadAsBinary = function (data, binaryType, callback) {\n\t  if (typeof binaryType === 'function') {\n\t    callback = binaryType;\n\t    binaryType = null;\n\t  }\n\t\n\t  var bufferTail = data;\n\t  var buffers = [];\n\t\n\t  var numberTooLong = false;\n\t  while (bufferTail.byteLength > 0) {\n\t    var tailArray = new Uint8Array(bufferTail);\n\t    var isString = tailArray[0] === 0;\n\t    var msgLength = '';\n\t\n\t    for (var i = 1; ; i++) {\n\t      if (tailArray[i] == 255) break;\n\t\n\t      if (msgLength.length > 310) {\n\t        numberTooLong = true;\n\t        break;\n\t      }\n\t\n\t      msgLength += tailArray[i];\n\t    }\n\t\n\t    if(numberTooLong) return callback(err, 0, 1);\n\t\n\t    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);\n\t    msgLength = parseInt(msgLength);\n\t\n\t    var msg = sliceBuffer(bufferTail, 0, msgLength);\n\t    if (isString) {\n\t      try {\n\t        msg = String.fromCharCode.apply(null, new Uint8Array(msg));\n\t      } catch (e) {\n\t        // iPhone Safari doesn't let you apply to typed arrays\n\t        var typed = new Uint8Array(msg);\n\t        msg = '';\n\t        for (var i = 0; i < typed.length; i++) {\n\t          msg += String.fromCharCode(typed[i]);\n\t        }\n\t      }\n\t    }\n\t\n\t    buffers.push(msg);\n\t    bufferTail = sliceBuffer(bufferTail, msgLength);\n\t  }\n\t\n\t  var total = buffers.length;\n\t  buffers.forEach(function(buffer, i) {\n\t    callback(exports.decodePacket(buffer, binaryType, true), i, total);\n\t  });\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 99 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * Gets the keys for an object.\n\t *\n\t * @return {Array} keys\n\t * @api private\n\t */\n\t\n\tmodule.exports = Object.keys || function keys (obj){\n\t  var arr = [];\n\t  var has = Object.prototype.hasOwnProperty;\n\t\n\t  for (var i in obj) {\n\t    if (has.call(obj, i)) {\n\t      arr.push(i);\n\t    }\n\t  }\n\t  return arr;\n\t};\n\n\n/***/ },\n/* 100 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\n\t/*\n\t * Module requirements.\n\t */\n\t\n\tvar isArray = __webpack_require__(101);\n\t\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = hasBinary;\n\t\n\t/**\n\t * Checks for binary data.\n\t *\n\t * Right now only Buffer and ArrayBuffer are supported..\n\t *\n\t * @param {Object} anything\n\t * @api public\n\t */\n\t\n\tfunction hasBinary(data) {\n\t\n\t  function _hasBinary(obj) {\n\t    if (!obj) return false;\n\t\n\t    if ( (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||\n\t         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||\n\t         (global.Blob && obj instanceof Blob) ||\n\t         (global.File && obj instanceof File)\n\t        ) {\n\t      return true;\n\t    }\n\t\n\t    if (isArray(obj)) {\n\t      for (var i = 0; i < obj.length; i++) {\n\t          if (_hasBinary(obj[i])) {\n\t              return true;\n\t          }\n\t      }\n\t    } else if (obj && 'object' == typeof obj) {\n\t      // see: https://github.com/Automattic/has-binary/pull/4\n\t      if (obj.toJSON && 'function' == typeof obj.toJSON) {\n\t        obj = obj.toJSON();\n\t      }\n\t\n\t      for (var key in obj) {\n\t        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {\n\t          return true;\n\t        }\n\t      }\n\t    }\n\t\n\t    return false;\n\t  }\n\t\n\t  return _hasBinary(data);\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 101 */\n/***/ function(module, exports) {\n\n\tmodule.exports = Array.isArray || function (arr) {\n\t  return Object.prototype.toString.call(arr) == '[object Array]';\n\t};\n\n\n/***/ },\n/* 102 */\n/***/ function(module, exports) {\n\n\t/**\n\t * An abstraction for slicing an arraybuffer even when\n\t * ArrayBuffer.prototype.slice is not supported\n\t *\n\t * @api public\n\t */\n\t\n\tmodule.exports = function(arraybuffer, start, end) {\n\t  var bytes = arraybuffer.byteLength;\n\t  start = start || 0;\n\t  end = end || bytes;\n\t\n\t  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }\n\t\n\t  if (start < 0) { start += bytes; }\n\t  if (end < 0) { end += bytes; }\n\t  if (end > bytes) { end = bytes; }\n\t\n\t  if (start >= bytes || start >= end || bytes === 0) {\n\t    return new ArrayBuffer(0);\n\t  }\n\t\n\t  var abv = new Uint8Array(arraybuffer);\n\t  var result = new Uint8Array(end - start);\n\t  for (var i = start, ii = 0; i < end; i++, ii++) {\n\t    result[ii] = abv[i];\n\t  }\n\t  return result.buffer;\n\t};\n\n\n/***/ },\n/* 103 */\n/***/ function(module, exports) {\n\n\tmodule.exports = after\n\t\n\tfunction after(count, callback, err_cb) {\n\t    var bail = false\n\t    err_cb = err_cb || noop\n\t    proxy.count = count\n\t\n\t    return (count === 0) ? callback() : proxy\n\t\n\t    function proxy(err, result) {\n\t        if (proxy.count <= 0) {\n\t            throw new Error('after called too many times')\n\t        }\n\t        --proxy.count\n\t\n\t        // after first error, rest are passed to err_cb\n\t        if (err) {\n\t            bail = true\n\t            callback(err)\n\t            // future error callbacks will go to error handler\n\t            callback = err_cb\n\t        } else if (proxy.count === 0 && !bail) {\n\t            callback(null, result)\n\t        }\n\t    }\n\t}\n\t\n\tfunction noop() {}\n\n\n/***/ },\n/* 104 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/wtf8 v1.0.0 by @mathias */\n\t;(function(root) {\n\t\n\t\t// Detect free variables `exports`\n\t\tvar freeExports = typeof exports == 'object' && exports;\n\t\n\t\t// Detect free variable `module`\n\t\tvar freeModule = typeof module == 'object' && module &&\n\t\t\tmodule.exports == freeExports && module;\n\t\n\t\t// Detect free variable `global`, from Node.js or Browserified code,\n\t\t// and use it as `root`\n\t\tvar freeGlobal = typeof global == 'object' && global;\n\t\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\t\troot = freeGlobal;\n\t\t}\n\t\n\t\t/*--------------------------------------------------------------------------*/\n\t\n\t\tvar stringFromCharCode = String.fromCharCode;\n\t\n\t\t// Taken from https://mths.be/punycode\n\t\tfunction ucs2decode(string) {\n\t\t\tvar output = [];\n\t\t\tvar counter = 0;\n\t\t\tvar length = string.length;\n\t\t\tvar value;\n\t\t\tvar extra;\n\t\t\twhile (counter < length) {\n\t\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\t\toutput.push(value);\n\t\t\t\t\t\tcounter--;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toutput.push(value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn output;\n\t\t}\n\t\n\t\t// Taken from https://mths.be/punycode\n\t\tfunction ucs2encode(array) {\n\t\t\tvar length = array.length;\n\t\t\tvar index = -1;\n\t\t\tvar value;\n\t\t\tvar output = '';\n\t\t\twhile (++index < length) {\n\t\t\t\tvalue = array[index];\n\t\t\t\tif (value > 0xFFFF) {\n\t\t\t\t\tvalue -= 0x10000;\n\t\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t\t}\n\t\t\t\toutput += stringFromCharCode(value);\n\t\t\t}\n\t\t\treturn output;\n\t\t}\n\t\n\t\t/*--------------------------------------------------------------------------*/\n\t\n\t\tfunction createByte(codePoint, shift) {\n\t\t\treturn stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);\n\t\t}\n\t\n\t\tfunction encodeCodePoint(codePoint) {\n\t\t\tif ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence\n\t\t\t\treturn stringFromCharCode(codePoint);\n\t\t\t}\n\t\t\tvar symbol = '';\n\t\t\tif ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence\n\t\t\t\tsymbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);\n\t\t\t}\n\t\t\telse if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence\n\t\t\t\tsymbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);\n\t\t\t\tsymbol += createByte(codePoint, 6);\n\t\t\t}\n\t\t\telse if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence\n\t\t\t\tsymbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);\n\t\t\t\tsymbol += createByte(codePoint, 12);\n\t\t\t\tsymbol += createByte(codePoint, 6);\n\t\t\t}\n\t\t\tsymbol += stringFromCharCode((codePoint & 0x3F) | 0x80);\n\t\t\treturn symbol;\n\t\t}\n\t\n\t\tfunction wtf8encode(string) {\n\t\t\tvar codePoints = ucs2decode(string);\n\t\t\tvar length = codePoints.length;\n\t\t\tvar index = -1;\n\t\t\tvar codePoint;\n\t\t\tvar byteString = '';\n\t\t\twhile (++index < length) {\n\t\t\t\tcodePoint = codePoints[index];\n\t\t\t\tbyteString += encodeCodePoint(codePoint);\n\t\t\t}\n\t\t\treturn byteString;\n\t\t}\n\t\n\t\t/*--------------------------------------------------------------------------*/\n\t\n\t\tfunction readContinuationByte() {\n\t\t\tif (byteIndex >= byteCount) {\n\t\t\t\tthrow Error('Invalid byte index');\n\t\t\t}\n\t\n\t\t\tvar continuationByte = byteArray[byteIndex] & 0xFF;\n\t\t\tbyteIndex++;\n\t\n\t\t\tif ((continuationByte & 0xC0) == 0x80) {\n\t\t\t\treturn continuationByte & 0x3F;\n\t\t\t}\n\t\n\t\t\t// If we end up here, it’s not a continuation byte.\n\t\t\tthrow Error('Invalid continuation byte');\n\t\t}\n\t\n\t\tfunction decodeSymbol() {\n\t\t\tvar byte1;\n\t\t\tvar byte2;\n\t\t\tvar byte3;\n\t\t\tvar byte4;\n\t\t\tvar codePoint;\n\t\n\t\t\tif (byteIndex > byteCount) {\n\t\t\t\tthrow Error('Invalid byte index');\n\t\t\t}\n\t\n\t\t\tif (byteIndex == byteCount) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\t// Read the first byte.\n\t\t\tbyte1 = byteArray[byteIndex] & 0xFF;\n\t\t\tbyteIndex++;\n\t\n\t\t\t// 1-byte sequence (no continuation bytes)\n\t\t\tif ((byte1 & 0x80) == 0) {\n\t\t\t\treturn byte1;\n\t\t\t}\n\t\n\t\t\t// 2-byte sequence\n\t\t\tif ((byte1 & 0xE0) == 0xC0) {\n\t\t\t\tvar byte2 = readContinuationByte();\n\t\t\t\tcodePoint = ((byte1 & 0x1F) << 6) | byte2;\n\t\t\t\tif (codePoint >= 0x80) {\n\t\t\t\t\treturn codePoint;\n\t\t\t\t} else {\n\t\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// 3-byte sequence (may include unpaired surrogates)\n\t\t\tif ((byte1 & 0xF0) == 0xE0) {\n\t\t\t\tbyte2 = readContinuationByte();\n\t\t\t\tbyte3 = readContinuationByte();\n\t\t\t\tcodePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;\n\t\t\t\tif (codePoint >= 0x0800) {\n\t\t\t\t\treturn codePoint;\n\t\t\t\t} else {\n\t\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// 4-byte sequence\n\t\t\tif ((byte1 & 0xF8) == 0xF0) {\n\t\t\t\tbyte2 = readContinuationByte();\n\t\t\t\tbyte3 = readContinuationByte();\n\t\t\t\tbyte4 = readContinuationByte();\n\t\t\t\tcodePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |\n\t\t\t\t\t(byte3 << 0x06) | byte4;\n\t\t\t\tif (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n\t\t\t\t\treturn codePoint;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tthrow Error('Invalid WTF-8 detected');\n\t\t}\n\t\n\t\tvar byteArray;\n\t\tvar byteCount;\n\t\tvar byteIndex;\n\t\tfunction wtf8decode(byteString) {\n\t\t\tbyteArray = ucs2decode(byteString);\n\t\t\tbyteCount = byteArray.length;\n\t\t\tbyteIndex = 0;\n\t\t\tvar codePoints = [];\n\t\t\tvar tmp;\n\t\t\twhile ((tmp = decodeSymbol()) !== false) {\n\t\t\t\tcodePoints.push(tmp);\n\t\t\t}\n\t\t\treturn ucs2encode(codePoints);\n\t\t}\n\t\n\t\t/*--------------------------------------------------------------------------*/\n\t\n\t\tvar wtf8 = {\n\t\t\t'version': '1.0.0',\n\t\t\t'encode': wtf8encode,\n\t\t\t'decode': wtf8decode\n\t\t};\n\t\n\t\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t\t// like the following:\n\t\tif (\n\t\t\ttrue\n\t\t) {\n\t\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\t\t\treturn wtf8;\n\t\t\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\t\tif (freeModule) { // in Node.js or RingoJS v0.8.0+\n\t\t\t\tfreeModule.exports = wtf8;\n\t\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\t\tvar object = {};\n\t\t\t\tvar hasOwnProperty = object.hasOwnProperty;\n\t\t\t\tfor (var key in wtf8) {\n\t\t\t\t\thasOwnProperty.call(wtf8, key) && (freeExports[key] = wtf8[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else { // in Rhino or a web browser\n\t\t\troot.wtf8 = wtf8;\n\t\t}\n\t\n\t}(this));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(82)(module), (function() { return this; }())))\n\n/***/ },\n/* 105 */\n/***/ function(module, exports) {\n\n\t/*\n\t * base64-arraybuffer\n\t * https://github.com/niklasvh/base64-arraybuffer\n\t *\n\t * Copyright (c) 2012 Niklas von Hertzen\n\t * Licensed under the MIT license.\n\t */\n\t(function(){\n\t  \"use strict\";\n\t\n\t  var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\t\n\t  // Use a lookup table to find the index.\n\t  var lookup = new Uint8Array(256);\n\t  for (var i = 0; i < chars.length; i++) {\n\t    lookup[chars.charCodeAt(i)] = i;\n\t  }\n\t\n\t  exports.encode = function(arraybuffer) {\n\t    var bytes = new Uint8Array(arraybuffer),\n\t    i, len = bytes.length, base64 = \"\";\n\t\n\t    for (i = 0; i < len; i+=3) {\n\t      base64 += chars[bytes[i] >> 2];\n\t      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n\t      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n\t      base64 += chars[bytes[i + 2] & 63];\n\t    }\n\t\n\t    if ((len % 3) === 2) {\n\t      base64 = base64.substring(0, base64.length - 1) + \"=\";\n\t    } else if (len % 3 === 1) {\n\t      base64 = base64.substring(0, base64.length - 2) + \"==\";\n\t    }\n\t\n\t    return base64;\n\t  };\n\t\n\t  exports.decode =  function(base64) {\n\t    var bufferLength = base64.length * 0.75,\n\t    len = base64.length, i, p = 0,\n\t    encoded1, encoded2, encoded3, encoded4;\n\t\n\t    if (base64[base64.length - 1] === \"=\") {\n\t      bufferLength--;\n\t      if (base64[base64.length - 2] === \"=\") {\n\t        bufferLength--;\n\t      }\n\t    }\n\t\n\t    var arraybuffer = new ArrayBuffer(bufferLength),\n\t    bytes = new Uint8Array(arraybuffer);\n\t\n\t    for (i = 0; i < len; i+=4) {\n\t      encoded1 = lookup[base64.charCodeAt(i)];\n\t      encoded2 = lookup[base64.charCodeAt(i+1)];\n\t      encoded3 = lookup[base64.charCodeAt(i+2)];\n\t      encoded4 = lookup[base64.charCodeAt(i+3)];\n\t\n\t      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n\t      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n\t      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n\t    }\n\t\n\t    return arraybuffer;\n\t  };\n\t})();\n\n\n/***/ },\n/* 106 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * Create a blob builder even when vendor prefixes exist\n\t */\n\t\n\tvar BlobBuilder = global.BlobBuilder\n\t  || global.WebKitBlobBuilder\n\t  || global.MSBlobBuilder\n\t  || global.MozBlobBuilder;\n\t\n\t/**\n\t * Check if Blob constructor is supported\n\t */\n\t\n\tvar blobSupported = (function() {\n\t  try {\n\t    var a = new Blob(['hi']);\n\t    return a.size === 2;\n\t  } catch(e) {\n\t    return false;\n\t  }\n\t})();\n\t\n\t/**\n\t * Check if Blob constructor supports ArrayBufferViews\n\t * Fails in Safari 6, so we need to map to ArrayBuffers there.\n\t */\n\t\n\tvar blobSupportsArrayBufferView = blobSupported && (function() {\n\t  try {\n\t    var b = new Blob([new Uint8Array([1,2])]);\n\t    return b.size === 2;\n\t  } catch(e) {\n\t    return false;\n\t  }\n\t})();\n\t\n\t/**\n\t * Check if BlobBuilder is supported\n\t */\n\t\n\tvar blobBuilderSupported = BlobBuilder\n\t  && BlobBuilder.prototype.append\n\t  && BlobBuilder.prototype.getBlob;\n\t\n\t/**\n\t * Helper function that maps ArrayBufferViews to ArrayBuffers\n\t * Used by BlobBuilder constructor and old browsers that didn't\n\t * support it in the Blob constructor.\n\t */\n\t\n\tfunction mapArrayBufferViews(ary) {\n\t  for (var i = 0; i < ary.length; i++) {\n\t    var chunk = ary[i];\n\t    if (chunk.buffer instanceof ArrayBuffer) {\n\t      var buf = chunk.buffer;\n\t\n\t      // if this is a subarray, make a copy so we only\n\t      // include the subarray region from the underlying buffer\n\t      if (chunk.byteLength !== buf.byteLength) {\n\t        var copy = new Uint8Array(chunk.byteLength);\n\t        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));\n\t        buf = copy.buffer;\n\t      }\n\t\n\t      ary[i] = buf;\n\t    }\n\t  }\n\t}\n\t\n\tfunction BlobBuilderConstructor(ary, options) {\n\t  options = options || {};\n\t\n\t  var bb = new BlobBuilder();\n\t  mapArrayBufferViews(ary);\n\t\n\t  for (var i = 0; i < ary.length; i++) {\n\t    bb.append(ary[i]);\n\t  }\n\t\n\t  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();\n\t};\n\t\n\tfunction BlobConstructor(ary, options) {\n\t  mapArrayBufferViews(ary);\n\t  return new Blob(ary, options || {});\n\t};\n\t\n\tmodule.exports = (function() {\n\t  if (blobSupported) {\n\t    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;\n\t  } else if (blobBuilderSupported) {\n\t    return BlobBuilderConstructor;\n\t  } else {\n\t    return undefined;\n\t  }\n\t})();\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 107 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * Compiles a querystring\r\n\t * Returns string representation of the object\r\n\t *\r\n\t * @param {Object}\r\n\t * @api private\r\n\t */\r\n\t\r\n\texports.encode = function (obj) {\r\n\t  var str = '';\r\n\t\r\n\t  for (var i in obj) {\r\n\t    if (obj.hasOwnProperty(i)) {\r\n\t      if (str.length) str += '&';\r\n\t      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  return str;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Parses a simple querystring into an object\r\n\t *\r\n\t * @param {String} qs\r\n\t * @api private\r\n\t */\r\n\t\r\n\texports.decode = function(qs){\r\n\t  var qry = {};\r\n\t  var pairs = qs.split('&');\r\n\t  for (var i = 0, l = pairs.length; i < l; i++) {\r\n\t    var pair = pairs[i].split('=');\r\n\t    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\r\n\t  }\r\n\t  return qry;\r\n\t};\r\n\n\n/***/ },\n/* 108 */\n/***/ function(module, exports) {\n\n\t\n\tmodule.exports = function(a, b){\n\t  var fn = function(){};\n\t  fn.prototype = b.prototype;\n\t  a.prototype = new fn;\n\t  a.prototype.constructor = a;\n\t};\n\n/***/ },\n/* 109 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')\n\t  , length = 64\n\t  , map = {}\n\t  , seed = 0\n\t  , i = 0\n\t  , prev;\n\t\n\t/**\n\t * Return a string representing the specified number.\n\t *\n\t * @param {Number} num The number to convert.\n\t * @returns {String} The string representation of the number.\n\t * @api public\n\t */\n\tfunction encode(num) {\n\t  var encoded = '';\n\t\n\t  do {\n\t    encoded = alphabet[num % length] + encoded;\n\t    num = Math.floor(num / length);\n\t  } while (num > 0);\n\t\n\t  return encoded;\n\t}\n\t\n\t/**\n\t * Return the integer value specified by the given string.\n\t *\n\t * @param {String} str The string to convert.\n\t * @returns {Number} The integer value represented by the string.\n\t * @api public\n\t */\n\tfunction decode(str) {\n\t  var decoded = 0;\n\t\n\t  for (i = 0; i < str.length; i++) {\n\t    decoded = decoded * length + map[str.charAt(i)];\n\t  }\n\t\n\t  return decoded;\n\t}\n\t\n\t/**\n\t * Yeast: A tiny growing id generator.\n\t *\n\t * @returns {String} A unique id.\n\t * @api public\n\t */\n\tfunction yeast() {\n\t  var now = encode(+new Date());\n\t\n\t  if (now !== prev) return seed = 0, prev = now;\n\t  return now +'.'+ encode(seed++);\n\t}\n\t\n\t//\n\t// Map each character to its index.\n\t//\n\tfor (; i < length; i++) map[alphabet[i]] = i;\n\t\n\t//\n\t// Expose the `yeast`, `encode` and `decode` functions.\n\t//\n\tyeast.encode = encode;\n\tyeast.decode = decode;\n\tmodule.exports = yeast;\n\n\n/***/ },\n/* 110 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {\n\t/**\n\t * This is the web browser implementation of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = __webpack_require__(111);\n\texports.log = log;\n\texports.formatArgs = formatArgs;\n\texports.save = save;\n\texports.load = load;\n\texports.useColors = useColors;\n\texports.storage = 'undefined' != typeof chrome\n\t               && 'undefined' != typeof chrome.storage\n\t                  ? chrome.storage.local\n\t                  : localstorage();\n\t\n\t/**\n\t * Colors.\n\t */\n\t\n\texports.colors = [\n\t  'lightseagreen',\n\t  'forestgreen',\n\t  'goldenrod',\n\t  'dodgerblue',\n\t  'darkorchid',\n\t  'crimson'\n\t];\n\t\n\t/**\n\t * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n\t * and the Firebug extension (any Firefox version) are known\n\t * to support \"%c\" CSS customizations.\n\t *\n\t * TODO: add a `localStorage` variable to explicitly enable/disable colors\n\t */\n\t\n\tfunction useColors() {\n\t  // is webkit? http://stackoverflow.com/a/16459606/376773\n\t  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\t  return (typeof document !== 'undefined' && 'WebkitAppearance' in document.documentElement.style) ||\n\t    // is firebug? http://stackoverflow.com/a/398120/376773\n\t    (window.console && (console.firebug || (console.exception && console.table))) ||\n\t    // is firefox >= v31?\n\t    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n\t}\n\t\n\t/**\n\t * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n\t */\n\t\n\texports.formatters.j = function(v) {\n\t  try {\n\t    return JSON.stringify(v);\n\t  } catch (err) {\n\t    return '[UnexpectedJSONParseError]: ' + err.message;\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Colorize log arguments if enabled.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction formatArgs() {\n\t  var args = arguments;\n\t  var useColors = this.useColors;\n\t\n\t  args[0] = (useColors ? '%c' : '')\n\t    + this.namespace\n\t    + (useColors ? ' %c' : ' ')\n\t    + args[0]\n\t    + (useColors ? '%c ' : ' ')\n\t    + '+' + exports.humanize(this.diff);\n\t\n\t  if (!useColors) return args;\n\t\n\t  var c = 'color: ' + this.color;\n\t  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\t\n\t  // the final \"%c\" is somewhat tricky, because there could be other\n\t  // arguments passed either before or after the %c, so we need to\n\t  // figure out the correct index to insert the CSS into\n\t  var index = 0;\n\t  var lastC = 0;\n\t  args[0].replace(/%[a-z%]/g, function(match) {\n\t    if ('%%' === match) return;\n\t    index++;\n\t    if ('%c' === match) {\n\t      // we only are interested in the *last* %c\n\t      // (the user may have provided their own)\n\t      lastC = index;\n\t    }\n\t  });\n\t\n\t  args.splice(lastC, 0, c);\n\t  return args;\n\t}\n\t\n\t/**\n\t * Invokes `console.log()` when available.\n\t * No-op when `console.log` is not a \"function\".\n\t *\n\t * @api public\n\t */\n\t\n\tfunction log() {\n\t  // this hackery is required for IE8/9, where\n\t  // the `console.log` function doesn't have 'apply'\n\t  return 'object' === typeof console\n\t    && console.log\n\t    && Function.prototype.apply.call(console.log, console, arguments);\n\t}\n\t\n\t/**\n\t * Save `namespaces`.\n\t *\n\t * @param {String} namespaces\n\t * @api private\n\t */\n\t\n\tfunction save(namespaces) {\n\t  try {\n\t    if (null == namespaces) {\n\t      exports.storage.removeItem('debug');\n\t    } else {\n\t      exports.storage.debug = namespaces;\n\t    }\n\t  } catch(e) {}\n\t}\n\t\n\t/**\n\t * Load `namespaces`.\n\t *\n\t * @return {String} returns the previously persisted debug modes\n\t * @api private\n\t */\n\t\n\tfunction load() {\n\t  var r;\n\t  try {\n\t    return exports.storage.debug;\n\t  } catch(e) {}\n\t\n\t  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\t  if (typeof process !== 'undefined' && 'env' in process) {\n\t    return process.env.DEBUG;\n\t  }\n\t}\n\t\n\t/**\n\t * Enable namespaces listed in `localStorage.debug` initially.\n\t */\n\t\n\texports.enable(load());\n\t\n\t/**\n\t * Localstorage attempts to return the localstorage.\n\t *\n\t * This is necessary because safari throws\n\t * when a user disables cookies/localstorage\n\t * and you attempt to access it.\n\t *\n\t * @return {LocalStorage}\n\t * @api private\n\t */\n\t\n\tfunction localstorage(){\n\t  try {\n\t    return window.localStorage;\n\t  } catch (e) {}\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ },\n/* 111 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * This is the common logic for both the Node.js and web browser\n\t * implementations of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = debug.debug = debug;\n\texports.coerce = coerce;\n\texports.disable = disable;\n\texports.enable = enable;\n\texports.enabled = enabled;\n\texports.humanize = __webpack_require__(112);\n\t\n\t/**\n\t * The currently active debug mode names, and names to skip.\n\t */\n\t\n\texports.names = [];\n\texports.skips = [];\n\t\n\t/**\n\t * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t *\n\t * Valid key names are a single, lowercased letter, i.e. \"n\".\n\t */\n\t\n\texports.formatters = {};\n\t\n\t/**\n\t * Previously assigned color.\n\t */\n\t\n\tvar prevColor = 0;\n\t\n\t/**\n\t * Previous log timestamp.\n\t */\n\t\n\tvar prevTime;\n\t\n\t/**\n\t * Select a color.\n\t *\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction selectColor() {\n\t  return exports.colors[prevColor++ % exports.colors.length];\n\t}\n\t\n\t/**\n\t * Create a debugger with the given `namespace`.\n\t *\n\t * @param {String} namespace\n\t * @return {Function}\n\t * @api public\n\t */\n\t\n\tfunction debug(namespace) {\n\t\n\t  // define the `disabled` version\n\t  function disabled() {\n\t  }\n\t  disabled.enabled = false;\n\t\n\t  // define the `enabled` version\n\t  function enabled() {\n\t\n\t    var self = enabled;\n\t\n\t    // set `diff` timestamp\n\t    var curr = +new Date();\n\t    var ms = curr - (prevTime || curr);\n\t    self.diff = ms;\n\t    self.prev = prevTime;\n\t    self.curr = curr;\n\t    prevTime = curr;\n\t\n\t    // add the `color` if not set\n\t    if (null == self.useColors) self.useColors = exports.useColors();\n\t    if (null == self.color && self.useColors) self.color = selectColor();\n\t\n\t    var args = new Array(arguments.length);\n\t    for (var i = 0; i < args.length; i++) {\n\t      args[i] = arguments[i];\n\t    }\n\t\n\t    args[0] = exports.coerce(args[0]);\n\t\n\t    if ('string' !== typeof args[0]) {\n\t      // anything else let's inspect with %o\n\t      args = ['%o'].concat(args);\n\t    }\n\t\n\t    // apply any `formatters` transformations\n\t    var index = 0;\n\t    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n\t      // if we encounter an escaped % then don't increase the array index\n\t      if (match === '%%') return match;\n\t      index++;\n\t      var formatter = exports.formatters[format];\n\t      if ('function' === typeof formatter) {\n\t        var val = args[index];\n\t        match = formatter.call(self, val);\n\t\n\t        // now we need to remove `args[index]` since it's inlined in the `format`\n\t        args.splice(index, 1);\n\t        index--;\n\t      }\n\t      return match;\n\t    });\n\t\n\t    // apply env-specific formatting\n\t    args = exports.formatArgs.apply(self, args);\n\t\n\t    var logFn = enabled.log || exports.log || console.log.bind(console);\n\t    logFn.apply(self, args);\n\t  }\n\t  enabled.enabled = true;\n\t\n\t  var fn = exports.enabled(namespace) ? enabled : disabled;\n\t\n\t  fn.namespace = namespace;\n\t\n\t  return fn;\n\t}\n\t\n\t/**\n\t * Enables a debug mode by namespaces. This can include modes\n\t * separated by a colon and wildcards.\n\t *\n\t * @param {String} namespaces\n\t * @api public\n\t */\n\t\n\tfunction enable(namespaces) {\n\t  exports.save(namespaces);\n\t\n\t  var split = (namespaces || '').split(/[\\s,]+/);\n\t  var len = split.length;\n\t\n\t  for (var i = 0; i < len; i++) {\n\t    if (!split[i]) continue; // ignore empty strings\n\t    namespaces = split[i].replace(/[\\\\^$+?.()|[\\]{}]/g, '\\\\$&').replace(/\\*/g, '.*?');\n\t    if (namespaces[0] === '-') {\n\t      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t    } else {\n\t      exports.names.push(new RegExp('^' + namespaces + '$'));\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Disable debug output.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction disable() {\n\t  exports.enable('');\n\t}\n\t\n\t/**\n\t * Returns true if the given mode name is enabled, false otherwise.\n\t *\n\t * @param {String} name\n\t * @return {Boolean}\n\t * @api public\n\t */\n\t\n\tfunction enabled(name) {\n\t  var i, len;\n\t  for (i = 0, len = exports.skips.length; i < len; i++) {\n\t    if (exports.skips[i].test(name)) {\n\t      return false;\n\t    }\n\t  }\n\t  for (i = 0, len = exports.names.length; i < len; i++) {\n\t    if (exports.names[i].test(name)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t * Coerce `val`.\n\t *\n\t * @param {Mixed} val\n\t * @return {Mixed}\n\t * @api private\n\t */\n\t\n\tfunction coerce(val) {\n\t  if (val instanceof Error) return val.stack || val.message;\n\t  return val;\n\t}\n\n\n/***/ },\n/* 112 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Helpers.\n\t */\n\t\n\tvar s = 1000\n\tvar m = s * 60\n\tvar h = m * 60\n\tvar d = h * 24\n\tvar y = d * 365.25\n\t\n\t/**\n\t * Parse or format the given `val`.\n\t *\n\t * Options:\n\t *\n\t *  - `long` verbose formatting [false]\n\t *\n\t * @param {String|Number} val\n\t * @param {Object} options\n\t * @throws {Error} throw an error if val is not a non-empty string or a number\n\t * @return {String|Number}\n\t * @api public\n\t */\n\t\n\tmodule.exports = function (val, options) {\n\t  options = options || {}\n\t  var type = typeof val\n\t  if (type === 'string' && val.length > 0) {\n\t    return parse(val)\n\t  } else if (type === 'number' && isNaN(val) === false) {\n\t    return options.long ?\n\t\t\t\tfmtLong(val) :\n\t\t\t\tfmtShort(val)\n\t  }\n\t  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))\n\t}\n\t\n\t/**\n\t * Parse the given `str` and return milliseconds.\n\t *\n\t * @param {String} str\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction parse(str) {\n\t  str = String(str)\n\t  if (str.length > 10000) {\n\t    return\n\t  }\n\t  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)\n\t  if (!match) {\n\t    return\n\t  }\n\t  var n = parseFloat(match[1])\n\t  var type = (match[2] || 'ms').toLowerCase()\n\t  switch (type) {\n\t    case 'years':\n\t    case 'year':\n\t    case 'yrs':\n\t    case 'yr':\n\t    case 'y':\n\t      return n * y\n\t    case 'days':\n\t    case 'day':\n\t    case 'd':\n\t      return n * d\n\t    case 'hours':\n\t    case 'hour':\n\t    case 'hrs':\n\t    case 'hr':\n\t    case 'h':\n\t      return n * h\n\t    case 'minutes':\n\t    case 'minute':\n\t    case 'mins':\n\t    case 'min':\n\t    case 'm':\n\t      return n * m\n\t    case 'seconds':\n\t    case 'second':\n\t    case 'secs':\n\t    case 'sec':\n\t    case 's':\n\t      return n * s\n\t    case 'milliseconds':\n\t    case 'millisecond':\n\t    case 'msecs':\n\t    case 'msec':\n\t    case 'ms':\n\t      return n\n\t    default:\n\t      return undefined\n\t  }\n\t}\n\t\n\t/**\n\t * Short format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction fmtShort(ms) {\n\t  if (ms >= d) {\n\t    return Math.round(ms / d) + 'd'\n\t  }\n\t  if (ms >= h) {\n\t    return Math.round(ms / h) + 'h'\n\t  }\n\t  if (ms >= m) {\n\t    return Math.round(ms / m) + 'm'\n\t  }\n\t  if (ms >= s) {\n\t    return Math.round(ms / s) + 's'\n\t  }\n\t  return ms + 'ms'\n\t}\n\t\n\t/**\n\t * Long format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction fmtLong(ms) {\n\t  return plural(ms, d, 'day') ||\n\t    plural(ms, h, 'hour') ||\n\t    plural(ms, m, 'minute') ||\n\t    plural(ms, s, 'second') ||\n\t    ms + ' ms'\n\t}\n\t\n\t/**\n\t * Pluralization helper.\n\t */\n\t\n\tfunction plural(ms, n, name) {\n\t  if (ms < n) {\n\t    return\n\t  }\n\t  if (ms < n * 1.5) {\n\t    return Math.floor(ms / n) + ' ' + name\n\t  }\n\t  return Math.ceil(ms / n) + ' ' + name + 's'\n\t}\n\n\n/***/ },\n/* 113 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\n\t/**\n\t * Module requirements.\n\t */\n\t\n\tvar Polling = __webpack_require__(96);\n\tvar inherit = __webpack_require__(108);\n\t\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = JSONPPolling;\n\t\n\t/**\n\t * Cached regular expressions.\n\t */\n\t\n\tvar rNewline = /\\n/g;\n\tvar rEscapedNewline = /\\\\n/g;\n\t\n\t/**\n\t * Global JSONP callbacks.\n\t */\n\t\n\tvar callbacks;\n\t\n\t/**\n\t * Noop.\n\t */\n\t\n\tfunction empty () { }\n\t\n\t/**\n\t * JSONP Polling constructor.\n\t *\n\t * @param {Object} opts.\n\t * @api public\n\t */\n\t\n\tfunction JSONPPolling (opts) {\n\t  Polling.call(this, opts);\n\t\n\t  this.query = this.query || {};\n\t\n\t  // define global callbacks array if not present\n\t  // we do this here (lazily) to avoid unneeded global pollution\n\t  if (!callbacks) {\n\t    // we need to consider multiple engines in the same page\n\t    if (!global.___eio) global.___eio = [];\n\t    callbacks = global.___eio;\n\t  }\n\t\n\t  // callback identifier\n\t  this.index = callbacks.length;\n\t\n\t  // add callback to jsonp global\n\t  var self = this;\n\t  callbacks.push(function (msg) {\n\t    self.onData(msg);\n\t  });\n\t\n\t  // append to query string\n\t  this.query.j = this.index;\n\t\n\t  // prevent spurious errors from being emitted when the window is unloaded\n\t  if (global.document && global.addEventListener) {\n\t    global.addEventListener('beforeunload', function () {\n\t      if (self.script) self.script.onerror = empty;\n\t    }, false);\n\t  }\n\t}\n\t\n\t/**\n\t * Inherits from Polling.\n\t */\n\t\n\tinherit(JSONPPolling, Polling);\n\t\n\t/*\n\t * JSONP only supports binary as base64 encoded strings\n\t */\n\t\n\tJSONPPolling.prototype.supportsBinary = false;\n\t\n\t/**\n\t * Closes the socket.\n\t *\n\t * @api private\n\t */\n\t\n\tJSONPPolling.prototype.doClose = function () {\n\t  if (this.script) {\n\t    this.script.parentNode.removeChild(this.script);\n\t    this.script = null;\n\t  }\n\t\n\t  if (this.form) {\n\t    this.form.parentNode.removeChild(this.form);\n\t    this.form = null;\n\t    this.iframe = null;\n\t  }\n\t\n\t  Polling.prototype.doClose.call(this);\n\t};\n\t\n\t/**\n\t * Starts a poll cycle.\n\t *\n\t * @api private\n\t */\n\t\n\tJSONPPolling.prototype.doPoll = function () {\n\t  var self = this;\n\t  var script = document.createElement('script');\n\t\n\t  if (this.script) {\n\t    this.script.parentNode.removeChild(this.script);\n\t    this.script = null;\n\t  }\n\t\n\t  script.async = true;\n\t  script.src = this.uri();\n\t  script.onerror = function (e) {\n\t    self.onError('jsonp poll error', e);\n\t  };\n\t\n\t  var insertAt = document.getElementsByTagName('script')[0];\n\t  if (insertAt) {\n\t    insertAt.parentNode.insertBefore(script, insertAt);\n\t  } else {\n\t    (document.head || document.body).appendChild(script);\n\t  }\n\t  this.script = script;\n\t\n\t  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);\n\t\n\t  if (isUAgecko) {\n\t    setTimeout(function () {\n\t      var iframe = document.createElement('iframe');\n\t      document.body.appendChild(iframe);\n\t      document.body.removeChild(iframe);\n\t    }, 100);\n\t  }\n\t};\n\t\n\t/**\n\t * Writes with a hidden iframe.\n\t *\n\t * @param {String} data to send\n\t * @param {Function} called upon flush.\n\t * @api private\n\t */\n\t\n\tJSONPPolling.prototype.doWrite = function (data, fn) {\n\t  var self = this;\n\t\n\t  if (!this.form) {\n\t    var form = document.createElement('form');\n\t    var area = document.createElement('textarea');\n\t    var id = this.iframeId = 'eio_iframe_' + this.index;\n\t    var iframe;\n\t\n\t    form.className = 'socketio';\n\t    form.style.position = 'absolute';\n\t    form.style.top = '-1000px';\n\t    form.style.left = '-1000px';\n\t    form.target = id;\n\t    form.method = 'POST';\n\t    form.setAttribute('accept-charset', 'utf-8');\n\t    area.name = 'd';\n\t    form.appendChild(area);\n\t    document.body.appendChild(form);\n\t\n\t    this.form = form;\n\t    this.area = area;\n\t  }\n\t\n\t  this.form.action = this.uri();\n\t\n\t  function complete () {\n\t    initIframe();\n\t    fn();\n\t  }\n\t\n\t  function initIframe () {\n\t    if (self.iframe) {\n\t      try {\n\t        self.form.removeChild(self.iframe);\n\t      } catch (e) {\n\t        self.onError('jsonp polling iframe removal error', e);\n\t      }\n\t    }\n\t\n\t    try {\n\t      // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n\t      var html = '<iframe src=\"javascript:0\" name=\"' + self.iframeId + '\">';\n\t      iframe = document.createElement(html);\n\t    } catch (e) {\n\t      iframe = document.createElement('iframe');\n\t      iframe.name = self.iframeId;\n\t      iframe.src = 'javascript:0';\n\t    }\n\t\n\t    iframe.id = self.iframeId;\n\t\n\t    self.form.appendChild(iframe);\n\t    self.iframe = iframe;\n\t  }\n\t\n\t  initIframe();\n\t\n\t  // escape \\n to prevent it from being converted into \\r\\n by some UAs\n\t  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side\n\t  data = data.replace(rEscapedNewline, '\\\\\\n');\n\t  this.area.value = data.replace(rNewline, '\\\\n');\n\t\n\t  try {\n\t    this.form.submit();\n\t  } catch (e) {}\n\t\n\t  if (this.iframe.attachEvent) {\n\t    this.iframe.onreadystatechange = function () {\n\t      if (self.iframe.readyState === 'complete') {\n\t        complete();\n\t      }\n\t    };\n\t  } else {\n\t    this.iframe.onload = complete;\n\t  }\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 114 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * Module dependencies.\n\t */\n\t\n\tvar Transport = __webpack_require__(97);\n\tvar parser = __webpack_require__(98);\n\tvar parseqs = __webpack_require__(107);\n\tvar inherit = __webpack_require__(108);\n\tvar yeast = __webpack_require__(109);\n\tvar debug = __webpack_require__(110)('engine.io-client:websocket');\n\tvar BrowserWebSocket = global.WebSocket || global.MozWebSocket;\n\tvar NodeWebSocket;\n\tif (typeof window === 'undefined') {\n\t  try {\n\t    NodeWebSocket = __webpack_require__(115);\n\t  } catch (e) { }\n\t}\n\t\n\t/**\n\t * Get either the `WebSocket` or `MozWebSocket` globals\n\t * in the browser or try to resolve WebSocket-compatible\n\t * interface exposed by `ws` for Node-like environment.\n\t */\n\t\n\tvar WebSocket = BrowserWebSocket;\n\tif (!WebSocket && typeof window === 'undefined') {\n\t  WebSocket = NodeWebSocket;\n\t}\n\t\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = WS;\n\t\n\t/**\n\t * WebSocket transport constructor.\n\t *\n\t * @api {Object} connection options\n\t * @api public\n\t */\n\t\n\tfunction WS (opts) {\n\t  var forceBase64 = (opts && opts.forceBase64);\n\t  if (forceBase64) {\n\t    this.supportsBinary = false;\n\t  }\n\t  this.perMessageDeflate = opts.perMessageDeflate;\n\t  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;\n\t  if (!this.usingBrowserWebSocket) {\n\t    WebSocket = NodeWebSocket;\n\t  }\n\t  Transport.call(this, opts);\n\t}\n\t\n\t/**\n\t * Inherits from Transport.\n\t */\n\t\n\tinherit(WS, Transport);\n\t\n\t/**\n\t * Transport name.\n\t *\n\t * @api public\n\t */\n\t\n\tWS.prototype.name = 'websocket';\n\t\n\t/*\n\t * WebSockets support binary\n\t */\n\t\n\tWS.prototype.supportsBinary = true;\n\t\n\t/**\n\t * Opens socket.\n\t *\n\t * @api private\n\t */\n\t\n\tWS.prototype.doOpen = function () {\n\t  if (!this.check()) {\n\t    // let probe timeout\n\t    return;\n\t  }\n\t\n\t  var uri = this.uri();\n\t  var protocols = void (0);\n\t  var opts = {\n\t    agent: this.agent,\n\t    perMessageDeflate: this.perMessageDeflate\n\t  };\n\t\n\t  // SSL options for Node.js client\n\t  opts.pfx = this.pfx;\n\t  opts.key = this.key;\n\t  opts.passphrase = this.passphrase;\n\t  opts.cert = this.cert;\n\t  opts.ca = this.ca;\n\t  opts.ciphers = this.ciphers;\n\t  opts.rejectUnauthorized = this.rejectUnauthorized;\n\t  if (this.extraHeaders) {\n\t    opts.headers = this.extraHeaders;\n\t  }\n\t  if (this.localAddress) {\n\t    opts.localAddress = this.localAddress;\n\t  }\n\t\n\t  try {\n\t    this.ws = this.usingBrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);\n\t  } catch (err) {\n\t    return this.emit('error', err);\n\t  }\n\t\n\t  if (this.ws.binaryType === undefined) {\n\t    this.supportsBinary = false;\n\t  }\n\t\n\t  if (this.ws.supports && this.ws.supports.binary) {\n\t    this.supportsBinary = true;\n\t    this.ws.binaryType = 'nodebuffer';\n\t  } else {\n\t    this.ws.binaryType = 'arraybuffer';\n\t  }\n\t\n\t  this.addEventListeners();\n\t};\n\t\n\t/**\n\t * Adds event listeners to the socket\n\t *\n\t * @api private\n\t */\n\t\n\tWS.prototype.addEventListeners = function () {\n\t  var self = this;\n\t\n\t  this.ws.onopen = function () {\n\t    self.onOpen();\n\t  };\n\t  this.ws.onclose = function () {\n\t    self.onClose();\n\t  };\n\t  this.ws.onmessage = function (ev) {\n\t    self.onData(ev.data);\n\t  };\n\t  this.ws.onerror = function (e) {\n\t    self.onError('websocket error', e);\n\t  };\n\t};\n\t\n\t/**\n\t * Writes data to socket.\n\t *\n\t * @param {Array} array of packets.\n\t * @api private\n\t */\n\t\n\tWS.prototype.write = function (packets) {\n\t  var self = this;\n\t  this.writable = false;\n\t\n\t  // encodePacket efficient as it uses WS framing\n\t  // no need for encodePayload\n\t  var total = packets.length;\n\t  for (var i = 0, l = total; i < l; i++) {\n\t    (function (packet) {\n\t      parser.encodePacket(packet, self.supportsBinary, function (data) {\n\t        if (!self.usingBrowserWebSocket) {\n\t          // always create a new object (GH-437)\n\t          var opts = {};\n\t          if (packet.options) {\n\t            opts.compress = packet.options.compress;\n\t          }\n\t\n\t          if (self.perMessageDeflate) {\n\t            var len = 'string' === typeof data ? global.Buffer.byteLength(data) : data.length;\n\t            if (len < self.perMessageDeflate.threshold) {\n\t              opts.compress = false;\n\t            }\n\t          }\n\t        }\n\t\n\t        // Sometimes the websocket has already been closed but the browser didn't\n\t        // have a chance of informing us about it yet, in that case send will\n\t        // throw an error\n\t        try {\n\t          if (self.usingBrowserWebSocket) {\n\t            // TypeError is thrown when passing the second argument on Safari\n\t            self.ws.send(data);\n\t          } else {\n\t            self.ws.send(data, opts);\n\t          }\n\t        } catch (e) {\n\t          debug('websocket closed before onclose event');\n\t        }\n\t\n\t        --total || done();\n\t      });\n\t    })(packets[i]);\n\t  }\n\t\n\t  function done () {\n\t    self.emit('flush');\n\t\n\t    // fake drain\n\t    // defer to next tick to allow Socket to clear writeBuffer\n\t    setTimeout(function () {\n\t      self.writable = true;\n\t      self.emit('drain');\n\t    }, 0);\n\t  }\n\t};\n\t\n\t/**\n\t * Called upon close\n\t *\n\t * @api private\n\t */\n\t\n\tWS.prototype.onClose = function () {\n\t  Transport.prototype.onClose.call(this);\n\t};\n\t\n\t/**\n\t * Closes socket.\n\t *\n\t * @api private\n\t */\n\t\n\tWS.prototype.doClose = function () {\n\t  if (typeof this.ws !== 'undefined') {\n\t    this.ws.close();\n\t  }\n\t};\n\t\n\t/**\n\t * Generates uri for connection.\n\t *\n\t * @api private\n\t */\n\t\n\tWS.prototype.uri = function () {\n\t  var query = this.query || {};\n\t  var schema = this.secure ? 'wss' : 'ws';\n\t  var port = '';\n\t\n\t  // avoid port if default for schema\n\t  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||\n\t    ('ws' === schema && Number(this.port) !== 80))) {\n\t    port = ':' + this.port;\n\t  }\n\t\n\t  // append timestamp to URI\n\t  if (this.timestampRequests) {\n\t    query[this.timestampParam] = yeast();\n\t  }\n\t\n\t  // communicate binary support capabilities\n\t  if (!this.supportsBinary) {\n\t    query.b64 = 1;\n\t  }\n\t\n\t  query = parseqs.encode(query);\n\t\n\t  // prepend ? to query\n\t  if (query.length) {\n\t    query = '?' + query;\n\t  }\n\t\n\t  var ipv6 = this.hostname.indexOf(':') !== -1;\n\t  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n\t};\n\t\n\t/**\n\t * Feature detection for WebSocket.\n\t *\n\t * @return {Boolean} whether this transport is available.\n\t * @api public\n\t */\n\t\n\tWS.prototype.check = function () {\n\t  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 115 */\n/***/ function(module, exports) {\n\n\t/* (ignored) */\n\n/***/ },\n/* 116 */\n/***/ function(module, exports) {\n\n\t\n\tvar indexOf = [].indexOf;\n\t\n\tmodule.exports = function(arr, obj){\n\t  if (indexOf) return arr.indexOf(obj);\n\t  for (var i = 0; i < arr.length; ++i) {\n\t    if (arr[i] === obj) return i;\n\t  }\n\t  return -1;\n\t};\n\n/***/ },\n/* 117 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\r\n\t * JSON parse.\r\n\t *\r\n\t * @see Based on jQuery#parseJSON (MIT) and JSON2\r\n\t * @api private\r\n\t */\r\n\t\r\n\tvar rvalidchars = /^[\\],:{}\\s]*$/;\r\n\tvar rvalidescape = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;\r\n\tvar rvalidtokens = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\r\n\tvar rvalidbraces = /(?:^|:|,)(?:\\s*\\[)+/g;\r\n\tvar rtrimLeft = /^\\s+/;\r\n\tvar rtrimRight = /\\s+$/;\r\n\t\r\n\tmodule.exports = function parsejson(data) {\r\n\t  if ('string' != typeof data || !data) {\r\n\t    return null;\r\n\t  }\r\n\t\r\n\t  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');\r\n\t\r\n\t  // Attempt to parse using the native JSON parser first\r\n\t  if (global.JSON && JSON.parse) {\r\n\t    return JSON.parse(data);\r\n\t  }\r\n\t\r\n\t  if (rvalidchars.test(data.replace(rvalidescape, '@')\r\n\t      .replace(rvalidtokens, ']')\r\n\t      .replace(rvalidbraces, ''))) {\r\n\t    return (new Function('return ' + data))();\r\n\t  }\r\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 118 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * Module dependencies.\n\t */\n\t\n\tvar parser = __webpack_require__(77);\n\tvar Emitter = __webpack_require__(21);\n\tvar toArray = __webpack_require__(119);\n\tvar on = __webpack_require__(120);\n\tvar bind = __webpack_require__(121);\n\tvar debug = __webpack_require__(74)('socket.io-client:socket');\n\tvar hasBin = __webpack_require__(100);\n\t\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = exports = Socket;\n\t\n\t/**\n\t * Internal events (blacklisted).\n\t * These events can't be emitted by the user.\n\t *\n\t * @api private\n\t */\n\t\n\tvar events = {\n\t  connect: 1,\n\t  connect_error: 1,\n\t  connect_timeout: 1,\n\t  connecting: 1,\n\t  disconnect: 1,\n\t  error: 1,\n\t  reconnect: 1,\n\t  reconnect_attempt: 1,\n\t  reconnect_failed: 1,\n\t  reconnect_error: 1,\n\t  reconnecting: 1,\n\t  ping: 1,\n\t  pong: 1\n\t};\n\t\n\t/**\n\t * Shortcut to `Emitter#emit`.\n\t */\n\t\n\tvar emit = Emitter.prototype.emit;\n\t\n\t/**\n\t * `Socket` constructor.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction Socket (io, nsp, opts) {\n\t  this.io = io;\n\t  this.nsp = nsp;\n\t  this.json = this; // compat\n\t  this.ids = 0;\n\t  this.acks = {};\n\t  this.receiveBuffer = [];\n\t  this.sendBuffer = [];\n\t  this.connected = false;\n\t  this.disconnected = true;\n\t  if (opts && opts.query) {\n\t    this.query = opts.query;\n\t  }\n\t  if (this.io.autoConnect) this.open();\n\t}\n\t\n\t/**\n\t * Mix in `Emitter`.\n\t */\n\t\n\tEmitter(Socket.prototype);\n\t\n\t/**\n\t * Subscribe to open, close and packet events\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.subEvents = function () {\n\t  if (this.subs) return;\n\t\n\t  var io = this.io;\n\t  this.subs = [\n\t    on(io, 'open', bind(this, 'onopen')),\n\t    on(io, 'packet', bind(this, 'onpacket')),\n\t    on(io, 'close', bind(this, 'onclose'))\n\t  ];\n\t};\n\t\n\t/**\n\t * \"Opens\" the socket.\n\t *\n\t * @api public\n\t */\n\t\n\tSocket.prototype.open =\n\tSocket.prototype.connect = function () {\n\t  if (this.connected) return this;\n\t\n\t  this.subEvents();\n\t  this.io.open(); // ensure open\n\t  if ('open' === this.io.readyState) this.onopen();\n\t  this.emit('connecting');\n\t  return this;\n\t};\n\t\n\t/**\n\t * Sends a `message` event.\n\t *\n\t * @return {Socket} self\n\t * @api public\n\t */\n\t\n\tSocket.prototype.send = function () {\n\t  var args = toArray(arguments);\n\t  args.unshift('message');\n\t  this.emit.apply(this, args);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Override `emit`.\n\t * If the event is in `events`, it's emitted normally.\n\t *\n\t * @param {String} event name\n\t * @return {Socket} self\n\t * @api public\n\t */\n\t\n\tSocket.prototype.emit = function (ev) {\n\t  if (events.hasOwnProperty(ev)) {\n\t    emit.apply(this, arguments);\n\t    return this;\n\t  }\n\t\n\t  var args = toArray(arguments);\n\t  var parserType = parser.EVENT; // default\n\t  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary\n\t  var packet = { type: parserType, data: args };\n\t\n\t  packet.options = {};\n\t  packet.options.compress = !this.flags || false !== this.flags.compress;\n\t\n\t  // event ack callback\n\t  if ('function' === typeof args[args.length - 1]) {\n\t    debug('emitting packet with ack id %d', this.ids);\n\t    this.acks[this.ids] = args.pop();\n\t    packet.id = this.ids++;\n\t  }\n\t\n\t  if (this.connected) {\n\t    this.packet(packet);\n\t  } else {\n\t    this.sendBuffer.push(packet);\n\t  }\n\t\n\t  delete this.flags;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Sends a packet.\n\t *\n\t * @param {Object} packet\n\t * @api private\n\t */\n\t\n\tSocket.prototype.packet = function (packet) {\n\t  packet.nsp = this.nsp;\n\t  this.io.packet(packet);\n\t};\n\t\n\t/**\n\t * Called upon engine `open`.\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.onopen = function () {\n\t  debug('transport is open - connecting');\n\t\n\t  // write connect packet if necessary\n\t  if ('/' !== this.nsp) {\n\t    if (this.query) {\n\t      this.packet({type: parser.CONNECT, query: this.query});\n\t    } else {\n\t      this.packet({type: parser.CONNECT});\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Called upon engine `close`.\n\t *\n\t * @param {String} reason\n\t * @api private\n\t */\n\t\n\tSocket.prototype.onclose = function (reason) {\n\t  debug('close (%s)', reason);\n\t  this.connected = false;\n\t  this.disconnected = true;\n\t  delete this.id;\n\t  this.emit('disconnect', reason);\n\t};\n\t\n\t/**\n\t * Called with socket packet.\n\t *\n\t * @param {Object} packet\n\t * @api private\n\t */\n\t\n\tSocket.prototype.onpacket = function (packet) {\n\t  if (packet.nsp !== this.nsp) return;\n\t\n\t  switch (packet.type) {\n\t    case parser.CONNECT:\n\t      this.onconnect();\n\t      break;\n\t\n\t    case parser.EVENT:\n\t      this.onevent(packet);\n\t      break;\n\t\n\t    case parser.BINARY_EVENT:\n\t      this.onevent(packet);\n\t      break;\n\t\n\t    case parser.ACK:\n\t      this.onack(packet);\n\t      break;\n\t\n\t    case parser.BINARY_ACK:\n\t      this.onack(packet);\n\t      break;\n\t\n\t    case parser.DISCONNECT:\n\t      this.ondisconnect();\n\t      break;\n\t\n\t    case parser.ERROR:\n\t      this.emit('error', packet.data);\n\t      break;\n\t  }\n\t};\n\t\n\t/**\n\t * Called upon a server event.\n\t *\n\t * @param {Object} packet\n\t * @api private\n\t */\n\t\n\tSocket.prototype.onevent = function (packet) {\n\t  var args = packet.data || [];\n\t  debug('emitting event %j', args);\n\t\n\t  if (null != packet.id) {\n\t    debug('attaching ack callback to event');\n\t    args.push(this.ack(packet.id));\n\t  }\n\t\n\t  if (this.connected) {\n\t    emit.apply(this, args);\n\t  } else {\n\t    this.receiveBuffer.push(args);\n\t  }\n\t};\n\t\n\t/**\n\t * Produces an ack callback to emit with an event.\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.ack = function (id) {\n\t  var self = this;\n\t  var sent = false;\n\t  return function () {\n\t    // prevent double callbacks\n\t    if (sent) return;\n\t    sent = true;\n\t    var args = toArray(arguments);\n\t    debug('sending ack %j', args);\n\t\n\t    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;\n\t    self.packet({\n\t      type: type,\n\t      id: id,\n\t      data: args\n\t    });\n\t  };\n\t};\n\t\n\t/**\n\t * Called upon a server acknowlegement.\n\t *\n\t * @param {Object} packet\n\t * @api private\n\t */\n\t\n\tSocket.prototype.onack = function (packet) {\n\t  var ack = this.acks[packet.id];\n\t  if ('function' === typeof ack) {\n\t    debug('calling ack %s with %j', packet.id, packet.data);\n\t    ack.apply(this, packet.data);\n\t    delete this.acks[packet.id];\n\t  } else {\n\t    debug('bad ack %s', packet.id);\n\t  }\n\t};\n\t\n\t/**\n\t * Called upon server connect.\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.onconnect = function () {\n\t  this.connected = true;\n\t  this.disconnected = false;\n\t  this.emit('connect');\n\t  this.emitBuffered();\n\t};\n\t\n\t/**\n\t * Emit buffered events (received and emitted).\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.emitBuffered = function () {\n\t  var i;\n\t  for (i = 0; i < this.receiveBuffer.length; i++) {\n\t    emit.apply(this, this.receiveBuffer[i]);\n\t  }\n\t  this.receiveBuffer = [];\n\t\n\t  for (i = 0; i < this.sendBuffer.length; i++) {\n\t    this.packet(this.sendBuffer[i]);\n\t  }\n\t  this.sendBuffer = [];\n\t};\n\t\n\t/**\n\t * Called upon server disconnect.\n\t *\n\t * @api private\n\t */\n\t\n\tSocket.prototype.ondisconnect = function () {\n\t  debug('server disconnect (%s)', this.nsp);\n\t  this.destroy();\n\t  this.onclose('io server disconnect');\n\t};\n\t\n\t/**\n\t * Called upon forced client/server side disconnections,\n\t * this method ensures the manager stops tracking us and\n\t * that reconnections don't get triggered for this.\n\t *\n\t * @api private.\n\t */\n\t\n\tSocket.prototype.destroy = function () {\n\t  if (this.subs) {\n\t    // clean subscriptions to avoid reconnections\n\t    for (var i = 0; i < this.subs.length; i++) {\n\t      this.subs[i].destroy();\n\t    }\n\t    this.subs = null;\n\t  }\n\t\n\t  this.io.destroy(this);\n\t};\n\t\n\t/**\n\t * Disconnects the socket manually.\n\t *\n\t * @return {Socket} self\n\t * @api public\n\t */\n\t\n\tSocket.prototype.close =\n\tSocket.prototype.disconnect = function () {\n\t  if (this.connected) {\n\t    debug('performing disconnect (%s)', this.nsp);\n\t    this.packet({ type: parser.DISCONNECT });\n\t  }\n\t\n\t  // remove socket from pool\n\t  this.destroy();\n\t\n\t  if (this.connected) {\n\t    // fire events\n\t    this.onclose('io client disconnect');\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t * Sets the compress flag.\n\t *\n\t * @param {Boolean} if `true`, compresses the sending data\n\t * @return {Socket} self\n\t * @api public\n\t */\n\t\n\tSocket.prototype.compress = function (compress) {\n\t  this.flags = this.flags || {};\n\t  this.flags.compress = compress;\n\t  return this;\n\t};\n\n\n/***/ },\n/* 119 */\n/***/ function(module, exports) {\n\n\tmodule.exports = toArray\n\t\n\tfunction toArray(list, index) {\n\t    var array = []\n\t\n\t    index = index || 0\n\t\n\t    for (var i = index || 0; i < list.length; i++) {\n\t        array[i - index] = list[i]\n\t    }\n\t\n\t    return array\n\t}\n\n\n/***/ },\n/* 120 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * Module exports.\n\t */\n\t\n\tmodule.exports = on;\n\t\n\t/**\n\t * Helper for subscriptions.\n\t *\n\t * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`\n\t * @param {String} event name\n\t * @param {Function} callback\n\t * @api public\n\t */\n\t\n\tfunction on (obj, ev, fn) {\n\t  obj.on(ev, fn);\n\t  return {\n\t    destroy: function () {\n\t      obj.removeListener(ev, fn);\n\t    }\n\t  };\n\t}\n\n\n/***/ },\n/* 121 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Slice reference.\n\t */\n\t\n\tvar slice = [].slice;\n\t\n\t/**\n\t * Bind `obj` to `fn`.\n\t *\n\t * @param {Object} obj\n\t * @param {Function|String} fn or string\n\t * @return {Function}\n\t * @api public\n\t */\n\t\n\tmodule.exports = function(obj, fn){\n\t  if ('string' == typeof fn) fn = obj[fn];\n\t  if ('function' != typeof fn) throw new Error('bind() requires a function');\n\t  var args = slice.call(arguments, 2);\n\t  return function(){\n\t    return fn.apply(obj, args.concat(slice.call(arguments)));\n\t  }\n\t};\n\n\n/***/ },\n/* 122 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * Expose `Backoff`.\n\t */\n\t\n\tmodule.exports = Backoff;\n\t\n\t/**\n\t * Initialize backoff timer with `opts`.\n\t *\n\t * - `min` initial timeout in milliseconds [100]\n\t * - `max` max timeout [10000]\n\t * - `jitter` [0]\n\t * - `factor` [2]\n\t *\n\t * @param {Object} opts\n\t * @api public\n\t */\n\t\n\tfunction Backoff(opts) {\n\t  opts = opts || {};\n\t  this.ms = opts.min || 100;\n\t  this.max = opts.max || 10000;\n\t  this.factor = opts.factor || 2;\n\t  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n\t  this.attempts = 0;\n\t}\n\t\n\t/**\n\t * Return the backoff duration.\n\t *\n\t * @return {Number}\n\t * @api public\n\t */\n\t\n\tBackoff.prototype.duration = function(){\n\t  var ms = this.ms * Math.pow(this.factor, this.attempts++);\n\t  if (this.jitter) {\n\t    var rand =  Math.random();\n\t    var deviation = Math.floor(rand * this.jitter * ms);\n\t    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;\n\t  }\n\t  return Math.min(ms, this.max) | 0;\n\t};\n\t\n\t/**\n\t * Reset the number of attempts.\n\t *\n\t * @api public\n\t */\n\t\n\tBackoff.prototype.reset = function(){\n\t  this.attempts = 0;\n\t};\n\t\n\t/**\n\t * Set the minimum duration\n\t *\n\t * @api public\n\t */\n\t\n\tBackoff.prototype.setMin = function(min){\n\t  this.ms = min;\n\t};\n\t\n\t/**\n\t * Set the maximum duration\n\t *\n\t * @api public\n\t */\n\t\n\tBackoff.prototype.setMax = function(max){\n\t  this.max = max;\n\t};\n\t\n\t/**\n\t * Set the jitter\n\t *\n\t * @api public\n\t */\n\t\n\tBackoff.prototype.setJitter = function(jitter){\n\t  this.jitter = jitter;\n\t};\n\t\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** telepat.client.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 64ca6c30c6b0c6b4d262\n **/","import fs from 'fs';\nimport PouchDB from 'pouchdb';\nimport API from './api';\nimport log from './logger';\nimport error from './error';\nimport EventObject from './event';\nimport Monitor from './monitor';\nimport Channel from './channel';\nimport User from './user';\n\nlet UDID_DB_KEY = ':deviceId';\n\n/**\n * The `Telepat` object is the first object you want to instantiate while working with the Telepat SDK.\n * It exposes methods and properties that enable you to register, login, subscribe to objects and to users.\n *\n * @class Telepat\n *\n * @example\n * let telepat = new Telepat();\n * telepat.connect({\n *  apiEndpoint: 'TELEPAT-API-ENDPOINT',\n *  socketEndpoint: 'TELEPAT-SOCKET-ENDPOINT',\n *  apiKey: 'APP-API-KEY',\n *  appId: 'APP-ID'\n * }, (err, res) => {\n *  if (err) {\n *    // Treat connection error\n *    console.log(err);\n *    return;\n *  }\n *\n *  // Display all collections\n *  console.log(telepat.collections);\n *\n *  // Login, display and update user data\n *  telepat.on('login', () => {\n *    console.log(telepat.user.data);\n *    telepat.user.data.change = true;\n *  });\n *  telepat.user.login('user', 'pass');\n *\n *  // Subscribe to data\n *  let articleChannel = telepat.subscribe({\n *    channel: {\n *      context: 'collection-identifier',\n *      model: 'article'\n *    }\n *  }, () => {\n *    console.log(articleChannel.objectsArray);\n *    articleChannel.objects['object-identifier'].title = 'new title';\n *\n *    articleChannel.on('update', (operationType, objectId, object, oldObject) => {\n *      // Update interface on data updates\n *    });\n *  });\n * });\n */\nexport default class Telepat {\n  constructor(options = null) {\n    function getUserHome() {\n      return process.env[(process.platform === 'win32') ? 'USERPROFILE' : 'HOME'];\n    }\n\n    function getTelepatDir() {\n      var dir = getUserHome() + '/.telepat-cli';\n\n      if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir, 744);\n      }\n      return dir;\n    }\n    this.name = (options && options.name) ? options.name : '';\n    UDID_DB_KEY += this.name;\n    this._db = new PouchDB((typeof window !== 'undefined') ? ('/_telepat') : (getTelepatDir()));\n    console.log(UDID_DB_KEY);\n    this._event = new EventObject(log);\n    this._monitor = new Monitor();\n    this._socketEndpoint = null;\n    this._socket = null;\n    this._persistentConnectionOptions = null;\n    /**\n     * Indicates whether the current instance is connected to the backend\n     * @type {boolean}\n     * @memberof Telepat\n     * @instance\n     */\n    this.connected = false;\n    /**\n     * Indicates whether the current instance is in the process of connecting to the backend.\n     * If true, the `connect` event will be fired as soon as connection is established.\n     * @type {boolean}\n     * @memberof Telepat\n     * @instance\n     */\n    this.connecting = false;\n    /**\n     * Indicates whether the current instance is properly configured and ready for connection.\n     * @type {boolean}\n     * @memberof Telepat\n     * @instance\n     */\n    this.configured = false;\n    /**\n     * If connected, this property reflects the current app id.\n     * @type {string}\n     * @memberof Telepat\n     * @instance\n     */\n    this.currentAppId = null;\n    /**\n     * This object contains details about all the collections available for the currently connected application.\n     * You can read this after the `connect` event is emitted, or if the `connected` property is true.\n     * Each available collection is stored as an Object, using a key whose name is equal to the collection's id.\n     * Modifications to collection objects stored within will be automatically synchronized with the Telepat backend.\n     * @type {Object}\n     * @memberof Telepat\n     * @instance\n     */\n    this.collections = {};\n    /**\n     * This object contains references to all of the {@link Channel}s that are actively subscribed.\n     * Each channel is stored using a key equal to the channel's unique identifier.\n     * @type {Object}\n     * @memberof Telepat\n     * @instance\n     */\n    this.subscriptions = {};\n    /**\n     * This property becomes available after successfully logging in as an administrator.\n     * It gives you access to a instance of the {@link Admin} class, allowing you access to administrator functionality.\n     * @type {Admin}\n     * @memberof Telepat\n     * @instance\n     *\n     * @example\n     * telepat.user.loginAdmin('admin@email.com', 'password', (err) => {\n     *  if (err) {\n     *    // Treat login error\n     *  } else {\n     *    telepat.admin.getAppUsers((err) => {\n     *      if (err) {\n     *        // Treat error\n     *      } else {\n     *        // Treat success\n     *        console.log(telepat.admin.users);\n     *      }\n     *    })\n     *  }\n     * });\n     */\n    this.admin = null;\n    /**\n     * An instance of the {@link User} class, this allows you to access user functionality like logging in,\n     * accessing and modifying current user data or registering new user accounts.\n     * @type {User}\n     * @memberof Telepat\n     * @instance\n     *\n     * @example\n     * telepat.user.login('email', 'password', (err) => {\n     *  if (err) {\n     *    // Treat login error\n     *  } else {\n     *    // Treat successful login\n     *    console.log(telepat.user.data);\n     *  }\n     * });\n     */\n    this.user = null;\n    this.collectionEvent = new EventObject(log);\n\n    if (options) {\n      this.connect(options);\n    }\n  }\n\n  onReady(callback) {\n    return this.on('ready', callback);\n  }\n\n  getCollections(callback = () => {}) {\n    API.get('context/all', '', (err, res) => {\n      if (err) {\n        let resultingError = error('Error retrieving collections ' + err);\n\n        this.callback(resultingError, null);\n      } else {\n        this._monitor.remove({channel: {model: 'context'}});\n        this.collections = {};\n        for (let index in res.body.content) {\n          this.collections[res.body.content[index].id] = res.body.content[index];\n        }\n\n        this._monitor.add({channel: {model: 'context'}}, this.collections, this.collectionEvent, this._addCollection.bind(this), this._deleteCollection.bind(this), this._updateCollection.bind(this));\n        this.collectionEvent.on('update', (operation, parentId, parentObject, delta) => {\n          this._event.emit('collections_update');\n        });\n        callback(null, this.collections);\n        this._event.emit('collections_update');\n      }\n    });\n  }\n\n  _addCollection(collection, callback = () => {}) {\n    if (this.admin) {\n      this.admin.addCollection(collection, callback);\n    } else {\n      log.warn('Editing collection data as non-admin user. Changes will not be remotely persisted.');\n    }\n  }\n\n  _updateCollection(id, patches, callback = () => {}) {\n    if (this.admin) {\n      this.admin.updateCollection(id, patches, callback);\n    } else {\n      log.warn('Editing collection data as non-admin user. Changes will not be remotely persisted.');\n    }\n  }\n\n  _deleteCollection(id, callback = () => {}) {\n    if (this.admin) {\n      this.admin.deleteCollection(id, callback);\n    } else {\n      log.warn('Editing collection data as non-admin user. Changes will not be remotely persisted.');\n    }\n  }\n\n  _updateUser(reauth = false, callback = () => {}) {\n    if (!this.user) {\n      this.user = new User(this._db, this._event, this._monitor, newAdmin => { this.admin = newAdmin; }, () => {\n        if (reauth) {\n          this.user.reauth(callback);\n        } else {\n          callback(null);\n        }\n      });\n    } else {\n      callback(null);\n    }\n  }\n\n  _getSavedUDID(callback) {\n    this._db.get(UDID_DB_KEY).then(doc => {\n      if (doc[API.appId]) {\n        callback(null, doc[API.appId]);\n      } else {\n        log.warn('Could not retrieve saved UDID');\n        callback(new Error('Could not retrieve saved UDID'));\n      }\n    }).catch((err) => {\n      log.warn('Could not retrieve saved UDID', err);\n      callback(err);\n    });\n  }\n\n  _saveUDID(udid, callback) {\n    this._db.get(UDID_DB_KEY).then(doc => {\n      doc[API.appId] = udid;\n      this._db.put(doc).then(() => {\n        log.info('Replaced existing UDID');\n        callback(null);\n      }).catch(err => {\n        log.warn('Could not persist UDID. Error: ' + err);\n        callback(err);\n      });\n    }).catch(() => {\n      let newObject = {\n        _id: UDID_DB_KEY\n      };\n\n      newObject[API.appId] = API.UDID;\n      this._db.put(newObject).then(() => {\n        log.info('Saved new UDID');\n        callback(null);\n      }).catch(err => {\n        log.warn('Could not persist UDID. Error: ' + err);\n        callback(err);\n      });\n    });\n  }\n\n  _rebindVolatileTransport(callback) {\n    if (this._socket) {\n      let watchdog = setTimeout(() => {\n        callback(error('Socket transport connection timeout'));\n      }, 5000);\n\n      this._socket.emit('bind_device', {\n        'device_id': API.UDID,\n        'application_id': API.appId\n      });\n      this._socket.on('ready', () => {\n        this._socket.removeAllListeners('ready');\n        clearTimeout(watchdog);\n        watchdog = null;\n\n        // Update all subscription data on transport reconnect\n        for (let key in this.subscriptions) {\n          this.subscriptions[key].subscribe();\n        }\n\n        callback(null);\n      });\n    }\n  }\n\n  /**\n   * Call this to configure Telepat server endpoints without connecting to a specific app.\n   *\n   * @param {Object} options Object containing all configuration options for connection\n   * @param {string} options.apiEndpoint The Telepat API endpoint URL\n   * @param {string} options.socketEndpoint The Telepat socket endpoint URL\n   * @param {boolean} [options.reauth=false] Should reauth previously logged in user on connection\n   * @param {TelepatCallback} callback Callback invoked after configuration is finished\n   *\n   * @fires Telepat.event:configure\n   *\n   * @example\n   * let telepat = new Telepat();\n   * telepat.configure({\n   *  apiEndpoint: 'TELEPAT-API-ENDPOINT',\n   *  socketEndpoint: 'TELEPAT-SOCKET-ENDPOINT'\n   * }, (err, res) => {\n   *  // Handle configuration\n   * });\n   */\n  configure(options = {}, callback = () => {}) {\n    if (typeof options.apiEndpoint !== 'undefined') {\n      API.apiEndpoint = options.apiEndpoint + '/';\n    } else {\n      callback(error('Configure options must provide an apiEndpoint property'));\n    }\n    // - `socketEndpoint`: the host and port number for the socket service\n    if (typeof options.socketEndpoint !== 'undefined') {\n      this._socketEndpoint = options.socketEndpoint;\n    } else {\n      callback(error('Configure options must provide an socketEndpoint property'));\n    }\n\n    this._updateUser(options.reauth, () => {\n      this._event.emit('configure');\n      this.configured = true;\n      callback(null, this);\n    });\n  }\n\n  /**\n   * Call this to register a device with the Telepat backend. This will be automatically invoked\n   * during the initial connection.\n   *\n   * @param {TelepatCallback} callback Callback invoked after device is registered\n   */\n  registerDevice(callback = () => {}) {\n    let finalizeRequest = (err, res) => {\n      if (err) {\n        callback(err);\n      } else {\n        if (res.body.content.identifier) {\n          API.UDID = res.body.content.identifier + this.name;\n          log.info('Received new UDID: ' + API.UDID);\n          this._saveUDID(API.UDID, () => {});\n        }\n        callback(null, res);\n      }\n    };\n\n    let request = {\n      'info': {\n        'os': 'web',\n        'userAgent': ((typeof navigator !== 'undefined') ? navigator.userAgent : 'node')\n      },\n      'volatile': {\n        'type': 'sockets',\n        'active': 1\n      }\n    };\n\n    if (this._persistentConnectionOptions) {\n      request.persistent = this._persistentConnectionOptions;\n      if (request.persistent.active === 1) {\n        request.volatile.active = 0;\n      }\n    }\n\n    API.call('device/register', request, (err, res) => {\n      if (err && API.UDID) {\n        // Maybe our UDID got out of sync with the server. Let's try to get a new one\n        API.UDID = null;\n        API.call('device/register', request, (err, res2) => {\n          finalizeRequest(err, res2);\n        });\n      } else {\n        finalizeRequest(null, res);\n      }\n    });\n  }\n\n  /**\n   * Call this to register the device with the Telepat volatile transport service. This will be automatically invoked\n   * during the initial connection.\n   *\n   * @param {Object} options Socket.io connection options. See http://socket.io/docs/client-api/#manager(url:string,-opts:object).\n   * @param {TelepatCallback} callback Callback invoked after transport is registered\n   */\n  connectVolatileTransport(ioOptions = {}, callback = () => {}) {\n    this.disconnectVolatileTransport();\n\n    this._socket = require('socket.io-client')(this._socketEndpoint, ioOptions);\n    log.info('Connecting to socket service ' + this._socketEndpoint);\n\n    this._socket.on('error', (err) => {\n      callback(err);\n    });\n\n    this._socket.on('connect', () => {\n      this._rebindVolatileTransport(err => {\n        callback(err);\n      });\n    });\n\n    this._socket.on('message', message => {\n      this.processMessage(message);\n    });\n\n    this._socket.on('context-update', () => {\n      this.getCollections();\n    });\n\n    this._socket.on('disconnect', () => {\n      log.warn('Sockets disconnected');\n      this._event.emit('volatile_disconnect');\n    });\n\n    this._socket.on('reconnect', () => {\n      this._rebindVolatileTransport(err => {\n        if (err) {\n          this._event.emit('reconnect_failed');\n        } else {\n          this._event.emit('reconnect');\n        }\n      });\n    });\n\n    this._socket.on('reconnect_failed', () => {\n      log.warn('Sockets reconnect failed');\n      this._event.emit('reconnect_failed');\n    });\n  }\n\n  /**\n   * Call this to unregister the device with the Telepat volatile transport service. This will be automatically invoked\n   * during disconnection.\n   *\n   * @fires Telepat.event:volatile_disconnect\n   */\n  disconnectVolatileTransport() {\n    if (this._socket) {\n      this._socket.removeAllListeners();\n      this._socket.close();\n      this._socket = null;\n    }\n  }\n\n  /**\n   * Call this to connect to a specific Telepat app.\n   * This is usually the first thing you need to do after instantiating the Telepat object.\n   *\n   * @param {Object} options Object containing all configuration options for connection\n   * @param {string} options.apiKey Your app API key\n   * @param {string} options.appId Your app id\n   * @param {string} [options.apiEndpoint] The Telepat API endpoint URL. If this is absent from the connect options, it must have been previously set by calling {@link #Telepat#configure configure}.\n   * @param {string} [options.socketEndpoint] The Telepat socket endpoint URL.\n   *  If this is absent from the connect options, it must have been previously set by calling {@link #Telepat#configure configure}.\n   * @param {boolean} [options.reauth=false] Should reauth previously logged in user on connection\n   * @param {Object} [options.persistentConnection=null] Set this to configure receiving updates via persistent channels, like push notifications.\n   * @param {Object} [options.ioOptions={}] Configuration options for socket.io\n   * @param {boolean} [options.updateUDID=false] Set this to true to force the client to update the saved device identifier.\n   * @param {number} [options.timerInterval=150] Frequency of running diff (in miliseconds) to check for object updates.\n   * @param {TelepatCallback} callback Callback invoked after configuration is finished\n   *\n   * @fires Telepat.event:connect\n   * @fires Telepat.event:ready\n   * @fires Telepat.event:connect_error\n   * @fires Telepat.event:disconnect\n   *\n   * @example\n   * // Simple connection to backend\n   *\n   * let telepat = new Telepat();\n   * telepat.connect({\n   *  apiEndpoint: 'TELEPAT-API-ENDPOINT',\n   *  socketEndpoint: 'TELEPAT-SOCKET-ENDPOINT',\n   *  apiKey: 'APP-API-KEY',\n   *  appId: 'APP-ID'\n   * }, (err, res) => {\n   *  // Handle connection\n   * });\n   *\n   * @example\n   * // Using connection event\n   *\n   * let telepat = new Telepat();\n   * telepat.connect({\n   *  apiEndpoint: 'TELEPAT-API-ENDPOINT',\n   *  socketEndpoint: 'TELEPAT-SOCKET-ENDPOINT',\n   *  apiKey: 'APP-API-KEY',\n   *  appId: 'APP-ID'\n   * });\n   * let connectCallbackId = telepat.on('connect', {\n   *  telepat.removeCallback(connectCallbackId);\n   *  // Handle connection\n   * });\n   *\n   * @example\n   * // Activating the push notifications transport.\n   * // Do this when running inside a mobile OS, for example.\n   * telepat.connect({\n   *  apiEndpoint: 'TELEPAT-API-ENDPOINT',\n   *  socketEndpoint: 'TELEPAT-SOCKET-ENDPOINT',\n   *  apiKey: 'APP-API-KEY',\n   *  appId: 'APP-ID',\n   *  persistentConnection: {\n   *    type: 'ios',\n   *    token: 'DEVICE-NOTIFICATION-TOKEN',\n   *    active: 1\n   *  }\n   * });\n   */\n  connect(options = {}, callback = () => {}) {\n    if (typeof options !== 'undefined') {\n      if (typeof options.apiKey === 'undefined') {\n        return callback(error('Connect options must provide an apiKey property'));\n      }\n      if (typeof options.appId === 'undefined') {\n        return callback(error('Connect options must provide an appId property'));\n      }\n      if (typeof options.apiEndpoint !== 'undefined') {\n        API.apiEndpoint = options.apiEndpoint + '/';\n      } else if (!API.apiEndpoint) {\n        return callback(error('Connect options must provide an apiEndpoint property, or you must run `configure` first'));\n      }\n      if (typeof options.socketEndpoint !== 'undefined') {\n        this._socketEndpoint = options.socketEndpoint;\n      } else if (!this._socketEndpoint) {\n        return callback(error('Connect options must provide an socketEndpoint property, or you must run `configure` first'));\n      }\n      if (typeof options.timerInterval !== 'undefined') {\n        this._monitor.timerInterval = options.timerInterval;\n      }\n    } else {\n      return callback(error('Options object not provided to the connect function'));\n    }\n\n    let signalConnectFailed = (err) => {\n      this.connected = false;\n      this.connecting = false;\n      this.currentAppId = null;\n      callback(error('Device registration failed with error: ' + err));\n      this._event.emit('connect_error', err);\n    };\n\n    let signalConnectSucceded = () => {\n      this.connected = true;\n      this.connecting = false;\n      this.currentAppId = API.appId;\n      callback(null);\n      this._event.emit('connect');\n      this._event.emit('ready');\n    };\n\n    let populateData = () => {\n      this.getCollections((err) => {\n        if (err) {\n          signalConnectFailed(err);\n        } else {\n          this._updateUser(options.reauth, () => {\n            signalConnectSucceded();\n          });\n        }\n      });\n    };\n\n    let postRegister = (err, res) => {\n      if (err) {\n        signalConnectFailed(err);\n      } else {\n        if (!this._persistentConnectionOptions || this._persistentConnectionOptions.active !== 1) {\n          this.connectVolatileTransport({}, (err) => {\n            if (err) {\n              signalConnectFailed(err);\n            } else {\n              populateData();\n            }\n          });\n        } else {\n          populateData();\n        }\n      }\n    };\n\n    // START CONNECTION PROCESS\n\n    if (this.connected) {\n      this.connected = false;\n      this.disconnect();\n    }\n    this.connecting = true;\n\n    API.apiKey = options.apiKey;\n    API.appId = options.appId;\n\n    if (this.admin && this.admin.apps) {\n      this.admin.app = this.admin.apps[API.appId];\n    }\n\n    this._persistentConnectionOptions = options.persistentConnection || this._persistentConnectionOptions;\n\n    if (options.updateUDID) {\n      this.registerDevice(postRegister);\n    } else {\n      this._getSavedUDID((err, udid) => {\n        if (!err) {\n          API.UDID = udid;\n        }\n        this.registerDevice(postRegister);\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Call this function to disconnect the client from the Telepat backend.\n   * @fires Telepat.event:disconnect\n   * @fires Telepat.event:volatile_disconnect\n   */\n  disconnect() {\n    this.disconnectVolatileTransport();\n    this.collections = null;\n    this._monitor.remove({channel: {model: 'context'}});\n\n    for (var key in this.subscriptions) {\n      this.subscriptions[key].unsubscribe();\n    }\n    this.subscriptions = {};\n\n    if (!this.user.isAdmin) {\n      this.user.logout(() => {\n        this.admin.unhook();\n        this.admin = null;\n        this.user = null;\n      });\n    }\n\n    API.apiKey = null;\n    API.appId = null;\n    API.UDID = null;\n\n    this._event.emit('disconnect');\n    this.currentAppId = null;\n    this.connected = false;\n  };\n\n  /**\n   * Forwards messages reveived via external channels to the processing unit.\n   * Use this if you've configured external transports (like push notifications), and you need to pass received payloads\n   * to the processing engine.\n   *\n   * @param {string} message The delta update notification received from Telepat\n   */\n  processMessage(message) {\n    this._monitor.processMessage(message);\n  }\n\n  /**\n   * You can tweak the logger verbosity using this function.\n   *\n   * @param {string} level One of `'debug'`, `'info'`, `'warn'` or `'error'`\n   */\n  setLogLevel(level) {\n    log.setLevel(level);\n    return this;\n  }\n\n  /**\n   * Invoked when client has connected to the backend.\n   *\n   * @event connect\n   */\n  /**\n   * Invoked when client has connected to the backend. Alias for the `connect` event.\n   *\n   * @event ready\n   */\n  /**\n   * Invoked when client has disconnected from the backend.\n   *\n   * @event disconnect\n   * @type {Error}\n   */\n  /**\n   * Invoked when volatile transport has been (temporarily) disconnected.\n   *\n   * @event volatile_disconnect\n   * @type {Error}\n   */\n  /**\n   * Invoked when volatile transport has reconnected.\n   *\n   * @event reconnect\n   * @type {Error}\n   */\n  /**\n   * Invoked when volatile transport has failed to reconnect.\n   *\n   * @event reconnect_failed\n   * @type {Error}\n   */\n  /**\n   * Invoked when client configuration has completed.\n   *\n   * @event configure\n   */\n  /**\n   * Invoked on connection error.\n   *\n   * @event connect_error\n   * @type {Error}\n   */\n  /**\n   * Invoked when the available collections have updated.\n   *\n   * @event collections_update\n   */\n  /**\n   * Invoked when client has successfully logged in.\n   *\n   * @event login\n   */\n  /**\n   * Invoked when there was an error with logging in.\n   *\n   * @event login_error\n   * @type {Error}\n   */\n  /**\n   * Invoked when client has successfully logged out.\n   *\n   * @event logout\n   */\n  /**\n   * Invoked when there was an error with logging out.\n   *\n   * @event logout_error\n   * @type {Error}\n   */\n\n  /**\n   * Call this function to add callbacks to be invoked on event triggers.\n   * Available callbacks:\n   *\n   * | Name                                                          | Description           |\n   * | ------------------------------------------------------------- | --------------------- |\n   * | {@link #Telepat.event:connect connect}                        | Invoked when client has connected to the backend |\n   * | {@link #Telepat.event:ready ready}                            | Alias for the connect event |\n   * | {@link #Telepat.event:disconnect disconnect}                  | Invoked when client has disconnected from the backend |\n   * | {@link #Telepat.event:reconnect reconnect}                    | Invoked when volatile transport has reconnected |\n   * | {@link #Telepat.event:reconnect_failed reconnect_failed}      | Invoked when volatile transport reconnection failed |\n   * | {@link #Telepat.event:volatile_disconnect volatile_disconnect}| Invoked when volatile transport has been disconnected |\n   * | {@link #Telepat.event:configure configure}                    | Invoked when client configuration has completed |\n   * | {@link #Telepat.event:connect_error connect_error}            | Invoked on connection errors |\n   * | {@link #Telepat.event:collections_update collections_update}  | Invoked when the available collections have updated |\n   * | {@link #Telepat.event:login login}                            | Invoked when client has successfully logged in |\n   * | {@link #Telepat.event:login_error login_error}                | Invoked when there was an error with logging in |\n   * | {@link #Telepat.event:logout logout}                          | Invoked when client has successfully logged out |\n   * | {@link #Telepat.event:logout_error logout_error}              | Invoked when there was an error with logging out |\n   *\n   * @param {string} name The name of the event to associate the callback with\n   * @param {function} callback The callback to be executed\n   * @return {number} A callback id. Save this in order to later remove the callback from the event (using {@link #Telepat#removeCallback removeCallback})\n   *\n   * @example\n   * telepat.on('connect', () => {\n   *  console.log('connected');\n   * });\n   */\n  on(name, callback) {\n    if ((name === 'connect' || name === 'ready') && this.connected) {\n      setTimeout(callback, 0);\n    }\n    return this._event.on(name, callback);\n  };\n\n  /**\n   * Call this function to remove callbacks that have been set using {@link #Telepat#on on}.\n   *\n   * @param {string} name The name of the event the callback was associated with\n   * @param {number} callbackId The callback id returned by calling {@link #Telepat#on on}\n   *\n   * @example\n   * let connectCallbackId = telepat.on('connect', () => {\n   *  // Remove the callback after the first connection event\n   *  telepat.removeCallback(connectCallbackId);\n   * });\n   */\n  removeCallback(name, index) {\n    return this._event.removeCallback(name, index);\n  };\n\n  /**\n   * Use this function to create a new {@link Channel} object and retrieve its objects.\n   *\n   * @param {Object} options The object describing the required subscription\n   * @param {function} onSubscribe Callback invoked when subscription is ready\n   * @param {Object} [options.channel] Describes the basic properties of the objects requested\n   * @param {string} [options.channel.context] The id of the collection in which you're searching for objects\n   * @param {string} [options.channel.model] The model of the objects you're searching for (needs to be defined in the schema first)\n   * @param {string} [options.channel.id] If set, specifies the id of the unique object that you're querying for\n   * @param {Object} [options.channel.parent] If set, specifies the parent id and parent model of the objects you're querying for.\n   * @param {string} [options.channel.parent.model] The model of the parent object\n   * @param {string} [options.channel.parent.id] The id of the parent object\n   * @param {string} [options.channel.user] If set, specifies the user id of the creator of the objects you're querying for.\n   * @param {Object} [options.sort] An object that defines how returned objects should be sorted. Each object key is a property name, and each value can be either `asc` or `desc`.\n   * @param {Object} [options.filters] An object describing how returned objects should be filtered.\n   * @param {number} [options.offset] The offset that should be applied for the returned objects (for pagination)\n   * @param {number} [options.limit] The maximum number of objects to be returned in this batch (for pagination)\n   * @return {Channel} The new {@link Channel} object\n   *\n   * @example\n   * // A simple subscription to all objects of type `article`\n   * // in a specific collection\n   *\n   * let articleChannel = telepat.subscribe({\n   *  channel: {\n   *    context: 'context-unique-identifier',\n   *    model: 'article'\n   *  }\n   * }, () => {\n   *  console.log(articleChannel.objectsArray);\n   * });\n   *\n   * @example\n   * // A filtered subscription to all objects of type `article`\n   * // in a specific collection, that have one of two specific tag values\n   *\n   * let articleChannel = telepat.subscribe({\n   *  channel: {\n   *    context: 'context-unique-identifier',\n   *    model: 'article'\n   *  },\n   *  filters: {\n   *    or: [\n   *      {\n   *        is: {\n   *          tag: 'specific-tag-value'\n   *        }\n   *      },\n   *      {\n   *        is: {\n   *          tag: 'another-tag-value'\n   *        }\n   *      }\n   *    ]\n   *  }\n   * }, () => {\n   *  console.log(articleChannel.objectsArray);\n   * });\n   *\n   * @example\n   * // A simple subscription to all objects of type `article`\n   * // in a specific collection, sorted by created date descending\n   *\n   * let articleChannel = telepat.subscribe({\n   *  channel: {\n   *    context: 'context-unique-identifier',\n   *    model: 'article'\n   *  },\n   *  sort: {\n   *    created: 'desc'\n   *  }\n   * }, () => {\n   *  console.log(articleChannel.objectsArray);\n   * });\n   *\n   * @example\n   * // A simple subscription to all objects of type `comment`\n   * // in a specific collection, that belong to a specific article parent\n   *\n   * let articleChannel = telepat.subscribe({\n   *  channel: {\n   *    context: 'context-unique-identifier',\n   *    model: 'comment',\n   *    parent: {\n   *      model: 'article',\n   *      id: 'article-parent-unique-identifier'\n   *    }\n   *  }\n   * }, () => {\n   *  console.log(articleChannel.objectsArray);\n   * });\n   */\n  subscribe(options, onSubscribe) {\n    let channel = new Channel(this._monitor, options);\n    let key = Monitor.subscriptionKeyForOptions(options);\n\n    this.subscriptions[key] = channel;\n    channel.subscribe();\n    if (onSubscribe !== undefined) {\n      channel.on('subscribe', onSubscribe);\n    }\n    channel.on('_unsubscribe', () => {\n      delete this.subscriptions[key];\n    });\n    return channel;\n  };\n\n  /**\n   * Same as {@link #Telepat#subscribe subscribe} method, but returns the new {@link Channel} object without calling subscribe on it.\n   *\n   * @param  {Object} options Same as {@link #Telepat#subscribe subscribe} Options\n   * @return {Channel} The new {@link Channel} object\n   */\n  getChannel(options) {\n    let key = Monitor.subscriptionKeyForOptions(options);\n\n    if (this.subscriptions[key]) {\n      return this.subscriptions[key];\n    }\n    return new Channel(this._monitor, options);\n  }\n\n  sendEmail(from, fromName, to, subject, body, callback) {\n    API.call('/email', {\n      'recipients': to,\n      'from': from,\n      'from_name': fromName,\n      'subject': subject,\n      'body': body\n    }, (err, res) => {\n      if (err) {\n        callback(error('Send email failed with error: ' + err), null);\n      } else {\n        callback(null, res.body.content);\n      }\n    });\n  };\n\n  get(options, callback) {\n    options['no_subscribe'] = true;\n    API.call('object/subscribe',\n    options,\n    (err, res) => {\n      if (err) {\n        callback(error('Get objects failed with error: ' + err), null);\n      } else {\n        callback(null, res.body.content);\n      }\n    });\n  }\n};\n\n/**\n * This callback is displayed as part of the Requester class.\n * @callback TelepatCallback\n * @param {Error} err If there was an error processing the requested operation, this will reference the error object resulted\n * @param {*} res The operation response\n */\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/telepat.js\n **/","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/process/browser.js\n ** module id = 1\n ** module chunks = 0\n **/","console.log(\"I'm `fs` modules\");\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fs/index.js\n ** module id = 2\n ** module chunks = 0\n **/","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar uuidV4 = _interopDefault(require('uuid'));\nvar lie = _interopDefault(require('lie'));\nvar getArguments = _interopDefault(require('argsarray'));\nvar events = require('events');\nvar inherits = _interopDefault(require('inherits'));\nvar nextTick = _interopDefault(require('immediate'));\nvar debug = _interopDefault(require('debug'));\nvar Md5 = _interopDefault(require('spark-md5'));\nvar vuvuzela = _interopDefault(require('vuvuzela'));\n\n/* istanbul ignore next */\nvar PouchPromise$1 = typeof Promise === 'function' ? Promise : lie;\n\nfunction isBinaryObject(object) {\n  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||\n    (typeof Blob !== 'undefined' && object instanceof Blob);\n}\n\nfunction cloneArrayBuffer(buff) {\n  if (typeof buff.slice === 'function') {\n    return buff.slice(0);\n  }\n  // IE10-11 slice() polyfill\n  var target = new ArrayBuffer(buff.byteLength);\n  var targetArray = new Uint8Array(target);\n  var sourceArray = new Uint8Array(buff);\n  targetArray.set(sourceArray);\n  return target;\n}\n\nfunction cloneBinaryObject(object) {\n  if (object instanceof ArrayBuffer) {\n    return cloneArrayBuffer(object);\n  }\n  var size = object.size;\n  var type = object.type;\n  // Blob\n  if (typeof object.slice === 'function') {\n    return object.slice(0, size, type);\n  }\n  // PhantomJS slice() replacement\n  return object.webkitSlice(0, size, type);\n}\n\n// most of this is borrowed from lodash.isPlainObject:\n// https://github.com/fis-components/lodash.isplainobject/\n// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js\n\nvar funcToString = Function.prototype.toString;\nvar objectCtorString = funcToString.call(Object);\n\nfunction isPlainObject(value) {\n  var proto = Object.getPrototypeOf(value);\n  /* istanbul ignore if */\n  if (proto === null) { // not sure when this happens, but I guess it can\n    return true;\n  }\n  var Ctor = proto.constructor;\n  return (typeof Ctor == 'function' &&\n    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n}\n\nfunction clone(object) {\n  var newObject;\n  var i;\n  var len;\n\n  if (!object || typeof object !== 'object') {\n    return object;\n  }\n\n  if (Array.isArray(object)) {\n    newObject = [];\n    for (i = 0, len = object.length; i < len; i++) {\n      newObject[i] = clone(object[i]);\n    }\n    return newObject;\n  }\n\n  // special case: to avoid inconsistencies between IndexedDB\n  // and other backends, we automatically stringify Dates\n  if (object instanceof Date) {\n    return object.toISOString();\n  }\n\n  if (isBinaryObject(object)) {\n    return cloneBinaryObject(object);\n  }\n\n  if (!isPlainObject(object)) {\n    return object; // don't clone objects like Workers\n  }\n\n  newObject = {};\n  for (i in object) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(object, i)) {\n      var value = clone(object[i]);\n      if (typeof value !== 'undefined') {\n        newObject[i] = value;\n      }\n    }\n  }\n  return newObject;\n}\n\nfunction once(fun) {\n  var called = false;\n  return getArguments(function (args) {\n    /* istanbul ignore if */\n    if (called) {\n      // this is a smoke test and should never actually happen\n      throw new Error('once called more than once');\n    } else {\n      called = true;\n      fun.apply(this, args);\n    }\n  });\n}\n\nfunction toPromise(func) {\n  //create the function we will be returning\n  return getArguments(function (args) {\n    // Clone arguments\n    args = clone(args);\n    var self = this;\n    // if the last argument is a function, assume its a callback\n    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n    var promise = new PouchPromise$1(function (fulfill, reject) {\n      var resp;\n      try {\n        var callback = once(function (err, mesg) {\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(mesg);\n          }\n        });\n        // create a callback for this invocation\n        // apply the function in the orig context\n        args.push(callback);\n        resp = func.apply(self, args);\n        if (resp && typeof resp.then === 'function') {\n          fulfill(resp);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n    // if there is a callback, call it back\n    if (usedCB) {\n      promise.then(function (result) {\n        usedCB(null, result);\n      }, usedCB);\n    }\n    return promise;\n  });\n}\n\nfunction logApiCall(self, name, args) {\n  /* istanbul ignore if */\n  if (self.constructor.listeners('debug').length) {\n    var logArgs = ['api', self.name, name];\n    for (var i = 0; i < args.length - 1; i++) {\n      logArgs.push(args[i]);\n    }\n    self.constructor.emit('debug', logArgs);\n\n    // override the callback itself to log the response\n    var origCallback = args[args.length - 1];\n    args[args.length - 1] = function (err, res) {\n      var responseArgs = ['api', self.name, name];\n      responseArgs = responseArgs.concat(\n        err ? ['error', err] : ['success', res]\n      );\n      self.constructor.emit('debug', responseArgs);\n      origCallback(err, res);\n    };\n  }\n}\n\nfunction adapterFun(name, callback) {\n  return toPromise(getArguments(function (args) {\n    if (this._closed) {\n      return PouchPromise$1.reject(new Error('database is closed'));\n    }\n    if (this._destroyed) {\n      return PouchPromise$1.reject(new Error('database is destroyed'));\n    }\n    var self = this;\n    logApiCall(self, name, args);\n    if (!this.taskqueue.isReady) {\n      return new PouchPromise$1(function (fulfill, reject) {\n        self.taskqueue.addTask(function (failed) {\n          if (failed) {\n            reject(failed);\n          } else {\n            fulfill(self[name].apply(self, args));\n          }\n        });\n      });\n    }\n    return callback.apply(this, args);\n  }));\n}\n\nfunction mangle(key) {\n  return '$' + key;\n}\nfunction unmangle(key) {\n  return key.substring(1);\n}\nfunction Map$1() {\n  this._store = {};\n}\nMap$1.prototype.get = function (key) {\n  var mangled = mangle(key);\n  return this._store[mangled];\n};\nMap$1.prototype.set = function (key, value) {\n  var mangled = mangle(key);\n  this._store[mangled] = value;\n  return true;\n};\nMap$1.prototype.has = function (key) {\n  var mangled = mangle(key);\n  return mangled in this._store;\n};\nMap$1.prototype.delete = function (key) {\n  var mangled = mangle(key);\n  var res = mangled in this._store;\n  delete this._store[mangled];\n  return res;\n};\nMap$1.prototype.forEach = function (cb) {\n  var keys = Object.keys(this._store);\n  for (var i = 0, len = keys.length; i < len; i++) {\n    var key = keys[i];\n    var value = this._store[key];\n    key = unmangle(key);\n    cb(value, key);\n  }\n};\nObject.defineProperty(Map$1.prototype, 'size', {\n  get: function () {\n    return Object.keys(this._store).length;\n  }\n});\n\nfunction Set$1(array) {\n  this._store = new Map$1();\n\n  // init with an array\n  if (array && Array.isArray(array)) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      this.add(array[i]);\n    }\n  }\n}\nSet$1.prototype.add = function (key) {\n  return this._store.set(key, true);\n};\nSet$1.prototype.has = function (key) {\n  return this._store.has(key);\n};\nSet$1.prototype.forEach = function (cb) {\n  this._store.forEach(function (value, key) {\n    cb(key);\n  });\n};\nObject.defineProperty(Set$1.prototype, 'size', {\n  get: function () {\n    return this._store.size;\n  }\n});\n\n/* global Map,Set,Symbol */\n// Based on https://kangax.github.io/compat-table/es6/ we can sniff out\n// incomplete Map/Set implementations which would otherwise cause our tests to fail.\n// Notably they fail in IE11 and iOS 8.4, which this prevents.\nfunction supportsMapAndSet() {\n  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {\n    return false;\n  }\n  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);\n  return prop && 'get' in prop && Map[Symbol.species] === Map;\n}\n\n// based on https://github.com/montagejs/collections\n/* global Map,Set */\n\nvar ExportedSet;\nvar ExportedMap;\n\n{\n  if (supportsMapAndSet()) { // prefer built-in Map/Set\n    ExportedSet = Set;\n    ExportedMap = Map;\n  } else { // fall back to our polyfill\n    ExportedSet = Set$1;\n    ExportedMap = Map$1;\n  }\n}\n\n// like underscore/lodash _.pick()\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var prop = arr[i];\n    if (prop in obj) {\n      res[prop] = obj[prop];\n    }\n  }\n  return res;\n}\n\n// Most browsers throttle concurrent requests at 6, so it's silly\n// to shim _bulk_get by trying to launch potentially hundreds of requests\n// and then letting the majority time out. We can handle this ourselves.\nvar MAX_NUM_CONCURRENT_REQUESTS = 6;\n\nfunction identityFunction(x) {\n  return x;\n}\n\nfunction formatResultForOpenRevsGet(result) {\n  return [{\n    ok: result\n  }];\n}\n\n// shim for P/CouchDB adapters that don't directly implement _bulk_get\nfunction bulkGet(db, opts, callback) {\n  var requests = opts.docs;\n\n  // consolidate into one request per doc if possible\n  var requestsById = new ExportedMap();\n  requests.forEach(function (request) {\n    if (requestsById.has(request.id)) {\n      requestsById.get(request.id).push(request);\n    } else {\n      requestsById.set(request.id, [request]);\n    }\n  });\n\n  var numDocs = requestsById.size;\n  var numDone = 0;\n  var perDocResults = new Array(numDocs);\n\n  function collapseResultsAndFinish() {\n    var results = [];\n    perDocResults.forEach(function (res) {\n      res.docs.forEach(function (info) {\n        results.push({\n          id: res.id,\n          docs: [info]\n        });\n      });\n    });\n    callback(null, {results: results});\n  }\n\n  function checkDone() {\n    if (++numDone === numDocs) {\n      collapseResultsAndFinish();\n    }\n  }\n\n  function gotResult(docIndex, id, docs) {\n    perDocResults[docIndex] = {id: id, docs: docs};\n    checkDone();\n  }\n\n  var allRequests = [];\n  requestsById.forEach(function (value, key) {\n    allRequests.push(key);\n  });\n\n  var i = 0;\n\n  function nextBatch() {\n\n    if (i >= allRequests.length) {\n      return;\n    }\n\n    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);\n    var batch = allRequests.slice(i, upTo);\n    processBatch(batch, i);\n    i += batch.length;\n  }\n\n  function processBatch(batch, offset) {\n    batch.forEach(function (docId, j) {\n      var docIdx = offset + j;\n      var docRequests = requestsById.get(docId);\n\n      // just use the first request as the \"template\"\n      // TODO: The _bulk_get API allows for more subtle use cases than this,\n      // but for now it is unlikely that there will be a mix of different\n      // \"atts_since\" or \"attachments\" in the same request, since it's just\n      // replicate.js that is using this for the moment.\n      // Also, atts_since is aspirational, since we don't support it yet.\n      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n      docOpts.open_revs = docRequests.map(function (request) {\n        // rev is optional, open_revs disallowed\n        return request.rev;\n      });\n\n      // remove falsey / undefined revisions\n      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);\n\n      var formatResult = identityFunction;\n\n      if (docOpts.open_revs.length === 0) {\n        delete docOpts.open_revs;\n\n        // when fetching only the \"winning\" leaf,\n        // transform the result so it looks like an open_revs\n        // request\n        formatResult = formatResultForOpenRevsGet;\n      }\n\n      // globally-supplied options\n      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {\n        if (param in opts) {\n          docOpts[param] = opts[param];\n        }\n      });\n      db.get(docId, docOpts, function (err, res) {\n        var result;\n        /* istanbul ignore if */\n        if (err) {\n          result = [{error: err}];\n        } else {\n          result = formatResult(res);\n        }\n        gotResult(docIdx, docId, result);\n        nextBatch();\n      });\n    });\n  }\n\n  nextBatch();\n\n}\n\nfunction isChromeApp() {\n  return (typeof chrome !== \"undefined\" &&\n    typeof chrome.storage !== \"undefined\" &&\n    typeof chrome.storage.local !== \"undefined\");\n}\n\nvar hasLocal;\n\nif (isChromeApp()) {\n  hasLocal = false;\n} else {\n  try {\n    localStorage.setItem('_pouch_check_localstorage', 1);\n    hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n  } catch (e) {\n    hasLocal = false;\n  }\n}\n\nfunction hasLocalStorage() {\n  return hasLocal;\n}\n\n// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We\n// avoid using process.nextTick() directly because the polyfill is very large and we don't\n// need all of it (see: https://github.com/defunctzombie/node-process).\n// \"immediate\" 3.0.8 is used by lie, and it's a smaller version of the latest \"immediate\"\n// package, so it's the one we use.\n// When we use nextTick() in our codebase, we only care about not releasing Zalgo\n// (see: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony).\n// Microtask vs macrotask doesn't matter to us. So we're free to use the fastest\n// (least latency) option, which is \"immediate\" due to use of microtasks.\n// All of our nextTicks are isolated to this one function so we can easily swap out one\n// implementation for another.\n\ninherits(Changes, events.EventEmitter);\n\n/* istanbul ignore next */\nfunction attachBrowserEvents(self) {\n  if (isChromeApp()) {\n    chrome.storage.onChanged.addListener(function (e) {\n      // make sure it's event addressed to us\n      if (e.db_name != null) {\n        //object only has oldValue, newValue members\n        self.emit(e.dbName.newValue);\n      }\n    });\n  } else if (hasLocalStorage()) {\n    if (typeof addEventListener !== 'undefined') {\n      addEventListener(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    } else { // old IE\n      window.attachEvent(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    }\n  }\n}\n\nfunction Changes() {\n  events.EventEmitter.call(this);\n  this._listeners = {};\n\n  attachBrowserEvents(this);\n}\nChanges.prototype.addListener = function (dbName, id, db, opts) {\n  /* istanbul ignore if */\n  if (this._listeners[id]) {\n    return;\n  }\n  var self = this;\n  var inprogress = false;\n  function eventFunction() {\n    /* istanbul ignore if */\n    if (!self._listeners[id]) {\n      return;\n    }\n    if (inprogress) {\n      inprogress = 'waiting';\n      return;\n    }\n    inprogress = true;\n    var changesOpts = pick(opts, [\n      'style', 'include_docs', 'attachments', 'conflicts', 'filter',\n      'doc_ids', 'view', 'since', 'query_params', 'binary'\n    ]);\n\n    /* istanbul ignore next */\n    function onError() {\n      inprogress = false;\n    }\n\n    db.changes(changesOpts).on('change', function (c) {\n      if (c.seq > opts.since && !opts.cancelled) {\n        opts.since = c.seq;\n        opts.onChange(c);\n      }\n    }).on('complete', function () {\n      if (inprogress === 'waiting') {\n        nextTick(eventFunction);\n      }\n      inprogress = false;\n    }).on('error', onError);\n  }\n  this._listeners[id] = eventFunction;\n  this.on(dbName, eventFunction);\n};\n\nChanges.prototype.removeListener = function (dbName, id) {\n  /* istanbul ignore if */\n  if (!(id in this._listeners)) {\n    return;\n  }\n  events.EventEmitter.prototype.removeListener.call(this, dbName,\n    this._listeners[id]);\n  delete this._listeners[id];\n};\n\n\n/* istanbul ignore next */\nChanges.prototype.notifyLocalWindows = function (dbName) {\n  //do a useless change on a storage thing\n  //in order to get other windows's listeners to activate\n  if (isChromeApp()) {\n    chrome.storage.local.set({dbName: dbName});\n  } else if (hasLocalStorage()) {\n    localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\n  }\n};\n\nChanges.prototype.notify = function (dbName) {\n  this.emit(dbName);\n  this.notifyLocalWindows(dbName);\n};\n\nfunction guardedConsole(method) {\n  /* istanbul ignore else */\n  if (console !== 'undefined' && method in console) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    console[method].apply(console, args);\n  }\n}\n\nfunction randomNumber(min, max) {\n  var maxTimeout = 600000; // Hard-coded default of 10 minutes\n  min = parseInt(min, 10) || 0;\n  max = parseInt(max, 10);\n  if (max !== max || max <= min) {\n    max = (min || 1) << 1; //doubling\n  } else {\n    max = max + 1;\n  }\n  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout\n  if (max > maxTimeout) {\n    min = maxTimeout >> 1; // divide by two\n    max = maxTimeout;\n  }\n  var ratio = Math.random();\n  var range = max - min;\n\n  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n}\n\nfunction defaultBackOff(min) {\n  var max = 0;\n  if (!min) {\n    max = 2000;\n  }\n  return randomNumber(min, max);\n}\n\n// designed to give info to browser users, who are disturbed\n// when they see http errors in the console\nfunction explainError(status, str) {\n  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);\n}\n\nvar assign;\n{\n  if (typeof Object.assign === 'function') {\n    assign = Object.assign;\n  } else {\n    // lite Object.assign polyfill based on\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n    assign = function (target) {\n      var to = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index];\n\n        if (nextSource != null) { // Skip over if undefined or null\n          for (var nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    };\n  }\n}\n\nvar $inject_Object_assign = assign;\n\ninherits(PouchError, Error);\n\nfunction PouchError(status, error, reason) {\n  Error.call(this, reason);\n  this.status = status;\n  this.name = error;\n  this.message = reason;\n  this.error = true;\n}\n\nPouchError.prototype.toString = function () {\n  return JSON.stringify({\n    status: this.status,\n    name: this.name,\n    message: this.message,\n    reason: this.reason\n  });\n};\n\nvar UNAUTHORIZED = new PouchError(401, 'unauthorized', \"Name or password is incorrect.\");\nvar MISSING_BULK_DOCS = new PouchError(400, 'bad_request', \"Missing JSON list of 'docs'\");\nvar MISSING_DOC = new PouchError(404, 'not_found', 'missing');\nvar REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');\nvar INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');\nvar MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');\nvar RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');\nvar NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');\nvar UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');\nvar BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');\nvar INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');\nvar QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');\nvar DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');\nvar BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');\nvar NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');\nvar DB_MISSING = new PouchError(404, 'not_found', 'Database not found');\nvar IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');\nvar WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');\nvar LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');\nvar FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');\nvar INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');\nvar FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');\nvar MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\\'t found');\nvar INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');\n\nfunction createError(error, reason) {\n  function CustomPouchError(reason) {\n    // inherit error properties from our parent error manually\n    // so as to allow proper JSON parsing.\n    /* jshint ignore:start */\n    for (var p in error) {\n      if (typeof error[p] !== 'function') {\n        this[p] = error[p];\n      }\n    }\n    /* jshint ignore:end */\n    if (reason !== undefined) {\n      this.reason = reason;\n    }\n  }\n  CustomPouchError.prototype = PouchError.prototype;\n  return new CustomPouchError(reason);\n}\n\nfunction generateErrorFromResponse(err) {\n\n  if (typeof err !== 'object') {\n    var data = err;\n    err = UNKNOWN_ERROR;\n    err.data = data;\n  }\n\n  if ('error' in err && err.error === 'conflict') {\n    err.name = 'conflict';\n    err.status = 409;\n  }\n\n  if (!('name' in err)) {\n    err.name = err.error || 'unknown';\n  }\n\n  if (!('status' in err)) {\n    err.status = 500;\n  }\n\n  if (!('message' in err)) {\n    err.message = err.message || err.reason;\n  }\n\n  return err;\n}\n\nfunction tryFilter(filter, doc, req) {\n  try {\n    return !filter(doc, req);\n  } catch (err) {\n    var msg = 'Filter function threw: ' + err.toString();\n    return createError(BAD_REQUEST, msg);\n  }\n}\n\nfunction filterChange(opts) {\n  var req = {};\n  var hasFilter = opts.filter && typeof opts.filter === 'function';\n  req.query = opts.query_params;\n\n  return function filter(change) {\n    if (!change.doc) {\n      // CSG sends events on the changes feed that don't have documents,\n      // this hack makes a whole lot of existing code robust.\n      change.doc = {};\n    }\n\n    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\n    if (typeof filterReturn === 'object') {\n      return filterReturn;\n    }\n\n    if (filterReturn) {\n      return false;\n    }\n\n    if (!opts.include_docs) {\n      delete change.doc;\n    } else if (!opts.attachments) {\n      for (var att in change.doc._attachments) {\n        /* istanbul ignore else */\n        if (change.doc._attachments.hasOwnProperty(att)) {\n          change.doc._attachments[att].stub = true;\n        }\n      }\n    }\n    return true;\n  };\n}\n\nfunction flatten(arrs) {\n  var res = [];\n  for (var i = 0, len = arrs.length; i < len; i++) {\n    res = res.concat(arrs[i]);\n  }\n  return res;\n}\n\n// shim for Function.prototype.name,\n// for browsers that don't support it like IE\n\n/* istanbul ignore next */\nfunction f() {}\n\nvar hasName = f.name;\nvar res;\n\n// We dont run coverage in IE\n/* istanbul ignore else */\nif (hasName) {\n  res = function (fun) {\n    return fun.name;\n  };\n} else {\n  res = function (fun) {\n    return fun.toString().match(/^\\s*function\\s*(\\S*)\\s*\\(/)[1];\n  };\n}\n\n// Determine id an ID is valid\n//   - invalid IDs begin with an underescore that does not begin '_design' or\n//     '_local'\n//   - any other string value is a valid id\n// Returns the specific error object for each case\nfunction invalidIdError(id) {\n  var err;\n  if (!id) {\n    err = createError(MISSING_ID);\n  } else if (typeof id !== 'string') {\n    err = createError(INVALID_ID);\n  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\n    err = createError(RESERVED_ID);\n  }\n  if (err) {\n    throw err;\n  }\n}\n\n// Checks if a PouchDB object is \"remote\" or not. This is\n// designed to opt-in to certain optimizations, such as\n// avoiding checks for \"dependentDbs\" and other things that\n// we know only apply to local databases. In general, \"remote\"\n// should be true for the http adapter, and for third-party\n// adapters with similar expensive boundaries to cross for\n// every API call, such as socket-pouch and worker-pouch.\n// Previously, this was handled via db.type() === 'http'\n// which is now deprecated.\n\nfunction isRemote(db) {\n  if (typeof db._remote === 'boolean') {\n    return db._remote;\n  }\n  /* istanbul ignore next */\n  if (typeof db.type === 'function') {\n    guardedConsole('warn',\n      'db.type() is deprecated and will be removed in ' +\n      'a future version of PouchDB');\n    return db.type() === 'http';\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nfunction listenerCount(ee, type) {\n  return 'listenerCount' in ee ? ee.listenerCount(type) :\n                                 events.EventEmitter.listenerCount(ee, type);\n}\n\nfunction parseDesignDocFunctionName(s) {\n  if (!s) {\n    return null;\n  }\n  var parts = s.split('/');\n  if (parts.length === 2) {\n    return parts;\n  }\n  if (parts.length === 1) {\n    return [s, s];\n  }\n  return null;\n}\n\nfunction normalizeDesignDocFunctionName(s) {\n  var normalized = parseDesignDocFunctionName(s);\n  return normalized ? normalized.join('/') : null;\n}\n\n// originally parseUri 1.2.2, now patched by us\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\",\n    \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\nvar qName =\"queryKey\";\nvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\n// use the \"loose\" parser\n/* eslint maxlen: 0, no-useless-escape: 0 */\nvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nfunction parseUri(str) {\n  var m = parser.exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) {\n    var key = keys[i];\n    var value = m[i] || \"\";\n    var encoded = ['user', 'password'].indexOf(key) !== -1;\n    uri[key] = encoded ? decodeURIComponent(value) : value;\n  }\n\n  uri[qName] = {};\n  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n    if ($1) {\n      uri[qName][$1] = $2;\n    }\n  });\n\n  return uri;\n}\n\n// Based on https://github.com/alexdavid/scope-eval v0.0.3\n// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)\n// This is basically just a wrapper around new Function()\n\nfunction scopeEval(source, scope) {\n  var keys = [];\n  var values = [];\n  for (var key in scope) {\n    if (scope.hasOwnProperty(key)) {\n      keys.push(key);\n      values.push(scope[key]);\n    }\n  }\n  keys.push(source);\n  return Function.apply(null, keys).apply(null, values);\n}\n\n// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n// the diffFun tells us what delta to apply to the doc.  it either returns\n// the doc, or false if it doesn't need to do an update after all\nfunction upsert(db, docId, diffFun) {\n  return new PouchPromise$1(function (fulfill, reject) {\n    db.get(docId, function (err, doc) {\n      if (err) {\n        /* istanbul ignore next */\n        if (err.status !== 404) {\n          return reject(err);\n        }\n        doc = {};\n      }\n\n      // the user might change the _rev, so save it for posterity\n      var docRev = doc._rev;\n      var newDoc = diffFun(doc);\n\n      if (!newDoc) {\n        // if the diffFun returns falsy, we short-circuit as\n        // an optimization\n        return fulfill({updated: false, rev: docRev});\n      }\n\n      // users aren't allowed to modify these values,\n      // so reset them here\n      newDoc._id = docId;\n      newDoc._rev = docRev;\n      fulfill(tryAndPut(db, newDoc, diffFun));\n    });\n  });\n}\n\nfunction tryAndPut(db, doc, diffFun) {\n  return db.put(doc).then(function (res) {\n    return {\n      updated: true,\n      rev: res.rev\n    };\n  }, function (err) {\n    /* istanbul ignore next */\n    if (err.status !== 409) {\n      throw err;\n    }\n    return upsert(db, doc._id, diffFun);\n  });\n}\n\nfunction rev() {\n  return uuidV4.v4().replace(/-/g, '').toLowerCase();\n}\n\nvar uuid = uuidV4.v4;\n\n// We fetch all leafs of the revision tree, and sort them based on tree length\n// and whether they were deleted, undeleted documents with the longest revision\n// tree (most edits) win\n// The final sort algorithm is slightly documented in a sidebar here:\n// http://guide.couchdb.org/draft/conflicts.html\nfunction winningRev(metadata) {\n  var winningId;\n  var winningPos;\n  var winningDeleted;\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var tree = node.ids;\n    var branches = tree[2];\n    var pos = node.pos;\n    if (branches.length) { // non-leaf\n      for (var i = 0, len = branches.length; i < len; i++) {\n        toVisit.push({pos: pos + 1, ids: branches[i]});\n      }\n      continue;\n    }\n    var deleted = !!tree[1].deleted;\n    var id = tree[0];\n    // sort by deleted, then pos, then id\n    if (!winningId || (winningDeleted !== deleted ? winningDeleted :\n        winningPos !== pos ? winningPos < pos : winningId < id)) {\n      winningId = id;\n      winningPos = pos;\n      winningDeleted = deleted;\n    }\n  }\n\n  return winningPos + '-' + winningId;\n}\n\n// Pretty much all below can be combined into a higher order function to\n// traverse revisions\n// The return value from the callback will be passed as context to all\n// children of that node\nfunction traverseRevTree(revs, callback) {\n  var toVisit = revs.slice();\n\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var branches = tree[2];\n    var newCtx =\n      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});\n    }\n  }\n}\n\nfunction sortByPos(a, b) {\n  return a.pos - b.pos;\n}\n\nfunction collectLeaves(revs) {\n  var leaves = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {\n    if (isLeaf) {\n      leaves.push({rev: pos + \"-\" + id, pos: pos, opts: opts});\n    }\n  });\n  leaves.sort(sortByPos).reverse();\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    delete leaves[i].pos;\n  }\n  return leaves;\n}\n\n// returns revs of all conflicts that is leaves such that\n// 1. are not deleted and\n// 2. are different than winning revision\nfunction collectConflicts(metadata) {\n  var win = winningRev(metadata);\n  var leaves = collectLeaves(metadata.rev_tree);\n  var conflicts = [];\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    var leaf = leaves[i];\n    if (leaf.rev !== win && !leaf.opts.deleted) {\n      conflicts.push(leaf.rev);\n    }\n  }\n  return conflicts;\n}\n\n// compact a tree by marking its non-leafs as missing,\n// and return a list of revs to delete\nfunction compactTree(metadata) {\n  var revs = [];\n  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                               revHash, ctx, opts) {\n    if (opts.status === 'available' && !isLeaf) {\n      revs.push(pos + '-' + revHash);\n      opts.status = 'missing';\n    }\n  });\n  return revs;\n}\n\n// build up a list of all the paths to the leafs in this revision tree\nfunction rootToLeaf(revs) {\n  var paths = [];\n  var toVisit = revs.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, opts: opts});\n    if (isLeaf) {\n      paths.push({pos: (pos + 1 - history.length), ids: history});\n    }\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], history: history});\n    }\n  }\n  return paths.reverse();\n}\n\n// for a better overview of what this is doing, read:\n// https://github.com/apache/couchdb-couch/blob/master/src/couch_key_tree.erl\n//\n// But for a quick intro, CouchDB uses a revision tree to store a documents\n// history, A -> B -> C, when a document has conflicts, that is a branch in the\n// tree, A -> (B1 | B2 -> C), We store these as a nested array in the format\n//\n// KeyTree = [Path ... ]\n// Path = {pos: position_from_root, ids: Tree}\n// Tree = [Key, Opts, [Tree, ...]], in particular single node: [Key, []]\n\nfunction sortByPos$1(a, b) {\n  return a.pos - b.pos;\n}\n\n// classic binary search\nfunction binarySearch(arr, item, comparator) {\n  var low = 0;\n  var high = arr.length;\n  var mid;\n  while (low < high) {\n    mid = (low + high) >>> 1;\n    if (comparator(arr[mid], item) < 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n}\n\n// assuming the arr is sorted, insert the item in the proper place\nfunction insertSorted(arr, item, comparator) {\n  var idx = binarySearch(arr, item, comparator);\n  arr.splice(idx, 0, item);\n}\n\n// Turn a path as a flat array into a tree with a single branch.\n// If any should be stemmed from the beginning of the array, that's passed\n// in as the second argument\nfunction pathToTree(path, numStemmed) {\n  var root;\n  var leaf;\n  for (var i = numStemmed, len = path.length; i < len; i++) {\n    var node = path[i];\n    var currentLeaf = [node.id, node.opts, []];\n    if (leaf) {\n      leaf[2].push(currentLeaf);\n      leaf = currentLeaf;\n    } else {\n      root = leaf = currentLeaf;\n    }\n  }\n  return root;\n}\n\n// compare the IDs of two trees\nfunction compareTree(a, b) {\n  return a[0] < b[0] ? -1 : 1;\n}\n\n// Merge two trees together\n// The roots of tree1 and tree2 must be the same revision\nfunction mergeTree(in_tree1, in_tree2) {\n  var queue = [{tree1: in_tree1, tree2: in_tree2}];\n  var conflicts = false;\n  while (queue.length > 0) {\n    var item = queue.pop();\n    var tree1 = item.tree1;\n    var tree2 = item.tree2;\n\n    if (tree1[1].status || tree2[1].status) {\n      tree1[1].status =\n        (tree1[1].status ===  'available' ||\n        tree2[1].status === 'available') ? 'available' : 'missing';\n    }\n\n    for (var i = 0; i < tree2[2].length; i++) {\n      if (!tree1[2][0]) {\n        conflicts = 'new_leaf';\n        tree1[2][0] = tree2[2][i];\n        continue;\n      }\n\n      var merged = false;\n      for (var j = 0; j < tree1[2].length; j++) {\n        if (tree1[2][j][0] === tree2[2][i][0]) {\n          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\n          merged = true;\n        }\n      }\n      if (!merged) {\n        conflicts = 'new_branch';\n        insertSorted(tree1[2], tree2[2][i], compareTree);\n      }\n    }\n  }\n  return {conflicts: conflicts, tree: in_tree1};\n}\n\nfunction doMerge(tree, path, dontExpand) {\n  var restree = [];\n  var conflicts = false;\n  var merged = false;\n  var res;\n\n  if (!tree.length) {\n    return {tree: [path], conflicts: 'new_leaf'};\n  }\n\n  for (var i = 0, len = tree.length; i < len; i++) {\n    var branch = tree[i];\n    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n      // Paths start at the same position and have the same root, so they need\n      // merged\n      res = mergeTree(branch.ids, path.ids);\n      restree.push({pos: branch.pos, ids: res.tree});\n      conflicts = conflicts || res.conflicts;\n      merged = true;\n    } else if (dontExpand !== true) {\n      // The paths start at a different position, take the earliest path and\n      // traverse up until it as at the same point from root as the path we\n      // want to merge.  If the keys match we return the longer path with the\n      // other merged After stemming we dont want to expand the trees\n\n      var t1 = branch.pos < path.pos ? branch : path;\n      var t2 = branch.pos < path.pos ? path : branch;\n      var diff = t2.pos - t1.pos;\n\n      var candidateParents = [];\n\n      var trees = [];\n      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\n      while (trees.length > 0) {\n        var item = trees.pop();\n        if (item.diff === 0) {\n          if (item.ids[0] === t2.ids[0]) {\n            candidateParents.push(item);\n          }\n          continue;\n        }\n        var elements = item.ids[2];\n        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {\n          trees.push({\n            ids: elements[j],\n            diff: item.diff - 1,\n            parent: item.ids,\n            parentIdx: j\n          });\n        }\n      }\n\n      var el = candidateParents[0];\n\n      if (!el) {\n        restree.push(branch);\n      } else {\n        res = mergeTree(el.ids, t2.ids);\n        el.parent[2][el.parentIdx] = res.tree;\n        restree.push({pos: t1.pos, ids: t1.ids});\n        conflicts = conflicts || res.conflicts;\n        merged = true;\n      }\n    } else {\n      restree.push(branch);\n    }\n  }\n\n  // We didnt find\n  if (!merged) {\n    restree.push(path);\n  }\n\n  restree.sort(sortByPos$1);\n\n  return {\n    tree: restree,\n    conflicts: conflicts || 'internal_node'\n  };\n}\n\n// To ensure we dont grow the revision tree infinitely, we stem old revisions\nfunction stem(tree, depth) {\n  // First we break out the tree into a complete list of root to leaf paths\n  var paths = rootToLeaf(tree);\n  var stemmedRevs;\n\n  var result;\n  for (var i = 0, len = paths.length; i < len; i++) {\n    // Then for each path, we cut off the start of the path based on the\n    // `depth` to stem to, and generate a new set of flat trees\n    var path = paths[i];\n    var stemmed = path.ids;\n    var node;\n    if (stemmed.length > depth) {\n      // only do the stemming work if we actually need to stem\n      if (!stemmedRevs) {\n        stemmedRevs = {}; // avoid allocating this object unnecessarily\n      }\n      var numStemmed = stemmed.length - depth;\n      node = {\n        pos: path.pos + numStemmed,\n        ids: pathToTree(stemmed, numStemmed)\n      };\n\n      for (var s = 0; s < numStemmed; s++) {\n        var rev = (path.pos + s) + '-' + stemmed[s].id;\n        stemmedRevs[rev] = true;\n      }\n    } else { // no need to actually stem\n      node = {\n        pos: path.pos,\n        ids: pathToTree(stemmed, 0)\n      };\n    }\n\n    // Then we remerge all those flat trees together, ensuring that we dont\n    // connect trees that would go beyond the depth limit\n    if (result) {\n      result = doMerge(result, node, true).tree;\n    } else {\n      result = [node];\n    }\n  }\n\n  // this is memory-heavy per Chrome profiler, avoid unless we actually stemmed\n  if (stemmedRevs) {\n    traverseRevTree(result, function (isLeaf, pos, revHash) {\n      // some revisions may have been removed in a branch but not in another\n      delete stemmedRevs[pos + '-' + revHash];\n    });\n  }\n\n  return {\n    tree: result,\n    revs: stemmedRevs ? Object.keys(stemmedRevs) : []\n  };\n}\n\nfunction merge(tree, path, depth) {\n  var newTree = doMerge(tree, path);\n  var stemmed = stem(newTree.tree, depth);\n  return {\n    tree: stemmed.tree,\n    stemmedRevs: stemmed.revs,\n    conflicts: newTree.conflicts\n  };\n}\n\n// return true if a rev exists in the rev tree, false otherwise\nfunction revExists(revs, rev) {\n  var toVisit = revs.slice();\n  var splitRev = rev.split('-');\n  var targetPos = parseInt(splitRev[0], 10);\n  var targetId = splitRev[1];\n\n  var node;\n  while ((node = toVisit.pop())) {\n    if (node.pos === targetPos && node.ids[0] === targetId) {\n      return true;\n    }\n    var branches = node.ids[2];\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: node.pos + 1, ids: branches[i]});\n    }\n  }\n  return false;\n}\n\nfunction getTrees(node) {\n  return node.ids;\n}\n\n// check if a specific revision of a doc has been deleted\n//  - metadata: the metadata object from the doc store\n//  - rev: (optional) the revision to check. defaults to winning revision\nfunction isDeleted(metadata, rev) {\n  if (!rev) {\n    rev = winningRev(metadata);\n  }\n  var id = rev.substring(rev.indexOf('-') + 1);\n  var toVisit = metadata.rev_tree.map(getTrees);\n\n  var tree;\n  while ((tree = toVisit.pop())) {\n    if (tree[0] === id) {\n      return !!tree[1].deleted;\n    }\n    toVisit = toVisit.concat(tree[2]);\n  }\n}\n\nfunction isLocalId(id) {\n  return (/^_local/).test(id);\n}\n\n// returns the current leaf node for a given revision\nfunction latest(rev, metadata) {\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, pos: pos, opts: opts});\n\n    if (isLeaf) {\n      for (var i = 0, len = history.length; i < len; i++) {\n        var historyNode = history[i];\n        var historyRev = historyNode.pos + '-' + historyNode.id;\n\n        if (historyRev === rev) {\n          // return the rev of this leaf\n          return pos + '-' + id;\n        }\n      }\n    }\n\n    for (var j = 0, l = branches.length; j < l; j++) {\n      toVisit.push({pos: pos + 1, ids: branches[j], history: history});\n    }\n  }\n\n  /* istanbul ignore next */\n  throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);\n}\n\ninherits(Changes$2, events.EventEmitter);\n\nfunction tryCatchInChangeListener(self, change) {\n  // isolate try/catches to avoid V8 deoptimizations\n  try {\n    self.emit('change', change);\n  } catch (e) {\n    guardedConsole('error', 'Error in .on(\"change\", function):', e);\n  }\n}\n\nfunction Changes$2(db, opts, callback) {\n  events.EventEmitter.call(this);\n  var self = this;\n  this.db = db;\n  opts = opts ? clone(opts) : {};\n  var complete = opts.complete = once(function (err, resp) {\n    if (err) {\n      if (listenerCount(self, 'error') > 0) {\n        self.emit('error', err);\n      }\n    } else {\n      self.emit('complete', resp);\n    }\n    self.removeAllListeners();\n    db.removeListener('destroyed', onDestroy);\n  });\n  if (callback) {\n    self.on('complete', function (resp) {\n      callback(null, resp);\n    });\n    self.on('error', callback);\n  }\n  function onDestroy() {\n    self.cancel();\n  }\n  db.once('destroyed', onDestroy);\n\n  opts.onChange = function (change) {\n    /* istanbul ignore if */\n    if (self.isCancelled) {\n      return;\n    }\n    tryCatchInChangeListener(self, change);\n  };\n\n  var promise = new PouchPromise$1(function (fulfill, reject) {\n    opts.complete = function (err, res) {\n      if (err) {\n        reject(err);\n      } else {\n        fulfill(res);\n      }\n    };\n  });\n  self.once('cancel', function () {\n    db.removeListener('destroyed', onDestroy);\n    opts.complete(null, {status: 'cancelled'});\n  });\n  this.then = promise.then.bind(promise);\n  this['catch'] = promise['catch'].bind(promise);\n  this.then(function (result) {\n    complete(null, result);\n  }, complete);\n\n\n\n  if (!db.taskqueue.isReady) {\n    db.taskqueue.addTask(function (failed) {\n      if (failed) {\n        opts.complete(failed);\n      } else if (self.isCancelled) {\n        self.emit('cancel');\n      } else {\n        self.validateChanges(opts);\n      }\n    });\n  } else {\n    self.validateChanges(opts);\n  }\n}\nChanges$2.prototype.cancel = function () {\n  this.isCancelled = true;\n  if (this.db.taskqueue.isReady) {\n    this.emit('cancel');\n  }\n};\nfunction processChange(doc, metadata, opts) {\n  var changeList = [{rev: doc._rev}];\n  if (opts.style === 'all_docs') {\n    changeList = collectLeaves(metadata.rev_tree)\n    .map(function (x) { return {rev: x.rev}; });\n  }\n  var change = {\n    id: metadata.id,\n    changes: changeList,\n    doc: doc\n  };\n\n  if (isDeleted(metadata, doc._rev)) {\n    change.deleted = true;\n  }\n  if (opts.conflicts) {\n    change.doc._conflicts = collectConflicts(metadata);\n    if (!change.doc._conflicts.length) {\n      delete change.doc._conflicts;\n    }\n  }\n  return change;\n}\n\nChanges$2.prototype.validateChanges = function (opts) {\n  var callback = opts.complete;\n  var self = this;\n\n  /* istanbul ignore else */\n  if (PouchDB$5._changesFilterPlugin) {\n    PouchDB$5._changesFilterPlugin.validate(opts, function (err) {\n      if (err) {\n        return callback(err);\n      }\n      self.doChanges(opts);\n    });\n  } else {\n    self.doChanges(opts);\n  }\n};\n\nChanges$2.prototype.doChanges = function (opts) {\n  var self = this;\n  var callback = opts.complete;\n\n  opts = clone(opts);\n  if ('live' in opts && !('continuous' in opts)) {\n    opts.continuous = opts.live;\n  }\n  opts.processChange = processChange;\n\n  if (opts.since === 'latest') {\n    opts.since = 'now';\n  }\n  if (!opts.since) {\n    opts.since = 0;\n  }\n  if (opts.since === 'now') {\n    this.db.info().then(function (info) {\n      /* istanbul ignore if */\n      if (self.isCancelled) {\n        callback(null, {status: 'cancelled'});\n        return;\n      }\n      opts.since = info.update_seq;\n      self.doChanges(opts);\n    }, callback);\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (PouchDB$5._changesFilterPlugin) {\n    PouchDB$5._changesFilterPlugin.normalize(opts);\n    if (PouchDB$5._changesFilterPlugin.shouldFilter(this, opts)) {\n      return PouchDB$5._changesFilterPlugin.filter(this, opts);\n    }\n  } else {\n    ['doc_ids', 'filter', 'selector', 'view'].forEach(function (key) {\n      if (key in opts) {\n        guardedConsole('warn',\n          'The \"' + key + '\" option was passed in to changes/replicate, ' +\n          'but pouchdb-changes-filter plugin is not installed, so it ' +\n          'was ignored. Please install the plugin to enable filtering.'\n        );\n      }\n    });\n  }\n\n  if (!('descending' in opts)) {\n    opts.descending = false;\n  }\n\n  // 0 and 1 should return 1 document\n  opts.limit = opts.limit === 0 ? 1 : opts.limit;\n  opts.complete = callback;\n  var newPromise = this.db._changes(opts);\n  /* istanbul ignore else */\n  if (newPromise && typeof newPromise.cancel === 'function') {\n    var cancel = self.cancel;\n    self.cancel = getArguments(function (args) {\n      newPromise.cancel();\n      cancel.apply(this, args);\n    });\n  }\n};\n\n/*\n * A generic pouch adapter\n */\n\nfunction compare(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Wrapper for functions that call the bulkdocs api with a single doc,\n// if the first result is an error, return an error\nfunction yankError(callback, docId) {\n  return function (err, results) {\n    if (err || (results[0] && results[0].error)) {\n      err = err || results[0];\n      err.docId = docId;\n      callback(err);\n    } else {\n      callback(null, results.length ? results[0]  : results);\n    }\n  };\n}\n\n// clean docs given to us by the user\nfunction cleanDocs(docs) {\n  for (var i = 0; i < docs.length; i++) {\n    var doc = docs[i];\n    if (doc._deleted) {\n      delete doc._attachments; // ignore atts for deleted docs\n    } else if (doc._attachments) {\n      // filter out extraneous keys from _attachments\n      var atts = Object.keys(doc._attachments);\n      for (var j = 0; j < atts.length; j++) {\n        var att = atts[j];\n        doc._attachments[att] = pick(doc._attachments[att],\n          ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);\n      }\n    }\n  }\n}\n\n// compare two docs, first by _id then by _rev\nfunction compareByIdThenRev(a, b) {\n  var idCompare = compare(a._id, b._id);\n  if (idCompare !== 0) {\n    return idCompare;\n  }\n  var aStart = a._revisions ? a._revisions.start : 0;\n  var bStart = b._revisions ? b._revisions.start : 0;\n  return compare(aStart, bStart);\n}\n\n// for every node in a revision tree computes its distance from the closest\n// leaf\nfunction computeHeight(revs) {\n  var height = {};\n  var edges = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, prnt) {\n    var rev$$1 = pos + \"-\" + id;\n    if (isLeaf) {\n      height[rev$$1] = 0;\n    }\n    if (prnt !== undefined) {\n      edges.push({from: prnt, to: rev$$1});\n    }\n    return rev$$1;\n  });\n\n  edges.reverse();\n  edges.forEach(function (edge) {\n    if (height[edge.from] === undefined) {\n      height[edge.from] = 1 + height[edge.to];\n    } else {\n      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\n    }\n  });\n  return height;\n}\n\nfunction allDocsKeysQuery(api, opts, callback) {\n  var keys =  ('limit' in opts) ?\n      opts.keys.slice(opts.skip, opts.limit + opts.skip) :\n      (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;\n  if (opts.descending) {\n    keys.reverse();\n  }\n  if (!keys.length) {\n    return api._allDocs({limit: 0}, callback);\n  }\n  var finalResults = {\n    offset: opts.skip\n  };\n  return PouchPromise$1.all(keys.map(function (key) {\n    var subOpts = $inject_Object_assign({key: key, deleted: 'ok'}, opts);\n    ['limit', 'skip', 'keys'].forEach(function (optKey) {\n      delete subOpts[optKey];\n    });\n    return new PouchPromise$1(function (resolve, reject) {\n      api._allDocs(subOpts, function (err, res) {\n        /* istanbul ignore if */\n        if (err) {\n          return reject(err);\n        }\n        finalResults.total_rows = res.total_rows;\n        resolve(res.rows[0] || {key: key, error: 'not_found'});\n      });\n    });\n  })).then(function (results) {\n    finalResults.rows = results;\n    return finalResults;\n  });\n}\n\n// all compaction is done in a queue, to avoid attaching\n// too many listeners at once\nfunction doNextCompaction(self) {\n  var task = self._compactionQueue[0];\n  var opts = task.opts;\n  var callback = task.callback;\n  self.get('_local/compaction').catch(function () {\n    return false;\n  }).then(function (doc) {\n    if (doc && doc.last_seq) {\n      opts.last_seq = doc.last_seq;\n    }\n    self._compact(opts, function (err, res) {\n      /* istanbul ignore if */\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, res);\n      }\n      nextTick(function () {\n        self._compactionQueue.shift();\n        if (self._compactionQueue.length) {\n          doNextCompaction(self);\n        }\n      });\n    });\n  });\n}\n\nfunction attachmentNameError(name) {\n  if (name.charAt(0) === '_') {\n    return name + ' is not a valid attachment name, attachment ' +\n      'names cannot start with \\'_\\'';\n  }\n  return false;\n}\n\ninherits(AbstractPouchDB, events.EventEmitter);\n\nfunction AbstractPouchDB() {\n  events.EventEmitter.call(this);\n}\n\nAbstractPouchDB.prototype.post =\n  adapterFun('post', function (doc, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return callback(createError(NOT_AN_OBJECT));\n  }\n  this.bulkDocs({docs: [doc]}, opts, yankError(callback, doc._id));\n});\n\nAbstractPouchDB.prototype.put = adapterFun('put', function (doc, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return cb(createError(NOT_AN_OBJECT));\n  }\n  invalidIdError(doc._id);\n  if (isLocalId(doc._id) && typeof this._putLocal === 'function') {\n    if (doc._deleted) {\n      return this._removeLocal(doc, cb);\n    } else {\n      return this._putLocal(doc, cb);\n    }\n  }\n  var self = this;\n  if (opts.force && doc._rev) {\n    transformForceOptionToNewEditsOption();\n    putDoc(function (err) {\n      var result = err ? null : {ok: true, id: doc._id, rev: doc._rev};\n      cb(err, result);\n    });\n  } else {\n    putDoc(cb);\n  }\n\n  function transformForceOptionToNewEditsOption() {\n    var parts = doc._rev.split('-');\n    var oldRevId = parts[1];\n    var oldRevNum = parseInt(parts[0], 10);\n\n    var newRevNum = oldRevNum + 1;\n    var newRevId = rev();\n\n    doc._revisions = {\n      start: newRevNum,\n      ids: [newRevId, oldRevId]\n    };\n    doc._rev = newRevNum + '-' + newRevId;\n    opts.new_edits = false;\n  }\n  function putDoc(next) {\n    if (typeof self._put === 'function' && opts.new_edits !== false) {\n      self._put(doc, opts, next);\n    } else {\n      self.bulkDocs({docs: [doc]}, opts, yankError(next, doc._id));\n    }\n  }\n});\n\nAbstractPouchDB.prototype.putAttachment =\n  adapterFun('putAttachment', function (docId, attachmentId, rev$$1,\n                                              blob, type) {\n  var api = this;\n  if (typeof type === 'function') {\n    type = blob;\n    blob = rev$$1;\n    rev$$1 = null;\n  }\n  // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267\n  /* istanbul ignore if */\n  if (typeof type === 'undefined') {\n    type = blob;\n    blob = rev$$1;\n    rev$$1 = null;\n  }\n  if (!type) {\n    guardedConsole('warn', 'Attachment', attachmentId, 'on document', docId, 'is missing content_type');\n  }\n\n  function createAttachment(doc) {\n    var prevrevpos = '_rev' in doc ? parseInt(doc._rev, 10) : 0;\n    doc._attachments = doc._attachments || {};\n    doc._attachments[attachmentId] = {\n      content_type: type,\n      data: blob,\n      revpos: ++prevrevpos\n    };\n    return api.put(doc);\n  }\n\n  return api.get(docId).then(function (doc) {\n    if (doc._rev !== rev$$1) {\n      throw createError(REV_CONFLICT);\n    }\n\n    return createAttachment(doc);\n  }, function (err) {\n     // create new doc\n    /* istanbul ignore else */\n    if (err.reason === MISSING_DOC.message) {\n      return createAttachment({_id: docId});\n    } else {\n      throw err;\n    }\n  });\n});\n\nAbstractPouchDB.prototype.removeAttachment =\n  adapterFun('removeAttachment', function (docId, attachmentId, rev$$1,\n                                                 callback) {\n  var self = this;\n  self.get(docId, function (err, obj) {\n    /* istanbul ignore if */\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (obj._rev !== rev$$1) {\n      callback(createError(REV_CONFLICT));\n      return;\n    }\n    /* istanbul ignore if */\n    if (!obj._attachments) {\n      return callback();\n    }\n    delete obj._attachments[attachmentId];\n    if (Object.keys(obj._attachments).length === 0) {\n      delete obj._attachments;\n    }\n    self.put(obj, callback);\n  });\n});\n\nAbstractPouchDB.prototype.remove =\n  adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {\n  var doc;\n  if (typeof optsOrRev === 'string') {\n    // id, rev, opts, callback style\n    doc = {\n      _id: docOrId,\n      _rev: optsOrRev\n    };\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n  } else {\n    // doc, opts, callback style\n    doc = docOrId;\n    if (typeof optsOrRev === 'function') {\n      callback = optsOrRev;\n      opts = {};\n    } else {\n      callback = opts;\n      opts = optsOrRev;\n    }\n  }\n  opts = opts || {};\n  opts.was_delete = true;\n  var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};\n  newDoc._deleted = true;\n  if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {\n    return this._removeLocal(doc, callback);\n  }\n  this.bulkDocs({docs: [newDoc]}, opts, yankError(callback, newDoc._id));\n});\n\nAbstractPouchDB.prototype.revsDiff =\n  adapterFun('revsDiff', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  var ids = Object.keys(req);\n\n  if (!ids.length) {\n    return callback(null, {});\n  }\n\n  var count = 0;\n  var missing = new ExportedMap();\n\n  function addToMissing(id, revId) {\n    if (!missing.has(id)) {\n      missing.set(id, {missing: []});\n    }\n    missing.get(id).missing.push(revId);\n  }\n\n  function processDoc(id, rev_tree) {\n    // Is this fast enough? Maybe we should switch to a set simulated by a map\n    var missingForId = req[id].slice(0);\n    traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,\n      opts) {\n        var rev$$1 = pos + '-' + revHash;\n        var idx = missingForId.indexOf(rev$$1);\n        if (idx === -1) {\n          return;\n        }\n\n        missingForId.splice(idx, 1);\n        /* istanbul ignore if */\n        if (opts.status !== 'available') {\n          addToMissing(id, rev$$1);\n        }\n      });\n\n    // Traversing the tree is synchronous, so now `missingForId` contains\n    // revisions that were not found in the tree\n    missingForId.forEach(function (rev$$1) {\n      addToMissing(id, rev$$1);\n    });\n  }\n\n  ids.map(function (id) {\n    this._getRevisionTree(id, function (err, rev_tree) {\n      if (err && err.status === 404 && err.message === 'missing') {\n        missing.set(id, {missing: req[id]});\n      } else if (err) {\n        /* istanbul ignore next */\n        return callback(err);\n      } else {\n        processDoc(id, rev_tree);\n      }\n\n      if (++count === ids.length) {\n        // convert LazyMap to object\n        var missingObj = {};\n        missing.forEach(function (value, key) {\n          missingObj[key] = value;\n        });\n        return callback(null, missingObj);\n      }\n    });\n  }, this);\n});\n\n// _bulk_get API for faster replication, as described in\n// https://github.com/apache/couchdb-chttpd/pull/33\n// At the \"abstract\" level, it will just run multiple get()s in\n// parallel, because this isn't much of a performance cost\n// for local databases (except the cost of multiple transactions, which is\n// small). The http adapter overrides this in order\n// to do a more efficient single HTTP request.\nAbstractPouchDB.prototype.bulkGet =\n  adapterFun('bulkGet', function (opts, callback) {\n  bulkGet(this, opts, callback);\n});\n\n// compact one document and fire callback\n// by compacting we mean removing all revisions which\n// are further from the leaf in revision tree than max_height\nAbstractPouchDB.prototype.compactDocument =\n  adapterFun('compactDocument', function (docId, maxHeight, callback) {\n  var self = this;\n  this._getRevisionTree(docId, function (err, revTree) {\n    /* istanbul ignore if */\n    if (err) {\n      return callback(err);\n    }\n    var height = computeHeight(revTree);\n    var candidates = [];\n    var revs = [];\n    Object.keys(height).forEach(function (rev$$1) {\n      if (height[rev$$1] > maxHeight) {\n        candidates.push(rev$$1);\n      }\n    });\n\n    traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {\n      var rev$$1 = pos + '-' + revHash;\n      if (opts.status === 'available' && candidates.indexOf(rev$$1) !== -1) {\n        revs.push(rev$$1);\n      }\n    });\n    self._doCompaction(docId, revs, callback);\n  });\n});\n\n// compact the whole database using single document\n// compaction\nAbstractPouchDB.prototype.compact =\n  adapterFun('compact', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  self._compactionQueue = self._compactionQueue || [];\n  self._compactionQueue.push({opts: opts, callback: callback});\n  if (self._compactionQueue.length === 1) {\n    doNextCompaction(self);\n  }\n});\nAbstractPouchDB.prototype._compact = function (opts, callback) {\n  var self = this;\n  var changesOpts = {\n    return_docs: false,\n    last_seq: opts.last_seq || 0\n  };\n  var promises = [];\n\n  function onChange(row) {\n    promises.push(self.compactDocument(row.id, 0));\n  }\n  function onComplete(resp) {\n    var lastSeq = resp.last_seq;\n    PouchPromise$1.all(promises).then(function () {\n      return upsert(self, '_local/compaction', function deltaFunc(doc) {\n        if (!doc.last_seq || doc.last_seq < lastSeq) {\n          doc.last_seq = lastSeq;\n          return doc;\n        }\n        return false; // somebody else got here first, don't update\n      });\n    }).then(function () {\n      callback(null, {ok: true});\n    }).catch(callback);\n  }\n  self.changes(changesOpts)\n    .on('change', onChange)\n    .on('complete', onComplete)\n    .on('error', callback);\n};\n\n/* Begin api wrappers. Specific functionality to storage belongs in the\n   _[method] */\nAbstractPouchDB.prototype.get = adapterFun('get', function (id, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof id !== 'string') {\n    return cb(createError(INVALID_ID));\n  }\n  if (isLocalId(id) && typeof this._getLocal === 'function') {\n    return this._getLocal(id, cb);\n  }\n  var leaves = [], self = this;\n\n  function finishOpenRevs() {\n    var result = [];\n    var count = leaves.length;\n    /* istanbul ignore if */\n    if (!count) {\n      return cb(null, result);\n    }\n\n    // order with open_revs is unspecified\n    leaves.forEach(function (leaf) {\n      self.get(id, {\n        rev: leaf,\n        revs: opts.revs,\n        latest: opts.latest,\n        attachments: opts.attachments\n      }, function (err, doc) {\n        if (!err) {\n          // using latest=true can produce duplicates\n          var existing;\n          for (var i = 0, l = result.length; i < l; i++) {\n            if (result[i].ok && result[i].ok._rev === doc._rev) {\n              existing = true;\n              break;\n            }\n          }\n          if (!existing) {\n            result.push({ok: doc});\n          }\n        } else {\n          result.push({missing: leaf});\n        }\n        count--;\n        if (!count) {\n          cb(null, result);\n        }\n      });\n    });\n  }\n\n  if (opts.open_revs) {\n    if (opts.open_revs === \"all\") {\n      this._getRevisionTree(id, function (err, rev_tree) {\n        if (err) {\n          return cb(err);\n        }\n        leaves = collectLeaves(rev_tree).map(function (leaf) {\n          return leaf.rev;\n        });\n        finishOpenRevs();\n      });\n    } else {\n      if (Array.isArray(opts.open_revs)) {\n        leaves = opts.open_revs;\n        for (var i = 0; i < leaves.length; i++) {\n          var l = leaves[i];\n          // looks like it's the only thing couchdb checks\n          if (!(typeof (l) === \"string\" && /^\\d+-/.test(l))) {\n            return cb(createError(INVALID_REV));\n          }\n        }\n        finishOpenRevs();\n      } else {\n        return cb(createError(UNKNOWN_ERROR, 'function_clause'));\n      }\n    }\n    return; // open_revs does not like other options\n  }\n\n  return this._get(id, opts, function (err, result) {\n    if (err) {\n      err.docId = id;\n      return cb(err);\n    }\n\n    var doc = result.doc;\n    var metadata = result.metadata;\n    var ctx = result.ctx;\n\n    if (opts.conflicts) {\n      var conflicts = collectConflicts(metadata);\n      if (conflicts.length) {\n        doc._conflicts = conflicts;\n      }\n    }\n\n    if (isDeleted(metadata, doc._rev)) {\n      doc._deleted = true;\n    }\n\n    if (opts.revs || opts.revs_info) {\n      var splittedRev = doc._rev.split('-');\n      var revNo       = parseInt(splittedRev[0], 10);\n      var revHash     = splittedRev[1];\n\n      var paths = rootToLeaf(metadata.rev_tree);\n      var path = null;\n\n      for (var i = 0; i < paths.length; i++) {\n        var currentPath = paths[i];\n        var hashIndex = currentPath.ids.map(function (x) { return x.id; })\n          .indexOf(revHash);\n        var hashFoundAtRevPos = hashIndex === (revNo - 1);\n\n        if (hashFoundAtRevPos || (!path && hashIndex !== -1)) {\n          path = currentPath;\n        }\n      }\n\n      var indexOfRev = path.ids.map(function (x) { return x.id; })\n        .indexOf(doc._rev.split('-')[1]) + 1;\n      var howMany = path.ids.length - indexOfRev;\n      path.ids.splice(indexOfRev, howMany);\n      path.ids.reverse();\n\n      if (opts.revs) {\n        doc._revisions = {\n          start: (path.pos + path.ids.length) - 1,\n          ids: path.ids.map(function (rev$$1) {\n            return rev$$1.id;\n          })\n        };\n      }\n      if (opts.revs_info) {\n        var pos =  path.pos + path.ids.length;\n        doc._revs_info = path.ids.map(function (rev$$1) {\n          pos--;\n          return {\n            rev: pos + '-' + rev$$1.id,\n            status: rev$$1.opts.status\n          };\n        });\n      }\n    }\n\n    if (opts.attachments && doc._attachments) {\n      var attachments = doc._attachments;\n      var count = Object.keys(attachments).length;\n      if (count === 0) {\n        return cb(null, doc);\n      }\n      Object.keys(attachments).forEach(function (key) {\n        this._getAttachment(doc._id, key, attachments[key], {\n          // Previously the revision handling was done in adapter.js\n          // getAttachment, however since idb-next doesnt we need to\n          // pass the rev through\n          rev: doc._rev,\n          binary: opts.binary,\n          ctx: ctx\n        }, function (err, data) {\n          var att = doc._attachments[key];\n          att.data = data;\n          delete att.stub;\n          delete att.length;\n          if (!--count) {\n            cb(null, doc);\n          }\n        });\n      }, self);\n    } else {\n      if (doc._attachments) {\n        for (var key in doc._attachments) {\n          /* istanbul ignore else */\n          if (doc._attachments.hasOwnProperty(key)) {\n            doc._attachments[key].stub = true;\n          }\n        }\n      }\n      cb(null, doc);\n    }\n  });\n});\n\n// TODO: I dont like this, it forces an extra read for every\n// attachment read and enforces a confusing api between\n// adapter.js and the adapter implementation\nAbstractPouchDB.prototype.getAttachment =\n  adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {\n  var self = this;\n  if (opts instanceof Function) {\n    callback = opts;\n    opts = {};\n  }\n  this._get(docId, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (res.doc._attachments && res.doc._attachments[attachmentId]) {\n      opts.ctx = res.ctx;\n      opts.binary = true;\n      self._getAttachment(docId, attachmentId,\n                          res.doc._attachments[attachmentId], opts, callback);\n    } else {\n      return callback(createError(MISSING_DOC));\n    }\n  });\n});\n\nAbstractPouchDB.prototype.allDocs =\n  adapterFun('allDocs', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;\n  if (opts.start_key) {\n    opts.startkey = opts.start_key;\n  }\n  if (opts.end_key) {\n    opts.endkey = opts.end_key;\n  }\n  if ('keys' in opts) {\n    if (!Array.isArray(opts.keys)) {\n      return callback(new TypeError('options.keys must be an array'));\n    }\n    var incompatibleOpt =\n      ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {\n      return incompatibleOpt in opts;\n    })[0];\n    if (incompatibleOpt) {\n      callback(createError(QUERY_PARSE_ERROR,\n        'Query parameter `' + incompatibleOpt +\n        '` is not compatible with multi-get'\n      ));\n      return;\n    }\n    if (!isRemote(this)) {\n      return allDocsKeysQuery(this, opts, callback);\n    }\n  }\n\n  return this._allDocs(opts, callback);\n});\n\nAbstractPouchDB.prototype.changes = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return new Changes$2(this, opts, callback);\n};\n\nAbstractPouchDB.prototype.close = adapterFun('close', function (callback) {\n  this._closed = true;\n  this.emit('closed');\n  return this._close(callback);\n});\n\nAbstractPouchDB.prototype.info = adapterFun('info', function (callback) {\n  var self = this;\n  this._info(function (err, info) {\n    if (err) {\n      return callback(err);\n    }\n    // assume we know better than the adapter, unless it informs us\n    info.db_name = info.db_name || self.name;\n    info.auto_compaction = !!(self.auto_compaction && !isRemote(self));\n    info.adapter = self.adapter;\n    callback(null, info);\n  });\n});\n\nAbstractPouchDB.prototype.id = adapterFun('id', function (callback) {\n  return this._id(callback);\n});\n\n/* istanbul ignore next */\nAbstractPouchDB.prototype.type = function () {\n  return (typeof this._type === 'function') ? this._type() : this.adapter;\n};\n\nAbstractPouchDB.prototype.bulkDocs =\n  adapterFun('bulkDocs', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n\n  if (Array.isArray(req)) {\n    req = {\n      docs: req\n    };\n  }\n\n  if (!req || !req.docs || !Array.isArray(req.docs)) {\n    return callback(createError(MISSING_BULK_DOCS));\n  }\n\n  for (var i = 0; i < req.docs.length; ++i) {\n    if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {\n      return callback(createError(NOT_AN_OBJECT));\n    }\n  }\n\n  var attachmentError;\n  req.docs.forEach(function (doc) {\n    if (doc._attachments) {\n      Object.keys(doc._attachments).forEach(function (name) {\n        attachmentError = attachmentError || attachmentNameError(name);\n        if (!doc._attachments[name].content_type) {\n          guardedConsole('warn', 'Attachment', name, 'on document', doc._id, 'is missing content_type');\n        }\n      });\n    }\n  });\n\n  if (attachmentError) {\n    return callback(createError(BAD_REQUEST, attachmentError));\n  }\n\n  if (!('new_edits' in opts)) {\n    if ('new_edits' in req) {\n      opts.new_edits = req.new_edits;\n    } else {\n      opts.new_edits = true;\n    }\n  }\n\n  var adapter = this;\n  if (!opts.new_edits && !isRemote(adapter)) {\n    // ensure revisions of the same doc are sorted, so that\n    // the local adapter processes them correctly (#2935)\n    req.docs.sort(compareByIdThenRev);\n  }\n\n  cleanDocs(req.docs);\n\n  // in the case of conflicts, we want to return the _ids to the user\n  // however, the underlying adapter may destroy the docs array, so\n  // create a copy here\n  var ids = req.docs.map(function (doc) {\n    return doc._id;\n  });\n\n  return this._bulkDocs(req, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (!opts.new_edits) {\n      // this is what couch does when new_edits is false\n      res = res.filter(function (x) {\n        return x.error;\n      });\n    }\n    // add ids for error/conflict responses (not required for CouchDB)\n    if (!isRemote(adapter)) {\n      for (var i = 0, l = res.length; i < l; i++) {\n        res[i].id = res[i].id || ids[i];\n      }\n    }\n\n    callback(null, res);\n  });\n});\n\nAbstractPouchDB.prototype.registerDependentDatabase =\n  adapterFun('registerDependentDatabase', function (dependentDb,\n                                                          callback) {\n  var depDB = new this.constructor(dependentDb, this.__opts);\n\n  function diffFun(doc) {\n    doc.dependentDbs = doc.dependentDbs || {};\n    if (doc.dependentDbs[dependentDb]) {\n      return false; // no update required\n    }\n    doc.dependentDbs[dependentDb] = true;\n    return doc;\n  }\n  upsert(this, '_local/_pouch_dependentDbs', diffFun)\n    .then(function () {\n      callback(null, {db: depDB});\n    }).catch(callback);\n});\n\nAbstractPouchDB.prototype.destroy =\n  adapterFun('destroy', function (opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  var usePrefix = 'use_prefix' in self ? self.use_prefix : true;\n\n  function destroyDb() {\n    // call destroy method of the particular adaptor\n    self._destroy(opts, function (err, resp) {\n      if (err) {\n        return callback(err);\n      }\n      self._destroyed = true;\n      self.emit('destroyed');\n      callback(null, resp || { 'ok': true });\n    });\n  }\n\n  if (isRemote(self)) {\n    // no need to check for dependent DBs if it's a remote DB\n    return destroyDb();\n  }\n\n  self.get('_local/_pouch_dependentDbs', function (err, localDoc) {\n    if (err) {\n      /* istanbul ignore if */\n      if (err.status !== 404) {\n        return callback(err);\n      } else { // no dependencies\n        return destroyDb();\n      }\n    }\n    var dependentDbs = localDoc.dependentDbs;\n    var PouchDB = self.constructor;\n    var deletedMap = Object.keys(dependentDbs).map(function (name) {\n      // use_prefix is only false in the browser\n      /* istanbul ignore next */\n      var trueName = usePrefix ?\n        name.replace(new RegExp('^' + PouchDB.prefix), '') : name;\n      return new PouchDB(trueName, self.__opts).destroy();\n    });\n    PouchPromise$1.all(deletedMap).then(destroyDb, callback);\n  });\n});\n\nfunction TaskQueue$1() {\n  this.isReady = false;\n  this.failed = false;\n  this.queue = [];\n}\n\nTaskQueue$1.prototype.execute = function () {\n  var fun;\n  if (this.failed) {\n    while ((fun = this.queue.shift())) {\n      fun(this.failed);\n    }\n  } else {\n    while ((fun = this.queue.shift())) {\n      fun();\n    }\n  }\n};\n\nTaskQueue$1.prototype.fail = function (err) {\n  this.failed = err;\n  this.execute();\n};\n\nTaskQueue$1.prototype.ready = function (db) {\n  this.isReady = true;\n  this.db = db;\n  this.execute();\n};\n\nTaskQueue$1.prototype.addTask = function (fun) {\n  this.queue.push(fun);\n  if (this.failed) {\n    this.execute();\n  }\n};\n\nfunction parseAdapter(name, opts) {\n  var match = name.match(/([a-z-]*):\\/\\/(.*)/);\n  if (match) {\n    // the http adapter expects the fully qualified name\n    return {\n      name: /https?/.test(match[1]) ? match[1] + '://' + match[2] : match[2],\n      adapter: match[1]\n    };\n  }\n\n  var adapters = PouchDB$5.adapters;\n  var preferredAdapters = PouchDB$5.preferredAdapters;\n  var prefix = PouchDB$5.prefix;\n  var adapterName = opts.adapter;\n\n  if (!adapterName) { // automatically determine adapter\n    for (var i = 0; i < preferredAdapters.length; ++i) {\n      adapterName = preferredAdapters[i];\n      // check for browsers that have been upgraded from websql-only to websql+idb\n      /* istanbul ignore if */\n      if (adapterName === 'idb' && 'websql' in adapters &&\n          hasLocalStorage() && localStorage['_pouch__websqldb_' + prefix + name]) {\n        // log it, because this can be confusing during development\n        guardedConsole('log', 'PouchDB is downgrading \"' + name + '\" to WebSQL to' +\n          ' avoid data loss, because it was already opened with WebSQL.');\n        continue; // keep using websql to avoid user data loss\n      }\n      break;\n    }\n  }\n\n  var adapter = adapters[adapterName];\n\n  // if adapter is invalid, then an error will be thrown later\n  var usePrefix = (adapter && 'use_prefix' in adapter) ?\n    adapter.use_prefix : true;\n\n  return {\n    name: usePrefix ? (prefix + name) : name,\n    adapter: adapterName\n  };\n}\n\n// OK, so here's the deal. Consider this code:\n//     var db1 = new PouchDB('foo');\n//     var db2 = new PouchDB('foo');\n//     db1.destroy();\n// ^ these two both need to emit 'destroyed' events,\n// as well as the PouchDB constructor itself.\n// So we have one db object (whichever one got destroy() called on it)\n// responsible for emitting the initial event, which then gets emitted\n// by the constructor, which then broadcasts it to any other dbs\n// that may have been created with the same name.\nfunction prepareForDestruction(self) {\n\n  function onDestroyed(from_constructor) {\n    self.removeListener('closed', onClosed);\n    if (!from_constructor) {\n      self.constructor.emit('destroyed', self.name);\n    }\n  }\n\n  function onClosed() {\n    self.removeListener('destroyed', onDestroyed);\n    self.constructor.emit('unref', self);\n  }\n\n  self.once('destroyed', onDestroyed);\n  self.once('closed', onClosed);\n  self.constructor.emit('ref', self);\n}\n\ninherits(PouchDB$5, AbstractPouchDB);\nfunction PouchDB$5(name, opts) {\n  // In Node our test suite only tests this for PouchAlt unfortunately\n  /* istanbul ignore if */\n  if (!(this instanceof PouchDB$5)) {\n    return new PouchDB$5(name, opts);\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  if (name && typeof name === 'object') {\n    opts = name;\n    name = opts.name;\n    delete opts.name;\n  }\n\n  this.__opts = opts = clone(opts);\n\n  self.auto_compaction = opts.auto_compaction;\n  self.prefix = PouchDB$5.prefix;\n\n  if (typeof name !== 'string') {\n    throw new Error('Missing/invalid DB name');\n  }\n\n  var prefixedName = (opts.prefix || '') + name;\n  var backend = parseAdapter(prefixedName, opts);\n\n  opts.name = backend.name;\n  opts.adapter = opts.adapter || backend.adapter;\n\n  self.name = name;\n  self._adapter = opts.adapter;\n  PouchDB$5.emit('debug', ['adapter', 'Picked adapter: ', opts.adapter]);\n\n  if (!PouchDB$5.adapters[opts.adapter] ||\n      !PouchDB$5.adapters[opts.adapter].valid()) {\n    throw new Error('Invalid Adapter: ' + opts.adapter);\n  }\n\n  AbstractPouchDB.call(self);\n  self.taskqueue = new TaskQueue$1();\n\n  self.adapter = opts.adapter;\n\n  PouchDB$5.adapters[opts.adapter].call(self, opts, function (err) {\n    if (err) {\n      return self.taskqueue.fail(err);\n    }\n    prepareForDestruction(self);\n\n    self.emit('created', self);\n    PouchDB$5.emit('created', self.name);\n    self.taskqueue.ready(self);\n  });\n\n}\n\nPouchDB$5.adapters = {};\nPouchDB$5.preferredAdapters = [];\n\nPouchDB$5.prefix = '_pouch_';\n\nvar eventEmitter = new events.EventEmitter();\n\nfunction setUpEventEmitter(Pouch) {\n  Object.keys(events.EventEmitter.prototype).forEach(function (key) {\n    if (typeof events.EventEmitter.prototype[key] === 'function') {\n      Pouch[key] = eventEmitter[key].bind(eventEmitter);\n    }\n  });\n\n  // these are created in constructor.js, and allow us to notify each DB with\n  // the same name that it was destroyed, via the constructor object\n  var destructListeners = Pouch._destructionListeners = new ExportedMap();\n\n  Pouch.on('ref', function onConstructorRef(db) {\n    if (!destructListeners.has(db.name)) {\n      destructListeners.set(db.name, []);\n    }\n    destructListeners.get(db.name).push(db);\n  });\n\n  Pouch.on('unref', function onConstructorUnref(db) {\n    if (!destructListeners.has(db.name)) {\n      return;\n    }\n    var dbList = destructListeners.get(db.name);\n    var pos = dbList.indexOf(db);\n    if (pos < 0) {\n      /* istanbul ignore next */\n      return;\n    }\n    dbList.splice(pos, 1);\n    if (dbList.length > 1) {\n      /* istanbul ignore next */\n      destructListeners.set(db.name, dbList);\n    } else {\n      destructListeners.delete(db.name);\n    }\n  });\n\n  Pouch.on('destroyed', function onConstructorDestroyed(name) {\n    if (!destructListeners.has(name)) {\n      return;\n    }\n    var dbList = destructListeners.get(name);\n    destructListeners.delete(name);\n    dbList.forEach(function (db) {\n      db.emit('destroyed',true);\n    });\n  });\n}\n\nsetUpEventEmitter(PouchDB$5);\n\nPouchDB$5.adapter = function (id, obj, addToPreferredAdapters) {\n  /* istanbul ignore else */\n  if (obj.valid()) {\n    PouchDB$5.adapters[id] = obj;\n    if (addToPreferredAdapters) {\n      PouchDB$5.preferredAdapters.push(id);\n    }\n  }\n};\n\nPouchDB$5.plugin = function (obj) {\n  if (typeof obj === 'function') { // function style for plugins\n    obj(PouchDB$5);\n  } else if (typeof obj !== 'object' || Object.keys(obj).length === 0) {\n    throw new Error('Invalid plugin: got \"' + obj + '\", expected an object or a function');\n  } else {\n    Object.keys(obj).forEach(function (id) { // object style for plugins\n      PouchDB$5.prototype[id] = obj[id];\n    });\n  }\n  if (this.__defaults) {\n    PouchDB$5.__defaults = $inject_Object_assign({}, this.__defaults);\n  }\n  return PouchDB$5;\n};\n\nPouchDB$5.defaults = function (defaultOpts) {\n  function PouchAlt(name, opts) {\n    if (!(this instanceof PouchAlt)) {\n      return new PouchAlt(name, opts);\n    }\n\n    opts = opts || {};\n\n    if (name && typeof name === 'object') {\n      opts = name;\n      name = opts.name;\n      delete opts.name;\n    }\n\n    opts = $inject_Object_assign({}, PouchAlt.__defaults, opts);\n    PouchDB$5.call(this, name, opts);\n  }\n\n  inherits(PouchAlt, PouchDB$5);\n\n  PouchAlt.preferredAdapters = PouchDB$5.preferredAdapters.slice();\n  Object.keys(PouchDB$5).forEach(function (key) {\n    if (!(key in PouchAlt)) {\n      PouchAlt[key] = PouchDB$5[key];\n    }\n  });\n\n  // make default options transitive\n  // https://github.com/pouchdb/pouchdb/issues/5922\n  PouchAlt.__defaults = $inject_Object_assign({}, this.__defaults, defaultOpts);\n\n  return PouchAlt;\n};\n\n// managed automatically by set-version.js\nvar version = \"6.3.4\";\n\nfunction debugPouch(PouchDB) {\n  PouchDB.debug = debug;\n  var logs = {};\n  /* istanbul ignore next */\n  PouchDB.on('debug', function (args) {\n    // first argument is log identifier\n    var logId = args[0];\n    // rest should be passed verbatim to debug module\n    var logArgs = args.slice(1);\n    if (!logs[logId]) {\n      logs[logId] = debug('pouchdb:' + logId);\n    }\n    logs[logId].apply(null, logArgs);\n  });\n}\n\n// this would just be \"return doc[field]\", but fields\n// can be \"deep\" due to dot notation\nfunction getFieldFromDoc(doc, parsedField) {\n  var value = doc;\n  for (var i = 0, len = parsedField.length; i < len; i++) {\n    var key = parsedField[i];\n    value = value[key];\n    if (!value) {\n      break;\n    }\n  }\n  return value;\n}\n\nfunction compare$1(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Converts a string in dot notation to an array of its components, with backslash escaping\nfunction parseField(fieldName) {\n  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n  var fields = [];\n  var current = '';\n  for (var i = 0, len = fieldName.length; i < len; i++) {\n    var ch = fieldName[i];\n    if (ch === '.') {\n      if (i > 0 && fieldName[i - 1] === '\\\\') { // escaped delimiter\n        current = current.substring(0, current.length - 1) + '.';\n      } else { // not escaped, so delimiter\n        fields.push(current);\n        current = '';\n      }\n    } else { // normal character\n      current += ch;\n    }\n  }\n  fields.push(current);\n  return fields;\n}\n\nvar combinationFields = ['$or', '$nor', '$not'];\nfunction isCombinationalField(field) {\n  return combinationFields.indexOf(field) > -1;\n}\n\nfunction getKey(obj) {\n  return Object.keys(obj)[0];\n}\n\nfunction getValue(obj) {\n  return obj[getKey(obj)];\n}\n\n\n// flatten an array of selectors joined by an $and operator\nfunction mergeAndedSelectors(selectors) {\n\n  // sort to ensure that e.g. if the user specified\n  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n  // just {$gt: 'b'}\n  var res = {};\n\n  selectors.forEach(function (selector) {\n    Object.keys(selector).forEach(function (field) {\n      var matcher = selector[field];\n      if (typeof matcher !== 'object') {\n        matcher = {$eq: matcher};\n      }\n\n      if (isCombinationalField(field)) {\n        if (matcher instanceof Array) {\n          res[field] = matcher.map(function (m) {\n            return mergeAndedSelectors([m]);\n          });\n        } else {\n          res[field] = mergeAndedSelectors([matcher]);\n        }\n      } else {\n        var fieldMatchers = res[field] = res[field] || {};\n        Object.keys(matcher).forEach(function (operator) {\n          var value = matcher[operator];\n\n          if (operator === '$gt' || operator === '$gte') {\n            return mergeGtGte(operator, value, fieldMatchers);\n          } else if (operator === '$lt' || operator === '$lte') {\n            return mergeLtLte(operator, value, fieldMatchers);\n          } else if (operator === '$ne') {\n            return mergeNe(value, fieldMatchers);\n          } else if (operator === '$eq') {\n            return mergeEq(value, fieldMatchers);\n          }\n          fieldMatchers[operator] = value;\n        });\n      }\n    });\n  });\n\n  return res;\n}\n\n\n\n// collapse logically equivalent gt/gte values\nfunction mergeGtGte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$gte !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gte) { // more specificity\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value >= fieldMatchers.$gte) { // more specificity\n        delete fieldMatchers.$gte;\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gt) { // more specificity\n        delete fieldMatchers.$gt;\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value > fieldMatchers.$gt) { // more specificity\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// collapse logically equivalent lt/lte values\nfunction mergeLtLte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$lte !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lte) { // more specificity\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value <= fieldMatchers.$lte) { // more specificity\n        delete fieldMatchers.$lte;\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lt) { // more specificity\n        delete fieldMatchers.$lt;\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value < fieldMatchers.$lt) { // more specificity\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// combine $ne values into one array\nfunction mergeNe(value, fieldMatchers) {\n  if ('$ne' in fieldMatchers) {\n    // there are many things this could \"not\" be\n    fieldMatchers.$ne.push(value);\n  } else { // doesn't exist yet\n    fieldMatchers.$ne = [value];\n  }\n}\n\n// add $eq into the mix\nfunction mergeEq(value, fieldMatchers) {\n  // these all have less specificity than the $eq\n  // TODO: check for user errors here\n  delete fieldMatchers.$gt;\n  delete fieldMatchers.$gte;\n  delete fieldMatchers.$lt;\n  delete fieldMatchers.$lte;\n  delete fieldMatchers.$ne;\n  fieldMatchers.$eq = value;\n}\n\n\n//\n// normalize the selector\n//\nfunction massageSelector(input) {\n  var result = clone(input);\n  var wasAnded = false;\n  if ('$and' in result) {\n    result = mergeAndedSelectors(result['$and']);\n    wasAnded = true;\n  }\n\n  ['$or', '$nor'].forEach(function (orOrNor) {\n    if (orOrNor in result) {\n      // message each individual selector\n      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}\n      result[orOrNor].forEach(function (subSelector) {\n        var fields = Object.keys(subSelector);\n        for (var i = 0; i < fields.length; i++) {\n          var field = fields[i];\n          var matcher = subSelector[field];\n          if (typeof matcher !== 'object' || matcher === null) {\n            subSelector[field] = {$eq: matcher};\n          }\n        }\n      });\n    }\n  });\n\n  if ('$not' in result) {\n    //This feels a little like forcing, but it will work for now,\n    //I would like to come back to this and make the merging of selectors a little more generic\n    result['$not'] = mergeAndedSelectors([result['$not']]);\n  }\n\n  var fields = Object.keys(result);\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    var matcher = result[field];\n\n    if (typeof matcher !== 'object' || matcher === null) {\n      matcher = {$eq: matcher};\n    } else if ('$ne' in matcher && !wasAnded) {\n      // I put these in an array, since there may be more than one\n      // but in the \"mergeAnded\" operation, I already take care of that\n      matcher.$ne = [matcher.$ne];\n    }\n    result[field] = matcher;\n  }\n\n  return result;\n}\n\nfunction pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  /* istanbul ignore next */\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\n\nfunction padLeft(str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n}\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging \n\nfunction collate(a, b) {\n\n  if (a === b) {\n    return 0;\n  }\n\n  a = normalizeKey(a);\n  b = normalizeKey(b);\n\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a < b ? -1 : 1;\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n}\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nfunction normalizeKey(key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = normalizeKey(origKey[i]);\n        }\n      /* istanbul ignore next */\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) { // generic object\n        key = {};\n        for (var k in origKey) {\n          if (origKey.hasOwnProperty(k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n}\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        return key\n          .replace(/\\u0002/g, '\\u0002\\u0002')\n          .replace(/\\u0001/g, '\\u0001\\u0002')\n          .replace(/\\u0000/g, '\\u0001\\u0001');\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += toIndexableString(objKey) +\n                toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nfunction toIndexableString(key) {\n  var zero = '\\u0000';\n  key = normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n}\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    /* istanbul ignore next */\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\u0000') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      /* istanbul ignore next */\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    /* istanbul ignore next */\n    if (neg) {\n      num = num - 10;\n    }\n    /* istanbul ignore next */\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return {num: num, length : i - originalIdx};\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nfunction parseIndexableString(str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\u0000') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\u0000') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n          .replace(/\\u0001\\u0002/g, '\\u0001')\n          .replace(/\\u0002\\u0002/g, '\\u0002');\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      /* istanbul ignore next */\n      default:\n        throw new Error(\n          'bad collationIndex or unexpectedly reached end of input: ' +\n            collationIndex);\n    }\n  }\n}\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? (idx + 2) : (idx + 3);\n  }\n  /* istanbul ignore next */\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n\n  var neg = num < 0;\n\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  /* istanbul ignore next */\n  if (neg) { // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n\n  result += SEP + factorStr;\n\n  return result;\n}\n\n// create a comparator based on the sort object\nfunction createFieldSorter(sort) {\n\n  function getFieldValuesAsArray(doc) {\n    return sort.map(function (sorting) {\n      var fieldName = getKey(sorting);\n      var parsedField = parseField(fieldName);\n      var docFieldValue = getFieldFromDoc(doc, parsedField);\n      return docFieldValue;\n    });\n  }\n\n  return function (aRow, bRow) {\n    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n    var collation = collate(aFieldValues, bFieldValues);\n    if (collation !== 0) {\n      return collation;\n    }\n    // this is what mango seems to do\n    return compare$1(aRow.doc._id, bRow.doc._id);\n  };\n}\n\nfunction filterInMemoryFields(rows, requestDef, inMemoryFields) {\n  rows = rows.filter(function (row) {\n    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n  });\n\n  if (requestDef.sort) {\n    // in-memory sort\n    var fieldSorter = createFieldSorter(requestDef.sort);\n    rows = rows.sort(fieldSorter);\n    if (typeof requestDef.sort[0] !== 'string' &&\n        getValue(requestDef.sort[0]) === 'desc') {\n      rows = rows.reverse();\n    }\n  }\n\n  if ('limit' in requestDef || 'skip' in requestDef) {\n    // have to do the limit in-memory\n    var skip = requestDef.skip || 0;\n    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n    rows = rows.slice(skip, limit);\n  }\n  return rows;\n}\n\nfunction rowFilter(doc, selector, inMemoryFields) {\n  return inMemoryFields.every(function (field) {\n    var matcher = selector[field];\n    var parsedField = parseField(field);\n    var docFieldValue = getFieldFromDoc(doc, parsedField);\n    if (isCombinationalField(field)) {\n      return matchCominationalSelector(field, matcher, doc);\n    }\n\n    return matchSelector(matcher, doc, parsedField, docFieldValue);\n  });\n}\n\nfunction matchSelector(matcher, doc, parsedField, docFieldValue) {\n  if (!matcher) {\n    // no filtering necessary; this field is just needed for sorting\n    return true;\n  }\n\n  return Object.keys(matcher).every(function (userOperator) {\n    var userValue = matcher[userOperator];\n    return match(userOperator, doc, userValue, parsedField, docFieldValue);\n  });\n}\n\nfunction matchCominationalSelector(field, matcher, doc) {\n\n  if (field === '$or') {\n    return matcher.some(function (orMatchers) {\n      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n    });\n  }\n\n  if (field === '$not') {\n    return !rowFilter(doc, matcher, Object.keys(matcher));\n  }\n\n  //`$nor`\n  return !matcher.find(function (orMatchers) {\n    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n  });\n\n}\n\nfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n  if (!matchers[userOperator]) {\n    throw new Error('unknown operator \"' + userOperator +\n      '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +\n      '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');\n  }\n  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n}\n\nfunction fieldExists(docFieldValue) {\n  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n}\n\nfunction fieldIsNotUndefined(docFieldValue) {\n  return typeof docFieldValue !== 'undefined';\n}\n\nfunction modField(docFieldValue, userValue) {\n  var divisor = userValue[0];\n  var mod = userValue[1];\n  if (divisor === 0) {\n    throw new Error('Bad divisor, cannot divide by zero');\n  }\n\n  if (parseInt(divisor, 10) !== divisor ) {\n    throw new Error('Divisor is not an integer');\n  }\n\n  if (parseInt(mod, 10) !== mod ) {\n    throw new Error('Modulus is not an integer');\n  }\n\n  if (parseInt(docFieldValue, 10) !== docFieldValue) {\n    return false;\n  }\n\n  return docFieldValue % divisor === mod;\n}\n\nfunction arrayContainsValue(docFieldValue, userValue) {\n  return userValue.some(function (val) {\n    if (docFieldValue instanceof Array) {\n      return docFieldValue.indexOf(val) > -1;\n    }\n\n    return docFieldValue === val;\n  });\n}\n\nfunction arrayContainsAllValues(docFieldValue, userValue) {\n  return userValue.every(function (val) {\n    return docFieldValue.indexOf(val) > -1;\n  });\n}\n\nfunction arraySize(docFieldValue, userValue) {\n  return docFieldValue.length === userValue;\n}\n\nfunction regexMatch(docFieldValue, userValue) {\n  var re = new RegExp(userValue);\n\n  return re.test(docFieldValue);\n}\n\nfunction typeMatch(docFieldValue, userValue) {\n\n  switch (userValue) {\n    case 'null':\n      return docFieldValue === null;\n    case 'boolean':\n      return typeof (docFieldValue) === 'boolean';\n    case 'number':\n      return typeof (docFieldValue) === 'number';\n    case 'string':\n      return typeof (docFieldValue) === 'string';\n    case 'array':\n      return docFieldValue instanceof Array;\n    case 'object':\n      return ({}).toString.call(docFieldValue) === '[object Object]';\n  }\n\n  throw new Error(userValue + ' not supported as a type.' +\n                  'Please use one of object, string, array, number, boolean or null.');\n\n}\n\nvar matchers = {\n\n  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.some(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.some(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$allMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    /* istanbul ignore next */\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.every(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.every(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n  },\n\n  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n  },\n\n  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n  },\n\n  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n  },\n\n  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n  },\n\n  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n    //a field that is null is still considered to exist\n    if (userValue) {\n      return fieldIsNotUndefined(docFieldValue);\n    }\n\n    return !fieldIsNotUndefined(docFieldValue);\n  },\n\n  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n  },\n\n  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n    return userValue.every(function (neValue) {\n      return collate(docFieldValue, neValue) !== 0;\n    });\n  },\n  '$in': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$size': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);\n  },\n\n  '$all': function (doc, userValue, parsedField, docFieldValue) {\n    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n  },\n\n  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);\n  },\n\n  '$type': function (doc, userValue, parsedField, docFieldValue) {\n    return typeMatch(docFieldValue, userValue);\n  }\n};\n\n// return true if the given doc matches the supplied selector\nfunction matchesSelector(doc, selector) {\n  /* istanbul ignore if */\n  if (typeof selector !== 'object') {\n    // match the CouchDB error message\n    throw new Error('Selector error: expected a JSON object');\n  }\n\n  selector = massageSelector(selector);\n  var row = {\n    'doc': doc\n  };\n\n  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));\n  return rowsMatched && rowsMatched.length === 1;\n}\n\nfunction evalFilter(input) {\n  return scopeEval('\"use strict\";\\nreturn ' + input + ';', {});\n}\n\nfunction evalView(input) {\n  var code = [\n    'return function(doc) {',\n    '  \"use strict\";',\n    '  var emitted = false;',\n    '  var emit = function (a, b) {',\n    '    emitted = true;',\n    '  };',\n    '  var view = ' + input + ';',\n    '  view(doc);',\n    '  if (emitted) {',\n    '    return true;',\n    '  }',\n    '};'\n  ].join('\\n');\n\n  return scopeEval(code, {});\n}\n\nfunction validate(opts, callback) {\n  if (opts.selector) {\n    if (opts.filter && opts.filter !== '_selector') {\n      var filterName = typeof opts.filter === 'string' ?\n        opts.filter : 'function';\n      return callback(new Error('selector invalid for filter \"' + filterName + '\"'));\n    }\n  }\n  callback();\n}\n\nfunction normalize(opts) {\n  if (opts.view && !opts.filter) {\n    opts.filter = '_view';\n  }\n\n  if (opts.selector && !opts.filter) {\n    opts.filter = '_selector';\n  }\n\n  if (opts.filter && typeof opts.filter === 'string') {\n    if (opts.filter === '_view') {\n      opts.view = normalizeDesignDocFunctionName(opts.view);\n    } else {\n      opts.filter = normalizeDesignDocFunctionName(opts.filter);\n    }\n  }\n}\n\nfunction shouldFilter(changesHandler, opts) {\n  return opts.filter && typeof opts.filter === 'string' &&\n    !opts.doc_ids && !isRemote(changesHandler.db);\n}\n\nfunction filter(changesHandler, opts) {\n  var callback = opts.complete;\n  if (opts.filter === '_view') {\n    if (!opts.view || typeof opts.view !== 'string') {\n      var err = createError(BAD_REQUEST,\n        '`view` filter parameter not found or invalid.');\n      return callback(err);\n    }\n    // fetch a view from a design doc, make it behave like a filter\n    var viewName = parseDesignDocFunctionName(opts.view);\n    changesHandler.db.get('_design/' + viewName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (changesHandler.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var mapFun = ddoc && ddoc.views && ddoc.views[viewName[1]] &&\n        ddoc.views[viewName[1]].map;\n      if (!mapFun) {\n        return callback(createError(MISSING_DOC,\n          (ddoc.views ? 'missing json key: ' + viewName[1] :\n            'missing json key: views')));\n      }\n      opts.filter = evalView(mapFun);\n      changesHandler.doChanges(opts);\n    });\n  } else if (opts.selector) {\n    opts.filter = function (doc) {\n      return matchesSelector(doc, opts.selector);\n    };\n    changesHandler.doChanges(opts);\n  } else {\n    // fetch a filter from a design doc\n    var filterName = parseDesignDocFunctionName(opts.filter);\n    changesHandler.db.get('_design/' + filterName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (changesHandler.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var filterFun = ddoc && ddoc.filters && ddoc.filters[filterName[1]];\n      if (!filterFun) {\n        return callback(createError(MISSING_DOC,\n          ((ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]\n            : 'missing json key: filters')));\n      }\n      opts.filter = evalFilter(filterFun);\n      changesHandler.doChanges(opts);\n    });\n  }\n}\n\nfunction applyChangesFilterPlugin(PouchDB) {\n  PouchDB._changesFilterPlugin = {\n    validate: validate,\n    normalize: normalize,\n    shouldFilter: shouldFilter,\n    filter: filter\n  };\n}\n\n// TODO: remove from pouchdb-core (breaking)\nPouchDB$5.plugin(debugPouch);\n\n// TODO: remove from pouchdb-core (breaking)\nPouchDB$5.plugin(applyChangesFilterPlugin);\n\nPouchDB$5.version = version;\n\nfunction toObject(array) {\n  return array.reduce(function (obj, item) {\n    obj[item] = true;\n    return obj;\n  }, {});\n}\n// List of top level reserved words for doc\nvar reservedWords = toObject([\n  '_id',\n  '_rev',\n  '_attachments',\n  '_deleted',\n  '_revisions',\n  '_revs_info',\n  '_conflicts',\n  '_deleted_conflicts',\n  '_local_seq',\n  '_rev_tree',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats',\n  // Specific to Couchbase Sync Gateway\n  '_removed'\n]);\n\n// List of reserved words that should end up the document\nvar dataWords = toObject([\n  '_attachments',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats'\n]);\n\nfunction parseRevisionInfo(rev$$1) {\n  if (!/^\\d+-./.test(rev$$1)) {\n    return createError(INVALID_REV);\n  }\n  var idx = rev$$1.indexOf('-');\n  var left = rev$$1.substring(0, idx);\n  var right = rev$$1.substring(idx + 1);\n  return {\n    prefix: parseInt(left, 10),\n    id: right\n  };\n}\n\nfunction makeRevTreeFromRevisions(revisions, opts) {\n  var pos = revisions.start - revisions.ids.length + 1;\n\n  var revisionIds = revisions.ids;\n  var ids = [revisionIds[0], opts, []];\n\n  for (var i = 1, len = revisionIds.length; i < len; i++) {\n    ids = [revisionIds[i], {status: 'missing'}, [ids]];\n  }\n\n  return [{\n    pos: pos,\n    ids: ids\n  }];\n}\n\n// Preprocess documents, parse their revisions, assign an id and a\n// revision for new writes that are missing them, etc\nfunction parseDoc(doc, newEdits) {\n\n  var nRevNum;\n  var newRevId;\n  var revInfo;\n  var opts = {status: 'available'};\n  if (doc._deleted) {\n    opts.deleted = true;\n  }\n\n  if (newEdits) {\n    if (!doc._id) {\n      doc._id = uuid();\n    }\n    newRevId = rev();\n    if (doc._rev) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      doc._rev_tree = [{\n        pos: revInfo.prefix,\n        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]\n      }];\n      nRevNum = revInfo.prefix + 1;\n    } else {\n      doc._rev_tree = [{\n        pos: 1,\n        ids : [newRevId, opts, []]\n      }];\n      nRevNum = 1;\n    }\n  } else {\n    if (doc._revisions) {\n      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);\n      nRevNum = doc._revisions.start;\n      newRevId = doc._revisions.ids[0];\n    }\n    if (!doc._rev_tree) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      nRevNum = revInfo.prefix;\n      newRevId = revInfo.id;\n      doc._rev_tree = [{\n        pos: nRevNum,\n        ids: [newRevId, opts, []]\n      }];\n    }\n  }\n\n  invalidIdError(doc._id);\n\n  doc._rev = nRevNum + '-' + newRevId;\n\n  var result = {metadata : {}, data : {}};\n  for (var key in doc) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(doc, key)) {\n      var specialKey = key[0] === '_';\n      if (specialKey && !reservedWords[key]) {\n        var error = createError(DOC_VALIDATION, key);\n        error.message = DOC_VALIDATION.message + ': ' + key;\n        throw error;\n      } else if (specialKey && !dataWords[key]) {\n        result.metadata[key.slice(1)] = doc[key];\n      } else {\n        result.data[key] = doc[key];\n      }\n    }\n  }\n  return result;\n}\n\nvar thisAtob = function (str) {\n  return atob(str);\n};\n\nvar thisBtoa = function (str) {\n  return btoa(str);\n};\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor (e.g.\n// old QtWebKit versions, Android < 4.4).\nfunction createBlob(parts, properties) {\n  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n  parts = parts || [];\n  properties = properties || {};\n  try {\n    return new Blob(parts, properties);\n  } catch (e) {\n    if (e.name !== \"TypeError\") {\n      throw e;\n    }\n    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n                  WebKitBlobBuilder;\n    var builder = new Builder();\n    for (var i = 0; i < parts.length; i += 1) {\n      builder.append(parts[i]);\n    }\n    return builder.getBlob(properties.type);\n  }\n}\n\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction binaryStringToArrayBuffer(bin) {\n  var length = bin.length;\n  var buf = new ArrayBuffer(length);\n  var arr = new Uint8Array(buf);\n  for (var i = 0; i < length; i++) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return buf;\n}\n\nfunction binStringToBluffer(binString, type) {\n  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});\n}\n\nfunction b64ToBluffer(b64, type) {\n  return binStringToBluffer(thisAtob(b64), type);\n}\n\n//Can't find original post, but this is close\n//http://stackoverflow.com/questions/6965107/ (continues on next line)\n//converting-between-strings-and-arraybuffers\nfunction arrayBufferToBinaryString(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n  var length = bytes.byteLength;\n  for (var i = 0; i < length; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return binary;\n}\n\n// shim for browsers that don't support it\nfunction readAsBinaryString(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(arrayBufferToBinaryString(\n      new FileReaderSync().readAsArrayBuffer(blob)));\n  }\n\n  var reader = new FileReader();\n  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n  reader.onloadend = function (e) {\n    var result = e.target.result || '';\n    if (hasBinaryString) {\n      return callback(result);\n    }\n    callback(arrayBufferToBinaryString(result));\n  };\n  if (hasBinaryString) {\n    reader.readAsBinaryString(blob);\n  } else {\n    reader.readAsArrayBuffer(blob);\n  }\n}\n\nfunction blobToBinaryString(blobOrBuffer, callback) {\n  readAsBinaryString(blobOrBuffer, function (bin) {\n    callback(bin);\n  });\n}\n\nfunction blobToBase64(blobOrBuffer, callback) {\n  blobToBinaryString(blobOrBuffer, function (base64) {\n    callback(thisBtoa(base64));\n  });\n}\n\n// simplified API. universal browser support is assumed\nfunction readAsArrayBuffer(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(new FileReaderSync().readAsArrayBuffer(blob));\n  }\n\n  var reader = new FileReader();\n  reader.onloadend = function (e) {\n    var result = e.target.result || new ArrayBuffer(0);\n    callback(result);\n  };\n  reader.readAsArrayBuffer(blob);\n}\n\n// this is not used in the browser\n\nvar setImmediateShim = global.setImmediate || global.setTimeout;\nvar MD5_CHUNK_SIZE = 32768;\n\nfunction rawToBase64(raw) {\n  return thisBtoa(raw);\n}\n\nfunction sliceBlob(blob, start, end) {\n  if (blob.webkitSlice) {\n    return blob.webkitSlice(start, end);\n  }\n  return blob.slice(start, end);\n}\n\nfunction appendBlob(buffer, blob, start, end, callback) {\n  if (start > 0 || end < blob.size) {\n    // only slice blob if we really need to\n    blob = sliceBlob(blob, start, end);\n  }\n  readAsArrayBuffer(blob, function (arrayBuffer) {\n    buffer.append(arrayBuffer);\n    callback();\n  });\n}\n\nfunction appendString(buffer, string, start, end, callback) {\n  if (start > 0 || end < string.length) {\n    // only create a substring if we really need to\n    string = string.substring(start, end);\n  }\n  buffer.appendBinary(string);\n  callback();\n}\n\nfunction binaryMd5(data, callback) {\n  var inputIsString = typeof data === 'string';\n  var len = inputIsString ? data.length : data.size;\n  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n  var chunks = Math.ceil(len / chunkSize);\n  var currentChunk = 0;\n  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();\n\n  var append = inputIsString ? appendString : appendBlob;\n\n  function next() {\n    setImmediateShim(loadNextChunk);\n  }\n\n  function done() {\n    var raw = buffer.end(true);\n    var base64 = rawToBase64(raw);\n    callback(base64);\n    buffer.destroy();\n  }\n\n  function loadNextChunk() {\n    var start = currentChunk * chunkSize;\n    var end = start + chunkSize;\n    currentChunk++;\n    if (currentChunk < chunks) {\n      append(buffer, data, start, end, next);\n    } else {\n      append(buffer, data, start, end, done);\n    }\n  }\n  loadNextChunk();\n}\n\nfunction stringMd5(string) {\n  return Md5.hash(string);\n}\n\nfunction parseBase64(data) {\n  try {\n    return thisAtob(data);\n  } catch (e) {\n    var err = createError(BAD_ARG,\n      'Attachment is not a valid base64 string');\n    return {error: err};\n  }\n}\n\nfunction preprocessString(att, blobType, callback) {\n  var asBinary = parseBase64(att.data);\n  if (asBinary.error) {\n    return callback(asBinary.error);\n  }\n\n  att.length = asBinary.length;\n  if (blobType === 'blob') {\n    att.data = binStringToBluffer(asBinary, att.content_type);\n  } else if (blobType === 'base64') {\n    att.data = thisBtoa(asBinary);\n  } else { // binary\n    att.data = asBinary;\n  }\n  binaryMd5(asBinary, function (result) {\n    att.digest = 'md5-' + result;\n    callback();\n  });\n}\n\nfunction preprocessBlob(att, blobType, callback) {\n  binaryMd5(att.data, function (md5) {\n    att.digest = 'md5-' + md5;\n    // size is for blobs (browser), length is for buffers (node)\n    att.length = att.data.size || att.data.length || 0;\n    if (blobType === 'binary') {\n      blobToBinaryString(att.data, function (binString) {\n        att.data = binString;\n        callback();\n      });\n    } else if (blobType === 'base64') {\n      blobToBase64(att.data, function (b64) {\n        att.data = b64;\n        callback();\n      });\n    } else {\n      callback();\n    }\n  });\n}\n\nfunction preprocessAttachment(att, blobType, callback) {\n  if (att.stub) {\n    return callback();\n  }\n  if (typeof att.data === 'string') { // input is a base64 string\n    preprocessString(att, blobType, callback);\n  } else { // input is a blob\n    preprocessBlob(att, blobType, callback);\n  }\n}\n\nfunction preprocessAttachments(docInfos, blobType, callback) {\n\n  if (!docInfos.length) {\n    return callback();\n  }\n\n  var docv = 0;\n  var overallErr;\n\n  docInfos.forEach(function (docInfo) {\n    var attachments = docInfo.data && docInfo.data._attachments ?\n      Object.keys(docInfo.data._attachments) : [];\n    var recv = 0;\n\n    if (!attachments.length) {\n      return done();\n    }\n\n    function processedAttachment(err) {\n      overallErr = err;\n      recv++;\n      if (recv === attachments.length) {\n        done();\n      }\n    }\n\n    for (var key in docInfo.data._attachments) {\n      if (docInfo.data._attachments.hasOwnProperty(key)) {\n        preprocessAttachment(docInfo.data._attachments[key],\n          blobType, processedAttachment);\n      }\n    }\n  });\n\n  function done() {\n    docv++;\n    if (docInfos.length === docv) {\n      if (overallErr) {\n        callback(overallErr);\n      } else {\n        callback();\n      }\n    }\n  }\n}\n\nfunction updateDoc(revLimit, prev, docInfo, results,\n                   i, cb, writeDoc, newEdits) {\n\n  if (revExists(prev.rev_tree, docInfo.metadata.rev)) {\n    results[i] = docInfo;\n    return cb();\n  }\n\n  // sometimes this is pre-calculated. historically not always\n  var previousWinningRev = prev.winningRev || winningRev(prev);\n  var previouslyDeleted = 'deleted' in prev ? prev.deleted :\n    isDeleted(prev, previousWinningRev);\n  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :\n    isDeleted(docInfo.metadata);\n  var isRoot = /^1-/.test(docInfo.metadata.rev);\n\n  if (previouslyDeleted && !deleted && newEdits && isRoot) {\n    var newDoc = docInfo.data;\n    newDoc._rev = previousWinningRev;\n    newDoc._id = docInfo.metadata.id;\n    docInfo = parseDoc(newDoc, newEdits);\n  }\n\n  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);\n\n  var inConflict = newEdits && ((\n    (previouslyDeleted && deleted && merged.conflicts !== 'new_leaf') ||\n    (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||\n    (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));\n\n  if (inConflict) {\n    var err = createError(REV_CONFLICT);\n    results[i] = err;\n    return cb();\n  }\n\n  var newRev = docInfo.metadata.rev;\n  docInfo.metadata.rev_tree = merged.tree;\n  docInfo.stemmedRevs = merged.stemmedRevs || [];\n  /* istanbul ignore else */\n  if (prev.rev_map) {\n    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb\n  }\n\n  // recalculate\n  var winningRev$$1 = winningRev(docInfo.metadata);\n  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$1);\n\n  // calculate the total number of documents that were added/removed,\n  // from the perspective of total_rows/doc_count\n  var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :\n    previouslyDeleted < winningRevIsDeleted ? -1 : 1;\n\n  var newRevIsDeleted;\n  if (newRev === winningRev$$1) {\n    // if the new rev is the same as the winning rev, we can reuse that value\n    newRevIsDeleted = winningRevIsDeleted;\n  } else {\n    // if they're not the same, then we need to recalculate\n    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);\n  }\n\n  writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n    true, delta, i, cb);\n}\n\nfunction rootIsMissing(docInfo) {\n  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';\n}\n\nfunction processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,\n                     writeDoc, opts, overallCallback) {\n\n  // Default to 1000 locally\n  revLimit = revLimit || 1000;\n\n  function insertDoc(docInfo, resultsIdx, callback) {\n    // Cant insert new deleted documents\n    var winningRev$$1 = winningRev(docInfo.metadata);\n    var deleted = isDeleted(docInfo.metadata, winningRev$$1);\n    if ('was_delete' in opts && deleted) {\n      results[resultsIdx] = createError(MISSING_DOC, 'deleted');\n      return callback();\n    }\n\n    // 4712 - detect whether a new document was inserted with a _rev\n    var inConflict = newEdits && rootIsMissing(docInfo);\n\n    if (inConflict) {\n      var err = createError(REV_CONFLICT);\n      results[resultsIdx] = err;\n      return callback();\n    }\n\n    var delta = deleted ? 0 : 1;\n\n    writeDoc(docInfo, winningRev$$1, deleted, deleted, false,\n      delta, resultsIdx, callback);\n  }\n\n  var newEdits = opts.new_edits;\n  var idsToDocs = new ExportedMap();\n\n  var docsDone = 0;\n  var docsToDo = docInfos.length;\n\n  function checkAllDocsDone() {\n    if (++docsDone === docsToDo && overallCallback) {\n      overallCallback();\n    }\n  }\n\n  docInfos.forEach(function (currentDoc, resultsIdx) {\n\n    if (currentDoc._id && isLocalId(currentDoc._id)) {\n      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';\n      api[fun](currentDoc, {ctx: tx}, function (err, res) {\n        results[resultsIdx] = err || res;\n        checkAllDocsDone();\n      });\n      return;\n    }\n\n    var id = currentDoc.metadata.id;\n    if (idsToDocs.has(id)) {\n      docsToDo--; // duplicate\n      idsToDocs.get(id).push([currentDoc, resultsIdx]);\n    } else {\n      idsToDocs.set(id, [[currentDoc, resultsIdx]]);\n    }\n  });\n\n  // in the case of new_edits, the user can provide multiple docs\n  // with the same id. these need to be processed sequentially\n  idsToDocs.forEach(function (docs, id) {\n    var numDone = 0;\n\n    function docWritten() {\n      if (++numDone < docs.length) {\n        nextDoc();\n      } else {\n        checkAllDocsDone();\n      }\n    }\n    function nextDoc() {\n      var value = docs[numDone];\n      var currentDoc = value[0];\n      var resultsIdx = value[1];\n\n      if (fetchedDocs.has(id)) {\n        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,\n          resultsIdx, docWritten, writeDoc, newEdits);\n      } else {\n        // Ensure stemming applies to new writes as well\n        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);\n        currentDoc.metadata.rev_tree = merged.tree;\n        currentDoc.stemmedRevs = merged.stemmedRevs || [];\n        insertDoc(currentDoc, resultsIdx, docWritten);\n      }\n    }\n    nextDoc();\n  });\n}\n\n// IndexedDB requires a versioned database structure, so we use the\n// version here to manage migrations.\nvar ADAPTER_VERSION = 5;\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\n// Keyed by document id\nvar DOC_STORE = 'document-store';\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE = 'by-sequence';\n// Where we store attachments\nvar ATTACH_STORE = 'attach-store';\n// Where we store many-to-many relations\n// between attachment digests and seqs\nvar ATTACH_AND_SEQ_STORE = 'attach-seq-store';\n\n// Where we store database-wide meta data in a single record\n// keyed by id: META_STORE\nvar META_STORE = 'meta-store';\n// Where we store local documents\nvar LOCAL_STORE = 'local-store';\n// Where we detect blob support\nvar DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\n\nfunction safeJsonParse(str) {\n  // This try/catch guards against stack overflow errors.\n  // JSON.parse() is faster than vuvuzela.parse() but vuvuzela\n  // cannot overflow.\n  try {\n    return JSON.parse(str);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.parse(str);\n  }\n}\n\nfunction safeJsonStringify(json) {\n  try {\n    return JSON.stringify(json);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.stringify(json);\n  }\n}\n\nfunction idbError(callback) {\n  return function (evt) {\n    var message = 'unknown_error';\n    if (evt.target && evt.target.error) {\n      message = evt.target.error.name || evt.target.error.message;\n    }\n    callback(createError(IDB_ERROR, message, evt.type));\n  };\n}\n\n// Unfortunately, the metadata has to be stringified\n// when it is put into the database, because otherwise\n// IndexedDB can throw errors for deeply-nested objects.\n// Originally we just used JSON.parse/JSON.stringify; now\n// we use this custom vuvuzela library that avoids recursion.\n// If we could do it all over again, we'd probably use a\n// format for the revision trees other than JSON.\nfunction encodeMetadata(metadata, winningRev, deleted) {\n  return {\n    data: safeJsonStringify(metadata),\n    winningRev: winningRev,\n    deletedOrLocal: deleted ? '1' : '0',\n    seq: metadata.seq, // highest seq for this doc\n    id: metadata.id\n  };\n}\n\nfunction decodeMetadata(storedObject) {\n  if (!storedObject) {\n    return null;\n  }\n  var metadata = safeJsonParse(storedObject.data);\n  metadata.winningRev = storedObject.winningRev;\n  metadata.deleted = storedObject.deletedOrLocal === '1';\n  metadata.seq = storedObject.seq;\n  return metadata;\n}\n\n// read the doc back out from the database. we don't store the\n// _id or _rev because we already have _doc_id_rev.\nfunction decodeDoc(doc) {\n  if (!doc) {\n    return doc;\n  }\n  var idx = doc._doc_id_rev.lastIndexOf(':');\n  doc._id = doc._doc_id_rev.substring(0, idx - 1);\n  doc._rev = doc._doc_id_rev.substring(idx + 1);\n  delete doc._doc_id_rev;\n  return doc;\n}\n\n// Read a blob from the database, encoding as necessary\n// and translating from base64 if the IDB doesn't support\n// native Blobs\nfunction readBlobData(body, type, asBlob, callback) {\n  if (asBlob) {\n    if (!body) {\n      callback(createBlob([''], {type: type}));\n    } else if (typeof body !== 'string') { // we have blob support\n      callback(body);\n    } else { // no blob support\n      callback(b64ToBluffer(body, type));\n    }\n  } else { // as base64 string\n    if (!body) {\n      callback('');\n    } else if (typeof body !== 'string') { // we have blob support\n      readAsBinaryString(body, function (binary) {\n        callback(thisBtoa(binary));\n      });\n    } else { // no blob support\n      callback(body);\n    }\n  }\n}\n\nfunction fetchAttachmentsIfNecessary(doc, opts, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var digest = attObj.digest;\n    var req = txn.objectStore(ATTACH_STORE).get(digest);\n    req.onsuccess = function (e) {\n      attObj.body = e.target.result.body;\n      checkDone();\n    };\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\n// IDB-specific postprocessing necessary because\n// we don't know whether we stored a true Blob or\n// a base64-encoded string, and if it's a Blob it\n// needs to be read outside of the transaction context\nfunction postProcessAttachments(results, asBlob) {\n  return PouchPromise$1.all(results.map(function (row) {\n    if (row.doc && row.doc._attachments) {\n      var attNames = Object.keys(row.doc._attachments);\n      return PouchPromise$1.all(attNames.map(function (att) {\n        var attObj = row.doc._attachments[att];\n        if (!('body' in attObj)) { // already processed\n          return;\n        }\n        var body = attObj.body;\n        var type = attObj.content_type;\n        return new PouchPromise$1(function (resolve) {\n          readBlobData(body, type, asBlob, function (data) {\n            row.doc._attachments[att] = $inject_Object_assign(\n              pick(attObj, ['digest', 'content_type']),\n              {data: data}\n            );\n            resolve();\n          });\n        });\n      }));\n    }\n  }));\n}\n\nfunction compactRevs(revs, docId, txn) {\n\n  var possiblyOrphanedDigests = [];\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var attStore = txn.objectStore(ATTACH_STORE);\n  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n  var count = revs.length;\n\n  function checkDone() {\n    count--;\n    if (!count) { // done processing all revs\n      deleteOrphanedAttachments();\n    }\n  }\n\n  function deleteOrphanedAttachments() {\n    if (!possiblyOrphanedDigests.length) {\n      return;\n    }\n    possiblyOrphanedDigests.forEach(function (digest) {\n      var countReq = attAndSeqStore.index('digestSeq').count(\n        IDBKeyRange.bound(\n          digest + '::', digest + '::\\uffff', false, false));\n      countReq.onsuccess = function (e) {\n        var count = e.target.result;\n        if (!count) {\n          // orphaned\n          attStore.delete(digest);\n        }\n      };\n    });\n  }\n\n  revs.forEach(function (rev$$1) {\n    var index = seqStore.index('_doc_id_rev');\n    var key = docId + \"::\" + rev$$1;\n    index.getKey(key).onsuccess = function (e) {\n      var seq = e.target.result;\n      if (typeof seq !== 'number') {\n        return checkDone();\n      }\n      seqStore.delete(seq);\n\n      var cursor = attAndSeqStore.index('seq')\n        .openCursor(IDBKeyRange.only(seq));\n\n      cursor.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          var digest = cursor.value.digestSeq.split('::')[0];\n          possiblyOrphanedDigests.push(digest);\n          attAndSeqStore.delete(cursor.primaryKey);\n          cursor.continue();\n        } else { // done\n          checkDone();\n        }\n      };\n    };\n  });\n}\n\nfunction openTransactionSafely(idb, stores, mode) {\n  try {\n    return {\n      txn: idb.transaction(stores, mode)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nvar changesHandler = new Changes();\n\nfunction idbBulkDocs(dbOpts, req, opts, api, idb, callback) {\n  var docInfos = req.docs;\n  var txn;\n  var docStore;\n  var bySeqStore;\n  var attachStore;\n  var attachAndSeqStore;\n  var metaStore;\n  var docInfoError;\n  var metaDoc;\n\n  for (var i = 0, len = docInfos.length; i < len; i++) {\n    var doc = docInfos[i];\n    if (doc._id && isLocalId(doc._id)) {\n      continue;\n    }\n    doc = docInfos[i] = parseDoc(doc, opts.new_edits);\n    if (doc.error && !docInfoError) {\n      docInfoError = doc;\n    }\n  }\n\n  if (docInfoError) {\n    return callback(docInfoError);\n  }\n\n  var allDocsProcessed = false;\n  var docCountDelta = 0;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new ExportedMap();\n  var preconditionErrored = false;\n  var blobType = api._meta.blobSupport ? 'blob' : 'base64';\n\n  preprocessAttachments(docInfos, blobType, function (err) {\n    if (err) {\n      return callback(err);\n    }\n    startTransaction();\n  });\n\n  function startTransaction() {\n\n    var stores = [\n      DOC_STORE, BY_SEQ_STORE,\n      ATTACH_STORE,\n      LOCAL_STORE, ATTACH_AND_SEQ_STORE,\n      META_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    txn = txnResult.txn;\n    txn.onabort = idbError(callback);\n    txn.ontimeout = idbError(callback);\n    txn.oncomplete = complete;\n    docStore = txn.objectStore(DOC_STORE);\n    bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    attachStore = txn.objectStore(ATTACH_STORE);\n    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n    metaStore = txn.objectStore(META_STORE);\n\n    metaStore.get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result;\n      updateDocCountIfReady();\n    };\n\n    verifyAttachments(function (err) {\n      if (err) {\n        preconditionErrored = true;\n        return callback(err);\n      }\n      fetchExistingDocs();\n    });\n  }\n\n  function onAllDocsProcessed() {\n    allDocsProcessed = true;\n    updateDocCountIfReady();\n  }\n\n  function idbProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,\n                txn, results, writeDoc, opts, onAllDocsProcessed);\n  }\n\n  function updateDocCountIfReady() {\n    if (!metaDoc || !allDocsProcessed) {\n      return;\n    }\n    // caching the docCount saves a lot of time in allDocs() and\n    // info(), which is why we go to all the trouble of doing this\n    metaDoc.docCount += docCountDelta;\n    metaStore.put(metaDoc);\n  }\n\n  function fetchExistingDocs() {\n\n    if (!docInfos.length) {\n      return;\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        idbProcessDocs();\n      }\n    }\n\n    function readMetadata(event) {\n      var metadata = decodeMetadata(event.target.result);\n\n      if (metadata) {\n        fetchedDocs.set(metadata.id, metadata);\n      }\n      checkDone();\n    }\n\n    for (var i = 0, len = docInfos.length; i < len; i++) {\n      var docInfo = docInfos[i];\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        checkDone(); // skip local docs\n        continue;\n      }\n      var req = docStore.get(docInfo.metadata.id);\n      req.onsuccess = readMetadata;\n    }\n  }\n\n  function complete() {\n    if (preconditionErrored) {\n      return;\n    }\n\n    changesHandler.notify(api._meta.name);\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n\n    var req = attachStore.get(digest);\n    req.onsuccess = function (e) {\n      if (!e.target.result) {\n        var err = createError(MISSING_STUB,\n          'unknown stub attachment with digest ' +\n          digest);\n        err.status = 412;\n        callback(err);\n      } else {\n        callback();\n      }\n    };\n  }\n\n  function verifyAttachments(finish) {\n\n\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n                    isUpdate, delta, resultsIdx, callback) {\n\n    docInfo.metadata.winningRev = winningRev$$1;\n    docInfo.metadata.deleted = winningRevIsDeleted;\n\n    var doc = docInfo.data;\n    doc._id = docInfo.metadata.id;\n    doc._rev = docInfo.metadata.rev;\n\n    if (newRevIsDeleted) {\n      doc._deleted = true;\n    }\n\n    var hasAttachments = doc._attachments &&\n      Object.keys(doc._attachments).length;\n    if (hasAttachments) {\n      return writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n        isUpdate, resultsIdx, callback);\n    }\n\n    docCountDelta += delta;\n    updateDocCountIfReady();\n\n    finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n      isUpdate, resultsIdx, callback);\n  }\n\n  function finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n                     isUpdate, resultsIdx, callback) {\n\n    var doc = docInfo.data;\n    var metadata = docInfo.metadata;\n\n    doc._doc_id_rev = metadata.id + '::' + metadata.rev;\n    delete doc._id;\n    delete doc._rev;\n\n    function afterPutDoc(e) {\n      var revsToDelete = docInfo.stemmedRevs || [];\n\n      if (isUpdate && api.auto_compaction) {\n        revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));\n      }\n\n      if (revsToDelete && revsToDelete.length) {\n        compactRevs(revsToDelete, docInfo.metadata.id, txn);\n      }\n\n      metadata.seq = e.target.result;\n      // Current _rev is calculated from _rev_tree on read\n      // delete metadata.rev;\n      var metadataToStore = encodeMetadata(metadata, winningRev$$1,\n        winningRevIsDeleted);\n      var metaDataReq = docStore.put(metadataToStore);\n      metaDataReq.onsuccess = afterPutMetadata;\n    }\n\n    function afterPutDocError(e) {\n      // ConstraintError, need to update, not put (see #1638 for details)\n      e.preventDefault(); // avoid transaction abort\n      e.stopPropagation(); // avoid transaction onerror\n      var index = bySeqStore.index('_doc_id_rev');\n      var getKeyReq = index.getKey(doc._doc_id_rev);\n      getKeyReq.onsuccess = function (e) {\n        var putReq = bySeqStore.put(doc, e.target.result);\n        putReq.onsuccess = afterPutDoc;\n      };\n    }\n\n    function afterPutMetadata() {\n      results[resultsIdx] = {\n        ok: true,\n        id: metadata.id,\n        rev: metadata.rev\n      };\n      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);\n      insertAttachmentMappings(docInfo, metadata.seq, callback);\n    }\n\n    var putReq = bySeqStore.put(doc);\n\n    putReq.onsuccess = afterPutDoc;\n    putReq.onerror = afterPutDocError;\n  }\n\n  function writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n                            isUpdate, resultsIdx, callback) {\n\n\n    var doc = docInfo.data;\n\n    var numDone = 0;\n    var attachments = Object.keys(doc._attachments);\n\n    function collectResults() {\n      if (numDone === attachments.length) {\n        finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n          isUpdate, resultsIdx, callback);\n      }\n    }\n\n    function attachmentSaved() {\n      numDone++;\n      collectResults();\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev$$1, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        numDone++;\n        collectResults();\n      }\n    });\n  }\n\n  // map seqs to attachment digests, which\n  // we will need later during compaction\n  function insertAttachmentMappings(docInfo, seq, callback) {\n\n    var attsAdded = 0;\n    var attsToAdd = Object.keys(docInfo.data._attachments || {});\n\n    if (!attsToAdd.length) {\n      return callback();\n    }\n\n    function checkDone() {\n      if (++attsAdded === attsToAdd.length) {\n        callback();\n      }\n    }\n\n    function add(att) {\n      var digest = docInfo.data._attachments[att].digest;\n      var req = attachAndSeqStore.put({\n        seq: seq,\n        digestSeq: digest + '::' + seq\n      });\n\n      req.onsuccess = checkDone;\n      req.onerror = function (e) {\n        // this callback is for a constaint error, which we ignore\n        // because this docid/rev has already been associated with\n        // the digest (e.g. when new_edits == false)\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n        checkDone();\n      };\n    }\n    for (var i = 0; i < attsToAdd.length; i++) {\n      add(attsToAdd[i]); // do in parallel\n    }\n  }\n\n  function saveAttachment(digest, data, callback) {\n\n\n    var getKeyReq = attachStore.count(digest);\n    getKeyReq.onsuccess = function (e) {\n      var count = e.target.result;\n      if (count) {\n        return callback(); // already exists\n      }\n      var newAtt = {\n        digest: digest,\n        body: data\n      };\n      var putReq = attachStore.put(newAtt);\n      putReq.onsuccess = callback;\n    };\n  }\n}\n\n// Abstraction over IDBCursor and getAll()/getAllKeys() that allows us to batch our operations\n// while falling back to a normal IDBCursor operation on browsers that don't support getAll() or\n// getAllKeys(). This allows for a much faster implementation than just straight-up cursors, because\n// we're not processing each document one-at-a-time.\nfunction runBatchedCursor(objectStore, keyRange, descending, batchSize, onBatch) {\n\n  // Bail out of getAll()/getAllKeys() in the following cases:\n  // 1) either method is unsupported - we need both\n  // 2) batchSize is 1 (might as well use IDBCursor), or batchSize is -1 (i.e. batchSize unlimited,\n  //    not really clear the user wants a batched approach where the entire DB is read into memory,\n  //    perhaps they are filtering on a per-doc basis)\n  // 3) descending – no real way to do this via getAll()/getAllKeys()\n\n  var useGetAll = typeof objectStore.getAll === 'function' &&\n    typeof objectStore.getAllKeys === 'function' &&\n    batchSize > 1 && !descending;\n\n  var keysBatch;\n  var valuesBatch;\n  var pseudoCursor;\n\n  function onGetAll(e) {\n    valuesBatch = e.target.result;\n    if (keysBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function onGetAllKeys(e) {\n    keysBatch = e.target.result;\n    if (valuesBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function continuePseudoCursor() {\n    if (!keysBatch.length) { // no more results\n      return onBatch();\n    }\n    // fetch next batch, exclusive start\n    var lastKey = keysBatch[keysBatch.length - 1];\n    var newKeyRange;\n    if (keyRange && keyRange.upper) {\n      try {\n        newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper,\n          true, keyRange.upperOpen);\n      } catch (e) {\n        if (e.name === \"DataError\" && e.code === 0) {\n          return onBatch(); // we're done, startkey and endkey are equal\n        }\n      }\n    } else {\n      newKeyRange = IDBKeyRange.lowerBound(lastKey, true);\n    }\n    keyRange = newKeyRange;\n    keysBatch = null;\n    valuesBatch = null;\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  }\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (!cursor) { // done\n      return onBatch();\n    }\n    // regular IDBCursor acts like a batch where batch size is always 1\n    onBatch([cursor.key], [cursor.value], cursor);\n  }\n\n  if (useGetAll) {\n    pseudoCursor = {\"continue\": continuePseudoCursor};\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  } else if (descending) {\n    objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;\n  } else {\n    objectStore.openCursor(keyRange).onsuccess = onCursor;\n  }\n}\n\n// simple shim for objectStore.getAll(), falling back to IDBCursor\nfunction getAll(objectStore, keyRange, onSuccess) {\n  if (typeof objectStore.getAll === 'function') {\n    // use native getAll\n    objectStore.getAll(keyRange).onsuccess = onSuccess;\n    return;\n  }\n  // fall back to cursors\n  var values = [];\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (cursor) {\n      values.push(cursor.value);\n      cursor.continue();\n    } else {\n      onSuccess({\n        target: {\n          result: values\n        }\n      });\n    }\n  }\n\n  objectStore.openCursor(keyRange).onsuccess = onCursor;\n}\n\nfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n  try {\n    if (start && end) {\n      if (descending) {\n        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n      } else {\n        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n      }\n    } else if (start) {\n      if (descending) {\n        return IDBKeyRange.upperBound(start);\n      } else {\n        return IDBKeyRange.lowerBound(start);\n      }\n    } else if (end) {\n      if (descending) {\n        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n      } else {\n        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n      }\n    } else if (key) {\n      return IDBKeyRange.only(key);\n    }\n  } catch (e) {\n    return {error: e};\n  }\n  return null;\n}\n\nfunction idbAllDocs(opts, idb, callback) {\n  var start = 'startkey' in opts ? opts.startkey : false;\n  var end = 'endkey' in opts ? opts.endkey : false;\n  var key = 'key' in opts ? opts.key : false;\n  var skip = opts.skip || 0;\n  var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n  var inclusiveEnd = opts.inclusive_end !== false;\n\n  var keyRange = createKeyRange(start, end, inclusiveEnd, key, opts.descending);\n  var keyRangeError = keyRange && keyRange.error;\n  if (keyRangeError && !(keyRangeError.name === \"DataError\" &&\n      keyRangeError.code === 0)) {\n    // DataError with error code 0 indicates start is less than end, so\n    // can just do an empty query. Else need to throw\n    return callback(createError(IDB_ERROR,\n      keyRangeError.name, keyRangeError.message));\n  }\n\n  var stores = [DOC_STORE, BY_SEQ_STORE, META_STORE];\n\n  if (opts.attachments) {\n    stores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, stores, 'readonly');\n  if (txnResult.error) {\n    return callback(txnResult.error);\n  }\n  var txn = txnResult.txn;\n  txn.oncomplete = onTxnComplete;\n  txn.onabort = idbError(callback);\n  var docStore = txn.objectStore(DOC_STORE);\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var metaStore = txn.objectStore(META_STORE);\n  var docIdRevIndex = seqStore.index('_doc_id_rev');\n  var results = [];\n  var docCount;\n\n  metaStore.get(META_STORE).onsuccess = function (e) {\n    docCount = e.target.result.docCount;\n  };\n\n  // if the user specifies include_docs=true, then we don't\n  // want to block the main cursor while we're fetching the doc\n  function fetchDocAsynchronously(metadata, row, winningRev$$1) {\n    var key = metadata.id + \"::\" + winningRev$$1;\n    docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {\n      row.doc = decodeDoc(e.target.result);\n      if (opts.conflicts) {\n        var conflicts = collectConflicts(metadata);\n        if (conflicts.length) {\n          row.doc._conflicts = conflicts;\n        }\n      }\n      fetchAttachmentsIfNecessary(row.doc, opts, txn);\n    };\n  }\n\n  function allDocsInner(winningRev$$1, metadata) {\n    var row = {\n      id: metadata.id,\n      key: metadata.id,\n      value: {\n        rev: winningRev$$1\n      }\n    };\n    var deleted = metadata.deleted;\n    if (opts.deleted === 'ok') {\n      results.push(row);\n      // deleted docs are okay with \"keys\" requests\n      if (deleted) {\n        row.value.deleted = true;\n        row.doc = null;\n      } else if (opts.include_docs) {\n        fetchDocAsynchronously(metadata, row, winningRev$$1);\n      }\n    } else if (!deleted && skip-- <= 0) {\n      results.push(row);\n      if (opts.include_docs) {\n        fetchDocAsynchronously(metadata, row, winningRev$$1);\n      }\n    }\n  }\n\n  function processBatch(batchValues) {\n    for (var i = 0, len = batchValues.length; i < len; i++) {\n      if (results.length === limit) {\n        break;\n      }\n      var batchValue = batchValues[i];\n      var metadata = decodeMetadata(batchValue);\n      var winningRev$$1 = metadata.winningRev;\n      allDocsInner(winningRev$$1, metadata);\n    }\n  }\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor) {\n      return;\n    }\n    processBatch(batchValues);\n    if (results.length < limit) {\n      cursor.continue();\n    }\n  }\n\n  function onGetAll(e) {\n    var values = e.target.result;\n    if (opts.descending) {\n      values = values.reverse();\n    }\n    processBatch(values);\n  }\n\n  function onResultsReady() {\n    callback(null, {\n      total_rows: docCount,\n      offset: opts.skip,\n      rows: results\n    });\n  }\n\n  function onTxnComplete() {\n    if (opts.attachments) {\n      postProcessAttachments(results, opts.binary).then(onResultsReady);\n    } else {\n      onResultsReady();\n    }\n  }\n\n  // don't bother doing any requests if start > end or limit === 0\n  if (keyRangeError || limit === 0) {\n    return;\n  }\n  if (limit === -1) { // just fetch everything\n    return getAll(docStore, keyRange, onGetAll);\n  }\n  // else do a cursor\n  // choose a batch size based on the skip, since we'll need to skip that many\n  runBatchedCursor(docStore, keyRange, opts.descending, limit + skip, onBatch);\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\nfunction checkBlobSupport(txn) {\n  return new PouchPromise$1(function (resolve) {\n    var blob = createBlob(['']);\n    var req = txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\n    req.onsuccess = function () {\n      var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n      var matchedEdge = navigator.userAgent.match(/Edge\\//);\n      // MS Edge pretends to be Chrome 42:\n      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n      resolve(matchedEdge || !matchedChrome ||\n        parseInt(matchedChrome[1], 10) >= 43);\n    };\n\n    txn.onabort = function (e) {\n      // If the transaction aborts now its due to not being able to\n      // write to the database, likely due to the disk being full\n      e.preventDefault();\n      e.stopPropagation();\n      resolve(false);\n    };\n  }).catch(function () {\n    return false; // error, so assume unsupported\n  });\n}\n\nfunction countDocs(txn, cb) {\n  var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');\n  index.count(IDBKeyRange.only('0')).onsuccess = function (e) {\n    cb(e.target.result);\n  };\n}\n\n// This task queue ensures that IDB open calls are done in their own tick\n// and sequentially - i.e. we wait for the async IDB open to *fully* complete\n// before calling the next one. This works around IE/Edge race conditions in IDB.\n\nvar running = false;\nvar queue = [];\n\nfunction tryCode(fun, err, res, PouchDB) {\n  try {\n    fun(err, res);\n  } catch (err) {\n    // Shouldn't happen, but in some odd cases\n    // IndexedDB implementations might throw a sync\n    // error, in which case this will at least log it.\n    PouchDB.emit('error', err);\n  }\n}\n\nfunction applyNext() {\n  if (running || !queue.length) {\n    return;\n  }\n  running = true;\n  queue.shift()();\n}\n\nfunction enqueueTask(action, callback, PouchDB) {\n  queue.push(function runAction() {\n    action(function runCallback(err, res) {\n      tryCode(callback, err, res, PouchDB);\n      running = false;\n      nextTick(function runNext() {\n        applyNext(PouchDB);\n      });\n    });\n  });\n  applyNext();\n}\n\nfunction changes(opts, api, dbName, idb) {\n  opts = clone(opts);\n\n  if (opts.continuous) {\n    var id = dbName + ':' + uuid();\n    changesHandler.addListener(dbName, id, api, opts);\n    changesHandler.notify(dbName);\n    return {\n      cancel: function () {\n        changesHandler.removeListener(dbName, id);\n      }\n    };\n  }\n\n  var docIds = opts.doc_ids && new ExportedSet(opts.doc_ids);\n\n  opts.since = opts.since || 0;\n  var lastSeq = opts.since;\n\n  var limit = 'limit' in opts ? opts.limit : -1;\n  if (limit === 0) {\n    limit = 1; // per CouchDB _changes spec\n  }\n  var returnDocs;\n  if ('return_docs' in opts) {\n    returnDocs = opts.return_docs;\n  } else if ('returnDocs' in opts) {\n    // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n    returnDocs = opts.returnDocs;\n  } else {\n    returnDocs = true;\n  }\n\n  var results = [];\n  var numResults = 0;\n  var filter = filterChange(opts);\n  var docIdsToMetadata = new ExportedMap();\n\n  var txn;\n  var bySeqStore;\n  var docStore;\n  var docIdRevIndex;\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor || !batchKeys.length) { // done\n      return;\n    }\n\n    var winningDocs = new Array(batchKeys.length);\n    var metadatas = new Array(batchKeys.length);\n\n    function processMetadataAndWinningDoc(metadata, winningDoc) {\n      var change = opts.processChange(winningDoc, metadata, opts);\n      lastSeq = change.seq = metadata.seq;\n\n      var filtered = filter(change);\n      if (typeof filtered === 'object') { // anything but true/false indicates error\n        return opts.complete(filtered);\n      }\n\n      if (filtered) {\n        numResults++;\n        if (returnDocs) {\n          results.push(change);\n        }\n        // process the attachment immediately\n        // for the benefit of live listeners\n        if (opts.attachments && opts.include_docs) {\n          fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {\n            postProcessAttachments([change], opts.binary).then(function () {\n              opts.onChange(change);\n            });\n          });\n        } else {\n          opts.onChange(change);\n        }\n      }\n    }\n\n    function onBatchDone() {\n      for (var i = 0, len = winningDocs.length; i < len; i++) {\n        if (numResults === limit) {\n          break;\n        }\n        var winningDoc = winningDocs[i];\n        if (!winningDoc) {\n          continue;\n        }\n        var metadata = metadatas[i];\n        processMetadataAndWinningDoc(metadata, winningDoc);\n      }\n\n      if (numResults !== limit) {\n        cursor.continue();\n      }\n    }\n\n    // Fetch all metadatas/winningdocs from this batch in parallel, then process\n    // them all only once all data has been collected. This is done in parallel\n    // because it's faster than doing it one-at-a-time.\n    var numDone = 0;\n    batchValues.forEach(function (value, i) {\n      var doc = decodeDoc(value);\n      var seq = batchKeys[i];\n      fetchWinningDocAndMetadata(doc, seq, function (metadata, winningDoc) {\n        metadatas[i] = metadata;\n        winningDocs[i] = winningDoc;\n        if (++numDone === batchKeys.length) {\n          onBatchDone();\n        }\n      });\n    });\n  }\n\n  function onGetMetadata(doc, seq, metadata, cb) {\n    if (metadata.seq !== seq) {\n      // some other seq is later\n      return cb();\n    }\n\n    if (metadata.winningRev === doc._rev) {\n      // this is the winning doc\n      return cb(metadata, doc);\n    }\n\n    // fetch winning doc in separate request\n    var docIdRev = doc._id + '::' + metadata.winningRev;\n    var req = docIdRevIndex.get(docIdRev);\n    req.onsuccess = function (e) {\n      cb(metadata, decodeDoc(e.target.result));\n    };\n  }\n\n  function fetchWinningDocAndMetadata(doc, seq, cb) {\n    if (docIds && !docIds.has(doc._id)) {\n      return cb();\n    }\n\n    var metadata = docIdsToMetadata.get(doc._id);\n    if (metadata) { // cached\n      return onGetMetadata(doc, seq, metadata, cb);\n    }\n    // metadata not cached, have to go fetch it\n    docStore.get(doc._id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      docIdsToMetadata.set(doc._id, metadata);\n      onGetMetadata(doc, seq, metadata, cb);\n    };\n  }\n\n  function finish() {\n    opts.complete(null, {\n      results: results,\n      last_seq: lastSeq\n    });\n  }\n\n  function onTxnComplete() {\n    if (!opts.continuous && opts.attachments) {\n      // cannot guarantee that postProcessing was already done,\n      // so do it again\n      postProcessAttachments(results).then(finish);\n    } else {\n      finish();\n    }\n  }\n\n  var objectStores = [DOC_STORE, BY_SEQ_STORE];\n  if (opts.attachments) {\n    objectStores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, objectStores, 'readonly');\n  if (txnResult.error) {\n    return opts.complete(txnResult.error);\n  }\n  txn = txnResult.txn;\n  txn.onabort = idbError(opts.complete);\n  txn.oncomplete = onTxnComplete;\n\n  bySeqStore = txn.objectStore(BY_SEQ_STORE);\n  docStore = txn.objectStore(DOC_STORE);\n  docIdRevIndex = bySeqStore.index('_doc_id_rev');\n\n  var keyRange = (opts.since && !opts.descending) ?\n    IDBKeyRange.lowerBound(opts.since, true) : null;\n\n  runBatchedCursor(bySeqStore, keyRange, opts.descending, limit, onBatch);\n}\n\nvar cachedDBs = new ExportedMap();\nvar blobSupportPromise;\nvar openReqList = new ExportedMap();\n\nfunction IdbPouch(opts, callback) {\n  var api = this;\n\n  enqueueTask(function (thisCallback) {\n    init(api, opts, thisCallback);\n  }, callback, api.constructor);\n}\n\nfunction init(api, opts, callback) {\n\n  var dbName = opts.name;\n\n  var idb = null;\n  api._meta = null;\n\n  // called when creating a fresh new database\n  function createSchema(db) {\n    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});\n    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\n    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\n    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n\n    // added in v2\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    // added in v3\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'});\n\n    // added in v4\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 2\n  // unfortunately \"deletedOrLocal\" is a misnomer now that we no longer\n  // store local docs in the main doc-store, but whaddyagonnado\n  function addDeletedOrLocalIndex(txn, callback) {\n    var docStore = txn.objectStore(DOC_STORE);\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    docStore.openCursor().onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var deleted = isDeleted(metadata);\n        metadata.deletedOrLocal = deleted ? \"1\" : \"0\";\n        docStore.put(metadata);\n        cursor.continue();\n      } else {\n        callback();\n      }\n    };\n  }\n\n  // migration to version 3 (part 1)\n  function createLocalStoreSchema(db) {\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n  }\n\n  // migration to version 3 (part 2)\n  function migrateLocalStore(txn, cb) {\n    var localStore = txn.objectStore(LOCAL_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var docId = metadata.id;\n        var local = isLocalId(docId);\n        var rev$$1 = winningRev(metadata);\n        if (local) {\n          var docIdRev = docId + \"::\" + rev$$1;\n          // remove all seq entries\n          // associated with this docId\n          var start = docId + \"::\";\n          var end = docId + \"::~\";\n          var index = seqStore.index('_doc_id_rev');\n          var range = IDBKeyRange.bound(start, end, false, false);\n          var seqCursor = index.openCursor(range);\n          seqCursor.onsuccess = function (e) {\n            seqCursor = e.target.result;\n            if (!seqCursor) {\n              // done\n              docStore.delete(cursor.primaryKey);\n              cursor.continue();\n            } else {\n              var data = seqCursor.value;\n              if (data._doc_id_rev === docIdRev) {\n                localStore.put(data);\n              }\n              seqStore.delete(seqCursor.primaryKey);\n              seqCursor.continue();\n            }\n          };\n        } else {\n          cursor.continue();\n        }\n      } else if (cb) {\n        cb();\n      }\n    };\n  }\n\n  // migration to version 4 (part 1)\n  function addAttachAndSeqStore(db) {\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 4 (part 2)\n  function migrateAttsAndSeqs(txn, callback) {\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n    var attStore = txn.objectStore(ATTACH_STORE);\n    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\n    // need to actually populate the table. this is the expensive part,\n    // so as an optimization, check first that this database even\n    // contains attachments\n    var req = attStore.count();\n    req.onsuccess = function (e) {\n      var count = e.target.result;\n      if (!count) {\n        return callback(); // done\n      }\n\n      seqStore.openCursor().onsuccess = function (e) {\n        var cursor = e.target.result;\n        if (!cursor) {\n          return callback(); // done\n        }\n        var doc = cursor.value;\n        var seq = cursor.primaryKey;\n        var atts = Object.keys(doc._attachments || {});\n        var digestMap = {};\n        for (var j = 0; j < atts.length; j++) {\n          var att = doc._attachments[atts[j]];\n          digestMap[att.digest] = true; // uniq digests, just in case\n        }\n        var digests = Object.keys(digestMap);\n        for (j = 0; j < digests.length; j++) {\n          var digest = digests[j];\n          attAndSeqStore.put({\n            seq: seq,\n            digestSeq: digest + '::' + seq\n          });\n        }\n        cursor.continue();\n      };\n    };\n  }\n\n  // migration to version 5\n  // Instead of relying on on-the-fly migration of metadata,\n  // this brings the doc-store to its modern form:\n  // - metadata.winningrev\n  // - metadata.seq\n  // - stringify the metadata when storing it\n  function migrateMetadata(txn) {\n\n    function decodeMetadataCompat(storedObject) {\n      if (!storedObject.data) {\n        // old format, when we didn't store it stringified\n        storedObject.deleted = storedObject.deletedOrLocal === '1';\n        return storedObject;\n      }\n      return decodeMetadata(storedObject);\n    }\n\n    // ensure that every metadata has a winningRev and seq,\n    // which was previously created on-the-fly but better to migrate\n    var bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (e) {\n      var cursor = e.target.result;\n      if (!cursor) {\n        return; // done\n      }\n      var metadata = decodeMetadataCompat(cursor.value);\n\n      metadata.winningRev = metadata.winningRev ||\n        winningRev(metadata);\n\n      function fetchMetadataSeq() {\n        // metadata.seq was added post-3.2.0, so if it's missing,\n        // we need to fetch it manually\n        var start = metadata.id + '::';\n        var end = metadata.id + '::\\uffff';\n        var req = bySeqStore.index('_doc_id_rev').openCursor(\n          IDBKeyRange.bound(start, end));\n\n        var metadataSeq = 0;\n        req.onsuccess = function (e) {\n          var cursor = e.target.result;\n          if (!cursor) {\n            metadata.seq = metadataSeq;\n            return onGetMetadataSeq();\n          }\n          var seq = cursor.primaryKey;\n          if (seq > metadataSeq) {\n            metadataSeq = seq;\n          }\n          cursor.continue();\n        };\n      }\n\n      function onGetMetadataSeq() {\n        var metadataToStore = encodeMetadata(metadata,\n          metadata.winningRev, metadata.deleted);\n\n        var req = docStore.put(metadataToStore);\n        req.onsuccess = function () {\n          cursor.continue();\n        };\n      }\n\n      if (metadata.seq) {\n        return onGetMetadataSeq();\n      }\n\n      fetchMetadataSeq();\n    };\n\n  }\n\n  api._remote = false;\n  api.type = function () {\n    return 'idb';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, api._meta.instanceId);\n  });\n\n  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {\n    idbBulkDocs(opts, req, reqOpts, api, idb, callback);\n  };\n\n  // First we look up the metadata in the ids database, then we fetch the\n  // current revision(s) from the by sequence store\n  api._get = function idb_get(id, opts, callback) {\n    var doc;\n    var metadata;\n    var err;\n    var txn = opts.ctx;\n    if (!txn) {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n\n    function finish() {\n      callback(err, {doc: doc, metadata: metadata, ctx: txn});\n    }\n\n    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      // we can determine the result here if:\n      // 1. there is no such document\n      // 2. the document is deleted and we don't ask about specific rev\n      // When we ask with opts.rev we expect the answer to be either\n      // doc (possibly with _deleted=true) or missing error\n      if (!metadata) {\n        err = createError(MISSING_DOC, 'missing');\n        return finish();\n      }\n\n      var rev$$1;\n      if (!opts.rev) {\n        rev$$1 = metadata.winningRev;\n        var deleted = isDeleted(metadata);\n        if (deleted) {\n          err = createError(MISSING_DOC, \"deleted\");\n          return finish();\n        }\n      } else {\n        rev$$1 = opts.latest ? latest(opts.rev, metadata) : opts.rev;\n      }\n\n      var objectStore = txn.objectStore(BY_SEQ_STORE);\n      var key = metadata.id + '::' + rev$$1;\n\n      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {\n        doc = e.target.result;\n        if (doc) {\n          doc = decodeDoc(doc);\n        }\n        if (!doc) {\n          err = createError(MISSING_DOC, 'missing');\n          return finish();\n        }\n        finish();\n      };\n    };\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var txn;\n    if (opts.ctx) {\n      txn = opts.ctx;\n    } else {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n\n    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {\n      var body = e.target.result.body;\n      readBlobData(body, type, opts.binary, function (blobData) {\n        callback(null, blobData);\n      });\n    };\n  };\n\n  api._info = function idb_info(callback) {\n    var updateSeq;\n    var docCount;\n\n    var txnResult = openTransactionSafely(idb, [META_STORE, BY_SEQ_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      docCount = e.target.result.docCount;\n    };\n    txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev').onsuccess = function (e) {\n      var cursor = e.target.result;\n      updateSeq = cursor ? cursor.key : 0;\n    };\n\n    txn.oncomplete = function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: updateSeq,\n        // for debugging\n        idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')\n      });\n    };\n  };\n\n  api._allDocs = function idb_allDocs(opts, callback) {\n    idbAllDocs(opts, idb, callback);\n  };\n\n  api._changes = function idbChanges(opts) {\n    return changes(opts, api, dbName, idb);\n  };\n\n  api._close = function (callback) {\n    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n    // \"Returns immediately and closes the connection in a separate thread...\"\n    idb.close();\n    cachedDBs.delete(dbName);\n    callback();\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    var req = txn.objectStore(DOC_STORE).get(docId);\n    req.onsuccess = function (event) {\n      var doc = decodeMetadata(event.target.result);\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        callback(null, doc.rev_tree);\n      }\n    };\n  };\n\n  // This function removes revisions of document docId\n  // which are listed in revs and sets this document\n  // revision to to rev_tree\n  api._doCompaction = function (docId, revs, callback) {\n    var stores = [\n      DOC_STORE,\n      BY_SEQ_STORE,\n      ATTACH_STORE,\n      ATTACH_AND_SEQ_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n\n    var docStore = txn.objectStore(DOC_STORE);\n\n    docStore.get(docId).onsuccess = function (event) {\n      var metadata = decodeMetadata(event.target.result);\n      traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                                         revHash, ctx, opts) {\n        var rev$$1 = pos + '-' + revHash;\n        if (revs.indexOf(rev$$1) !== -1) {\n          opts.status = 'missing';\n        }\n      });\n      compactRevs(revs, docId, txn);\n      var winningRev$$1 = metadata.winningRev;\n      var deleted = metadata.deleted;\n      txn.objectStore(DOC_STORE).put(\n        encodeMetadata(metadata, winningRev$$1, deleted));\n    };\n    txn.onabort = idbError(callback);\n    txn.oncomplete = function () {\n      callback();\n    };\n  };\n\n\n  api._getLocal = function (id, callback) {\n    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var tx = txnResult.txn;\n    var req = tx.objectStore(LOCAL_STORE).get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var doc = e.target.result;\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        delete doc['_doc_id_rev']; // for backwards compat\n        callback(null, doc);\n      }\n    };\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    if (!oldRev) {\n      doc._rev = '0-1';\n    } else {\n      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n\n    var tx = opts.ctx;\n    var ret;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.onerror = idbError(callback);\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req;\n    if (oldRev) {\n      req = oStore.get(id);\n      req.onsuccess = function (e) {\n        var oldDoc = e.target.result;\n        if (!oldDoc || oldDoc._rev !== oldRev) {\n          callback(createError(REV_CONFLICT));\n        } else { // update\n          var req = oStore.put(doc);\n          req.onsuccess = function () {\n            ret = {ok: true, id: doc._id, rev: doc._rev};\n            if (opts.ctx) { // return immediately\n              callback(null, ret);\n            }\n          };\n        }\n      };\n    } else { // new doc\n      req = oStore.add(doc);\n      req.onerror = function (e) {\n        // constraint error, already exists\n        callback(createError(REV_CONFLICT));\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n      };\n      req.onsuccess = function () {\n        ret = {ok: true, id: doc._id, rev: doc._rev};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      };\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var tx = opts.ctx;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n    var ret;\n    var id = doc._id;\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req = oStore.get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var oldDoc = e.target.result;\n      if (!oldDoc || oldDoc._rev !== doc._rev) {\n        callback(createError(MISSING_DOC));\n      } else {\n        oStore.delete(id);\n        ret = {ok: true, id: id, rev: '0-0'};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      }\n    };\n  };\n\n  api._destroy = function (opts, callback) {\n    changesHandler.removeAllListeners(dbName);\n\n    //Close open request for \"dbName\" database to fix ie delay.\n    var openReq = openReqList.get(dbName);\n    if (openReq && openReq.result) {\n      openReq.result.close();\n      cachedDBs.delete(dbName);\n    }\n    var req = indexedDB.deleteDatabase(dbName);\n\n    req.onsuccess = function () {\n      //Remove open request from the list.\n      openReqList.delete(dbName);\n      if (hasLocalStorage() && (dbName in localStorage)) {\n        delete localStorage[dbName];\n      }\n      callback(null, { 'ok': true });\n    };\n\n    req.onerror = idbError(callback);\n  };\n\n  var cached = cachedDBs.get(dbName);\n\n  if (cached) {\n    idb = cached.idb;\n    api._meta = cached.global;\n    return nextTick(function () {\n      callback(null, api);\n    });\n  }\n\n  var req;\n  if (opts.storage) {\n    req = tryStorageOption(dbName, opts.storage);\n  } else {\n    req = indexedDB.open(dbName, ADAPTER_VERSION);\n  }\n\n  openReqList.set(dbName, req);\n\n  req.onupgradeneeded = function (e) {\n    var db = e.target.result;\n    if (e.oldVersion < 1) {\n      return createSchema(db); // new db, initial schema\n    }\n    // do migrations\n\n    var txn = e.currentTarget.transaction;\n    // these migrations have to be done in this function, before\n    // control is returned to the event loop, because IndexedDB\n\n    if (e.oldVersion < 3) {\n      createLocalStoreSchema(db); // v2 -> v3\n    }\n    if (e.oldVersion < 4) {\n      addAttachAndSeqStore(db); // v3 -> v4\n    }\n\n    var migrations = [\n      addDeletedOrLocalIndex, // v1 -> v2\n      migrateLocalStore,      // v2 -> v3\n      migrateAttsAndSeqs,     // v3 -> v4\n      migrateMetadata         // v4 -> v5\n    ];\n\n    var i = e.oldVersion;\n\n    function next() {\n      var migration = migrations[i - 1];\n      i++;\n      if (migration) {\n        migration(txn, next);\n      }\n    }\n\n    next();\n  };\n\n  req.onsuccess = function (e) {\n\n    idb = e.target.result;\n\n    idb.onversionchange = function () {\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    idb.onabort = function (e) {\n      guardedConsole('error', 'Database has a global failure', e.target.error);\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    // Do a few setup operations (in parallel as much as possible):\n    // 1. Fetch meta doc\n    // 2. Check blob support\n    // 3. Calculate docCount\n    // 4. Generate an instanceId if necessary\n    // 5. Store docCount and instanceId on meta doc\n\n    var txn = idb.transaction([\n      META_STORE,\n      DETECT_BLOB_SUPPORT_STORE,\n      DOC_STORE\n    ], 'readwrite');\n\n    var storedMetaDoc = false;\n    var metaDoc;\n    var docCount;\n    var blobSupport;\n    var instanceId;\n\n    function completeSetup() {\n      if (typeof blobSupport === 'undefined' || !storedMetaDoc) {\n        return;\n      }\n      api._meta = {\n        name: dbName,\n        instanceId: instanceId,\n        blobSupport: blobSupport\n      };\n\n      cachedDBs.set(dbName, {\n        idb: idb,\n        global: api._meta\n      });\n      callback(null, api);\n    }\n\n    function storeMetaDocIfReady() {\n      if (typeof docCount === 'undefined' || typeof metaDoc === 'undefined') {\n        return;\n      }\n      var instanceKey = dbName + '_id';\n      if (instanceKey in metaDoc) {\n        instanceId = metaDoc[instanceKey];\n      } else {\n        metaDoc[instanceKey] = instanceId = uuid();\n      }\n      metaDoc.docCount = docCount;\n      txn.objectStore(META_STORE).put(metaDoc);\n    }\n\n    //\n    // fetch or generate the instanceId\n    //\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result || { id: META_STORE };\n      storeMetaDocIfReady();\n    };\n\n    //\n    // countDocs\n    //\n    countDocs(txn, function (count) {\n      docCount = count;\n      storeMetaDocIfReady();\n    });\n\n    //\n    // check blob support\n    //\n    if (!blobSupportPromise) {\n      // make sure blob support is only checked once\n      blobSupportPromise = checkBlobSupport(txn);\n    }\n\n    blobSupportPromise.then(function (val) {\n      blobSupport = val;\n      completeSetup();\n    });\n\n    // only when the metadata put transaction has completed,\n    // consider the setup done\n    txn.oncomplete = function () {\n      storedMetaDoc = true;\n      completeSetup();\n    };\n  };\n\n  req.onerror = function () {\n    var msg = 'Failed to open indexedDB, are you in private browsing mode?';\n    guardedConsole('error', msg);\n    callback(createError(IDB_ERROR, msg));\n  };\n}\n\nIdbPouch.valid = function () {\n  // Issue #2533, we finally gave up on doing bug\n  // detection instead of browser sniffing. Safari brought us\n  // to our knees.\n  var isSafari = typeof openDatabase !== 'undefined' &&\n    /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) &&\n    !/Chrome/.test(navigator.userAgent) &&\n    !/BlackBerry/.test(navigator.platform);\n\n  // some outdated implementations of IDB that appear on Samsung\n  // and HTC Android devices <4.4 are missing IDBKeyRange\n  return !isSafari && typeof indexedDB !== 'undefined' &&\n    typeof IDBKeyRange !== 'undefined';\n};\n\nfunction tryStorageOption(dbName, storage) {\n  try { // option only available in Firefox 26+\n    return indexedDB.open(dbName, {\n      version: ADAPTER_VERSION,\n      storage: storage\n    });\n  } catch (err) {\n      return indexedDB.open(dbName, ADAPTER_VERSION);\n  }\n}\n\nvar IDBPouch = function (PouchDB) {\n  PouchDB.adapter('idb', IdbPouch, true);\n};\n\n//\n// Parsing hex strings. Yeah.\n//\n// So basically we need this because of a bug in WebSQL:\n// https://code.google.com/p/chromium/issues/detail?id=422690\n// https://bugs.webkit.org/show_bug.cgi?id=137637\n//\n// UTF-8 and UTF-16 are provided as separate functions\n// for meager performance improvements\n//\n\nfunction decodeUtf8(str) {\n  return decodeURIComponent(escape(str));\n}\n\nfunction hexToInt(charCode) {\n  // '0'-'9' is 48-57\n  // 'A'-'F' is 65-70\n  // SQLite will only give us uppercase hex\n  return charCode < 65 ? (charCode - 48) : (charCode - 55);\n}\n\n\n// Example:\n// pragma encoding=utf8;\n// select hex('A');\n// returns '41'\nfunction parseHexUtf8(str, start, end) {\n  var result = '';\n  while (start < end) {\n    result += String.fromCharCode(\n      (hexToInt(str.charCodeAt(start++)) << 4) |\n        hexToInt(str.charCodeAt(start++)));\n  }\n  return result;\n}\n\n// Example:\n// pragma encoding=utf16;\n// select hex('A');\n// returns '4100'\n// notice that the 00 comes after the 41 (i.e. it's swizzled)\nfunction parseHexUtf16(str, start, end) {\n  var result = '';\n  while (start < end) {\n    // UTF-16, so swizzle the bytes\n    result += String.fromCharCode(\n      (hexToInt(str.charCodeAt(start + 2)) << 12) |\n        (hexToInt(str.charCodeAt(start + 3)) << 8) |\n        (hexToInt(str.charCodeAt(start)) << 4) |\n        hexToInt(str.charCodeAt(start + 1)));\n    start += 4;\n  }\n  return result;\n}\n\nfunction parseHexString(str, encoding) {\n  if (encoding === 'UTF-8') {\n    return decodeUtf8(parseHexUtf8(str, 0, str.length));\n  } else {\n    return parseHexUtf16(str, 0, str.length);\n  }\n}\n\nfunction quote(str) {\n  return \"'\" + str + \"'\";\n}\n\nvar ADAPTER_VERSION$1 = 7; // used to manage migrations\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\nvar DOC_STORE$1 = quote('document-store');\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE$1 = quote('by-sequence');\n// Where we store attachments\nvar ATTACH_STORE$1 = quote('attach-store');\nvar LOCAL_STORE$1 = quote('local-store');\nvar META_STORE$1 = quote('metadata-store');\n// where we store many-to-many relations between attachment\n// digests and seqs\nvar ATTACH_AND_SEQ_STORE$1 = quote('attach-seq-store');\n\n// escapeBlob and unescapeBlob are workarounds for a websql bug:\n// https://code.google.com/p/chromium/issues/detail?id=422690\n// https://bugs.webkit.org/show_bug.cgi?id=137637\n// The goal is to never actually insert the \\u0000 character\n// in the database.\nfunction escapeBlob(str) {\n  return str\n    .replace(/\\u0002/g, '\\u0002\\u0002')\n    .replace(/\\u0001/g, '\\u0001\\u0002')\n    .replace(/\\u0000/g, '\\u0001\\u0001');\n}\n\nfunction unescapeBlob(str) {\n  return str\n    .replace(/\\u0001\\u0001/g, '\\u0000')\n    .replace(/\\u0001\\u0002/g, '\\u0001')\n    .replace(/\\u0002\\u0002/g, '\\u0002');\n}\n\nfunction stringifyDoc(doc) {\n  // don't bother storing the id/rev. it uses lots of space,\n  // in persistent map/reduce especially\n  delete doc._id;\n  delete doc._rev;\n  return JSON.stringify(doc);\n}\n\nfunction unstringifyDoc(doc, id, rev$$1) {\n  doc = JSON.parse(doc);\n  doc._id = id;\n  doc._rev = rev$$1;\n  return doc;\n}\n\n// question mark groups IN queries, e.g. 3 -> '(?,?,?)'\nfunction qMarks(num) {\n  var s = '(';\n  while (num--) {\n    s += '?';\n    if (num) {\n      s += ',';\n    }\n  }\n  return s + ')';\n}\n\nfunction select(selector, table, joiner, where, orderBy) {\n  return 'SELECT ' + selector + ' FROM ' +\n    (typeof table === 'string' ? table : table.join(' JOIN ')) +\n    (joiner ? (' ON ' + joiner) : '') +\n    (where ? (' WHERE ' +\n    (typeof where === 'string' ? where : where.join(' AND '))) : '') +\n    (orderBy ? (' ORDER BY ' + orderBy) : '');\n}\n\nfunction compactRevs$1(revs, docId, tx) {\n\n  if (!revs.length) {\n    return;\n  }\n\n  var numDone = 0;\n  var seqs = [];\n\n  function checkDone() {\n    if (++numDone === revs.length) { // done\n      deleteOrphans();\n    }\n  }\n\n  function deleteOrphans() {\n    // find orphaned attachment digests\n\n    if (!seqs.length) {\n      return;\n    }\n\n    var sql = 'SELECT DISTINCT digest AS digest FROM ' +\n      ATTACH_AND_SEQ_STORE$1 + ' WHERE seq IN ' + qMarks(seqs.length);\n\n    tx.executeSql(sql, seqs, function (tx, res) {\n\n      var digestsToCheck = [];\n      for (var i = 0; i < res.rows.length; i++) {\n        digestsToCheck.push(res.rows.item(i).digest);\n      }\n      if (!digestsToCheck.length) {\n        return;\n      }\n\n      var sql = 'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 +\n        ' WHERE seq IN (' +\n        seqs.map(function () { return '?'; }).join(',') +\n        ')';\n      tx.executeSql(sql, seqs, function (tx) {\n\n        var sql = 'SELECT digest FROM ' + ATTACH_AND_SEQ_STORE$1 +\n          ' WHERE digest IN (' +\n          digestsToCheck.map(function () { return '?'; }).join(',') +\n          ')';\n        tx.executeSql(sql, digestsToCheck, function (tx, res) {\n          var nonOrphanedDigests = new ExportedSet();\n          for (var i = 0; i < res.rows.length; i++) {\n            nonOrphanedDigests.add(res.rows.item(i).digest);\n          }\n          digestsToCheck.forEach(function (digest) {\n            if (nonOrphanedDigests.has(digest)) {\n              return;\n            }\n            tx.executeSql(\n              'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE digest=?',\n              [digest]);\n            tx.executeSql(\n              'DELETE FROM ' + ATTACH_STORE$1 + ' WHERE digest=?', [digest]);\n          });\n        });\n      });\n    });\n  }\n\n  // update by-seq and attach stores in parallel\n  revs.forEach(function (rev$$1) {\n    var sql = 'SELECT seq FROM ' + BY_SEQ_STORE$1 +\n      ' WHERE doc_id=? AND rev=?';\n\n    tx.executeSql(sql, [docId, rev$$1], function (tx, res) {\n      if (!res.rows.length) { // already deleted\n        return checkDone();\n      }\n      var seq = res.rows.item(0).seq;\n      seqs.push(seq);\n\n      tx.executeSql(\n        'DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?', [seq], checkDone);\n    });\n  });\n}\n\nfunction websqlError(callback) {\n  return function (event) {\n    guardedConsole('error', 'WebSQL threw an error', event);\n    // event may actually be a SQLError object, so report is as such\n    var errorNameMatch = event && event.constructor.toString()\n        .match(/function ([^(]+)/);\n    var errorName = (errorNameMatch && errorNameMatch[1]) || event.type;\n    var errorReason = event.target || event.message;\n    callback(createError(WSQ_ERROR, errorReason, errorName));\n  };\n}\n\nfunction getSize(opts) {\n  if ('size' in opts) {\n    // triggers immediate popup in iOS, fixes #2347\n    // e.g. 5000001 asks for 5 MB, 10000001 asks for 10 MB,\n    return opts.size * 1000000;\n  }\n  // In iOS, doesn't matter as long as it's <= 5000000.\n  // Except that if you request too much, our tests fail\n  // because of the native \"do you accept?\" popup.\n  // In Android <=4.3, this value is actually used as an\n  // honest-to-god ceiling for data, so we need to\n  // set it to a decently high number.\n  var isAndroid = typeof navigator !== 'undefined' &&\n    /Android/.test(navigator.userAgent);\n  return isAndroid ? 5000000 : 1; // in PhantomJS, if you use 0 it will crash\n}\n\nfunction websqlBulkDocs(dbOpts, req, opts, api, db, websqlChanges, callback) {\n  var newEdits = opts.new_edits;\n  var userDocs = req.docs;\n\n  // Parse the docs, give them a sequence number for the result\n  var docInfos = userDocs.map(function (doc) {\n    if (doc._id && isLocalId(doc._id)) {\n      return doc;\n    }\n    var newDoc = parseDoc(doc, newEdits);\n    return newDoc;\n  });\n\n  var docInfoErrors = docInfos.filter(function (docInfo) {\n    return docInfo.error;\n  });\n  if (docInfoErrors.length) {\n    return callback(docInfoErrors[0]);\n  }\n\n  var tx;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new ExportedMap();\n\n  var preconditionErrored;\n  function complete() {\n    if (preconditionErrored) {\n      return callback(preconditionErrored);\n    }\n    websqlChanges.notify(api._name);\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n    var sql = 'SELECT count(*) as cnt FROM ' + ATTACH_STORE$1 +\n      ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      if (result.rows.item(0).cnt === 0) {\n        var err = createError(MISSING_STUB,\n          'unknown stub attachment with digest ' +\n          digest);\n        callback(err);\n      } else {\n        callback();\n      }\n    });\n  }\n\n  function verifyAttachments(finish) {\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n                    isUpdate, delta, resultsIdx, callback) {\n\n    function finish() {\n      var data = docInfo.data;\n      var deletedInt = newRevIsDeleted ? 1 : 0;\n\n      var id = data._id;\n      var rev = data._rev;\n      var json = stringifyDoc(data);\n      var sql = 'INSERT INTO ' + BY_SEQ_STORE$1 +\n        ' (doc_id, rev, json, deleted) VALUES (?, ?, ?, ?);';\n      var sqlArgs = [id, rev, json, deletedInt];\n\n      // map seqs to attachment digests, which\n      // we will need later during compaction\n      function insertAttachmentMappings(seq, callback) {\n        var attsAdded = 0;\n        var attsToAdd = Object.keys(data._attachments || {});\n\n        if (!attsToAdd.length) {\n          return callback();\n        }\n        function checkDone() {\n          if (++attsAdded === attsToAdd.length) {\n            callback();\n          }\n          return false; // ack handling a constraint error\n        }\n        function add(att) {\n          var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n            ' (digest, seq) VALUES (?,?)';\n          var sqlArgs = [data._attachments[att].digest, seq];\n          tx.executeSql(sql, sqlArgs, checkDone, checkDone);\n          // second callback is for a constaint error, which we ignore\n          // because this docid/rev has already been associated with\n          // the digest (e.g. when new_edits == false)\n        }\n        for (var i = 0; i < attsToAdd.length; i++) {\n          add(attsToAdd[i]); // do in parallel\n        }\n      }\n\n      tx.executeSql(sql, sqlArgs, function (tx, result) {\n        var seq = result.insertId;\n        insertAttachmentMappings(seq, function () {\n          dataWritten(tx, seq);\n        });\n      }, function () {\n        // constraint error, recover by updating instead (see #1638)\n        var fetchSql = select('seq', BY_SEQ_STORE$1, null,\n          'doc_id=? AND rev=?');\n        tx.executeSql(fetchSql, [id, rev], function (tx, res) {\n          var seq = res.rows.item(0).seq;\n          var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n            ' SET json=?, deleted=? WHERE doc_id=? AND rev=?;';\n          var sqlArgs = [json, deletedInt, id, rev];\n          tx.executeSql(sql, sqlArgs, function (tx) {\n            insertAttachmentMappings(seq, function () {\n              dataWritten(tx, seq);\n            });\n          });\n        });\n        return false; // ack that we've handled the error\n      });\n    }\n\n    function collectResults(attachmentErr) {\n      if (!err) {\n        if (attachmentErr) {\n          err = attachmentErr;\n          callback(err);\n        } else if (recv === attachments.length) {\n          finish();\n        }\n      }\n    }\n\n    var err = null;\n    var recv = 0;\n\n    docInfo.data._id = docInfo.metadata.id;\n    docInfo.data._rev = docInfo.metadata.rev;\n    var attachments = Object.keys(docInfo.data._attachments || {});\n\n\n    if (newRevIsDeleted) {\n      docInfo.data._deleted = true;\n    }\n\n    function attachmentSaved(err) {\n      recv++;\n      collectResults(err);\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev$$1, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        recv++;\n        collectResults();\n      }\n    });\n\n    if (!attachments.length) {\n      finish();\n    }\n\n    function dataWritten(tx, seq) {\n      var id = docInfo.metadata.id;\n\n      var revsToCompact = docInfo.stemmedRevs || [];\n      if (isUpdate && api.auto_compaction) {\n        revsToCompact = compactTree(docInfo.metadata).concat(revsToCompact);\n      }\n      if (revsToCompact.length) {\n        compactRevs$1(revsToCompact, id, tx);\n      }\n\n      docInfo.metadata.seq = seq;\n      var rev = docInfo.metadata.rev;\n      delete docInfo.metadata.rev;\n\n      var sql = isUpdate ?\n      'UPDATE ' + DOC_STORE$1 +\n      ' SET json=?, max_seq=?, winningseq=' +\n      '(SELECT seq FROM ' + BY_SEQ_STORE$1 +\n      ' WHERE doc_id=' + DOC_STORE$1 + '.id AND rev=?) WHERE id=?'\n        : 'INSERT INTO ' + DOC_STORE$1 +\n      ' (id, winningseq, max_seq, json) VALUES (?,?,?,?);';\n      var metadataStr = safeJsonStringify(docInfo.metadata);\n      var params = isUpdate ?\n        [metadataStr, seq, winningRev$$1, id] :\n        [id, seq, seq, metadataStr];\n      tx.executeSql(sql, params, function () {\n        results[resultsIdx] = {\n          ok: true,\n          id: docInfo.metadata.id,\n          rev: rev\n        };\n        fetchedDocs.set(id, docInfo.metadata);\n        callback();\n      });\n    }\n  }\n\n  function websqlProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs, tx,\n                results, writeDoc, opts);\n  }\n\n  function fetchExistingDocs(callback) {\n    if (!docInfos.length) {\n      return callback();\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        callback();\n      }\n    }\n\n    docInfos.forEach(function (docInfo) {\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        return checkDone(); // skip local docs\n      }\n      var id = docInfo.metadata.id;\n      tx.executeSql('SELECT json FROM ' + DOC_STORE$1 +\n      ' WHERE id = ?', [id], function (tx, result) {\n        if (result.rows.length) {\n          var metadata = safeJsonParse(result.rows.item(0).json);\n          fetchedDocs.set(id, metadata);\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function saveAttachment(digest, data, callback) {\n    var sql = 'SELECT digest FROM ' + ATTACH_STORE$1 + ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      if (result.rows.length) { // attachment already exists\n        return callback();\n      }\n      // we could just insert before selecting and catch the error,\n      // but my hunch is that it's cheaper not to serialize the blob\n      // from JS to C if we don't have to (TODO: confirm this)\n      sql = 'INSERT INTO ' + ATTACH_STORE$1 +\n      ' (digest, body, escaped) VALUES (?,?,1)';\n      tx.executeSql(sql, [digest, escapeBlob(data)], function () {\n        callback();\n      }, function () {\n        // ignore constaint errors, means it already exists\n        callback();\n        return false; // ack we handled the error\n      });\n    });\n  }\n\n  preprocessAttachments(docInfos, 'binary', function (err) {\n    if (err) {\n      return callback(err);\n    }\n    db.transaction(function (txn) {\n      tx = txn;\n      verifyAttachments(function (err) {\n        if (err) {\n          preconditionErrored = err;\n        } else {\n          fetchExistingDocs(websqlProcessDocs);\n        }\n      });\n    }, websqlError(callback), complete);\n  });\n}\n\nvar cachedDatabases = new ExportedMap();\n\n// openDatabase passed in through opts (e.g. for node-websql)\nfunction openDatabaseWithOpts(opts) {\n  return opts.websql(opts.name, opts.version, opts.description, opts.size);\n}\n\nfunction openDBSafely(opts) {\n  try {\n    return {\n      db: openDatabaseWithOpts(opts)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nfunction openDB$1(opts) {\n  var cachedResult = cachedDatabases.get(opts.name);\n  if (!cachedResult) {\n    cachedResult = openDBSafely(opts);\n    cachedDatabases.set(opts.name, cachedResult);\n  }\n  return cachedResult;\n}\n\nvar websqlChanges = new Changes();\n\nfunction fetchAttachmentsIfNecessary$1(doc, opts, api, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var attOpts = {binary: opts.binary, ctx: txn};\n    api._getAttachment(doc._id, att, attObj, attOpts, function (_, data) {\n      doc._attachments[att] = $inject_Object_assign(\n        pick(attObj, ['digest', 'content_type']),\n        { data: data }\n      );\n      checkDone();\n    });\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\nvar POUCH_VERSION = 1;\n\n// these indexes cover the ground for most allDocs queries\nvar BY_SEQ_STORE_DELETED_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'by-seq-deleted-idx\\' ON ' +\n  BY_SEQ_STORE$1 + ' (seq, deleted)';\nvar BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL =\n  'CREATE UNIQUE INDEX IF NOT EXISTS \\'by-seq-doc-id-rev\\' ON ' +\n    BY_SEQ_STORE$1 + ' (doc_id, rev)';\nvar DOC_STORE_WINNINGSEQ_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'doc-winningseq-idx\\' ON ' +\n  DOC_STORE$1 + ' (winningseq)';\nvar ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'attach-seq-seq-idx\\' ON ' +\n    ATTACH_AND_SEQ_STORE$1 + ' (seq)';\nvar ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL =\n  'CREATE UNIQUE INDEX IF NOT EXISTS \\'attach-seq-digest-idx\\' ON ' +\n    ATTACH_AND_SEQ_STORE$1 + ' (digest, seq)';\n\nvar DOC_STORE_AND_BY_SEQ_JOINER = BY_SEQ_STORE$1 +\n  '.seq = ' + DOC_STORE$1 + '.winningseq';\n\nvar SELECT_DOCS = BY_SEQ_STORE$1 + '.seq AS seq, ' +\n  BY_SEQ_STORE$1 + '.deleted AS deleted, ' +\n  BY_SEQ_STORE$1 + '.json AS data, ' +\n  BY_SEQ_STORE$1 + '.rev AS rev, ' +\n  DOC_STORE$1 + '.json AS metadata';\n\nfunction WebSqlPouch$1(opts, callback) {\n  var api = this;\n  var instanceId = null;\n  var size = getSize(opts);\n  var idRequests = [];\n  var encoding;\n\n  api._name = opts.name;\n\n  // extend the options here, because sqlite plugin has a ton of options\n  // and they are constantly changing, so it's more prudent to allow anything\n  var websqlOpts = $inject_Object_assign({}, opts, {\n    version: POUCH_VERSION,\n    description: opts.name,\n    size: size\n  });\n  var openDBResult = openDB$1(websqlOpts);\n  if (openDBResult.error) {\n    return websqlError(callback)(openDBResult.error);\n  }\n  var db = openDBResult.db;\n  if (typeof db.readTransaction !== 'function') {\n    // doesn't exist in sqlite plugin\n    db.readTransaction = db.transaction;\n  }\n\n  function dbCreated() {\n    // note the db name in case the browser upgrades to idb\n    if (hasLocalStorage()) {\n      window.localStorage['_pouch__websqldb_' + api._name] = true;\n    }\n    callback(null, api);\n  }\n\n  // In this migration, we added the 'deleted' and 'local' columns to the\n  // by-seq and doc store tables.\n  // To preserve existing user data, we re-process all the existing JSON\n  // and add these values.\n  // Called migration2 because it corresponds to adapter version (db_version) #2\n  function runMigration2(tx, callback) {\n    // index used for the join in the allDocs query\n    tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n\n    tx.executeSql('ALTER TABLE ' + BY_SEQ_STORE$1 +\n      ' ADD COLUMN deleted TINYINT(1) DEFAULT 0', [], function () {\n      tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n      tx.executeSql('ALTER TABLE ' + DOC_STORE$1 +\n        ' ADD COLUMN local TINYINT(1) DEFAULT 0', [], function () {\n        tx.executeSql('CREATE INDEX IF NOT EXISTS \\'doc-store-local-idx\\' ON ' +\n          DOC_STORE$1 + ' (local, id)');\n\n        var sql = 'SELECT ' + DOC_STORE$1 + '.winningseq AS seq, ' + DOC_STORE$1 +\n          '.json AS metadata FROM ' + BY_SEQ_STORE$1 + ' JOIN ' + DOC_STORE$1 +\n          ' ON ' + BY_SEQ_STORE$1 + '.seq = ' + DOC_STORE$1 + '.winningseq';\n\n        tx.executeSql(sql, [], function (tx, result) {\n\n          var deleted = [];\n          var local = [];\n\n          for (var i = 0; i < result.rows.length; i++) {\n            var item = result.rows.item(i);\n            var seq = item.seq;\n            var metadata = JSON.parse(item.metadata);\n            if (isDeleted(metadata)) {\n              deleted.push(seq);\n            }\n            if (isLocalId(metadata.id)) {\n              local.push(metadata.id);\n            }\n          }\n          tx.executeSql('UPDATE ' + DOC_STORE$1 + 'SET local = 1 WHERE id IN ' +\n            qMarks(local.length), local, function () {\n            tx.executeSql('UPDATE ' + BY_SEQ_STORE$1 +\n              ' SET deleted = 1 WHERE seq IN ' +\n              qMarks(deleted.length), deleted, callback);\n          });\n        });\n      });\n    });\n  }\n\n  // in this migration, we make all the local docs unversioned\n  function runMigration3(tx, callback) {\n    var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n      ' (id UNIQUE, rev, json)';\n    tx.executeSql(local, [], function () {\n      var sql = 'SELECT ' + DOC_STORE$1 + '.id AS id, ' +\n        BY_SEQ_STORE$1 + '.json AS data ' +\n        'FROM ' + BY_SEQ_STORE$1 + ' JOIN ' +\n        DOC_STORE$1 + ' ON ' + BY_SEQ_STORE$1 + '.seq = ' +\n        DOC_STORE$1 + '.winningseq WHERE local = 1';\n      tx.executeSql(sql, [], function (tx, res) {\n        var rows = [];\n        for (var i = 0; i < res.rows.length; i++) {\n          rows.push(res.rows.item(i));\n        }\n        function doNext() {\n          if (!rows.length) {\n            return callback(tx);\n          }\n          var row = rows.shift();\n          var rev$$1 = JSON.parse(row.data)._rev;\n          tx.executeSql('INSERT INTO ' + LOCAL_STORE$1 +\n              ' (id, rev, json) VALUES (?,?,?)',\n              [row.id, rev$$1, row.data], function (tx) {\n            tx.executeSql('DELETE FROM ' + DOC_STORE$1 + ' WHERE id=?',\n                [row.id], function (tx) {\n              tx.executeSql('DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?',\n                  [row.seq], function () {\n                doNext();\n              });\n            });\n          });\n        }\n        doNext();\n      });\n    });\n  }\n\n  // in this migration, we remove doc_id_rev and just use rev\n  function runMigration4(tx, callback) {\n\n    function updateRows(rows) {\n      function doNext() {\n        if (!rows.length) {\n          return callback(tx);\n        }\n        var row = rows.shift();\n        var doc_id_rev = parseHexString(row.hex, encoding);\n        var idx = doc_id_rev.lastIndexOf('::');\n        var doc_id = doc_id_rev.substring(0, idx);\n        var rev$$1 = doc_id_rev.substring(idx + 2);\n        var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n          ' SET doc_id=?, rev=? WHERE doc_id_rev=?';\n        tx.executeSql(sql, [doc_id, rev$$1, doc_id_rev], function () {\n          doNext();\n        });\n      }\n      doNext();\n    }\n\n    var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN doc_id';\n    tx.executeSql(sql, [], function (tx) {\n      var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN rev';\n      tx.executeSql(sql, [], function (tx) {\n        tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL, [], function (tx) {\n          var sql = 'SELECT hex(doc_id_rev) as hex FROM ' + BY_SEQ_STORE$1;\n          tx.executeSql(sql, [], function (tx, res) {\n            var rows = [];\n            for (var i = 0; i < res.rows.length; i++) {\n              rows.push(res.rows.item(i));\n            }\n            updateRows(rows);\n          });\n        });\n      });\n    });\n  }\n\n  // in this migration, we add the attach_and_seq table\n  // for issue #2818\n  function runMigration5(tx, callback) {\n\n    function migrateAttsAndSeqs(tx) {\n      // need to actually populate the table. this is the expensive part,\n      // so as an optimization, check first that this database even\n      // contains attachments\n      var sql = 'SELECT COUNT(*) AS cnt FROM ' + ATTACH_STORE$1;\n      tx.executeSql(sql, [], function (tx, res) {\n        var count = res.rows.item(0).cnt;\n        if (!count) {\n          return callback(tx);\n        }\n\n        var offset = 0;\n        var pageSize = 10;\n        function nextPage() {\n          var sql = select(\n            SELECT_DOCS + ', ' + DOC_STORE$1 + '.id AS id',\n            [DOC_STORE$1, BY_SEQ_STORE$1],\n            DOC_STORE_AND_BY_SEQ_JOINER,\n            null,\n            DOC_STORE$1 + '.id '\n          );\n          sql += ' LIMIT ' + pageSize + ' OFFSET ' + offset;\n          offset += pageSize;\n          tx.executeSql(sql, [], function (tx, res) {\n            if (!res.rows.length) {\n              return callback(tx);\n            }\n            var digestSeqs = {};\n            function addDigestSeq(digest, seq) {\n              // uniq digest/seq pairs, just in case there are dups\n              var seqs = digestSeqs[digest] = (digestSeqs[digest] || []);\n              if (seqs.indexOf(seq) === -1) {\n                seqs.push(seq);\n              }\n            }\n            for (var i = 0; i < res.rows.length; i++) {\n              var row = res.rows.item(i);\n              var doc = unstringifyDoc(row.data, row.id, row.rev);\n              var atts = Object.keys(doc._attachments || {});\n              for (var j = 0; j < atts.length; j++) {\n                var att = doc._attachments[atts[j]];\n                addDigestSeq(att.digest, row.seq);\n              }\n            }\n            var digestSeqPairs = [];\n            Object.keys(digestSeqs).forEach(function (digest) {\n              var seqs = digestSeqs[digest];\n              seqs.forEach(function (seq) {\n                digestSeqPairs.push([digest, seq]);\n              });\n            });\n            if (!digestSeqPairs.length) {\n              return nextPage();\n            }\n            var numDone = 0;\n            digestSeqPairs.forEach(function (pair) {\n              var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n                ' (digest, seq) VALUES (?,?)';\n              tx.executeSql(sql, pair, function () {\n                if (++numDone === digestSeqPairs.length) {\n                  nextPage();\n                }\n              });\n            });\n          });\n        }\n        nextPage();\n      });\n    }\n\n    var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n      ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n    tx.executeSql(attachAndRev, [], function (tx) {\n      tx.executeSql(\n        ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL, [], function (tx) {\n          tx.executeSql(\n            ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL, [],\n            migrateAttsAndSeqs);\n        });\n    });\n  }\n\n  // in this migration, we use escapeBlob() and unescapeBlob()\n  // instead of reading out the binary as HEX, which is slow\n  function runMigration6(tx, callback) {\n    var sql = 'ALTER TABLE ' + ATTACH_STORE$1 +\n      ' ADD COLUMN escaped TINYINT(1) DEFAULT 0';\n    tx.executeSql(sql, [], callback);\n  }\n\n  // issue #3136, in this migration we need a \"latest seq\" as well\n  // as the \"winning seq\" in the doc store\n  function runMigration7(tx, callback) {\n    var sql = 'ALTER TABLE ' + DOC_STORE$1 +\n      ' ADD COLUMN max_seq INTEGER';\n    tx.executeSql(sql, [], function (tx) {\n      var sql = 'UPDATE ' + DOC_STORE$1 + ' SET max_seq=(SELECT MAX(seq) FROM ' +\n        BY_SEQ_STORE$1 + ' WHERE doc_id=id)';\n      tx.executeSql(sql, [], function (tx) {\n        // add unique index after filling, else we'll get a constraint\n        // error when we do the ALTER TABLE\n        var sql =\n          'CREATE UNIQUE INDEX IF NOT EXISTS \\'doc-max-seq-idx\\' ON ' +\n          DOC_STORE$1 + ' (max_seq)';\n        tx.executeSql(sql, [], callback);\n      });\n    });\n  }\n\n  function checkEncoding(tx, cb) {\n    // UTF-8 on chrome/android, UTF-16 on safari < 7.1\n    tx.executeSql('SELECT HEX(\"a\") AS hex', [], function (tx, res) {\n        var hex = res.rows.item(0).hex;\n        encoding = hex.length === 2 ? 'UTF-8' : 'UTF-16';\n        cb();\n      }\n    );\n  }\n\n  function onGetInstanceId() {\n    while (idRequests.length > 0) {\n      var idCallback = idRequests.pop();\n      idCallback(null, instanceId);\n    }\n  }\n\n  function onGetVersion(tx, dbVersion) {\n    if (dbVersion === 0) {\n      // initial schema\n\n      var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE$1 +\n        ' (dbid, db_version INTEGER)';\n      var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE$1 +\n        ' (digest UNIQUE, escaped TINYINT(1), body BLOB)';\n      var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n        ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n      // TODO: migrate winningseq to INTEGER\n      var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE$1 +\n        ' (id unique, json, winningseq, max_seq INTEGER UNIQUE)';\n      var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE$1 +\n        ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, ' +\n        'json, deleted TINYINT(1), doc_id, rev)';\n      var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n        ' (id UNIQUE, rev, json)';\n\n      // creates\n      tx.executeSql(attach);\n      tx.executeSql(local);\n      tx.executeSql(attachAndRev, [], function () {\n        tx.executeSql(ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL);\n        tx.executeSql(ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL);\n      });\n      tx.executeSql(doc, [], function () {\n        tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n        tx.executeSql(seq, [], function () {\n          tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n          tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL);\n          tx.executeSql(meta, [], function () {\n            // mark the db version, and new dbid\n            var initSeq = 'INSERT INTO ' + META_STORE$1 +\n              ' (db_version, dbid) VALUES (?,?)';\n            instanceId = uuid();\n            var initSeqArgs = [ADAPTER_VERSION$1, instanceId];\n            tx.executeSql(initSeq, initSeqArgs, function () {\n              onGetInstanceId();\n            });\n          });\n        });\n      });\n    } else { // version > 0\n\n      var setupDone = function () {\n        var migrated = dbVersion < ADAPTER_VERSION$1;\n        if (migrated) {\n          // update the db version within this transaction\n          tx.executeSql('UPDATE ' + META_STORE$1 + ' SET db_version = ' +\n            ADAPTER_VERSION$1);\n        }\n        // notify db.id() callers\n        var sql = 'SELECT dbid FROM ' + META_STORE$1;\n        tx.executeSql(sql, [], function (tx, result) {\n          instanceId = result.rows.item(0).dbid;\n          onGetInstanceId();\n        });\n      };\n\n      // would love to use promises here, but then websql\n      // ends the transaction early\n      var tasks = [\n        runMigration2,\n        runMigration3,\n        runMigration4,\n        runMigration5,\n        runMigration6,\n        runMigration7,\n        setupDone\n      ];\n\n      // run each migration sequentially\n      var i = dbVersion;\n      var nextMigration = function (tx) {\n        tasks[i - 1](tx, nextMigration);\n        i++;\n      };\n      nextMigration(tx);\n    }\n  }\n\n  function setup() {\n    db.transaction(function (tx) {\n      // first check the encoding\n      checkEncoding(tx, function () {\n        // then get the version\n        fetchVersion(tx);\n      });\n    }, websqlError(callback), dbCreated);\n  }\n\n  function fetchVersion(tx) {\n    var sql = 'SELECT sql FROM sqlite_master WHERE tbl_name = ' + META_STORE$1;\n    tx.executeSql(sql, [], function (tx, result) {\n      if (!result.rows.length) {\n        // database hasn't even been created yet (version 0)\n        onGetVersion(tx, 0);\n      } else if (!/db_version/.test(result.rows.item(0).sql)) {\n        // table was created, but without the new db_version column,\n        // so add it.\n        tx.executeSql('ALTER TABLE ' + META_STORE$1 +\n          ' ADD COLUMN db_version INTEGER', [], function () {\n          // before version 2, this column didn't even exist\n          onGetVersion(tx, 1);\n        });\n      } else { // column exists, we can safely get it\n        tx.executeSql('SELECT db_version FROM ' + META_STORE$1,\n          [], function (tx, result) {\n          var dbVersion = result.rows.item(0).db_version;\n          onGetVersion(tx, dbVersion);\n        });\n      }\n    });\n  }\n\n  setup();\n\n  function getMaxSeq(tx, callback) {\n    var sql = 'SELECT MAX(seq) AS seq FROM ' + BY_SEQ_STORE$1;\n    tx.executeSql(sql, [], function (tx, res) {\n      var updateSeq = res.rows.item(0).seq || 0;\n      callback(updateSeq);\n    });\n  }\n\n  function countDocs(tx, callback) {\n    // count the total rows\n    var sql = select(\n      'COUNT(' + DOC_STORE$1 + '.id) AS \\'num\\'',\n      [DOC_STORE$1, BY_SEQ_STORE$1],\n      DOC_STORE_AND_BY_SEQ_JOINER,\n      BY_SEQ_STORE$1 + '.deleted=0');\n\n    tx.executeSql(sql, [], function (tx, result) {\n      callback(result.rows.item(0).num);\n    });\n  }\n\n  api._remote = false;\n  api.type = function () {\n    return 'websql';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, instanceId);\n  });\n\n  api._info = function (callback) {\n    var seq;\n    var docCount;\n    db.readTransaction(function (tx) {\n      getMaxSeq(tx, function (theSeq) {\n        seq = theSeq;\n      });\n      countDocs(tx, function (theDocCount) {\n        docCount = theDocCount;\n      });\n    }, websqlError(callback), function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: seq,\n        websql_encoding: encoding\n      });\n    });\n  };\n\n  api._bulkDocs = function (req, reqOpts, callback) {\n    websqlBulkDocs(opts, req, reqOpts, api, db, websqlChanges, callback);\n  };\n\n  function latest$$1(tx, id, rev$$1, callback, finish) {\n    var sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        DOC_STORE$1 + '.id=?');\n    var sqlArgs = [id];\n\n    tx.executeSql(sql, sqlArgs, function (a, results) {\n      if (!results.rows.length) {\n        var err = createError(MISSING_DOC, 'missing');\n        return finish(err);\n      }\n      var item = results.rows.item(0);\n      var metadata = safeJsonParse(item.metadata);\n      callback(latest(rev$$1, metadata));\n    });\n  }\n\n  api._get = function (id, opts, callback) {\n    var doc;\n    var metadata;\n    var tx = opts.ctx;\n    if (!tx) {\n      return db.readTransaction(function (txn) {\n        api._get(id, $inject_Object_assign({ctx: txn}, opts), callback);\n      });\n    }\n\n    function finish(err) {\n      callback(err, {doc: doc, metadata: metadata, ctx: tx});\n    }\n\n    var sql;\n    var sqlArgs;\n\n    if (!opts.rev) {\n      sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        DOC_STORE$1 + '.id=?');\n      sqlArgs = [id];\n    } else if (opts.latest) {\n      latest$$1(tx, id, opts.rev, function (latestRev) {\n        opts.latest = false;\n        opts.rev = latestRev;\n        api._get(id, opts, callback);\n      }, finish);\n      return;\n    } else {\n      sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id',\n        [BY_SEQ_STORE$1 + '.doc_id=?', BY_SEQ_STORE$1 + '.rev=?']);\n      sqlArgs = [id, opts.rev];\n    }\n\n    tx.executeSql(sql, sqlArgs, function (a, results) {\n      if (!results.rows.length) {\n        var missingErr = createError(MISSING_DOC, 'missing');\n        return finish(missingErr);\n      }\n      var item = results.rows.item(0);\n      metadata = safeJsonParse(item.metadata);\n      if (item.deleted && !opts.rev) {\n        var deletedErr = createError(MISSING_DOC, 'deleted');\n        return finish(deletedErr);\n      }\n      doc = unstringifyDoc(item.data, metadata.id, item.rev);\n      finish();\n    });\n  };\n\n  api._allDocs = function (opts, callback) {\n    var results = [];\n    var totalRows;\n\n    var start = 'startkey' in opts ? opts.startkey : false;\n    var end = 'endkey' in opts ? opts.endkey : false;\n    var key = 'key' in opts ? opts.key : false;\n    var descending = 'descending' in opts ? opts.descending : false;\n    var limit = 'limit' in opts ? opts.limit : -1;\n    var offset = 'skip' in opts ? opts.skip : 0;\n    var inclusiveEnd = opts.inclusive_end !== false;\n\n    var sqlArgs = [];\n    var criteria = [];\n\n    if (key !== false) {\n      criteria.push(DOC_STORE$1 + '.id = ?');\n      sqlArgs.push(key);\n    } else if (start !== false || end !== false) {\n      if (start !== false) {\n        criteria.push(DOC_STORE$1 + '.id ' + (descending ? '<=' : '>=') + ' ?');\n        sqlArgs.push(start);\n      }\n      if (end !== false) {\n        var comparator = descending ? '>' : '<';\n        if (inclusiveEnd) {\n          comparator += '=';\n        }\n        criteria.push(DOC_STORE$1 + '.id ' + comparator + ' ?');\n        sqlArgs.push(end);\n      }\n      if (key !== false) {\n        criteria.push(DOC_STORE$1 + '.id = ?');\n        sqlArgs.push(key);\n      }\n    }\n\n    if (opts.deleted !== 'ok') {\n      // report deleted if keys are specified\n      criteria.push(BY_SEQ_STORE$1 + '.deleted = 0');\n    }\n\n    db.readTransaction(function (tx) {\n      // count the docs in parallel to other operations\n      countDocs(tx, function (docCount) {\n        totalRows = docCount;\n      });\n\n      if (limit === 0) {\n        return;\n      }\n\n      // do a single query to fetch the documents\n      var sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        criteria,\n        DOC_STORE$1 + '.id ' + (descending ? 'DESC' : 'ASC')\n        );\n      sql += ' LIMIT ' + limit + ' OFFSET ' + offset;\n\n      tx.executeSql(sql, sqlArgs, function (tx, result) {\n        for (var i = 0, l = result.rows.length; i < l; i++) {\n          var item = result.rows.item(i);\n          var metadata = safeJsonParse(item.metadata);\n          var id = metadata.id;\n          var data = unstringifyDoc(item.data, id, item.rev);\n          var winningRev$$1 = data._rev;\n          var doc = {\n            id: id,\n            key: id,\n            value: {rev: winningRev$$1}\n          };\n          if (opts.include_docs) {\n            doc.doc = data;\n            doc.doc._rev = winningRev$$1;\n            if (opts.conflicts) {\n              var conflicts = collectConflicts(metadata);\n              if (conflicts.length) {\n                doc.doc._conflicts = conflicts;\n              }\n            }\n            fetchAttachmentsIfNecessary$1(doc.doc, opts, api, tx);\n          }\n          if (item.deleted) {\n            if (opts.deleted === 'ok') {\n              doc.value.deleted = true;\n              doc.doc = null;\n            } else {\n              continue;\n            }\n          }\n          results.push(doc);\n        }\n      });\n    }, websqlError(callback), function () {\n      callback(null, {\n        total_rows: totalRows,\n        offset: opts.skip,\n        rows: results\n      });\n    });\n  };\n\n  api._changes = function (opts) {\n    opts = clone(opts);\n\n    if (opts.continuous) {\n      var id = api._name + ':' + uuid();\n      websqlChanges.addListener(api._name, id, api, opts);\n      websqlChanges.notify(api._name);\n      return {\n        cancel: function () {\n          websqlChanges.removeListener(api._name, id);\n        }\n      };\n    }\n\n    var descending = opts.descending;\n\n    // Ignore the `since` parameter when `descending` is true\n    opts.since = opts.since && !descending ? opts.since : 0;\n\n    var limit = 'limit' in opts ? opts.limit : -1;\n    if (limit === 0) {\n      limit = 1; // per CouchDB _changes spec\n    }\n\n    var returnDocs;\n    if ('return_docs' in opts) {\n      returnDocs = opts.return_docs;\n    } else if ('returnDocs' in opts) {\n      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n      returnDocs = opts.returnDocs;\n    } else {\n      returnDocs = true;\n    }\n    var results = [];\n    var numResults = 0;\n\n    function fetchChanges() {\n\n      var selectStmt =\n        DOC_STORE$1 + '.json AS metadata, ' +\n        DOC_STORE$1 + '.max_seq AS maxSeq, ' +\n        BY_SEQ_STORE$1 + '.json AS winningDoc, ' +\n        BY_SEQ_STORE$1 + '.rev AS winningRev ';\n\n      var from = DOC_STORE$1 + ' JOIN ' + BY_SEQ_STORE$1;\n\n      var joiner = DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id' +\n        ' AND ' + DOC_STORE$1 + '.winningseq=' + BY_SEQ_STORE$1 + '.seq';\n\n      var criteria = ['maxSeq > ?'];\n      var sqlArgs = [opts.since];\n\n      if (opts.doc_ids) {\n        criteria.push(DOC_STORE$1 + '.id IN ' + qMarks(opts.doc_ids.length));\n        sqlArgs = sqlArgs.concat(opts.doc_ids);\n      }\n\n      var orderBy = 'maxSeq ' + (descending ? 'DESC' : 'ASC');\n\n      var sql = select(selectStmt, from, joiner, criteria, orderBy);\n\n      var filter = filterChange(opts);\n      if (!opts.view && !opts.filter) {\n        // we can just limit in the query\n        sql += ' LIMIT ' + limit;\n      }\n\n      var lastSeq = opts.since || 0;\n      db.readTransaction(function (tx) {\n        tx.executeSql(sql, sqlArgs, function (tx, result) {\n          function reportChange(change) {\n            return function () {\n              opts.onChange(change);\n            };\n          }\n          for (var i = 0, l = result.rows.length; i < l; i++) {\n            var item = result.rows.item(i);\n            var metadata = safeJsonParse(item.metadata);\n            lastSeq = item.maxSeq;\n\n            var doc = unstringifyDoc(item.winningDoc, metadata.id,\n              item.winningRev);\n            var change = opts.processChange(doc, metadata, opts);\n            change.seq = item.maxSeq;\n\n            var filtered = filter(change);\n            if (typeof filtered === 'object') {\n              return opts.complete(filtered);\n            }\n\n            if (filtered) {\n              numResults++;\n              if (returnDocs) {\n                results.push(change);\n              }\n              // process the attachment immediately\n              // for the benefit of live listeners\n              if (opts.attachments && opts.include_docs) {\n                fetchAttachmentsIfNecessary$1(doc, opts, api, tx,\n                  reportChange(change));\n              } else {\n                reportChange(change)();\n              }\n            }\n            if (numResults === limit) {\n              break;\n            }\n          }\n        });\n      }, websqlError(opts.complete), function () {\n        if (!opts.continuous) {\n          opts.complete(null, {\n            results: results,\n            last_seq: lastSeq\n          });\n        }\n      });\n    }\n\n    fetchChanges();\n  };\n\n  api._close = function (callback) {\n    //WebSQL databases do not need to be closed\n    callback();\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var res;\n    var tx = opts.ctx;\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n    var sql = 'SELECT escaped, ' +\n      'CASE WHEN escaped = 1 THEN body ELSE HEX(body) END AS body FROM ' +\n      ATTACH_STORE$1 + ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      // websql has a bug where \\u0000 causes early truncation in strings\n      // and blobs. to work around this, we used to use the hex() function,\n      // but that's not performant. after migration 6, we remove \\u0000\n      // and add it back in afterwards\n      var item = result.rows.item(0);\n      var data = item.escaped ? unescapeBlob(item.body) :\n        parseHexString(item.body, encoding);\n      if (opts.binary) {\n        res = binStringToBluffer(data, type);\n      } else {\n        res = thisBtoa(data);\n      }\n      callback(null, res);\n    });\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    db.readTransaction(function (tx) {\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function (tx, result) {\n        if (!result.rows.length) {\n          callback(createError(MISSING_DOC));\n        } else {\n          var data = safeJsonParse(result.rows.item(0).metadata);\n          callback(null, data.rev_tree);\n        }\n      });\n    });\n  };\n\n  api._doCompaction = function (docId, revs, callback) {\n    if (!revs.length) {\n      return callback();\n    }\n    db.transaction(function (tx) {\n\n      // update doc store\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function (tx, result) {\n        var metadata = safeJsonParse(result.rows.item(0).metadata);\n        traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                                           revHash, ctx, opts) {\n          var rev$$1 = pos + '-' + revHash;\n          if (revs.indexOf(rev$$1) !== -1) {\n            opts.status = 'missing';\n          }\n        });\n\n        var sql = 'UPDATE ' + DOC_STORE$1 + ' SET json = ? WHERE id = ?';\n        tx.executeSql(sql, [safeJsonStringify(metadata), docId]);\n      });\n\n      compactRevs$1(revs, docId, tx);\n    }, websqlError(callback), function () {\n      callback();\n    });\n  };\n\n  api._getLocal = function (id, callback) {\n    db.readTransaction(function (tx) {\n      var sql = 'SELECT json, rev FROM ' + LOCAL_STORE$1 + ' WHERE id=?';\n      tx.executeSql(sql, [id], function (tx, res) {\n        if (res.rows.length) {\n          var item = res.rows.item(0);\n          var doc = unstringifyDoc(item.json, id, item.rev);\n          callback(null, doc);\n        } else {\n          callback(createError(MISSING_DOC));\n        }\n      });\n    });\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    var newRev;\n    if (!oldRev) {\n      newRev = doc._rev = '0-1';\n    } else {\n      newRev = doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n    var json = stringifyDoc(doc);\n\n    var ret;\n    function putLocal(tx) {\n      var sql;\n      var values;\n      if (oldRev) {\n        sql = 'UPDATE ' + LOCAL_STORE$1 + ' SET rev=?, json=? ' +\n          'WHERE id=? AND rev=?';\n        values = [newRev, json, id, oldRev];\n      } else {\n        sql = 'INSERT INTO ' + LOCAL_STORE$1 + ' (id, rev, json) VALUES (?,?,?)';\n        values = [id, newRev, json];\n      }\n      tx.executeSql(sql, values, function (tx, res) {\n        if (res.rowsAffected) {\n          ret = {ok: true, id: id, rev: newRev};\n          if (opts.ctx) { // return immediately\n            callback(null, ret);\n          }\n        } else {\n          callback(createError(REV_CONFLICT));\n        }\n      }, function () {\n        callback(createError(REV_CONFLICT));\n        return false; // ack that we handled the error\n      });\n    }\n\n    if (opts.ctx) {\n      putLocal(opts.ctx);\n    } else {\n      db.transaction(putLocal, websqlError(callback), function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      });\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var ret;\n\n    function removeLocal(tx) {\n      var sql = 'DELETE FROM ' + LOCAL_STORE$1 + ' WHERE id=? AND rev=?';\n      var params = [doc._id, doc._rev];\n      tx.executeSql(sql, params, function (tx, res) {\n        if (!res.rowsAffected) {\n          return callback(createError(MISSING_DOC));\n        }\n        ret = {ok: true, id: doc._id, rev: '0-0'};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      });\n    }\n\n    if (opts.ctx) {\n      removeLocal(opts.ctx);\n    } else {\n      db.transaction(removeLocal, websqlError(callback), function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      });\n    }\n  };\n\n  api._destroy = function (opts, callback) {\n    websqlChanges.removeAllListeners(api._name);\n    db.transaction(function (tx) {\n      var stores = [DOC_STORE$1, BY_SEQ_STORE$1, ATTACH_STORE$1, META_STORE$1,\n        LOCAL_STORE$1, ATTACH_AND_SEQ_STORE$1];\n      stores.forEach(function (store) {\n        tx.executeSql('DROP TABLE IF EXISTS ' + store, []);\n      });\n    }, websqlError(callback), function () {\n      if (hasLocalStorage()) {\n        delete window.localStorage['_pouch__websqldb_' + api._name];\n        delete window.localStorage[api._name];\n      }\n      callback(null, {'ok': true});\n    });\n  };\n}\n\nfunction canOpenTestDB() {\n  try {\n    openDatabase('_pouch_validate_websql', 1, '', 1);\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\n// WKWebView had a bug where WebSQL would throw a DOM Exception 18\n// (see https://bugs.webkit.org/show_bug.cgi?id=137760 and\n// https://github.com/pouchdb/pouchdb/issues/5079)\n// This has been fixed in latest WebKit, so we try to detect it here.\nfunction isValidWebSQL() {\n  // WKWebView UA:\n  //   Mozilla/5.0 (iPhone; CPU iPhone OS 9_2 like Mac OS X)\n  //   AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13C75\n  // Chrome for iOS UA:\n  //   Mozilla/5.0 (iPhone; U; CPU iPhone OS 5_1_1 like Mac OS X; en)\n  //   AppleWebKit/534.46.0 (KHTML, like Gecko) CriOS/19.0.1084.60\n  //   Mobile/9B206 Safari/7534.48.3\n  // Firefox for iOS UA:\n  //   Mozilla/5.0 (iPhone; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4\n  //   (KHTML, like Gecko) FxiOS/1.0 Mobile/12F69 Safari/600.1.4\n\n  // indexedDB is null on some UIWebViews and undefined in others\n  // see: https://bugs.webkit.org/show_bug.cgi?id=137034\n  if (typeof indexedDB === 'undefined' || indexedDB === null ||\n      !/iP(hone|od|ad)/.test(navigator.userAgent)) {\n    // definitely not WKWebView, avoid creating an unnecessary database\n    return true;\n  }\n  // Cache the result in LocalStorage. Reason we do this is because if we\n  // call openDatabase() too many times, Safari craps out in SauceLabs and\n  // starts throwing DOM Exception 14s.\n  var hasLS = hasLocalStorage();\n  // Include user agent in the hash, so that if Safari is upgraded, we don't\n  // continually think it's broken.\n  var localStorageKey = '_pouch__websqldb_valid_' + navigator.userAgent;\n  if (hasLS && localStorage[localStorageKey]) {\n    return localStorage[localStorageKey] === '1';\n  }\n  var openedTestDB = canOpenTestDB();\n  if (hasLS) {\n    localStorage[localStorageKey] = openedTestDB ? '1' : '0';\n  }\n  return openedTestDB;\n}\n\nfunction valid() {\n  if (typeof openDatabase !== 'function') {\n    return false;\n  }\n  return isValidWebSQL();\n}\n\nfunction openDB(name, version, description, size) {\n  // Traditional WebSQL API\n  return openDatabase(name, version, description, size);\n}\n\nfunction WebSQLPouch(opts, callback) {\n  var _opts = $inject_Object_assign({\n    websql: openDB\n  }, opts);\n\n  WebSqlPouch$1.call(this, _opts, callback);\n}\n\nWebSQLPouch.valid = valid;\n\nWebSQLPouch.use_prefix = true;\n\nvar WebSqlPouch = function (PouchDB) {\n  PouchDB.adapter('websql', WebSQLPouch, true);\n};\n\n/* global fetch */\n/* global Headers */\nfunction wrappedFetch() {\n  var wrappedPromise = {};\n\n  var promise = new PouchPromise$1(function (resolve, reject) {\n    wrappedPromise.resolve = resolve;\n    wrappedPromise.reject = reject;\n  });\n\n  var args = new Array(arguments.length);\n\n  for (var i = 0; i < args.length; i++) {\n    args[i] = arguments[i];\n  }\n\n  wrappedPromise.promise = promise;\n\n  PouchPromise$1.resolve().then(function () {\n    return fetch.apply(null, args);\n  }).then(function (response) {\n    wrappedPromise.resolve(response);\n  }).catch(function (error) {\n    wrappedPromise.reject(error);\n  });\n\n  return wrappedPromise;\n}\n\nfunction fetchRequest(options, callback) {\n  var wrappedPromise, timer, response;\n\n  var headers = new Headers();\n\n  var fetchOptions = {\n    method: options.method,\n    credentials: 'include',\n    headers: headers\n  };\n\n  if (options.json) {\n    headers.set('Accept', 'application/json');\n    headers.set('Content-Type', options.headers['Content-Type'] ||\n      'application/json');\n  }\n\n  if (options.body &&\n      options.processData &&\n      typeof options.body !== 'string') {\n    fetchOptions.body = JSON.stringify(options.body);\n  } else if ('body' in options) {\n    fetchOptions.body = options.body;\n  } else {\n    fetchOptions.body = null;\n  }\n\n  Object.keys(options.headers).forEach(function (key) {\n    if (options.headers.hasOwnProperty(key)) {\n      headers.set(key, options.headers[key]);\n    }\n  });\n\n  wrappedPromise = wrappedFetch(options.url, fetchOptions);\n\n  if (options.timeout > 0) {\n    timer = setTimeout(function () {\n      wrappedPromise.reject(new Error('Load timeout for resource: ' +\n        options.url));\n    }, options.timeout);\n  }\n\n  wrappedPromise.promise.then(function (fetchResponse) {\n    response = {\n      statusCode: fetchResponse.status\n    };\n\n    if (options.timeout > 0) {\n      clearTimeout(timer);\n    }\n\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      return options.binary ? fetchResponse.blob() : fetchResponse.text();\n    }\n\n    return fetchResponse.json();\n  }).then(function (result) {\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      callback(null, response, result);\n    } else {\n      result.status = response.statusCode;\n      callback(result);\n    }\n  }).catch(function (error) {\n    if (!error) {\n      // this happens when the listener is canceled\n      error = new Error('canceled');\n    }\n    callback(error);\n  });\n\n  return {abort: wrappedPromise.reject};\n}\n\nfunction xhRequest(options, callback) {\n\n  var xhr, timer;\n  var timedout = false;\n\n  var abortReq = function () {\n    xhr.abort();\n    cleanUp();\n  };\n\n  var timeoutReq = function () {\n    timedout = true;\n    xhr.abort();\n    cleanUp();\n  };\n\n  var ret = {abort: abortReq};\n\n  var cleanUp = function () {\n    clearTimeout(timer);\n    ret.abort = function () {};\n    if (xhr) {\n      xhr.onprogress = undefined;\n      if (xhr.upload) {\n        xhr.upload.onprogress = undefined;\n      }\n      xhr.onreadystatechange = undefined;\n      xhr = undefined;\n    }\n  };\n\n  if (options.xhr) {\n    xhr = new options.xhr();\n  } else {\n    xhr = new XMLHttpRequest();\n  }\n\n  try {\n    xhr.open(options.method, options.url);\n  } catch (exception) {\n    return callback(new Error(exception.name || 'Url is invalid'));\n  }\n\n  xhr.withCredentials = ('withCredentials' in options) ?\n    options.withCredentials : true;\n\n  if (options.method === 'GET') {\n    delete options.headers['Content-Type'];\n  } else if (options.json) {\n    options.headers.Accept = 'application/json';\n    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n      'application/json';\n    if (options.body &&\n        options.processData &&\n        typeof options.body !== \"string\") {\n      options.body = JSON.stringify(options.body);\n    }\n  }\n\n  if (options.binary) {\n    xhr.responseType = 'arraybuffer';\n  }\n\n  if (!('body' in options)) {\n    options.body = null;\n  }\n\n  for (var key in options.headers) {\n    if (options.headers.hasOwnProperty(key)) {\n      xhr.setRequestHeader(key, options.headers[key]);\n    }\n  }\n\n  if (options.timeout > 0) {\n    timer = setTimeout(timeoutReq, options.timeout);\n    xhr.onprogress = function () {\n      clearTimeout(timer);\n      if (xhr.readyState !== 4) {\n        timer = setTimeout(timeoutReq, options.timeout);\n      }\n    };\n    if (typeof xhr.upload !== 'undefined') { // does not exist in ie9\n      xhr.upload.onprogress = xhr.onprogress;\n    }\n  }\n\n  xhr.onreadystatechange = function () {\n    if (xhr.readyState !== 4) {\n      return;\n    }\n\n    var response = {\n      statusCode: xhr.status\n    };\n\n    if (xhr.status >= 200 && xhr.status < 300) {\n      var data;\n      if (options.binary) {\n        data = createBlob([xhr.response || ''], {\n          type: xhr.getResponseHeader('Content-Type')\n        });\n      } else {\n        data = xhr.responseText;\n      }\n      callback(null, response, data);\n    } else {\n      var err = {};\n      if (timedout) {\n        err = new Error('ETIMEDOUT');\n        err.code = 'ETIMEDOUT';\n      } else if (typeof xhr.response === 'string') {\n        try {\n          err = JSON.parse(xhr.response);\n        } catch (e) {}\n      }\n      err.status = xhr.status;\n      callback(err);\n    }\n    cleanUp();\n  };\n\n  if (options.body && (options.body instanceof Blob)) {\n    readAsArrayBuffer(options.body, function (arrayBuffer) {\n      xhr.send(arrayBuffer);\n    });\n  } else {\n    xhr.send(options.body);\n  }\n\n  return ret;\n}\n\nfunction testXhr() {\n  try {\n    new XMLHttpRequest();\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nvar hasXhr = testXhr();\n\nfunction ajax$1(options, callback) {\n  if (!false && (hasXhr || options.xhr)) {\n    return xhRequest(options, callback);\n  } else {\n    return fetchRequest(options, callback);\n  }\n}\n\n// the blob already has a type; do nothing\nvar res$2 = function () {};\n\nfunction defaultBody() {\n  return '';\n}\n\nfunction ajaxCore$1(options, callback) {\n\n  options = clone(options);\n\n  var defaultOptions = {\n    method : \"GET\",\n    headers: {},\n    json: true,\n    processData: true,\n    timeout: 10000,\n    cache: false\n  };\n\n  options = $inject_Object_assign(defaultOptions, options);\n\n  function onSuccess(obj, resp, cb) {\n    if (!options.binary && options.json && typeof obj === 'string') {\n      /* istanbul ignore next */\n      try {\n        obj = JSON.parse(obj);\n      } catch (e) {\n        // Probably a malformed JSON from server\n        return cb(e);\n      }\n    }\n    if (Array.isArray(obj)) {\n      obj = obj.map(function (v) {\n        if (v.error || v.missing) {\n          return generateErrorFromResponse(v);\n        } else {\n          return v;\n        }\n      });\n    }\n    if (options.binary) {\n      res$2(obj, resp);\n    }\n    cb(null, obj, resp);\n  }\n\n  if (options.json) {\n    if (!options.binary) {\n      options.headers.Accept = 'application/json';\n    }\n    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n      'application/json';\n  }\n\n  if (options.binary) {\n    options.encoding = null;\n    options.json = false;\n  }\n\n  if (!options.processData) {\n    options.json = false;\n  }\n\n  return ajax$1(options, function (err, response, body) {\n\n    if (err) {\n      return callback(generateErrorFromResponse(err));\n    }\n\n    var error;\n    var content_type = response.headers && response.headers['content-type'];\n    var data = body || defaultBody();\n\n    // CouchDB doesn't always return the right content-type for JSON data, so\n    // we check for ^{ and }$ (ignoring leading/trailing whitespace)\n    if (!options.binary && (options.json || !options.processData) &&\n        typeof data !== 'object' &&\n        (/json/.test(content_type) ||\n         (/^[\\s]*\\{/.test(data) && /\\}[\\s]*$/.test(data)))) {\n      try {\n        data = JSON.parse(data.toString());\n      } catch (e) {}\n    }\n\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      onSuccess(data, response, callback);\n    } else {\n      error = generateErrorFromResponse(data);\n      error.status = response.statusCode;\n      callback(error);\n    }\n  });\n}\n\nfunction ajax(opts, callback) {\n\n  // cache-buster, specifically designed to work around IE's aggressive caching\n  // see http://www.dashbay.com/2011/05/internet-explorer-caches-ajax/\n  // Also Safari caches POSTs, so we need to cache-bust those too.\n  var ua = (navigator && navigator.userAgent) ?\n    navigator.userAgent.toLowerCase() : '';\n\n  var isSafari = ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1;\n  var isIE = ua.indexOf('msie') !== -1;\n  var isEdge = ua.indexOf('edge') !== -1;\n\n  // it appears the new version of safari also caches GETs,\n  // see https://github.com/pouchdb/pouchdb/issues/5010\n  var shouldCacheBust = (isSafari ||\n    ((isIE || isEdge) && opts.method === 'GET'));\n\n  var cache = 'cache' in opts ? opts.cache : true;\n\n  var isBlobUrl = /^blob:/.test(opts.url); // don't append nonces for blob URLs\n\n  if (!isBlobUrl && (shouldCacheBust || !cache)) {\n    var hasArgs = opts.url.indexOf('?') !== -1;\n    opts.url += (hasArgs ? '&' : '?') + '_nonce=' + Date.now();\n  }\n\n  return ajaxCore$1(opts, callback);\n}\n\n// dead simple promise pool, inspired by https://github.com/timdp/es6-promise-pool\n// but much smaller in code size. limits the number of concurrent promises that are executed\n\n\nfunction pool(promiseFactories, limit) {\n  return new PouchPromise$1(function (resolve, reject) {\n    var running = 0;\n    var current = 0;\n    var done = 0;\n    var len = promiseFactories.length;\n    var err;\n\n    function runNext() {\n      running++;\n      promiseFactories[current++]().then(onSuccess, onError);\n    }\n\n    function doNext() {\n      if (++done === len) {\n        /* istanbul ignore if */\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      } else {\n        runNextBatch();\n      }\n    }\n\n    function onSuccess() {\n      running--;\n      doNext();\n    }\n\n    /* istanbul ignore next */\n    function onError(thisErr) {\n      running--;\n      err = err || thisErr;\n      doNext();\n    }\n\n    function runNextBatch() {\n      while (running < limit && current < len) {\n        runNext();\n      }\n    }\n\n    runNextBatch();\n  });\n}\n\nvar CHANGES_BATCH_SIZE = 25;\nvar MAX_SIMULTANEOUS_REVS = 50;\nvar CHANGES_TIMEOUT_BUFFER = 5000;\nvar DEFAULT_HEARTBEAT = 10000;\n\nvar supportsBulkGetMap = {};\n\nfunction readAttachmentsAsBlobOrBuffer(row) {\n  var atts = row.doc && row.doc._attachments;\n  if (!atts) {\n    return;\n  }\n  Object.keys(atts).forEach(function (filename) {\n    var att = atts[filename];\n    att.data = b64ToBluffer(att.data, att.content_type);\n  });\n}\n\nfunction encodeDocId(id) {\n  if (/^_design/.test(id)) {\n    return '_design/' + encodeURIComponent(id.slice(8));\n  }\n  if (/^_local/.test(id)) {\n    return '_local/' + encodeURIComponent(id.slice(7));\n  }\n  return encodeURIComponent(id);\n}\n\nfunction preprocessAttachments$2(doc) {\n  if (!doc._attachments || !Object.keys(doc._attachments)) {\n    return PouchPromise$1.resolve();\n  }\n\n  return PouchPromise$1.all(Object.keys(doc._attachments).map(function (key) {\n    var attachment = doc._attachments[key];\n    if (attachment.data && typeof attachment.data !== 'string') {\n      return new PouchPromise$1(function (resolve) {\n        blobToBase64(attachment.data, resolve);\n      }).then(function (b64) {\n        attachment.data = b64;\n      });\n    }\n  }));\n}\n\nfunction hasUrlPrefix(opts) {\n  if (!opts.prefix) {\n    return false;\n  }\n\n  var protocol = parseUri(opts.prefix).protocol;\n\n  return protocol === 'http' || protocol === 'https';\n}\n\n// Get all the information you possibly can about the URI given by name and\n// return it as a suitable object.\nfunction getHost(name, opts) {\n\n  // encode db name if opts.prefix is a url (#5574)\n  if (hasUrlPrefix(opts)) {\n    var dbName = opts.name.substr(opts.prefix.length);\n    name = opts.prefix + encodeURIComponent(dbName);\n  }\n\n  // Prase the URI into all its little bits\n  var uri = parseUri(name);\n\n  // Store the user and password as a separate auth object\n  if (uri.user || uri.password) {\n    uri.auth = {username: uri.user, password: uri.password};\n  }\n\n  // Split the path part of the URI into parts using '/' as the delimiter\n  // after removing any leading '/' and any trailing '/'\n  var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\n  // Store the first part as the database name and remove it from the parts\n  // array\n  uri.db = parts.pop();\n  // Prevent double encoding of URI component\n  if (uri.db.indexOf('%') === -1) {\n    uri.db = encodeURIComponent(uri.db);\n  }\n\n  // Restore the path by joining all the remaining parts (all the parts\n  // except for the database name) with '/'s\n  uri.path = parts.join('/');\n\n  return uri;\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genDBUrl(opts, path) {\n  return genUrl(opts, opts.db + '/' + path);\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genUrl(opts, path) {\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  var pathDel = !opts.path ? '' : '/';\n\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  return opts.protocol + '://' + opts.host +\n         (opts.port ? (':' + opts.port) : '') +\n         '/' + opts.path + pathDel + path;\n}\n\nfunction paramsToStr(params) {\n  return '?' + Object.keys(params).map(function (k) {\n    return k + '=' + encodeURIComponent(params[k]);\n  }).join('&');\n}\n\n// Implements the PouchDB API for dealing with CouchDB instances over HTTP\nfunction HttpPouch(opts, callback) {\n\n  // The functions that will be publicly available for HttpPouch\n  var api = this;\n\n  var host = getHost(opts.name, opts);\n  var dbUrl = genDBUrl(host, '');\n\n  opts = clone(opts);\n  var ajaxOpts = opts.ajax || {};\n\n  if (opts.auth || host.auth) {\n    var nAuth = opts.auth || host.auth;\n    var str = nAuth.username + ':' + nAuth.password;\n    var token = thisBtoa(unescape(encodeURIComponent(str)));\n    ajaxOpts.headers = ajaxOpts.headers || {};\n    ajaxOpts.headers.Authorization = 'Basic ' + token;\n  }\n\n  // Not strictly necessary, but we do this because numerous tests\n  // rely on swapping ajax in and out.\n  api._ajax = ajax;\n\n  function ajax$$1(userOpts, options, callback) {\n    var reqAjax = userOpts.ajax || {};\n    var reqOpts = $inject_Object_assign(clone(ajaxOpts), reqAjax, options);\n    var defaultHeaders = clone(ajaxOpts.headers || {});\n    reqOpts.headers = $inject_Object_assign(defaultHeaders, reqAjax.headers,\n      options.headers || {});\n    /* istanbul ignore if */\n    if (api.constructor.listeners('debug').length) {\n      api.constructor.emit('debug', ['http', reqOpts.method, reqOpts.url]);\n    }\n    return api._ajax(reqOpts, callback);\n  }\n\n  function ajaxPromise(userOpts, opts) {\n    return new PouchPromise$1(function (resolve, reject) {\n      ajax$$1(userOpts, opts, function (err, res) {\n        /* istanbul ignore if */\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function adapterFun$$1(name, fun) {\n    return adapterFun(name, getArguments(function (args) {\n      setup().then(function () {\n        return fun.apply(this, args);\n      }).catch(function (e) {\n        var callback = args.pop();\n        callback(e);\n      });\n    }));\n  }\n\n  var setupPromise;\n\n  function setup() {\n    // TODO: Remove `skipSetup` in favor of `skip_setup` in a future release\n    if (opts.skipSetup || opts.skip_setup) {\n      return PouchPromise$1.resolve();\n    }\n\n    // If there is a setup in process or previous successful setup\n    // done then we will use that\n    // If previous setups have been rejected we will try again\n    if (setupPromise) {\n      return setupPromise;\n    }\n\n    var checkExists = {method: 'GET', url: dbUrl};\n    setupPromise = ajaxPromise({}, checkExists).catch(function (err) {\n      if (err && err.status && err.status === 404) {\n        // Doesnt exist, create it\n        explainError(404, 'PouchDB is just detecting if the remote exists.');\n        return ajaxPromise({}, {method: 'PUT', url: dbUrl});\n      } else {\n        return PouchPromise$1.reject(err);\n      }\n    }).catch(function (err) {\n      // If we try to create a database that already exists, skipped in\n      // istanbul since its catching a race condition.\n      /* istanbul ignore if */\n      if (err && err.status && err.status === 412) {\n        return true;\n      }\n      return PouchPromise$1.reject(err);\n    });\n\n    setupPromise.catch(function () {\n      setupPromise = null;\n    });\n\n    return setupPromise;\n  }\n\n  nextTick(function () {\n    callback(null, api);\n  });\n\n  api._remote = true;\n  /* istanbul ignore next */\n  api.type = function () {\n    return 'http';\n  };\n\n  api.id = adapterFun$$1('id', function (callback) {\n    ajax$$1({}, {method: 'GET', url: genUrl(host, '')}, function (err, result) {\n      var uuid$$1 = (result && result.uuid) ?\n        (result.uuid + host.db) : genDBUrl(host, '');\n      callback(null, uuid$$1);\n    });\n  });\n\n  api.request = adapterFun$$1('request', function (options, callback) {\n    options.url = genDBUrl(host, options.url);\n    ajax$$1({}, options, callback);\n  });\n\n  // Sends a POST request to the host calling the couchdb _compact function\n  //    version: The version of CouchDB it is running\n  api.compact = adapterFun$$1('compact', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n    ajax$$1(opts, {\n      url: genDBUrl(host, '_compact'),\n      method: 'POST'\n    }, function () {\n      function ping() {\n        api.info(function (err, res) {\n          // CouchDB may send a \"compact_running:true\" if it's\n          // already compacting. PouchDB Server doesn't.\n          /* istanbul ignore else */\n          if (res && !res.compact_running) {\n            callback(null, {ok: true});\n          } else {\n            setTimeout(ping, opts.interval || 200);\n          }\n        });\n      }\n      // Ping the http if it's finished compaction\n      ping();\n    });\n  });\n\n  api.bulkGet = adapterFun('bulkGet', function (opts, callback) {\n    var self = this;\n\n    function doBulkGet(cb) {\n      var params = {};\n      if (opts.revs) {\n        params.revs = true;\n      }\n      if (opts.attachments) {\n        /* istanbul ignore next */\n        params.attachments = true;\n      }\n      if (opts.latest) {\n        params.latest = true;\n      }\n      ajax$$1(opts, {\n        url: genDBUrl(host, '_bulk_get' + paramsToStr(params)),\n        method: 'POST',\n        body: { docs: opts.docs}\n      }, cb);\n    }\n\n    /* istanbul ignore next */\n    function doBulkGetShim() {\n      // avoid \"url too long error\" by splitting up into multiple requests\n      var batchSize = MAX_SIMULTANEOUS_REVS;\n      var numBatches = Math.ceil(opts.docs.length / batchSize);\n      var numDone = 0;\n      var results = new Array(numBatches);\n\n      function onResult(batchNum) {\n        return function (err, res) {\n          // err is impossible because shim returns a list of errs in that case\n          results[batchNum] = res.results;\n          if (++numDone === numBatches) {\n            callback(null, {results: flatten(results)});\n          }\n        };\n      }\n\n      for (var i = 0; i < numBatches; i++) {\n        var subOpts = pick(opts, ['revs', 'attachments', 'latest']);\n        subOpts.ajax = ajaxOpts;\n        subOpts.docs = opts.docs.slice(i * batchSize,\n          Math.min(opts.docs.length, (i + 1) * batchSize));\n        bulkGet(self, subOpts, onResult(i));\n      }\n    }\n\n    // mark the whole database as either supporting or not supporting _bulk_get\n    var dbUrl = genUrl(host, '');\n    var supportsBulkGet = supportsBulkGetMap[dbUrl];\n\n    /* istanbul ignore next */\n    if (typeof supportsBulkGet !== 'boolean') {\n      // check if this database supports _bulk_get\n      doBulkGet(function (err, res) {\n        if (err) {\n          supportsBulkGetMap[dbUrl] = false;\n          explainError(\n            err.status,\n            'PouchDB is just detecting if the remote ' +\n            'supports the _bulk_get API.'\n          );\n          doBulkGetShim();\n        } else {\n          supportsBulkGetMap[dbUrl] = true;\n          callback(null, res);\n        }\n      });\n    } else if (supportsBulkGet) {\n      doBulkGet(callback);\n    } else {\n      doBulkGetShim();\n    }\n  });\n\n  // Calls GET on the host, which gets back a JSON string containing\n  //    couchdb: A welcome string\n  //    version: The version of CouchDB it is running\n  api._info = function (callback) {\n    setup().then(function () {\n      ajax$$1({}, {\n        method: 'GET',\n        url: genDBUrl(host, '')\n      }, function (err, res) {\n        /* istanbul ignore next */\n        if (err) {\n        return callback(err);\n        }\n        res.host = genDBUrl(host, '');\n        callback(null, res);\n      });\n    }).catch(callback);\n  };\n\n  // Get the document with the given id from the database given by host.\n  // The id could be solely the _id in the database, or it may be a\n  // _design/ID or _local/ID path\n  api.get = adapterFun$$1('get', function (id, opts, callback) {\n    // If no options were given, set the callback to the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n\n    if (opts.revs) {\n      params.revs = true;\n    }\n\n    if (opts.revs_info) {\n      params.revs_info = true;\n    }\n\n    if (opts.latest) {\n      params.latest = true;\n    }\n\n    if (opts.open_revs) {\n      if (opts.open_revs !== \"all\") {\n        opts.open_revs = JSON.stringify(opts.open_revs);\n      }\n      params.open_revs = opts.open_revs;\n    }\n\n    if (opts.rev) {\n      params.rev = opts.rev;\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = opts.conflicts;\n    }\n\n    id = encodeDocId(id);\n\n    // Set the options for the ajax call\n    var options = {\n      method: 'GET',\n      url: genDBUrl(host, id + paramsToStr(params))\n    };\n\n    function fetchAttachments(doc) {\n      var atts = doc._attachments;\n      var filenames = atts && Object.keys(atts);\n      if (!atts || !filenames.length) {\n        return;\n      }\n      // we fetch these manually in separate XHRs, because\n      // Sync Gateway would normally send it back as multipart/mixed,\n      // which we cannot parse. Also, this is more efficient than\n      // receiving attachments as base64-encoded strings.\n      function fetch(filename) {\n        var att = atts[filename];\n        var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +\n          '?rev=' + doc._rev;\n        return ajaxPromise(opts, {\n          method: 'GET',\n          url: genDBUrl(host, path),\n          binary: true\n        }).then(function (blob) {\n          if (opts.binary) {\n            return blob;\n          }\n          return new PouchPromise$1(function (resolve) {\n            blobToBase64(blob, resolve);\n          });\n        }).then(function (data) {\n          delete att.stub;\n          delete att.length;\n          att.data = data;\n        });\n      }\n\n      var promiseFactories = filenames.map(function (filename) {\n        return function () {\n          return fetch(filename);\n        };\n      });\n\n      // This limits the number of parallel xhr requests to 5 any time\n      // to avoid issues with maximum browser request limits\n      return pool(promiseFactories, 5);\n    }\n\n    function fetchAllAttachments(docOrDocs) {\n      if (Array.isArray(docOrDocs)) {\n        return PouchPromise$1.all(docOrDocs.map(function (doc) {\n          if (doc.ok) {\n            return fetchAttachments(doc.ok);\n          }\n        }));\n      }\n      return fetchAttachments(docOrDocs);\n    }\n\n    ajaxPromise(opts, options).then(function (res) {\n      return PouchPromise$1.resolve().then(function () {\n        if (opts.attachments) {\n          return fetchAllAttachments(res);\n        }\n      }).then(function () {\n        callback(null, res);\n      });\n    }).catch(function (e) {\n      e.docId = id;\n      callback(e);\n    });\n  });\n\n  // Delete the document given by doc from the database given by host.\n  api.remove = adapterFun$$1('remove',\n      function (docOrId, optsOrRev, opts, callback) {\n    var doc;\n    if (typeof optsOrRev === 'string') {\n      // id, rev, opts, callback style\n      doc = {\n        _id: docOrId,\n        _rev: optsOrRev\n      };\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n    } else {\n      // doc, opts, callback style\n      doc = docOrId;\n      if (typeof optsOrRev === 'function') {\n        callback = optsOrRev;\n        opts = {};\n      } else {\n        callback = opts;\n        opts = optsOrRev;\n      }\n    }\n\n    var rev$$1 = (doc._rev || opts.rev);\n\n    // Delete the document\n    ajax$$1(opts, {\n      method: 'DELETE',\n      url: genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev$$1\n    }, callback);\n  });\n\n  function encodeAttachmentId(attachmentId) {\n    return attachmentId.split(\"/\").map(encodeURIComponent).join(\"/\");\n  }\n\n  // Get the attachment\n  api.getAttachment =\n    adapterFun$$1('getAttachment', function (docId, attachmentId, opts,\n                                                callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var params = opts.rev ? ('?rev=' + opts.rev) : '';\n    var url = genDBUrl(host, encodeDocId(docId)) + '/' +\n      encodeAttachmentId(attachmentId) + params;\n    ajax$$1(opts, {\n      method: 'GET',\n      url: url,\n      binary: true\n    }, callback);\n  });\n\n  // Remove the attachment given by the id and rev\n  api.removeAttachment =\n    adapterFun$$1('removeAttachment', function (docId, attachmentId, rev$$1,\n                                                   callback) {\n\n    var url = genDBUrl(host, encodeDocId(docId) + '/' +\n      encodeAttachmentId(attachmentId)) + '?rev=' + rev$$1;\n\n    ajax$$1({}, {\n      method: 'DELETE',\n      url: url\n    }, callback);\n  });\n\n  // Add the attachment given by blob and its contentType property\n  // to the document with the given id, the revision given by rev, and\n  // add it to the database given by host.\n  api.putAttachment =\n    adapterFun$$1('putAttachment', function (docId, attachmentId, rev$$1, blob,\n                                                type, callback) {\n    if (typeof type === 'function') {\n      callback = type;\n      type = blob;\n      blob = rev$$1;\n      rev$$1 = null;\n    }\n    var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);\n    var url = genDBUrl(host, id);\n    if (rev$$1) {\n      url += '?rev=' + rev$$1;\n    }\n\n    if (typeof blob === 'string') {\n      // input is assumed to be a base64 string\n      var binary;\n      try {\n        binary = thisAtob(blob);\n      } catch (err) {\n        return callback(createError(BAD_ARG,\n                        'Attachment is not a valid base64 string'));\n      }\n      blob = binary ? binStringToBluffer(binary, type) : '';\n    }\n\n    var opts = {\n      headers: {'Content-Type': type},\n      method: 'PUT',\n      url: url,\n      processData: false,\n      body: blob,\n      timeout: ajaxOpts.timeout || 60000\n    };\n    // Add the attachment\n    ajax$$1({}, opts, callback);\n  });\n\n  // Update/create multiple documents given by req in the database\n  // given by host.\n  api._bulkDocs = function (req, opts, callback) {\n    // If new_edits=false then it prevents the database from creating\n    // new revision numbers for the documents. Instead it just uses\n    // the old ones. This is used in database replication.\n    req.new_edits = opts.new_edits;\n\n    setup().then(function () {\n      return PouchPromise$1.all(req.docs.map(preprocessAttachments$2));\n    }).then(function () {\n      // Update/create the documents\n      ajax$$1(opts, {\n        method: 'POST',\n        url: genDBUrl(host, '_bulk_docs'),\n        timeout: opts.timeout,\n        body: req\n      }, function (err, results) {\n        if (err) {\n          return callback(err);\n        }\n        results.forEach(function (result) {\n          result.ok = true; // smooths out cloudant not adding this\n        });\n        callback(null, results);\n      });\n    }).catch(callback);\n  };\n\n\n  // Update/create document\n  api._put = function (doc, opts, callback) {\n    setup().then(function () {\n      return preprocessAttachments$2(doc);\n    }).then(function () {\n      // Update/create the document\n      ajax$$1(opts, {\n        method: 'PUT',\n        url: genDBUrl(host, encodeDocId(doc._id)),\n        body: doc\n      }, function (err, result) {\n        if (err) {\n          err.docId = doc && doc._id;\n          return callback(err);\n        }\n        callback(null, result);\n      });\n    }).catch(callback);\n  };\n\n\n  // Get a listing of the documents in the database given\n  // by host and ordered by increasing id.\n  api.allDocs = adapterFun$$1('allDocs', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n    var body;\n    var method = 'GET';\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    if (opts.include_docs) {\n      params.include_docs = true;\n    }\n\n    // added in CouchDB 1.6.0\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.key) {\n      params.key = JSON.stringify(opts.key);\n    }\n\n    if (opts.start_key) {\n      opts.startkey = opts.start_key;\n    }\n\n    if (opts.startkey) {\n      params.startkey = JSON.stringify(opts.startkey);\n    }\n\n    if (opts.end_key) {\n      opts.endkey = opts.end_key;\n    }\n\n    if (opts.endkey) {\n      params.endkey = JSON.stringify(opts.endkey);\n    }\n\n    if (typeof opts.inclusive_end !== 'undefined') {\n      params.inclusive_end = !!opts.inclusive_end;\n    }\n\n    if (typeof opts.limit !== 'undefined') {\n      params.limit = opts.limit;\n    }\n\n    if (typeof opts.skip !== 'undefined') {\n      params.skip = opts.skip;\n    }\n\n    var paramStr = paramsToStr(params);\n\n    if (typeof opts.keys !== 'undefined') {\n      method = 'POST';\n      body = {keys: opts.keys};\n    }\n\n    // Get the document listing\n    ajaxPromise(opts, {\n      method: method,\n      url: genDBUrl(host, '_all_docs' + paramStr),\n      body: body\n    }).then(function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        res.rows.forEach(readAttachmentsAsBlobOrBuffer);\n      }\n      callback(null, res);\n    }).catch(callback);\n  });\n\n  // Get a list of changes made to documents in the database given by host.\n  // TODO According to the README, there should be two other methods here,\n  // api.changes.addListener and api.changes.removeListener.\n  api._changes = function (opts) {\n\n    // We internally page the results of a changes request, this means\n    // if there is a large set of changes to be returned we can start\n    // processing them quicker instead of waiting on the entire\n    // set of changes to return and attempting to process them at once\n    var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;\n\n    opts = clone(opts);\n\n    if (opts.continuous && !('heartbeat' in opts)) {\n      opts.heartbeat = DEFAULT_HEARTBEAT;\n    }\n\n    var requestTimeout = ('timeout' in opts) ? opts.timeout :\n      ('timeout' in ajaxOpts) ? ajaxOpts.timeout :\n      30 * 1000;\n\n    // ensure CHANGES_TIMEOUT_BUFFER applies\n    if ('timeout' in opts && opts.timeout &&\n      (requestTimeout - opts.timeout) < CHANGES_TIMEOUT_BUFFER) {\n        requestTimeout = opts.timeout + CHANGES_TIMEOUT_BUFFER;\n    }\n\n    if ('heartbeat' in opts && opts.heartbeat &&\n       (requestTimeout - opts.heartbeat) < CHANGES_TIMEOUT_BUFFER) {\n        requestTimeout = opts.heartbeat + CHANGES_TIMEOUT_BUFFER;\n    }\n\n    var params = {};\n    if ('timeout' in opts && opts.timeout) {\n      params.timeout = opts.timeout;\n    }\n\n    var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;\n    var returnDocs;\n    if ('return_docs' in opts) {\n      returnDocs = opts.return_docs;\n    } else if ('returnDocs' in opts) {\n      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n      returnDocs = opts.returnDocs;\n    } else {\n      returnDocs = true;\n    }\n    //\n    var leftToFetch = limit;\n\n    if (opts.style) {\n      params.style = opts.style;\n    }\n\n    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n      params.include_docs = true;\n    }\n\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.continuous) {\n      params.feed = 'longpoll';\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    if ('heartbeat' in opts) {\n      // If the heartbeat value is false, it disables the default heartbeat\n      if (opts.heartbeat) {\n        params.heartbeat = opts.heartbeat;\n      }\n    }\n\n    if (opts.filter && typeof opts.filter === 'string') {\n      params.filter = opts.filter;\n    }\n\n    if (opts.view && typeof opts.view === 'string') {\n      params.filter = '_view';\n      params.view = opts.view;\n    }\n\n    // If opts.query_params exists, pass it through to the changes request.\n    // These parameters may be used by the filter on the source database.\n    if (opts.query_params && typeof opts.query_params === 'object') {\n      for (var param_name in opts.query_params) {\n        /* istanbul ignore else */\n        if (opts.query_params.hasOwnProperty(param_name)) {\n          params[param_name] = opts.query_params[param_name];\n        }\n      }\n    }\n\n    var method = 'GET';\n    var body;\n\n    if (opts.doc_ids) {\n      // set this automagically for the user; it's annoying that couchdb\n      // requires both a \"filter\" and a \"doc_ids\" param.\n      params.filter = '_doc_ids';\n      method = 'POST';\n      body = {doc_ids: opts.doc_ids };\n    }\n    /* istanbul ignore next */\n    else if (opts.selector) {\n      // set this automagically for the user, similar to above\n      params.filter = '_selector';\n      method = 'POST';\n      body = {selector: opts.selector };\n    }\n\n    var xhr;\n    var lastFetchedSeq;\n\n    // Get all the changes starting wtih the one immediately after the\n    // sequence number given by since.\n    var fetch = function (since, callback) {\n      if (opts.aborted) {\n        return;\n      }\n      params.since = since;\n      // \"since\" can be any kind of json object in Coudant/CouchDB 2.x\n      /* istanbul ignore next */\n      if (typeof params.since === \"object\") {\n        params.since = JSON.stringify(params.since);\n      }\n\n      if (opts.descending) {\n        if (limit) {\n          params.limit = leftToFetch;\n        }\n      } else {\n        params.limit = (!limit || leftToFetch > batchSize) ?\n          batchSize : leftToFetch;\n      }\n\n      // Set the options for the ajax call\n      var xhrOpts = {\n        method: method,\n        url: genDBUrl(host, '_changes' + paramsToStr(params)),\n        timeout: requestTimeout,\n        body: body\n      };\n      lastFetchedSeq = since;\n\n      /* istanbul ignore if */\n      if (opts.aborted) {\n        return;\n      }\n\n      // Get the changes\n      setup().then(function () {\n        xhr = ajax$$1(opts, xhrOpts, callback);\n      }).catch(callback);\n    };\n\n    // If opts.since exists, get all the changes from the sequence\n    // number given by opts.since. Otherwise, get all the changes\n    // from the sequence number 0.\n    var results = {results: []};\n\n    var fetched = function (err, res) {\n      if (opts.aborted) {\n        return;\n      }\n      var raw_results_length = 0;\n      // If the result of the ajax call (res) contains changes (res.results)\n      if (res && res.results) {\n        raw_results_length = res.results.length;\n        results.last_seq = res.last_seq;\n        // For each change\n        var req = {};\n        req.query = opts.query_params;\n        res.results = res.results.filter(function (c) {\n          leftToFetch--;\n          var ret = filterChange(opts)(c);\n          if (ret) {\n            if (opts.include_docs && opts.attachments && opts.binary) {\n              readAttachmentsAsBlobOrBuffer(c);\n            }\n            if (returnDocs) {\n              results.results.push(c);\n            }\n            opts.onChange(c);\n          }\n          return ret;\n        });\n      } else if (err) {\n        // In case of an error, stop listening for changes and call\n        // opts.complete\n        opts.aborted = true;\n        opts.complete(err);\n        return;\n      }\n\n      // The changes feed may have timed out with no results\n      // if so reuse last update sequence\n      if (res && res.last_seq) {\n        lastFetchedSeq = res.last_seq;\n      }\n\n      var finished = (limit && leftToFetch <= 0) ||\n        (res && raw_results_length < batchSize) ||\n        (opts.descending);\n\n      if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {\n        // Queue a call to fetch again with the newest sequence number\n        nextTick(function () { fetch(lastFetchedSeq, fetched); });\n      } else {\n        // We're done, call the callback\n        opts.complete(null, results);\n      }\n    };\n\n    fetch(opts.since || 0, fetched);\n\n    // Return a method to cancel this method from processing any more\n    return {\n      cancel: function () {\n        opts.aborted = true;\n        if (xhr) {\n          xhr.abort();\n        }\n      }\n    };\n  };\n\n  // Given a set of document/revision IDs (given by req), tets the subset of\n  // those that do NOT correspond to revisions stored in the database.\n  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n  api.revsDiff = adapterFun$$1('revsDiff', function (req, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Get the missing document/revision IDs\n    ajax$$1(opts, {\n      method: 'POST',\n      url: genDBUrl(host, '_revs_diff'),\n      body: req\n    }, callback);\n  });\n\n  api._close = function (callback) {\n    callback();\n  };\n\n  api._destroy = function (options, callback) {\n    ajax$$1(options, {\n      url: genDBUrl(host, ''),\n      method: 'DELETE'\n    }, function (err, resp) {\n      if (err && err.status && err.status !== 404) {\n        return callback(err);\n      }\n      callback(null, resp);\n    });\n  };\n}\n\n// HttpPouch is a valid adapter.\nHttpPouch.valid = function () {\n  return true;\n};\n\nvar HttpPouch$1 = function (PouchDB) {\n  PouchDB.adapter('http', HttpPouch, false);\n  PouchDB.adapter('https', HttpPouch, false);\n};\n\nfunction QueryParseError(message) {\n  this.status = 400;\n  this.name = 'query_parse_error';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, QueryParseError);\n  } catch (e) {}\n}\n\ninherits(QueryParseError, Error);\n\nfunction NotFoundError(message) {\n  this.status = 404;\n  this.name = 'not_found';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, NotFoundError);\n  } catch (e) {}\n}\n\ninherits(NotFoundError, Error);\n\nfunction BuiltInError(message) {\n  this.status = 500;\n  this.name = 'invalid_value';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, BuiltInError);\n  } catch (e) {}\n}\n\ninherits(BuiltInError, Error);\n\nfunction promisedCallback(promise, callback) {\n  if (callback) {\n    promise.then(function (res) {\n      nextTick(function () {\n        callback(null, res);\n      });\n    }, function (reason) {\n      nextTick(function () {\n        callback(reason);\n      });\n    });\n  }\n  return promise;\n}\n\nfunction callbackify(fun) {\n  return getArguments(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    if (typeof cb === 'function') {\n      promisedCallback(promise, cb);\n    }\n    return promise;\n  });\n}\n\n// Promise finally util similar to Q.finally\nfunction fin(promise, finalPromiseFactory) {\n  return promise.then(function (res) {\n    return finalPromiseFactory().then(function () {\n      return res;\n    });\n  }, function (reason) {\n    return finalPromiseFactory().then(function () {\n      throw reason;\n    });\n  });\n}\n\nfunction sequentialize(queue, promiseFactory) {\n  return function () {\n    var args = arguments;\n    var that = this;\n    return queue.add(function () {\n      return promiseFactory.apply(that, args);\n    });\n  };\n}\n\n// uniq an array of strings, order not guaranteed\n// similar to underscore/lodash _.uniq\nfunction uniq(arr) {\n  var theSet = new ExportedSet(arr);\n  var result = new Array(theSet.size);\n  var index = -1;\n  theSet.forEach(function (value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nfunction mapToKeysArray(map) {\n  var result = new Array(map.size);\n  var index = -1;\n  map.forEach(function (value, key) {\n    result[++index] = key;\n  });\n  return result;\n}\n\nfunction createBuiltInError(name) {\n  var message = 'builtin ' + name +\n    ' function requires map values to be numbers' +\n    ' or number arrays';\n  return new BuiltInError(message);\n}\n\nfunction sum(values) {\n  var result = 0;\n  for (var i = 0, len = values.length; i < len; i++) {\n    var num = values[i];\n    if (typeof num !== 'number') {\n      if (Array.isArray(num)) {\n        // lists of numbers are also allowed, sum them separately\n        result = typeof result === 'number' ? [result] : result;\n        for (var j = 0, jLen = num.length; j < jLen; j++) {\n          var jNum = num[j];\n          if (typeof jNum !== 'number') {\n            throw createBuiltInError('_sum');\n          } else if (typeof result[j] === 'undefined') {\n            result.push(jNum);\n          } else {\n            result[j] += jNum;\n          }\n        }\n      } else { // not array/number\n        throw createBuiltInError('_sum');\n      }\n    } else if (typeof result === 'number') {\n      result += num;\n    } else { // add number to array\n      result[0] += num;\n    }\n  }\n  return result;\n}\n\nvar log = guardedConsole.bind(null, 'log');\nvar isArray = Array.isArray;\nvar toJSON = JSON.parse;\n\nfunction evalFunctionWithEval(func, emit) {\n  return scopeEval(\n    \"return (\" + func.replace(/;\\s*$/, \"\") + \");\",\n    {\n      emit: emit,\n      sum: sum,\n      log: log,\n      isArray: isArray,\n      toJSON: toJSON\n    }\n  );\n}\n\n/*\n * Simple task queue to sequentialize actions. Assumes\n * callbacks will eventually fire (once).\n */\n\n\nfunction TaskQueue$2() {\n  this.promise = new PouchPromise$1(function (fulfill) {fulfill(); });\n}\nTaskQueue$2.prototype.add = function (promiseFactory) {\n  this.promise = this.promise.catch(function () {\n    // just recover\n  }).then(function () {\n    return promiseFactory();\n  });\n  return this.promise;\n};\nTaskQueue$2.prototype.finish = function () {\n  return this.promise;\n};\n\nfunction stringify(input) {\n  if (!input) {\n    return 'undefined'; // backwards compat for empty reduce\n  }\n  // for backwards compat with mapreduce, functions/strings are stringified\n  // as-is. everything else is JSON-stringified.\n  switch (typeof input) {\n    case 'function':\n      // e.g. a mapreduce map\n      return input.toString();\n    case 'string':\n      // e.g. a mapreduce built-in _reduce function\n      return input.toString();\n    default:\n      // e.g. a JSON object in the case of mango queries\n      return JSON.stringify(input);\n  }\n}\n\n/* create a string signature for a view so we can cache it and uniq it */\nfunction createViewSignature(mapFun, reduceFun) {\n  // the \"undefined\" part is for backwards compatibility\n  return stringify(mapFun) + stringify(reduceFun) + 'undefined';\n}\n\nfunction createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {\n  var viewSignature = createViewSignature(mapFun, reduceFun);\n\n  var cachedViews;\n  if (!temporary) {\n    // cache this to ensure we don't try to update the same view twice\n    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n    if (cachedViews[viewSignature]) {\n      return cachedViews[viewSignature];\n    }\n  }\n\n  var promiseForView = sourceDB.info().then(function (info) {\n\n    var depDbName = info.db_name + '-mrview-' +\n      (temporary ? 'temp' : stringMd5(viewSignature));\n\n    // save the view name in the source db so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      var fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    return upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {\n      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n        var db = res.db;\n        db.auto_compaction = true;\n        var view = {\n          name: depDbName,\n          db: db,\n          sourceDB: sourceDB,\n          adapter: sourceDB.adapter,\n          mapFun: mapFun,\n          reduceFun: reduceFun\n        };\n        return view.db.get('_local/lastSeq').catch(function (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            throw err;\n          }\n        }).then(function (lastSeqDoc) {\n          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n          if (cachedViews) {\n            view.db.once('destroyed', function () {\n              delete cachedViews[viewSignature];\n            });\n          }\n          return view;\n        });\n      });\n    });\n  });\n\n  if (cachedViews) {\n    cachedViews[viewSignature] = promiseForView;\n  }\n  return promiseForView;\n}\n\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue$2();\nvar CHANGES_BATCH_SIZE$1 = 50;\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction emitError(db, e) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    guardedConsole('error',\n      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n      'You can debug this error by doing:\\n' +\n      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n      'Please double-check your map/reduce function.');\n    guardedConsole('error', e);\n  }\n}\n\n/**\n * Returns an \"abstract\" mapreduce object of the form:\n *\n *   {\n *     query: queryFun,\n *     viewCleanup: viewCleanupFun\n *   }\n *\n * Arguments are:\n *\n * localDoc: string\n *   This is for the local doc that gets saved in order to track the\n *   \"dependent\" DBs and clean them up for viewCleanup. It should be\n *   unique, so that indexer plugins don't collide with each other.\n * mapper: function (mapFunDef, emit)\n *   Returns a map function based on the mapFunDef, which in the case of\n *   normal map/reduce is just the de-stringified function, but may be\n *   something else, such as an object in the case of pouchdb-find.\n * reducer: function (reduceFunDef)\n *   Ditto, but for reducing. Modules don't have to support reducing\n *   (e.g. pouchdb-find).\n * ddocValidator: function (ddoc, viewName)\n *   Throws an error if the ddoc or viewName is not valid.\n *   This could be a way to communicate to the user that the configuration for the\n *   indexer is invalid.\n */\nfunction createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {\n\n  function tryMap(db, fun, doc) {\n    // emit an event if there was an error thrown by a map function.\n    // putting try/catches in a single function also avoids deoptimizations.\n    try {\n      fun(doc);\n    } catch (e) {\n      emitError(db, e);\n    }\n  }\n\n  function tryReduce(db, fun, keys, values, rereduce) {\n    // same as above, but returning the result or an error. there are two separate\n    // functions to avoid extra memory allocations since the tryCode() case is used\n    // for custom map functions (common) vs this function, which is only used for\n    // custom reduce functions (rare)\n    try {\n      return {output : fun(keys, values, rereduce)};\n    } catch (e) {\n      emitError(db, e);\n      return {error: e};\n    }\n  }\n\n  function sortByKeyThenValue(x, y) {\n    var keyCompare = collate(x.key, y.key);\n    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n  }\n\n  function sliceResults(results, limit, skip) {\n    skip = skip || 0;\n    if (typeof limit === 'number') {\n      return results.slice(skip, limit + skip);\n    } else if (skip > 0) {\n      return results.slice(skip);\n    }\n    return results;\n  }\n\n  function rowToDocId(row) {\n    var val = row.value;\n    // Users can explicitly specify a joined doc _id, or it\n    // defaults to the doc _id that emitted the key/value.\n    var docId = (val && typeof val === 'object' && val._id) || row.id;\n    return docId;\n  }\n\n  function readAttachmentsAsBlobOrBuffer(res) {\n    res.rows.forEach(function (row) {\n      var atts = row.doc && row.doc._attachments;\n      if (!atts) {\n        return;\n      }\n      Object.keys(atts).forEach(function (filename) {\n        var att = atts[filename];\n        atts[filename].data = b64ToBluffer(att.data, att.content_type);\n      });\n    });\n  }\n\n  function postprocessAttachments(opts) {\n    return function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        readAttachmentsAsBlobOrBuffer(res);\n      }\n      return res;\n    };\n  }\n\n  function addHttpParam(paramName, opts, params, asJson) {\n    // add an http param from opts to params, optionally json-encoded\n    var val = opts[paramName];\n    if (typeof val !== 'undefined') {\n      if (asJson) {\n        val = encodeURIComponent(JSON.stringify(val));\n      }\n      params.push(paramName + '=' + val);\n    }\n  }\n\n  function coerceInteger(integerCandidate) {\n    if (typeof integerCandidate !== 'undefined') {\n      var asNumber = Number(integerCandidate);\n      // prevents e.g. '1foo' or '1.1' being coerced to 1\n      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n        return asNumber;\n      } else {\n        return integerCandidate;\n      }\n    }\n  }\n\n  function coerceOptions(opts) {\n    opts.group_level = coerceInteger(opts.group_level);\n    opts.limit = coerceInteger(opts.limit);\n    opts.skip = coerceInteger(opts.skip);\n    return opts;\n  }\n\n  function checkPositiveInteger(number) {\n    if (number) {\n      if (typeof number !== 'number') {\n        return  new QueryParseError('Invalid value for integer: \"' +\n          number + '\"');\n      }\n      if (number < 0) {\n        return new QueryParseError('Invalid value for positive integer: ' +\n          '\"' + number + '\"');\n      }\n    }\n  }\n\n  function checkQueryParseError(options, fun) {\n    var startkeyName = options.descending ? 'endkey' : 'startkey';\n    var endkeyName = options.descending ? 'startkey' : 'endkey';\n\n    if (typeof options[startkeyName] !== 'undefined' &&\n      typeof options[endkeyName] !== 'undefined' &&\n      collate(options[startkeyName], options[endkeyName]) > 0) {\n      throw new QueryParseError('No rows can match your key range, ' +\n        'reverse your start_key and end_key or set {descending : true}');\n    } else if (fun.reduce && options.reduce !== false) {\n      if (options.include_docs) {\n        throw new QueryParseError('{include_docs:true} is invalid for reduce');\n      } else if (options.keys && options.keys.length > 1 &&\n        !options.group && !options.group_level) {\n        throw new QueryParseError('Multi-key fetches for reduce views must use ' +\n          '{group: true}');\n      }\n    }\n    ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n      var error = checkPositiveInteger(options[optionName]);\n      if (error) {\n        throw error;\n      }\n    });\n  }\n\n  function httpQuery(db, fun, opts) {\n    // List of parameters to add to the PUT request\n    var params = [];\n    var body;\n    var method = 'GET';\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    addHttpParam('reduce', opts, params);\n    addHttpParam('include_docs', opts, params);\n    addHttpParam('attachments', opts, params);\n    addHttpParam('limit', opts, params);\n    addHttpParam('descending', opts, params);\n    addHttpParam('group', opts, params);\n    addHttpParam('group_level', opts, params);\n    addHttpParam('skip', opts, params);\n    addHttpParam('stale', opts, params);\n    addHttpParam('conflicts', opts, params);\n    addHttpParam('startkey', opts, params, true);\n    addHttpParam('start_key', opts, params, true);\n    addHttpParam('endkey', opts, params, true);\n    addHttpParam('end_key', opts, params, true);\n    addHttpParam('inclusive_end', opts, params);\n    addHttpParam('key', opts, params, true);\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // If keys are supplied, issue a POST to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      var MAX_URL_LENGTH = 2000;\n      // according to http://stackoverflow.com/a/417184/680742,\n      // the de facto URL length limit is 2000 characters\n\n      var keysAsString =\n        'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n        // If the keys are short enough, do a GET. we do this to work around\n        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n        params += (params[0] === '?' ? '&' : '?') + keysAsString;\n      } else {\n        method = 'POST';\n        if (typeof fun === 'string') {\n          body = {keys: opts.keys};\n        } else { // fun is {map : mapfun}, so append to this\n          fun.keys = opts.keys;\n        }\n      }\n    }\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      var parts = parseViewName(fun);\n      return db.request({\n        method: method,\n        url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\n        body: body\n      }).then(\n        /* istanbul ignore next */\n        function (result) {\n          // fail the entire request if the result contains an error\n          result.rows.forEach(function (row) {\n            if (row.value && row.value.error && row.value.error === \"builtin_reduce_error\") {\n              throw new Error(row.reason);\n            }\n          });\n\n          return result;\n      })\n      .then(postprocessAttachments(opts));\n    }\n\n    // We are using a temporary view, terrible for performance, good for testing\n    body = body || {};\n    Object.keys(fun).forEach(function (key) {\n      if (Array.isArray(fun[key])) {\n        body[key] = fun[key];\n      } else {\n        body[key] = fun[key].toString();\n      }\n    });\n    return db.request({\n      method: 'POST',\n      url: '_temp_view' + params,\n      body: body\n    }).then(postprocessAttachments(opts));\n  }\n\n  // custom adapters can define their own api._query\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customQuery(db, fun, opts) {\n    return new PouchPromise$1(function (resolve, reject) {\n      db._query(fun, opts, function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  // custom adapters can define their own api._viewCleanup\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customViewCleanup(db) {\n    return new PouchPromise$1(function (resolve, reject) {\n      db._viewCleanup(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function defaultsTo(value) {\n    return function (reason) {\n      /* istanbul ignore else */\n      if (reason.status === 404) {\n        return value;\n      } else {\n        throw reason;\n      }\n    };\n  }\n\n  // returns a promise for a list of docs to update, based on the input docId.\n  // the order doesn't matter, because post-3.2.0, bulkDocs\n  // is an atomic operation in all three adapters.\n  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n    var metaDocId = '_local/doc_' + docId;\n    var defaultMetaDoc = {_id: metaDocId, keys: []};\n    var docData = docIdsToChangesAndEmits.get(docId);\n    var indexableKeysToKeyValues = docData[0];\n    var changes = docData[1];\n\n    function getMetaDoc() {\n      if (isGenOne(changes)) {\n        // generation 1, so we can safely assume initial state\n        // for performance reasons (avoids unnecessary GETs)\n        return PouchPromise$1.resolve(defaultMetaDoc);\n      }\n      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n    }\n\n    function getKeyValueDocs(metaDoc) {\n      if (!metaDoc.keys.length) {\n        // no keys, no need for a lookup\n        return PouchPromise$1.resolve({rows: []});\n      }\n      return view.db.allDocs({\n        keys: metaDoc.keys,\n        include_docs: true\n      });\n    }\n\n    function processKeyValueDocs(metaDoc, kvDocsRes) {\n      var kvDocs = [];\n      var oldKeys = new ExportedSet();\n\n      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n        var row = kvDocsRes.rows[i];\n        var doc = row.doc;\n        if (!doc) { // deleted\n          continue;\n        }\n        kvDocs.push(doc);\n        oldKeys.add(doc._id);\n        doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n        if (!doc._deleted) {\n          var keyValue = indexableKeysToKeyValues.get(doc._id);\n          if ('value' in keyValue) {\n            doc.value = keyValue.value;\n          }\n        }\n      }\n      var newKeys = mapToKeysArray(indexableKeysToKeyValues);\n      newKeys.forEach(function (key) {\n        if (!oldKeys.has(key)) {\n          // new doc\n          var kvDoc = {\n            _id: key\n          };\n          var keyValue = indexableKeysToKeyValues.get(key);\n          if ('value' in keyValue) {\n            kvDoc.value = keyValue.value;\n          }\n          kvDocs.push(kvDoc);\n        }\n      });\n      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n      kvDocs.push(metaDoc);\n\n      return kvDocs;\n    }\n\n    return getMetaDoc().then(function (metaDoc) {\n      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n        return processKeyValueDocs(metaDoc, kvDocsRes);\n      });\n    });\n  }\n\n  // updates all emitted key/value docs and metaDocs in the mrview database\n  // for the given batch of documents from the source database\n  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n    var seqDocId = '_local/lastSeq';\n    return view.db.get(seqDocId)\n      .catch(defaultsTo({_id: seqDocId, seq: 0}))\n      .then(function (lastSeqDoc) {\n        var docIds = mapToKeysArray(docIdsToChangesAndEmits);\n        return PouchPromise$1.all(docIds.map(function (docId) {\n          return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n        })).then(function (listOfDocsToPersist) {\n          var docsToPersist = flatten(listOfDocsToPersist);\n          lastSeqDoc.seq = seq;\n          docsToPersist.push(lastSeqDoc);\n          // write all docs in a single operation, update the seq once\n          return view.db.bulkDocs({docs : docsToPersist});\n        });\n      });\n  }\n\n  function getQueue(view) {\n    var viewName = typeof view === 'string' ? view : view.name;\n    var queue = persistentQueues[viewName];\n    if (!queue) {\n      queue = persistentQueues[viewName] = new TaskQueue$2();\n    }\n    return queue;\n  }\n\n  function updateView(view) {\n    return sequentialize(getQueue(view), function () {\n      return updateViewInQueue(view);\n    })();\n  }\n\n  function updateViewInQueue(view) {\n    // bind the emit function once\n    var mapResults;\n    var doc;\n\n    function emit(key, value) {\n      var output = {id: doc._id, key: normalizeKey(key)};\n      // Don't explicitly store the value unless it's defined and non-null.\n      // This saves on storage space, because often people don't use it.\n      if (typeof value !== 'undefined' && value !== null) {\n        output.value = normalizeKey(value);\n      }\n      mapResults.push(output);\n    }\n\n    var mapFun = mapper(view.mapFun, emit);\n\n    var currentSeq = view.seq || 0;\n\n    function processChange(docIdsToChangesAndEmits, seq) {\n      return function () {\n        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n      };\n    }\n\n    var queue = new TaskQueue$2();\n\n    function processNextBatch() {\n      return view.sourceDB.changes({\n        conflicts: true,\n        include_docs: true,\n        style: 'all_docs',\n        since: currentSeq,\n        limit: CHANGES_BATCH_SIZE$1\n      }).then(processBatch);\n    }\n\n    function processBatch(response) {\n      var results = response.results;\n      if (!results.length) {\n        return;\n      }\n      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n      if (results.length < CHANGES_BATCH_SIZE$1) {\n        return;\n      }\n      return processNextBatch();\n    }\n\n    function createDocIdsToChangesAndEmits(results) {\n      var docIdsToChangesAndEmits = new ExportedMap();\n      for (var i = 0, len = results.length; i < len; i++) {\n        var change = results[i];\n        if (change.doc._id[0] !== '_') {\n          mapResults = [];\n          doc = change.doc;\n\n          if (!doc._deleted) {\n            tryMap(view.sourceDB, mapFun, doc);\n          }\n          mapResults.sort(sortByKeyThenValue);\n\n          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n          docIdsToChangesAndEmits.set(change.doc._id, [\n            indexableKeysToKeyValues,\n            change.changes\n          ]);\n        }\n        currentSeq = change.seq;\n      }\n      return docIdsToChangesAndEmits;\n    }\n\n    function createIndexableKeysToKeyValues(mapResults) {\n      var indexableKeysToKeyValues = new ExportedMap();\n      var lastKey;\n      for (var i = 0, len = mapResults.length; i < len; i++) {\n        var emittedKeyValue = mapResults[i];\n        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {\n          complexKey.push(i); // dup key+id, so make it unique\n        }\n        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);\n        lastKey = emittedKeyValue.key;\n      }\n      return indexableKeysToKeyValues;\n    }\n\n    return processNextBatch().then(function () {\n      return queue.finish();\n    }).then(function () {\n      view.seq = currentSeq;\n    });\n  }\n\n  function reduceView(view, results, options) {\n    if (options.group_level === 0) {\n      delete options.group_level;\n    }\n\n    var shouldGroup = options.group || options.group_level;\n\n    var reduceFun = reducer(view.reduceFun);\n\n    var groups = [];\n    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n      options.group_level;\n    results.forEach(function (e) {\n      var last = groups[groups.length - 1];\n      var groupKey = shouldGroup ? e.key : null;\n\n      // only set group_level for array keys\n      if (shouldGroup && Array.isArray(groupKey)) {\n        groupKey = groupKey.slice(0, lvl);\n      }\n\n      if (last && collate(last.groupKey, groupKey) === 0) {\n        last.keys.push([e.key, e.id]);\n        last.values.push(e.value);\n        return;\n      }\n      groups.push({\n        keys: [[e.key, e.id]],\n        values: [e.value],\n        groupKey: groupKey\n      });\n    });\n    results = [];\n    for (var i = 0, len = groups.length; i < len; i++) {\n      var e = groups[i];\n      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n        // CouchDB returns an error if a built-in errors out\n        throw reduceTry.error;\n      }\n      results.push({\n        // CouchDB just sets the value to null if a non-built-in errors out\n        value: reduceTry.error ? null : reduceTry.output,\n        key: e.groupKey\n      });\n    }\n    // no total_rows/offset when reducing\n    return {rows: sliceResults(results, options.limit, options.skip)};\n  }\n\n  function queryView(view, opts) {\n    return sequentialize(getQueue(view), function () {\n      return queryViewInQueue(view, opts);\n    })();\n  }\n\n  function queryViewInQueue(view, opts) {\n    var totalRows;\n    var shouldReduce = view.reduceFun && opts.reduce !== false;\n    var skip = opts.skip || 0;\n    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n      // equivalent query\n      opts.limit = 0;\n      delete opts.keys;\n    }\n\n    function fetchFromView(viewOpts) {\n      viewOpts.include_docs = true;\n      return view.db.allDocs(viewOpts).then(function (res) {\n        totalRows = res.total_rows;\n        return res.rows.map(function (result) {\n\n          // implicit migration - in older versions of PouchDB,\n          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n          // this is tested in a migration test\n          /* istanbul ignore next */\n          if ('value' in result.doc && typeof result.doc.value === 'object' &&\n            result.doc.value !== null) {\n            var keys = Object.keys(result.doc.value).sort();\n            // this detection method is not perfect, but it's unlikely the user\n            // emitted a value which was an object with these 3 exact keys\n            var expectedKeys = ['id', 'key', 'value'];\n            if (!(keys < expectedKeys || keys > expectedKeys)) {\n              return result.doc.value;\n            }\n          }\n\n          var parsedKeyAndDocId = parseIndexableString(result.doc._id);\n          return {\n            key: parsedKeyAndDocId[0],\n            id: parsedKeyAndDocId[1],\n            value: ('value' in result.doc ? result.doc.value : null)\n          };\n        });\n      });\n    }\n\n    function onMapResultsReady(rows) {\n      var finalResults;\n      if (shouldReduce) {\n        finalResults = reduceView(view, rows, opts);\n      } else {\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: rows\n        };\n      }\n      if (opts.include_docs) {\n        var docIds = uniq(rows.map(rowToDocId));\n\n        return view.sourceDB.allDocs({\n          keys: docIds,\n          include_docs: true,\n          conflicts: opts.conflicts,\n          attachments: opts.attachments,\n          binary: opts.binary\n        }).then(function (allDocsRes) {\n          var docIdsToDocs = new ExportedMap();\n          allDocsRes.rows.forEach(function (row) {\n            docIdsToDocs.set(row.id, row.doc);\n          });\n          rows.forEach(function (row) {\n            var docId = rowToDocId(row);\n            var doc = docIdsToDocs.get(docId);\n            if (doc) {\n              row.doc = doc;\n            }\n          });\n          return finalResults;\n        });\n      } else {\n        return finalResults;\n      }\n    }\n\n    if (typeof opts.keys !== 'undefined') {\n      var keys = opts.keys;\n      var fetchPromises = keys.map(function (key) {\n        var viewOpts = {\n          startkey : toIndexableString([key]),\n          endkey   : toIndexableString([key, {}])\n        };\n        return fetchFromView(viewOpts);\n      });\n      return PouchPromise$1.all(fetchPromises).then(flatten).then(onMapResultsReady);\n    } else { // normal query, no 'keys'\n      var viewOpts = {\n        descending : opts.descending\n      };\n      var startkey;\n      var endkey;\n      if ('start_key' in opts) {\n        startkey = opts.start_key;\n      }\n      if ('startkey' in opts) {\n        startkey = opts.startkey;\n      }\n      if ('end_key' in opts) {\n        endkey = opts.end_key;\n      }\n      if ('endkey' in opts) {\n        endkey = opts.endkey;\n      }\n      if (typeof startkey !== 'undefined') {\n        viewOpts.startkey = opts.descending ?\n          toIndexableString([startkey, {}]) :\n          toIndexableString([startkey]);\n      }\n      if (typeof endkey !== 'undefined') {\n        var inclusiveEnd = opts.inclusive_end !== false;\n        if (opts.descending) {\n          inclusiveEnd = !inclusiveEnd;\n        }\n\n        viewOpts.endkey = toIndexableString(\n          inclusiveEnd ? [endkey, {}] : [endkey]);\n      }\n      if (typeof opts.key !== 'undefined') {\n        var keyStart = toIndexableString([opts.key]);\n        var keyEnd = toIndexableString([opts.key, {}]);\n        if (viewOpts.descending) {\n          viewOpts.endkey = keyStart;\n          viewOpts.startkey = keyEnd;\n        } else {\n          viewOpts.startkey = keyStart;\n          viewOpts.endkey = keyEnd;\n        }\n      }\n      if (!shouldReduce) {\n        if (typeof opts.limit === 'number') {\n          viewOpts.limit = opts.limit;\n        }\n        viewOpts.skip = skip;\n      }\n      return fetchFromView(viewOpts).then(onMapResultsReady);\n    }\n  }\n\n  function httpViewCleanup(db) {\n    return db.request({\n      method: 'POST',\n      url: '_view_cleanup'\n    });\n  }\n\n  function localViewCleanup(db) {\n    return db.get('_local/' + localDocName).then(function (metaDoc) {\n      var docsToViews = new ExportedMap();\n      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n        var parts = parseViewName(fullViewName);\n        var designDocName = '_design/' + parts[0];\n        var viewName = parts[1];\n        var views = docsToViews.get(designDocName);\n        if (!views) {\n          views = new ExportedSet();\n          docsToViews.set(designDocName, views);\n        }\n        views.add(viewName);\n      });\n      var opts = {\n        keys : mapToKeysArray(docsToViews),\n        include_docs : true\n      };\n      return db.allDocs(opts).then(function (res) {\n        var viewsToStatus = {};\n        res.rows.forEach(function (row) {\n          var ddocName = row.key.substring(8); // cuts off '_design/'\n          docsToViews.get(row.key).forEach(function (viewName) {\n            var fullViewName = ddocName + '/' + viewName;\n            /* istanbul ignore if */\n            if (!metaDoc.views[fullViewName]) {\n              // new format, without slashes, to support PouchDB 2.2.0\n              // migration test in pouchdb's browser.migration.js verifies this\n              fullViewName = viewName;\n            }\n            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n            // design doc deleted, or view function nonexistent\n            var statusIsGood = row.doc && row.doc.views &&\n              row.doc.views[viewName];\n            viewDBNames.forEach(function (viewDBName) {\n              viewsToStatus[viewDBName] =\n                viewsToStatus[viewDBName] || statusIsGood;\n            });\n          });\n        });\n        var dbsToDelete = Object.keys(viewsToStatus).filter(\n          function (viewDBName) { return !viewsToStatus[viewDBName]; });\n        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n          return sequentialize(getQueue(viewDBName), function () {\n            return new db.constructor(viewDBName, db.__opts).destroy();\n          })();\n        });\n        return PouchPromise$1.all(destroyPromises).then(function () {\n          return {ok: true};\n        });\n      });\n    }, defaultsTo({ok: true}));\n  }\n\n  function queryPromised(db, fun, opts) {\n    /* istanbul ignore next */\n    if (typeof db._query === 'function') {\n      return customQuery(db, fun, opts);\n    }\n    if (isRemote(db)) {\n      return httpQuery(db, fun, opts);\n    }\n\n    if (typeof fun !== 'string') {\n      // temp_view\n      checkQueryParseError(opts, fun);\n\n      tempViewQueue.add(function () {\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ 'temp_view/temp_view',\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ true,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          return fin(updateView(view).then(function () {\n            return queryView(view, opts);\n          }), function () {\n            return view.db.destroy();\n          });\n        });\n      });\n      return tempViewQueue.finish();\n    } else {\n      // persistent view\n      var fullViewName = fun;\n      var parts = parseViewName(fullViewName);\n      var designDocName = parts[0];\n      var viewName = parts[1];\n      return db.get('_design/' + designDocName).then(function (doc) {\n        var fun = doc.views && doc.views[viewName];\n\n        if (!fun) {\n          // basic validator; it's assumed that every subclass would want this\n          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +\n            viewName);\n        }\n\n        ddocValidator(doc, viewName);\n        checkQueryParseError(opts, fun);\n\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ fullViewName,\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ false,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n            if (opts.stale === 'update_after') {\n              nextTick(function () {\n                updateView(view);\n              });\n            }\n            return queryView(view, opts);\n          } else { // stale not ok\n            return updateView(view).then(function () {\n              return queryView(view, opts);\n            });\n          }\n        });\n      });\n    }\n  }\n\n  function abstractQuery(fun, opts, callback) {\n    var db = this;\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = opts ? coerceOptions(opts) : {};\n\n    if (typeof fun === 'function') {\n      fun = {map : fun};\n    }\n\n    var promise = PouchPromise$1.resolve().then(function () {\n      return queryPromised(db, fun, opts);\n    });\n    promisedCallback(promise, callback);\n    return promise;\n  }\n\n  var abstractViewCleanup = callbackify(function () {\n    var db = this;\n    /* istanbul ignore next */\n    if (typeof db._viewCleanup === 'function') {\n      return customViewCleanup(db);\n    }\n    if (isRemote(db)) {\n      return httpViewCleanup(db);\n    }\n    return localViewCleanup(db);\n  });\n\n  return {\n    query: abstractQuery,\n    viewCleanup: abstractViewCleanup\n  };\n}\n\nvar builtInReduce = {\n  _sum: function (keys, values) {\n    return sum(values);\n  },\n\n  _count: function (keys, values) {\n    return values.length;\n  },\n\n  _stats: function (keys, values) {\n    // no need to implement rereduce=true, because Pouch\n    // will never call it\n    function sumsqr(values) {\n      var _sumsqr = 0;\n      for (var i = 0, len = values.length; i < len; i++) {\n        var num = values[i];\n        _sumsqr += (num * num);\n      }\n      return _sumsqr;\n    }\n    return {\n      sum     : sum(values),\n      min     : Math.min.apply(null, values),\n      max     : Math.max.apply(null, values),\n      count   : values.length,\n      sumsqr : sumsqr(values)\n    };\n  }\n};\n\nfunction getBuiltIn(reduceFunString) {\n  if (/^_sum/.test(reduceFunString)) {\n    return builtInReduce._sum;\n  } else if (/^_count/.test(reduceFunString)) {\n    return builtInReduce._count;\n  } else if (/^_stats/.test(reduceFunString)) {\n    return builtInReduce._stats;\n  } else if (/^_/.test(reduceFunString)) {\n    throw new Error(reduceFunString + ' is not a supported reduce function.');\n  }\n}\n\nfunction mapper(mapFun, emit) {\n  // for temp_views one can use emit(doc, emit), see #38\n  if (typeof mapFun === \"function\" && mapFun.length === 2) {\n    var origMap = mapFun;\n    return function (doc) {\n      return origMap(doc, emit);\n    };\n  } else {\n    return evalFunctionWithEval(mapFun.toString(), emit);\n  }\n}\n\nfunction reducer(reduceFun) {\n  var reduceFunString = reduceFun.toString();\n  var builtIn = getBuiltIn(reduceFunString);\n  if (builtIn) {\n    return builtIn;\n  } else {\n    return evalFunctionWithEval(reduceFunString);\n  }\n}\n\nfunction ddocValidator(ddoc, viewName) {\n  var fun = ddoc.views && ddoc.views[viewName];\n  if (typeof fun.map !== 'string') {\n    throw new NotFoundError('ddoc ' + ddoc._id + ' has no string view named ' +\n      viewName + ', instead found object of type: ' + typeof fun.map);\n  }\n}\n\nvar localDocName = 'mrviews';\nvar abstract = createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator);\n\nfunction query(fun, opts, callback) {\n  return abstract.query.call(this, fun, opts, callback);\n}\n\nfunction viewCleanup(callback) {\n  return abstract.viewCleanup.call(this, callback);\n}\n\nvar mapreduce = {\n  query: query,\n  viewCleanup: viewCleanup\n};\n\nfunction isGenOne$1(rev$$1) {\n  return /^1-/.test(rev$$1);\n}\n\nfunction fileHasChanged(localDoc, remoteDoc, filename) {\n  return !localDoc._attachments ||\n         !localDoc._attachments[filename] ||\n         localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;\n}\n\nfunction getDocAttachments(db, doc) {\n  var filenames = Object.keys(doc._attachments);\n  return PouchPromise$1.all(filenames.map(function (filename) {\n    return db.getAttachment(doc._id, filename, {rev: doc._rev});\n  }));\n}\n\nfunction getDocAttachmentsFromTargetOrSource(target, src, doc) {\n  var doCheckForLocalAttachments = isRemote(src) && !isRemote(target);\n  var filenames = Object.keys(doc._attachments);\n\n  if (!doCheckForLocalAttachments) {\n    return getDocAttachments(src, doc);\n  }\n\n  return target.get(doc._id).then(function (localDoc) {\n    return PouchPromise$1.all(filenames.map(function (filename) {\n      if (fileHasChanged(localDoc, doc, filename)) {\n        return src.getAttachment(doc._id, filename);\n      }\n\n      return target.getAttachment(localDoc._id, filename);\n    }));\n  }).catch(function (error) {\n    /* istanbul ignore if */\n    if (error.status !== 404) {\n      throw error;\n    }\n\n    return getDocAttachments(src, doc);\n  });\n}\n\nfunction createBulkGetOpts(diffs) {\n  var requests = [];\n  Object.keys(diffs).forEach(function (id) {\n    var missingRevs = diffs[id].missing;\n    missingRevs.forEach(function (missingRev) {\n      requests.push({\n        id: id,\n        rev: missingRev\n      });\n    });\n  });\n\n  return {\n    docs: requests,\n    revs: true,\n    latest: true\n  };\n}\n\n//\n// Fetch all the documents from the src as described in the \"diffs\",\n// which is a mapping of docs IDs to revisions. If the state ever\n// changes to \"cancelled\", then the returned promise will be rejected.\n// Else it will be resolved with a list of fetched documents.\n//\nfunction getDocs(src, target, diffs, state) {\n  diffs = clone(diffs); // we do not need to modify this\n\n  var resultDocs = [],\n      ok = true;\n\n  function getAllDocs() {\n\n    var bulkGetOpts = createBulkGetOpts(diffs);\n\n    if (!bulkGetOpts.docs.length) { // optimization: skip empty requests\n      return;\n    }\n\n    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {\n      /* istanbul ignore if */\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      return PouchPromise$1.all(bulkGetResponse.results.map(function (bulkGetInfo) {\n        return PouchPromise$1.all(bulkGetInfo.docs.map(function (doc) {\n          var remoteDoc = doc.ok;\n\n          if (doc.error) {\n            // when AUTO_COMPACTION is set, docs can be returned which look\n            // like this: {\"missing\":\"1-7c3ac256b693c462af8442f992b83696\"}\n            ok = false;\n          }\n\n          if (!remoteDoc || !remoteDoc._attachments) {\n            return remoteDoc;\n          }\n\n          return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc)\n                   .then(function (attachments) {\n                           var filenames = Object.keys(remoteDoc._attachments);\n                           attachments\n                             .forEach(function (attachment, i) {\n                                        var att = remoteDoc._attachments[filenames[i]];\n                                        delete att.stub;\n                                        delete att.length;\n                                        att.data = attachment;\n                                      });\n\n                                      return remoteDoc;\n                                    });\n        }));\n      }))\n\n      .then(function (results) {\n        resultDocs = resultDocs.concat(flatten(results).filter(Boolean));\n      });\n    });\n  }\n\n  function hasAttachments(doc) {\n    return doc._attachments && Object.keys(doc._attachments).length > 0;\n  }\n\n  function hasConflicts(doc) {\n    return doc._conflicts && doc._conflicts.length > 0;\n  }\n\n  function fetchRevisionOneDocs(ids) {\n    // Optimization: fetch gen-1 docs and attachments in\n    // a single request using _all_docs\n    return src.allDocs({\n      keys: ids,\n      include_docs: true,\n      conflicts: true\n    }).then(function (res) {\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      res.rows.forEach(function (row) {\n        if (row.deleted || !row.doc || !isGenOne$1(row.value.rev) ||\n            hasAttachments(row.doc) || hasConflicts(row.doc)) {\n          // if any of these conditions apply, we need to fetch using get()\n          return;\n        }\n\n        // strip _conflicts array to appease CSG (#5793)\n        /* istanbul ignore if */\n        if (row.doc._conflicts) {\n          delete row.doc._conflicts;\n        }\n\n        // the doc we got back from allDocs() is sufficient\n        resultDocs.push(row.doc);\n        delete diffs[row.id];\n      });\n    });\n  }\n\n  function getRevisionOneDocs() {\n    // filter out the generation 1 docs and get them\n    // leaving the non-generation one docs to be got otherwise\n    var ids = Object.keys(diffs).filter(function (id) {\n      var missing = diffs[id].missing;\n      return missing.length === 1 && isGenOne$1(missing[0]);\n    });\n    if (ids.length > 0) {\n      return fetchRevisionOneDocs(ids);\n    }\n  }\n\n  function returnResult() {\n    return { ok:ok, docs:resultDocs };\n  }\n\n  return PouchPromise$1.resolve()\n    .then(getRevisionOneDocs)\n    .then(getAllDocs)\n    .then(returnResult);\n}\n\nvar CHECKPOINT_VERSION = 1;\nvar REPLICATOR = \"pouchdb\";\n// This is an arbitrary number to limit the\n// amount of replication history we save in the checkpoint.\n// If we save too much, the checkpoing docs will become very big,\n// if we save fewer, we'll run a greater risk of having to\n// read all the changes from 0 when checkpoint PUTs fail\n// CouchDB 2.0 has a more involved history pruning,\n// but let's go for the simple version for now.\nvar CHECKPOINT_HISTORY_SIZE = 5;\nvar LOWEST_SEQ = 0;\n\nfunction updateCheckpoint(db, id, checkpoint, session, returnValue) {\n  return db.get(id).catch(function (err) {\n    if (err.status === 404) {\n      if (db.adapter === 'http' || db.adapter === 'https') {\n        explainError(\n          404, 'PouchDB is just checking if a remote checkpoint exists.'\n        );\n      }\n      return {\n        session_id: session,\n        _id: id,\n        history: [],\n        replicator: REPLICATOR,\n        version: CHECKPOINT_VERSION\n      };\n    }\n    throw err;\n  }).then(function (doc) {\n    if (returnValue.cancelled) {\n      return;\n    }\n\n    // if the checkpoint has not changed, do not update\n    if (doc.last_seq === checkpoint) {\n      return;\n    }\n\n    // Filter out current entry for this replication\n    doc.history = (doc.history || []).filter(function (item) {\n      return item.session_id !== session;\n    });\n\n    // Add the latest checkpoint to history\n    doc.history.unshift({\n      last_seq: checkpoint,\n      session_id: session\n    });\n\n    // Just take the last pieces in history, to\n    // avoid really big checkpoint docs.\n    // see comment on history size above\n    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);\n\n    doc.version = CHECKPOINT_VERSION;\n    doc.replicator = REPLICATOR;\n\n    doc.session_id = session;\n    doc.last_seq = checkpoint;\n\n    return db.put(doc).catch(function (err) {\n      if (err.status === 409) {\n        // retry; someone is trying to write a checkpoint simultaneously\n        return updateCheckpoint(db, id, checkpoint, session, returnValue);\n      }\n      throw err;\n    });\n  });\n}\n\nfunction Checkpointer(src, target, id, returnValue, opts) {\n  this.src = src;\n  this.target = target;\n  this.id = id;\n  this.returnValue = returnValue;\n  this.opts = opts;\n}\n\nCheckpointer.prototype.writeCheckpoint = function (checkpoint, session) {\n  var self = this;\n  return this.updateTarget(checkpoint, session).then(function () {\n    return self.updateSource(checkpoint, session);\n  });\n};\n\nCheckpointer.prototype.updateTarget = function (checkpoint, session) {\n  if (this.opts.writeTargetCheckpoint) {\n    return updateCheckpoint(this.target, this.id, checkpoint,\n      session, this.returnValue);\n  } else {\n    return PouchPromise$1.resolve(true);\n  }\n};\n\nCheckpointer.prototype.updateSource = function (checkpoint, session) {\n  if (this.opts.writeSourceCheckpoint) {\n    var self = this;\n    if (this.readOnlySource) {\n      return PouchPromise$1.resolve(true);\n    }\n    return updateCheckpoint(this.src, this.id, checkpoint,\n      session, this.returnValue)\n      .catch(function (err) {\n        if (isForbiddenError(err)) {\n          self.readOnlySource = true;\n          return true;\n        }\n        throw err;\n      });\n  } else {\n    return PouchPromise$1.resolve(true);\n  }\n};\n\nvar comparisons = {\n  \"undefined\": function (targetDoc, sourceDoc) {\n    // This is the previous comparison function\n    if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {\n      return sourceDoc.last_seq;\n    }\n    /* istanbul ignore next */\n    return 0;\n  },\n  \"1\": function (targetDoc, sourceDoc) {\n    // This is the comparison function ported from CouchDB\n    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;\n  }\n};\n\nCheckpointer.prototype.getCheckpoint = function () {\n  var self = this;\n  return self.target.get(self.id).then(function (targetDoc) {\n    if (self.readOnlySource) {\n      return PouchPromise$1.resolve(targetDoc.last_seq);\n    }\n\n    return self.src.get(self.id).then(function (sourceDoc) {\n      // Since we can't migrate an old version doc to a new one\n      // (no session id), we just go with the lowest seq in this case\n      /* istanbul ignore if */\n      if (targetDoc.version !== sourceDoc.version) {\n        return LOWEST_SEQ;\n      }\n\n      var version;\n      if (targetDoc.version) {\n        version = targetDoc.version.toString();\n      } else {\n        version = \"undefined\";\n      }\n\n      if (version in comparisons) {\n        return comparisons[version](targetDoc, sourceDoc);\n      }\n      /* istanbul ignore next */\n      return LOWEST_SEQ;\n    }, function (err) {\n      if (err.status === 404 && targetDoc.last_seq) {\n        return self.src.put({\n          _id: self.id,\n          last_seq: LOWEST_SEQ\n        }).then(function () {\n          return LOWEST_SEQ;\n        }, function (err) {\n          if (isForbiddenError(err)) {\n            self.readOnlySource = true;\n            return targetDoc.last_seq;\n          }\n          /* istanbul ignore next */\n          return LOWEST_SEQ;\n        });\n      }\n      throw err;\n    });\n  }).catch(function (err) {\n    if (err.status !== 404) {\n      throw err;\n    }\n    return LOWEST_SEQ;\n  });\n};\n// This checkpoint comparison is ported from CouchDBs source\n// they come from here:\n// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906\n\nfunction compareReplicationLogs(srcDoc, tgtDoc) {\n  if (srcDoc.session_id === tgtDoc.session_id) {\n    return {\n      last_seq: srcDoc.last_seq,\n      history: srcDoc.history\n    };\n  }\n\n  return compareReplicationHistory(srcDoc.history, tgtDoc.history);\n}\n\nfunction compareReplicationHistory(sourceHistory, targetHistory) {\n  // the erlang loop via function arguments is not so easy to repeat in JS\n  // therefore, doing this as recursion\n  var S = sourceHistory[0];\n  var sourceRest = sourceHistory.slice(1);\n  var T = targetHistory[0];\n  var targetRest = targetHistory.slice(1);\n\n  if (!S || targetHistory.length === 0) {\n    return {\n      last_seq: LOWEST_SEQ,\n      history: []\n    };\n  }\n\n  var sourceId = S.session_id;\n  /* istanbul ignore if */\n  if (hasSessionId(sourceId, targetHistory)) {\n    return {\n      last_seq: S.last_seq,\n      history: sourceHistory\n    };\n  }\n\n  var targetId = T.session_id;\n  if (hasSessionId(targetId, sourceRest)) {\n    return {\n      last_seq: T.last_seq,\n      history: targetRest\n    };\n  }\n\n  return compareReplicationHistory(sourceRest, targetRest);\n}\n\nfunction hasSessionId(sessionId, history) {\n  var props = history[0];\n  var rest = history.slice(1);\n\n  if (!sessionId || history.length === 0) {\n    return false;\n  }\n\n  if (sessionId === props.session_id) {\n    return true;\n  }\n\n  return hasSessionId(sessionId, rest);\n}\n\nfunction isForbiddenError(err) {\n  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;\n}\n\nvar STARTING_BACK_OFF = 0;\n\nfunction backOff(opts, returnValue, error, callback) {\n  if (opts.retry === false) {\n    returnValue.emit('error', error);\n    returnValue.removeAllListeners();\n    return;\n  }\n  if (typeof opts.back_off_function !== 'function') {\n    opts.back_off_function = defaultBackOff;\n  }\n  returnValue.emit('requestError', error);\n  if (returnValue.state === 'active' || returnValue.state === 'pending') {\n    returnValue.emit('paused', error);\n    returnValue.state = 'stopped';\n    var backOffSet = function backoffTimeSet() {\n      opts.current_back_off = STARTING_BACK_OFF;\n    };\n    var removeBackOffSetter = function removeBackOffTimeSet() {\n      returnValue.removeListener('active', backOffSet);\n    };\n    returnValue.once('paused', removeBackOffSetter);\n    returnValue.once('active', backOffSet);\n  }\n\n  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;\n  opts.current_back_off = opts.back_off_function(opts.current_back_off);\n  setTimeout(callback, opts.current_back_off);\n}\n\nfunction sortObjectPropertiesByKey(queryParams) {\n  return Object.keys(queryParams).sort(collate).reduce(function (result, key) {\n    result[key] = queryParams[key];\n    return result;\n  }, {});\n}\n\n// Generate a unique id particular to this replication.\n// Not guaranteed to align perfectly with CouchDB's rep ids.\nfunction generateReplicationId(src, target, opts) {\n  var docIds = opts.doc_ids ? opts.doc_ids.sort(collate) : '';\n  var filterFun = opts.filter ? opts.filter.toString() : '';\n  var queryParams = '';\n  var filterViewName =  '';\n  var selector = '';\n\n  // possibility for checkpoints to be lost here as behaviour of\n  // JSON.stringify is not stable (see #6226)\n  /* istanbul ignore if */\n  if (opts.selector) {\n    selector = JSON.stringify(opts.selector);\n  }\n\n  if (opts.filter && opts.query_params) {\n    queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));\n  }\n\n  if (opts.filter && opts.filter === '_view') {\n    filterViewName = opts.view.toString();\n  }\n\n  return PouchPromise$1.all([src.id(), target.id()]).then(function (res) {\n    var queryData = res[0] + res[1] + filterFun + filterViewName +\n      queryParams + docIds + selector;\n    return new PouchPromise$1(function (resolve) {\n      binaryMd5(queryData, resolve);\n    });\n  }).then(function (md5sum) {\n    // can't use straight-up md5 alphabet, because\n    // the char '/' is interpreted as being for attachments,\n    // and + is also not url-safe\n    md5sum = md5sum.replace(/\\//g, '.').replace(/\\+/g, '_');\n    return '_local/' + md5sum;\n  });\n}\n\nfunction replicate(src, target, opts, returnValue, result) {\n  var batches = [];               // list of batches to be processed\n  var currentBatch;               // the batch currently being processed\n  var pendingBatch = {\n    seq: 0,\n    changes: [],\n    docs: []\n  }; // next batch, not yet ready to be processed\n  var writingCheckpoint = false;  // true while checkpoint is being written\n  var changesCompleted = false;   // true when all changes received\n  var replicationCompleted = false; // true when replication has completed\n  var last_seq = 0;\n  var continuous = opts.continuous || opts.live || false;\n  var batch_size = opts.batch_size || 100;\n  var batches_limit = opts.batches_limit || 10;\n  var changesPending = false;     // true while src.changes is running\n  var doc_ids = opts.doc_ids;\n  var selector = opts.selector;\n  var repId;\n  var checkpointer;\n  var changedDocs = [];\n  // Like couchdb, every replication gets a unique session id\n  var session = uuid();\n\n  result = result || {\n    ok: true,\n    start_time: new Date(),\n    docs_read: 0,\n    docs_written: 0,\n    doc_write_failures: 0,\n    errors: []\n  };\n\n  var changesOpts = {};\n  returnValue.ready(src, target);\n\n  function initCheckpointer() {\n    if (checkpointer) {\n      return PouchPromise$1.resolve();\n    }\n    return generateReplicationId(src, target, opts).then(function (res) {\n      repId = res;\n\n      var checkpointOpts = {};\n      if (opts.checkpoint === false) {\n        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: false };\n      } else if (opts.checkpoint === 'source') {\n        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: false };\n      } else if (opts.checkpoint === 'target') {\n        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: true };\n      } else {\n        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: true };\n      }\n\n      checkpointer = new Checkpointer(src, target, repId, returnValue, checkpointOpts);\n    });\n  }\n\n  function writeDocs() {\n    changedDocs = [];\n\n    if (currentBatch.docs.length === 0) {\n      return;\n    }\n    var docs = currentBatch.docs;\n    var bulkOpts = {timeout: opts.timeout};\n    return target.bulkDocs({docs: docs, new_edits: false}, bulkOpts).then(function (res) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n\n      // `res` doesn't include full documents (which live in `docs`), so we create a map of \n      // (id -> error), and check for errors while iterating over `docs`\n      var errorsById = Object.create(null);\n      res.forEach(function (res) {\n        if (res.error) {\n          errorsById[res.id] = res;\n        }\n      });\n\n      var errorsNo = Object.keys(errorsById).length;\n      result.doc_write_failures += errorsNo;\n      result.docs_written += docs.length - errorsNo;\n\n      docs.forEach(function (doc) {\n        var error = errorsById[doc._id];\n        if (error) {\n          result.errors.push(error);\n          if (error.name === 'unauthorized' || error.name === 'forbidden') {\n            returnValue.emit('denied', clone(error));\n          } else {\n            throw error;\n          }\n        } else {\n          changedDocs.push(doc);\n        }\n      });\n\n    }, function (err) {\n      result.doc_write_failures += docs.length;\n      throw err;\n    });\n  }\n\n  function finishBatch() {\n    if (currentBatch.error) {\n      throw new Error('There was a problem getting docs.');\n    }\n    result.last_seq = last_seq = currentBatch.seq;\n    var outResult = clone(result);\n    if (changedDocs.length) {\n      outResult.docs = changedDocs;\n      returnValue.emit('change', outResult);\n    }\n    writingCheckpoint = true;\n    return checkpointer.writeCheckpoint(currentBatch.seq,\n        session).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      currentBatch = undefined;\n      getChanges();\n    }).catch(function (err) {\n      onCheckpointError(err);\n      throw err;\n    });\n  }\n\n  function getDiffs() {\n    var diff = {};\n    currentBatch.changes.forEach(function (change) {\n      // Couchbase Sync Gateway emits these, but we can ignore them\n      /* istanbul ignore if */\n      if (change.id === \"_user/\") {\n        return;\n      }\n      diff[change.id] = change.changes.map(function (x) {\n        return x.rev;\n      });\n    });\n    return target.revsDiff(diff).then(function (diffs) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      // currentBatch.diffs elements are deleted as the documents are written\n      currentBatch.diffs = diffs;\n    });\n  }\n\n  function getBatchDocs() {\n    return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {\n      currentBatch.error = !got.ok;\n      got.docs.forEach(function (doc) {\n        delete currentBatch.diffs[doc._id];\n        result.docs_read++;\n        currentBatch.docs.push(doc);\n      });\n    });\n  }\n\n  function startNextBatch() {\n    if (returnValue.cancelled || currentBatch) {\n      return;\n    }\n    if (batches.length === 0) {\n      processPendingBatch(true);\n      return;\n    }\n    currentBatch = batches.shift();\n    getDiffs()\n      .then(getBatchDocs)\n      .then(writeDocs)\n      .then(finishBatch)\n      .then(startNextBatch)\n      .catch(function (err) {\n        abortReplication('batch processing terminated with error', err);\n      });\n  }\n\n\n  function processPendingBatch(immediate) {\n    if (pendingBatch.changes.length === 0) {\n      if (batches.length === 0 && !currentBatch) {\n        if ((continuous && changesOpts.live) || changesCompleted) {\n          returnValue.state = 'pending';\n          returnValue.emit('paused');\n        }\n        if (changesCompleted) {\n          completeReplication();\n        }\n      }\n      return;\n    }\n    if (\n      immediate ||\n      changesCompleted ||\n      pendingBatch.changes.length >= batch_size\n    ) {\n      batches.push(pendingBatch);\n      pendingBatch = {\n        seq: 0,\n        changes: [],\n        docs: []\n      };\n      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {\n        returnValue.state = 'active';\n        returnValue.emit('active');\n      }\n      startNextBatch();\n    }\n  }\n\n\n  function abortReplication(reason, err) {\n    if (replicationCompleted) {\n      return;\n    }\n    if (!err.message) {\n      err.message = reason;\n    }\n    result.ok = false;\n    result.status = 'aborting';\n    batches = [];\n    pendingBatch = {\n      seq: 0,\n      changes: [],\n      docs: []\n    };\n    completeReplication(err);\n  }\n\n\n  function completeReplication(fatalError) {\n    if (replicationCompleted) {\n      return;\n    }\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      result.status = 'cancelled';\n      if (writingCheckpoint) {\n        return;\n      }\n    }\n    result.status = result.status || 'complete';\n    result.end_time = new Date();\n    result.last_seq = last_seq;\n    replicationCompleted = true;\n\n    if (fatalError) {\n      // need to extend the error because Firefox considers \".result\" read-only\n      fatalError = createError(fatalError);\n      fatalError.result = result;\n\n      if (fatalError.name === 'unauthorized' || fatalError.name === 'forbidden') {\n        returnValue.emit('error', fatalError);\n        returnValue.removeAllListeners();\n      } else {\n        backOff(opts, returnValue, fatalError, function () {\n          replicate(src, target, opts, returnValue);\n        });\n      }\n    } else {\n      returnValue.emit('complete', result);\n      returnValue.removeAllListeners();\n    }\n  }\n\n\n  function onChange(change) {\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    var filter = filterChange(opts)(change);\n    if (!filter) {\n      return;\n    }\n    pendingBatch.seq = change.seq;\n    pendingBatch.changes.push(change);\n    processPendingBatch(batches.length === 0 && changesOpts.live);\n  }\n\n\n  function onChangesComplete(changes) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n\n    // if no results were returned then we're done,\n    // else fetch more\n    if (changes.results.length > 0) {\n      changesOpts.since = changes.last_seq;\n      getChanges();\n      processPendingBatch(true);\n    } else {\n\n      var complete = function () {\n        if (continuous) {\n          changesOpts.live = true;\n          getChanges();\n        } else {\n          changesCompleted = true;\n        }\n        processPendingBatch(true);\n      };\n\n      // update the checkpoint so we start from the right seq next time\n      if (!currentBatch && changes.results.length === 0) {\n        writingCheckpoint = true;\n        checkpointer.writeCheckpoint(changes.last_seq,\n            session).then(function () {\n          writingCheckpoint = false;\n          result.last_seq = last_seq = changes.last_seq;\n          complete();\n        })\n        .catch(onCheckpointError);\n      } else {\n        complete();\n      }\n    }\n  }\n\n\n  function onChangesError(err) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    abortReplication('changes rejected', err);\n  }\n\n\n  function getChanges() {\n    if (!(\n      !changesPending &&\n      !changesCompleted &&\n      batches.length < batches_limit\n      )) {\n      return;\n    }\n    changesPending = true;\n    function abortChanges() {\n      changes.cancel();\n    }\n    function removeListener() {\n      returnValue.removeListener('cancel', abortChanges);\n    }\n\n    if (returnValue._changes) { // remove old changes() and listeners\n      returnValue.removeListener('cancel', returnValue._abortChanges);\n      returnValue._changes.cancel();\n    }\n    returnValue.once('cancel', abortChanges);\n\n    var changes = src.changes(changesOpts)\n      .on('change', onChange);\n    changes.then(removeListener, removeListener);\n    changes.then(onChangesComplete)\n      .catch(onChangesError);\n\n    if (opts.retry) {\n      // save for later so we can cancel if necessary\n      returnValue._changes = changes;\n      returnValue._abortChanges = abortChanges;\n    }\n  }\n\n\n  function startChanges() {\n    initCheckpointer().then(function () {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      return checkpointer.getCheckpoint().then(function (checkpoint) {\n        last_seq = checkpoint;\n        changesOpts = {\n          since: last_seq,\n          limit: batch_size,\n          batch_size: batch_size,\n          style: 'all_docs',\n          doc_ids: doc_ids,\n          selector: selector,\n          return_docs: true // required so we know when we're done\n        };\n        if (opts.filter) {\n          if (typeof opts.filter !== 'string') {\n            // required for the client-side filter in onChange\n            changesOpts.include_docs = true;\n          } else { // ddoc filter\n            changesOpts.filter = opts.filter;\n          }\n        }\n        if ('heartbeat' in opts) {\n          changesOpts.heartbeat = opts.heartbeat;\n        }\n        if ('timeout' in opts) {\n          changesOpts.timeout = opts.timeout;\n        }\n        if (opts.query_params) {\n          changesOpts.query_params = opts.query_params;\n        }\n        if (opts.view) {\n          changesOpts.view = opts.view;\n        }\n        getChanges();\n      });\n    }).catch(function (err) {\n      abortReplication('getCheckpoint rejected with ', err);\n    });\n  }\n\n  /* istanbul ignore next */\n  function onCheckpointError(err) {\n    writingCheckpoint = false;\n    abortReplication('writeCheckpoint completed with error', err);\n  }\n\n  /* istanbul ignore if */\n  if (returnValue.cancelled) { // cancelled immediately\n    completeReplication();\n    return;\n  }\n\n  if (!returnValue._addedListeners) {\n    returnValue.once('cancel', completeReplication);\n\n    if (typeof opts.complete === 'function') {\n      returnValue.once('error', opts.complete);\n      returnValue.once('complete', function (result) {\n        opts.complete(null, result);\n      });\n    }\n    returnValue._addedListeners = true;\n  }\n\n  if (typeof opts.since === 'undefined') {\n    startChanges();\n  } else {\n    initCheckpointer().then(function () {\n      writingCheckpoint = true;\n      return checkpointer.writeCheckpoint(opts.since, session);\n    }).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      last_seq = opts.since;\n      startChanges();\n    }).catch(onCheckpointError);\n  }\n}\n\n// We create a basic promise so the caller can cancel the replication possibly\n// before we have actually started listening to changes etc\ninherits(Replication, events.EventEmitter);\nfunction Replication() {\n  events.EventEmitter.call(this);\n  this.cancelled = false;\n  this.state = 'pending';\n  var self = this;\n  var promise = new PouchPromise$1(function (fulfill, reject) {\n    self.once('complete', fulfill);\n    self.once('error', reject);\n  });\n  self.then = function (resolve, reject) {\n    return promise.then(resolve, reject);\n  };\n  self.catch = function (reject) {\n    return promise.catch(reject);\n  };\n  // As we allow error handling via \"error\" event as well,\n  // put a stub in here so that rejecting never throws UnhandledError.\n  self.catch(function () {});\n}\n\nReplication.prototype.cancel = function () {\n  this.cancelled = true;\n  this.state = 'cancelled';\n  this.emit('cancel');\n};\n\nReplication.prototype.ready = function (src, target) {\n  var self = this;\n  if (self._readyCalled) {\n    return;\n  }\n  self._readyCalled = true;\n\n  function onDestroy() {\n    self.cancel();\n  }\n  src.once('destroyed', onDestroy);\n  target.once('destroyed', onDestroy);\n  function cleanup() {\n    src.removeListener('destroyed', onDestroy);\n    target.removeListener('destroyed', onDestroy);\n  }\n  self.once('complete', cleanup);\n};\n\nfunction toPouch(db, opts) {\n  var PouchConstructor = opts.PouchConstructor;\n  if (typeof db === 'string') {\n    return new PouchConstructor(db, opts);\n  } else {\n    return db;\n  }\n}\n\nfunction replicateWrapper(src, target, opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n\n  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {\n    throw createError(BAD_REQUEST,\n                       \"`doc_ids` filter parameter is not a list.\");\n  }\n\n  opts.complete = callback;\n  opts = clone(opts);\n  opts.continuous = opts.continuous || opts.live;\n  opts.retry = ('retry' in opts) ? opts.retry : false;\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  var replicateRet = new Replication(opts);\n  var srcPouch = toPouch(src, opts);\n  var targetPouch = toPouch(target, opts);\n  replicate(srcPouch, targetPouch, opts, replicateRet);\n  return replicateRet;\n}\n\ninherits(Sync, events.EventEmitter);\nfunction sync$1(src, target, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n  opts = clone(opts);\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  src = toPouch(src, opts);\n  target = toPouch(target, opts);\n  return new Sync(src, target, opts, callback);\n}\n\nfunction Sync(src, target, opts, callback) {\n  var self = this;\n  this.canceled = false;\n\n  var optsPush = opts.push ? $inject_Object_assign({}, opts, opts.push) : opts;\n  var optsPull = opts.pull ? $inject_Object_assign({}, opts, opts.pull) : opts;\n\n  this.push = replicateWrapper(src, target, optsPush);\n  this.pull = replicateWrapper(target, src, optsPull);\n\n  this.pushPaused = true;\n  this.pullPaused = true;\n\n  function pullChange(change) {\n    self.emit('change', {\n      direction: 'pull',\n      change: change\n    });\n  }\n  function pushChange(change) {\n    self.emit('change', {\n      direction: 'push',\n      change: change\n    });\n  }\n  function pushDenied(doc) {\n    self.emit('denied', {\n      direction: 'push',\n      doc: doc\n    });\n  }\n  function pullDenied(doc) {\n    self.emit('denied', {\n      direction: 'pull',\n      doc: doc\n    });\n  }\n  function pushPaused() {\n    self.pushPaused = true;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('paused');\n    }\n  }\n  function pullPaused() {\n    self.pullPaused = true;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('paused');\n    }\n  }\n  function pushActive() {\n    self.pushPaused = false;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('active', {\n        direction: 'push'\n      });\n    }\n  }\n  function pullActive() {\n    self.pullPaused = false;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('active', {\n        direction: 'pull'\n      });\n    }\n  }\n\n  var removed = {};\n\n  function removeAll(type) { // type is 'push' or 'pull'\n    return function (event, func) {\n      var isChange = event === 'change' &&\n        (func === pullChange || func === pushChange);\n      var isDenied = event === 'denied' &&\n        (func === pullDenied || func === pushDenied);\n      var isPaused = event === 'paused' &&\n        (func === pullPaused || func === pushPaused);\n      var isActive = event === 'active' &&\n        (func === pullActive || func === pushActive);\n\n      if (isChange || isDenied || isPaused || isActive) {\n        if (!(event in removed)) {\n          removed[event] = {};\n        }\n        removed[event][type] = true;\n        if (Object.keys(removed[event]).length === 2) {\n          // both push and pull have asked to be removed\n          self.removeAllListeners(event);\n        }\n      }\n    };\n  }\n\n  if (opts.live) {\n    this.push.on('complete', self.pull.cancel.bind(self.pull));\n    this.pull.on('complete', self.push.cancel.bind(self.push));\n  }\n\n  function addOneListener(ee, event, listener) {\n    if (ee.listeners(event).indexOf(listener) == -1) {\n      ee.on(event, listener);\n    }\n  }\n\n  this.on('newListener', function (event) {\n    if (event === 'change') {\n      addOneListener(self.pull, 'change', pullChange);\n      addOneListener(self.push, 'change', pushChange);\n    } else if (event === 'denied') {\n      addOneListener(self.pull, 'denied', pullDenied);\n      addOneListener(self.push, 'denied', pushDenied);\n    } else if (event === 'active') {\n      addOneListener(self.pull, 'active', pullActive);\n      addOneListener(self.push, 'active', pushActive);\n    } else if (event === 'paused') {\n      addOneListener(self.pull, 'paused', pullPaused);\n      addOneListener(self.push, 'paused', pushPaused);\n    }\n  });\n\n  this.on('removeListener', function (event) {\n    if (event === 'change') {\n      self.pull.removeListener('change', pullChange);\n      self.push.removeListener('change', pushChange);\n    } else if (event === 'denied') {\n      self.pull.removeListener('denied', pullDenied);\n      self.push.removeListener('denied', pushDenied);\n    } else if (event === 'active') {\n      self.pull.removeListener('active', pullActive);\n      self.push.removeListener('active', pushActive);\n    } else if (event === 'paused') {\n      self.pull.removeListener('paused', pullPaused);\n      self.push.removeListener('paused', pushPaused);\n    }\n  });\n\n  this.pull.on('removeListener', removeAll('pull'));\n  this.push.on('removeListener', removeAll('push'));\n\n  var promise = PouchPromise$1.all([\n    this.push,\n    this.pull\n  ]).then(function (resp) {\n    var out = {\n      push: resp[0],\n      pull: resp[1]\n    };\n    self.emit('complete', out);\n    if (callback) {\n      callback(null, out);\n    }\n    self.removeAllListeners();\n    return out;\n  }, function (err) {\n    self.cancel();\n    if (callback) {\n      // if there's a callback, then the callback can receive\n      // the error event\n      callback(err);\n    } else {\n      // if there's no callback, then we're safe to emit an error\n      // event, which would otherwise throw an unhandled error\n      // due to 'error' being a special event in EventEmitters\n      self.emit('error', err);\n    }\n    self.removeAllListeners();\n    if (callback) {\n      // no sense throwing if we're already emitting an 'error' event\n      throw err;\n    }\n  });\n\n  this.then = function (success, err) {\n    return promise.then(success, err);\n  };\n\n  this.catch = function (err) {\n    return promise.catch(err);\n  };\n}\n\nSync.prototype.cancel = function () {\n  if (!this.canceled) {\n    this.canceled = true;\n    this.push.cancel();\n    this.pull.cancel();\n  }\n};\n\nfunction replication(PouchDB) {\n  PouchDB.replicate = replicateWrapper;\n  PouchDB.sync = sync$1;\n\n  Object.defineProperty(PouchDB.prototype, 'replicate', {\n    get: function () {\n      var self = this;\n      return {\n        from: function (other, opts, callback) {\n          return self.constructor.replicate(other, self, opts, callback);\n        },\n        to: function (other, opts, callback) {\n          return self.constructor.replicate(self, other, opts, callback);\n        }\n      };\n    }\n  });\n\n  PouchDB.prototype.sync = function (dbName, opts, callback) {\n    return this.constructor.sync(this, dbName, opts, callback);\n  };\n}\n\nPouchDB$5.plugin(IDBPouch)\n  .plugin(WebSqlPouch)\n  .plugin(HttpPouch$1)\n  .plugin(mapreduce)\n  .plugin(replication);\n\n// Pull from src because pouchdb-node/pouchdb-browser themselves\n// are aggressively optimized and jsnext:main would normally give us this\n// aggressive bundle.\n\nmodule.exports = PouchDB$5;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb/lib/index-browser.js\n ** module id = 3\n ** module chunks = 0\n **/","var v1 = require('./v1');\nvar v4 = require('./v4');\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/uuid/index.js\n ** module id = 4\n ** module chunks = 0\n **/","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/uuid/v1.js\n ** module id = 5\n ** module chunks = 0\n **/","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(rnds8);\n    return rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\nmodule.exports = rng;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/uuid/lib/rng-browser.js\n ** module id = 6\n ** module chunks = 0\n **/","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/uuid/lib/bytesToUuid.js\n ** module id = 7\n ** module chunks = 0\n **/","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/uuid/v4.js\n ** module id = 8\n ** module chunks = 0\n **/","'use strict';\nvar immediate = require('immediate');\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lie/lib/browser.js\n ** module id = 9\n ** module chunks = 0\n **/","'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/immediate/lib/browser.js\n ** module id = 10\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = argsArray;\n\nfunction argsArray(fun) {\n  return function () {\n    var len = arguments.length;\n    if (len) {\n      var args = [];\n      var i = -1;\n      while (++i < len) {\n        args[i] = arguments[i];\n      }\n      return fun.call(this, args);\n    } else {\n      return fun.call(this, []);\n    }\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/argsarray/index.js\n ** module id = 11\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/events/events.js\n ** module id = 12\n ** module chunks = 0\n **/","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/inherits/inherits_browser.js\n ** module id = 13\n ** module chunks = 0\n **/","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window && typeof window.process !== 'undefined' && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document && 'WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window && window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/debug/src/browser.js\n ** module id = 14\n ** module chunks = 0\n **/","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/debug/src/debug.js\n ** module id = 15\n ** module chunks = 0\n **/","/**\n * Helpers.\n */\n\nvar s = 1000\nvar m = s * 60\nvar h = m * 60\nvar d = h * 24\nvar y = d * 365.25\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {}\n  var type = typeof val\n  if (type === 'string' && val.length > 0) {\n    return parse(val)\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ?\n\t\t\tfmtLong(val) :\n\t\t\tfmtShort(val)\n  }\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))\n}\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str)\n  if (str.length > 10000) {\n    return\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)\n  if (!match) {\n    return\n  }\n  var n = parseFloat(match[1])\n  var type = (match[2] || 'ms').toLowerCase()\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n\n    default:\n      return undefined\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd'\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h'\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm'\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's'\n  }\n  return ms + 'ms'\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms'\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's'\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ms/index.js\n ** module id = 16\n ** module chunks = 0\n **/","(function (factory) {\n    if (typeof exports === 'object') {\n        // Node/CommonJS\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(factory);\n    } else {\n        // Browser globals (with support for web workers)\n        var glob;\n\n        try {\n            glob = window;\n        } catch (e) {\n            glob = self;\n        }\n\n        glob.SparkMD5 = factory();\n    }\n}(function (undefined) {\n\n    'use strict';\n\n    /*\n     * Fastest md5 implementation around (JKM md5).\n     * Credits: Joseph Myers\n     *\n     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n     * @see http://jsperf.com/md5-shootout/7\n     */\n\n    /* this function is much faster,\n      so if possible we use it. Some IEs\n      are the only ones I know of that\n      need the idiotic second function,\n      generated by an if clause.  */\n    var add32 = function (a, b) {\n        return (a + b) & 0xFFFFFFFF;\n    },\n        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\n\n    function cmn(q, a, b, x, s, t) {\n        a = add32(add32(a, q), add32(x, t));\n        return add32((a << s) | (a >>> (32 - s)), b);\n    }\n\n    function md5cycle(x, k) {\n        var a = x[0],\n            b = x[1],\n            c = x[2],\n            d = x[3];\n\n        a += (b & c | ~b & d) + k[0] - 680876936 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[1] - 389564586 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[2] + 606105819 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[4] - 176418897 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[7] - 45705983 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[10] - 42063 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[13] - 40341101 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n\n        a += (b & d | c & ~d) + k[1] - 165796510 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[11] + 643717713 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[0] - 373897302 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[5] - 701558691 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[10] + 38016083 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[15] - 660478335 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[4] - 405537848 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[9] + 568446438 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[3] - 187363961 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[2] - 51403784 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n\n        a += (b ^ c ^ d) + k[5] - 378558 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[14] - 35309556 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[7] - 155497632 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[13] + 681279174 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[0] - 358537222 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[3] - 722521979 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[6] + 76029189 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[9] - 640364487 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[12] - 421815835 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[15] + 530742520 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[2] - 995338651 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n\n        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;\n        b  = (b << 21 | b >>> 11) + c | 0;\n\n        x[0] = a + x[0] | 0;\n        x[1] = b + x[1] | 0;\n        x[2] = c + x[2] | 0;\n        x[3] = d + x[3] | 0;\n    }\n\n    function md5blk(s) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n        }\n        return md5blks;\n    }\n\n    function md5blk_array(a) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n        }\n        return md5blks;\n    }\n\n    function md51(s) {\n        var n = s.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk(s.substring(i - 64, i)));\n        }\n        s = s.substring(i - 64);\n        length = s.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n        }\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n        return state;\n    }\n\n    function md51_array(a) {\n        var n = a.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n        }\n\n        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n        // containing the last element of the parent array if the sub array specified starts\n        // beyond the length of the parent array - weird.\n        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\n        length = a.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n        }\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n\n        return state;\n    }\n\n    function rhex(n) {\n        var s = '',\n            j;\n        for (j = 0; j < 4; j += 1) {\n            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n        }\n        return s;\n    }\n\n    function hex(x) {\n        var i;\n        for (i = 0; i < x.length; i += 1) {\n            x[i] = rhex(x[i]);\n        }\n        return x.join('');\n    }\n\n    // In some cases the fast add32 function cannot be used..\n    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {\n        add32 = function (x, y) {\n            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n            return (msw << 16) | (lsw & 0xFFFF);\n        };\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * ArrayBuffer slice polyfill.\n     *\n     * @see https://github.com/ttaubert/node-arraybuffer-slice\n     */\n\n    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {\n        (function () {\n            function clamp(val, length) {\n                val = (val | 0) || 0;\n\n                if (val < 0) {\n                    return Math.max(val + length, 0);\n                }\n\n                return Math.min(val, length);\n            }\n\n            ArrayBuffer.prototype.slice = function (from, to) {\n                var length = this.byteLength,\n                    begin = clamp(from, length),\n                    end = length,\n                    num,\n                    target,\n                    targetArray,\n                    sourceArray;\n\n                if (to !== undefined) {\n                    end = clamp(to, length);\n                }\n\n                if (begin > end) {\n                    return new ArrayBuffer(0);\n                }\n\n                num = end - begin;\n                target = new ArrayBuffer(num);\n                targetArray = new Uint8Array(target);\n\n                sourceArray = new Uint8Array(this, begin, num);\n                targetArray.set(sourceArray);\n\n                return target;\n            };\n        })();\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * Helpers.\n     */\n\n    function toUtf8(str) {\n        if (/[\\u0080-\\uFFFF]/.test(str)) {\n            str = unescape(encodeURIComponent(str));\n        }\n\n        return str;\n    }\n\n    function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n        var length = str.length,\n           buff = new ArrayBuffer(length),\n           arr = new Uint8Array(buff),\n           i;\n\n        for (i = 0; i < length; i += 1) {\n            arr[i] = str.charCodeAt(i);\n        }\n\n        return returnUInt8Array ? arr : buff;\n    }\n\n    function arrayBuffer2Utf8Str(buff) {\n        return String.fromCharCode.apply(null, new Uint8Array(buff));\n    }\n\n    function concatenateArrayBuffers(first, second, returnUInt8Array) {\n        var result = new Uint8Array(first.byteLength + second.byteLength);\n\n        result.set(new Uint8Array(first));\n        result.set(new Uint8Array(second), first.byteLength);\n\n        return returnUInt8Array ? result : result.buffer;\n    }\n\n    function hexToBinaryString(hex) {\n        var bytes = [],\n            length = hex.length,\n            x;\n\n        for (x = 0; x < length - 1; x += 2) {\n            bytes.push(parseInt(hex.substr(x, 2), 16));\n        }\n\n        return String.fromCharCode.apply(String, bytes);\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation.\n     *\n     * Use this class to perform an incremental md5, otherwise use the\n     * static methods instead.\n     */\n\n    function SparkMD5() {\n        // call reset to init the instance\n        this.reset();\n    }\n\n    /**\n     * Appends a string.\n     * A conversion will be applied if an utf8 string is detected.\n     *\n     * @param {String} str The string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.append = function (str) {\n        // Converts the string to utf8 bytes if necessary\n        // Then append as binary\n        this.appendBinary(toUtf8(str));\n\n        return this;\n    };\n\n    /**\n     * Appends a binary string.\n     *\n     * @param {String} contents The binary string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.appendBinary = function (contents) {\n        this._buff += contents;\n        this._length += contents.length;\n\n        var length = this._buff.length,\n            i;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n        }\n\n        this._buff = this._buff.substring(i - 64);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            i,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.reset = function () {\n        this._buff = '';\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.prototype.getState = function () {\n        return {\n            buff: this._buff,\n            length: this._length,\n            hash: this._hash\n        };\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.setState = function (state) {\n        this._buff = state.buff;\n        this._length = state.length;\n        this._hash = state.hash;\n\n        return this;\n    };\n\n    /**\n     * Releases memory used by the incremental buffer and other additional\n     * resources. If you plan to use the instance again, use reset instead.\n     */\n    SparkMD5.prototype.destroy = function () {\n        delete this._hash;\n        delete this._buff;\n        delete this._length;\n    };\n\n    /**\n     * Finish the final calculation based on the tail.\n     *\n     * @param {Array}  tail   The tail (will be modified)\n     * @param {Number} length The length of the remaining buffer\n     */\n    SparkMD5.prototype._finish = function (tail, length) {\n        var i = length,\n            tmp,\n            lo,\n            hi;\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(this._hash, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Do the final computation based on the tail and length\n        // Beware that the final length may not fit in 32 bits so we take care of that\n        tmp = this._length * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n        md5cycle(this._hash, tail);\n    };\n\n    /**\n     * Performs the md5 hash on a string.\n     * A conversion will be applied if utf8 string is detected.\n     *\n     * @param {String}  str The string\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hash = function (str, raw) {\n        // Converts the string to utf8 bytes if necessary\n        // Then compute it using the binary function\n        return SparkMD5.hashBinary(toUtf8(str), raw);\n    };\n\n    /**\n     * Performs the md5 hash on a binary string.\n     *\n     * @param {String}  content The binary string\n     * @param {Boolean} raw     True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hashBinary = function (content, raw) {\n        var hash = md51(content),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation for array buffers.\n     *\n     * Use this class to perform an incremental md5 ONLY for array buffers.\n     */\n    SparkMD5.ArrayBuffer = function () {\n        // call reset to init the instance\n        this.reset();\n    };\n\n    /**\n     * Appends an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array to be appended\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),\n            length = buff.length,\n            i;\n\n        this._length += arr.byteLength;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n        }\n\n        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            i,\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.reset = function () {\n        this._buff = new Uint8Array(0);\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.ArrayBuffer.prototype.getState = function () {\n        var state = SparkMD5.prototype.getState.call(this);\n\n        // Convert buffer to a string\n        state.buff = arrayBuffer2Utf8Str(state.buff);\n\n        return state;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.setState = function (state) {\n        // Convert string to buffer\n        state.buff = utf8Str2ArrayBuffer(state.buff, true);\n\n        return SparkMD5.prototype.setState.call(this, state);\n    };\n\n    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\n    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\n    /**\n     * Performs the md5 hash on an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array buffer\n     * @param {Boolean}     raw True to get the raw string, false to get the hex one\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n        var hash = md51_array(new Uint8Array(arr)),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    return SparkMD5;\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/spark-md5/spark-md5.js\n ** module id = 17\n ** module chunks = 0\n **/","'use strict';\n\n/**\n * Stringify/parse functions that don't operate\n * recursively, so they avoid call stack exceeded\n * errors.\n */\nexports.stringify = function stringify(input) {\n  var queue = [];\n  queue.push({obj: input});\n\n  var res = '';\n  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;\n  while ((next = queue.pop())) {\n    obj = next.obj;\n    prefix = next.prefix || '';\n    val = next.val || '';\n    res += prefix;\n    if (val) {\n      res += val;\n    } else if (typeof obj !== 'object') {\n      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);\n    } else if (obj === null) {\n      res += 'null';\n    } else if (Array.isArray(obj)) {\n      queue.push({val: ']'});\n      for (i = obj.length - 1; i >= 0; i--) {\n        arrayPrefix = i === 0 ? '' : ',';\n        queue.push({obj: obj[i], prefix: arrayPrefix});\n      }\n      queue.push({val: '['});\n    } else { // object\n      keys = [];\n      for (k in obj) {\n        if (obj.hasOwnProperty(k)) {\n          keys.push(k);\n        }\n      }\n      queue.push({val: '}'});\n      for (i = keys.length - 1; i >= 0; i--) {\n        key = keys[i];\n        value = obj[key];\n        objPrefix = (i > 0 ? ',' : '');\n        objPrefix += JSON.stringify(key) + ':';\n        queue.push({obj: value, prefix: objPrefix});\n      }\n      queue.push({val: '{'});\n    }\n  }\n  return res;\n};\n\n// Convenience function for the parse function.\n// This pop function is basically copied from\n// pouchCollate.parseIndexableString\nfunction pop(obj, stack, metaStack) {\n  var lastMetaElement = metaStack[metaStack.length - 1];\n  if (obj === lastMetaElement.element) {\n    // popping a meta-element, e.g. an object whose value is another object\n    metaStack.pop();\n    lastMetaElement = metaStack[metaStack.length - 1];\n  }\n  var element = lastMetaElement.element;\n  var lastElementIndex = lastMetaElement.index;\n  if (Array.isArray(element)) {\n    element.push(obj);\n  } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n    var key = stack.pop();\n    element[key] = obj;\n  } else {\n    stack.push(obj); // obj with key only\n  }\n}\n\nexports.parse = function (str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n  var collationIndex,parsedNum,numChar;\n  var parsedString,lastCh,numConsecutiveSlashes,ch;\n  var arrayElement, objElement;\n  while (true) {\n    collationIndex = str[i++];\n    if (collationIndex === '}' ||\n        collationIndex === ']' ||\n        typeof collationIndex === 'undefined') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack.pop(), stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case ' ':\n      case '\\t':\n      case '\\n':\n      case ':':\n      case ',':\n        break;\n      case 'n':\n        i += 3; // 'ull'\n        pop(null, stack, metaStack);\n        break;\n      case 't':\n        i += 3; // 'rue'\n        pop(true, stack, metaStack);\n        break;\n      case 'f':\n        i += 4; // 'alse'\n        pop(false, stack, metaStack);\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '-':\n        parsedNum = '';\n        i--;\n        while (true) {\n          numChar = str[i++];\n          if (/[\\d\\.\\-e\\+]/.test(numChar)) {\n            parsedNum += numChar;\n          } else {\n            i--;\n            break;\n          }\n        }\n        pop(parseFloat(parsedNum), stack, metaStack);\n        break;\n      case '\"':\n        parsedString = '';\n        lastCh = void 0;\n        numConsecutiveSlashes = 0;\n        while (true) {\n          ch = str[i++];\n          if (ch !== '\"' || (lastCh === '\\\\' &&\n              numConsecutiveSlashes % 2 === 1)) {\n            parsedString += ch;\n            lastCh = ch;\n            if (lastCh === '\\\\') {\n              numConsecutiveSlashes++;\n            } else {\n              numConsecutiveSlashes = 0;\n            }\n          } else {\n            break;\n          }\n        }\n        pop(JSON.parse('\"' + parsedString + '\"'), stack, metaStack);\n        break;\n      case '[':\n        arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '{':\n        objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      default:\n        throw new Error(\n          'unexpectedly reached end of input: ' + collationIndex);\n    }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vuvuzela/index.js\n ** module id = 18\n ** module chunks = 0\n **/","import request from 'superagent';\nimport SHA256 from 'crypto-js/sha256';\n\nvar API = {\n  apiEndpoint: null,\n  apiKey: null,\n  appId: null,\n  UDID: null,\n  authenticationToken: null,\n  tokenUpdateCallback: (newToken) => {}\n};\n\nAPI.call = function (endpoint, data, callback = () => {}, method) {\n  if (!this.apiEndpoint) {\n    callback(new Error('No API endpoint set - run Telepat.configure or Telepat.connect first'), null);\n  }\n  var req;\n\n  if (method === 'get') {\n    req = request.get(this.apiEndpoint + endpoint + '?' + data);\n  } else if (method === 'delete') {\n    req = request.del(this.apiEndpoint + endpoint);\n  } else {\n    req = request.post(this.apiEndpoint + endpoint);\n  }\n\n  if (method !== 'get') {\n    req.send(data);\n  }\n\n  req.set('Content-Type', 'application/json')\n    .set('X-BLGREQ-SIGN', SHA256(this.apiKey))\n    .set('X-BLGREQ-APPID', this.appId)\n    .set('X-BLGREQ-UDID', this.UDID || 'TP_EMPTY_UDID');\n\n  if (this.authenticationToken) {\n    req.set('Authorization', 'Bearer ' + this.authenticationToken);\n  }\n\n  req.end((err, res) => {\n    if (this.needsTokenUpdate(res)) {\n      this.updateToken((error, result) => {\n        if (error) {\n          callback(error, null);\n        } else {\n          this.call(endpoint, data, callback, method);\n        }\n      });\n    } else {\n      callback(err, res);\n    }\n  });\n};\n\nAPI.needsTokenUpdate = function (response) {\n  return (this.authenticationToken && (response.status === 401));\n};\n\nAPI.updateToken = function (callback) {\n  this.get('user/refresh_token', '', (err, res) => {\n    if (err) {\n      callback(err, null);\n    } else {\n      this.authenticationToken = res.body.content.token;\n      this.tokenUpdateCallback(this.authenticationToken);\n      callback(null, res);\n    }\n  });\n};\n\nAPI.get = function (endpoint, data, callback) {\n  return this.call(endpoint, data, callback, 'get');\n};\n\nAPI.del = function (endpoint, data, callback) {\n  return this.call(endpoint, data, callback, 'delete');\n};\n\nexport default API;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/api.js\n **/","/**\n * Root reference for iframes.\n */\n\nvar root;\nif (typeof window !== 'undefined') { // Browser window\n  root = window;\n} else if (typeof self !== 'undefined') { // Web Worker\n  root = self;\n} else { // Other environments\n  console.warn(\"Using browser-only version of superagent in non-browser environment\");\n  root = this;\n}\n\nvar Emitter = require('emitter');\nvar requestBase = require('./request-base');\nvar isObject = require('./is-object');\n\n/**\n * Noop.\n */\n\nfunction noop(){};\n\n/**\n * Expose `request`.\n */\n\nvar request = module.exports = require('./request').bind(null, Request);\n\n/**\n * Determine XHR.\n */\n\nrequest.getXHR = function () {\n  if (root.XMLHttpRequest\n      && (!root.location || 'file:' != root.location.protocol\n          || !root.ActiveXObject)) {\n    return new XMLHttpRequest;\n  } else {\n    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\n  }\n  throw Error(\"Browser-only verison of superagent could not find XHR\");\n};\n\n/**\n * Removes leading and trailing whitespace, added to support IE.\n *\n * @param {String} s\n * @return {String}\n * @api private\n */\n\nvar trim = ''.trim\n  ? function(s) { return s.trim(); }\n  : function(s) { return s.replace(/(^\\s*|\\s*$)/g, ''); };\n\n/**\n * Serialize the given `obj`.\n *\n * @param {Object} obj\n * @return {String}\n * @api private\n */\n\nfunction serialize(obj) {\n  if (!isObject(obj)) return obj;\n  var pairs = [];\n  for (var key in obj) {\n    pushEncodedKeyValuePair(pairs, key, obj[key]);\n  }\n  return pairs.join('&');\n}\n\n/**\n * Helps 'serialize' with serializing arrays.\n * Mutates the pairs array.\n *\n * @param {Array} pairs\n * @param {String} key\n * @param {Mixed} val\n */\n\nfunction pushEncodedKeyValuePair(pairs, key, val) {\n  if (val != null) {\n    if (Array.isArray(val)) {\n      val.forEach(function(v) {\n        pushEncodedKeyValuePair(pairs, key, v);\n      });\n    } else if (isObject(val)) {\n      for(var subkey in val) {\n        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);\n      }\n    } else {\n      pairs.push(encodeURIComponent(key)\n        + '=' + encodeURIComponent(val));\n    }\n  } else if (val === null) {\n    pairs.push(encodeURIComponent(key));\n  }\n}\n\n/**\n * Expose serialization method.\n */\n\n request.serializeObject = serialize;\n\n /**\n  * Parse the given x-www-form-urlencoded `str`.\n  *\n  * @param {String} str\n  * @return {Object}\n  * @api private\n  */\n\nfunction parseString(str) {\n  var obj = {};\n  var pairs = str.split('&');\n  var pair;\n  var pos;\n\n  for (var i = 0, len = pairs.length; i < len; ++i) {\n    pair = pairs[i];\n    pos = pair.indexOf('=');\n    if (pos == -1) {\n      obj[decodeURIComponent(pair)] = '';\n    } else {\n      obj[decodeURIComponent(pair.slice(0, pos))] =\n        decodeURIComponent(pair.slice(pos + 1));\n    }\n  }\n\n  return obj;\n}\n\n/**\n * Expose parser.\n */\n\nrequest.parseString = parseString;\n\n/**\n * Default MIME type map.\n *\n *     superagent.types.xml = 'application/xml';\n *\n */\n\nrequest.types = {\n  html: 'text/html',\n  json: 'application/json',\n  xml: 'application/xml',\n  urlencoded: 'application/x-www-form-urlencoded',\n  'form': 'application/x-www-form-urlencoded',\n  'form-data': 'application/x-www-form-urlencoded'\n};\n\n/**\n * Default serialization map.\n *\n *     superagent.serialize['application/xml'] = function(obj){\n *       return 'generated xml here';\n *     };\n *\n */\n\n request.serialize = {\n   'application/x-www-form-urlencoded': serialize,\n   'application/json': JSON.stringify\n };\n\n /**\n  * Default parsers.\n  *\n  *     superagent.parse['application/xml'] = function(str){\n  *       return { object parsed from str };\n  *     };\n  *\n  */\n\nrequest.parse = {\n  'application/x-www-form-urlencoded': parseString,\n  'application/json': JSON.parse\n};\n\n/**\n * Parse the given header `str` into\n * an object containing the mapped fields.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction parseHeader(str) {\n  var lines = str.split(/\\r?\\n/);\n  var fields = {};\n  var index;\n  var line;\n  var field;\n  var val;\n\n  lines.pop(); // trailing CRLF\n\n  for (var i = 0, len = lines.length; i < len; ++i) {\n    line = lines[i];\n    index = line.indexOf(':');\n    field = line.slice(0, index).toLowerCase();\n    val = trim(line.slice(index + 1));\n    fields[field] = val;\n  }\n\n  return fields;\n}\n\n/**\n * Check if `mime` is json or has +json structured syntax suffix.\n *\n * @param {String} mime\n * @return {Boolean}\n * @api private\n */\n\nfunction isJSON(mime) {\n  return /[\\/+]json\\b/.test(mime);\n}\n\n/**\n * Return the mime type for the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nfunction type(str){\n  return str.split(/ *; */).shift();\n};\n\n/**\n * Return header field parameters.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction params(str){\n  return str.split(/ *; */).reduce(function(obj, str){\n    var parts = str.split(/ *= */),\n        key = parts.shift(),\n        val = parts.shift();\n\n    if (key && val) obj[key] = val;\n    return obj;\n  }, {});\n};\n\n/**\n * Initialize a new `Response` with the given `xhr`.\n *\n *  - set flags (.ok, .error, etc)\n *  - parse header\n *\n * Examples:\n *\n *  Aliasing `superagent` as `request` is nice:\n *\n *      request = superagent;\n *\n *  We can use the promise-like API, or pass callbacks:\n *\n *      request.get('/').end(function(res){});\n *      request.get('/', function(res){});\n *\n *  Sending data can be chained:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' })\n *        .end(function(res){});\n *\n *  Or passed to `.send()`:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' }, function(res){});\n *\n *  Or passed to `.post()`:\n *\n *      request\n *        .post('/user', { name: 'tj' })\n *        .end(function(res){});\n *\n * Or further reduced to a single call for simple cases:\n *\n *      request\n *        .post('/user', { name: 'tj' }, function(res){});\n *\n * @param {XMLHTTPRequest} xhr\n * @param {Object} options\n * @api private\n */\n\nfunction Response(req, options) {\n  options = options || {};\n  this.req = req;\n  this.xhr = this.req.xhr;\n  // responseText is accessible only if responseType is '' or 'text' and on older browsers\n  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')\n     ? this.xhr.responseText\n     : null;\n  this.statusText = this.req.xhr.statusText;\n  this._setStatusProperties(this.xhr.status);\n  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());\n  // getAllResponseHeaders sometimes falsely returns \"\" for CORS requests, but\n  // getResponseHeader still works. so we get content-type even if getting\n  // other headers fails.\n  this.header['content-type'] = this.xhr.getResponseHeader('content-type');\n  this._setHeaderProperties(this.header);\n  this.body = this.req.method != 'HEAD'\n    ? this._parseBody(this.text ? this.text : this.xhr.response)\n    : null;\n}\n\n/**\n * Get case-insensitive `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nResponse.prototype.get = function(field){\n  return this.header[field.toLowerCase()];\n};\n\n/**\n * Set header related properties:\n *\n *   - `.type` the content type without params\n *\n * A response of \"Content-Type: text/plain; charset=utf-8\"\n * will provide you with a `.type` of \"text/plain\".\n *\n * @param {Object} header\n * @api private\n */\n\nResponse.prototype._setHeaderProperties = function(header){\n  // content-type\n  var ct = this.header['content-type'] || '';\n  this.type = type(ct);\n\n  // params\n  var obj = params(ct);\n  for (var key in obj) this[key] = obj[key];\n};\n\n/**\n * Parse the given body `str`.\n *\n * Used for auto-parsing of bodies. Parsers\n * are defined on the `superagent.parse` object.\n *\n * @param {String} str\n * @return {Mixed}\n * @api private\n */\n\nResponse.prototype._parseBody = function(str){\n  var parse = request.parse[this.type];\n  if (!parse && isJSON(this.type)) {\n    parse = request.parse['application/json'];\n  }\n  return parse && str && (str.length || str instanceof Object)\n    ? parse(str)\n    : null;\n};\n\n/**\n * Set flags such as `.ok` based on `status`.\n *\n * For example a 2xx response will give you a `.ok` of __true__\n * whereas 5xx will be __false__ and `.error` will be __true__. The\n * `.clientError` and `.serverError` are also available to be more\n * specific, and `.statusType` is the class of error ranging from 1..5\n * sometimes useful for mapping respond colors etc.\n *\n * \"sugar\" properties are also defined for common cases. Currently providing:\n *\n *   - .noContent\n *   - .badRequest\n *   - .unauthorized\n *   - .notAcceptable\n *   - .notFound\n *\n * @param {Number} status\n * @api private\n */\n\nResponse.prototype._setStatusProperties = function(status){\n  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n  if (status === 1223) {\n    status = 204;\n  }\n\n  var type = status / 100 | 0;\n\n  // status / class\n  this.status = this.statusCode = status;\n  this.statusType = type;\n\n  // basics\n  this.info = 1 == type;\n  this.ok = 2 == type;\n  this.clientError = 4 == type;\n  this.serverError = 5 == type;\n  this.error = (4 == type || 5 == type)\n    ? this.toError()\n    : false;\n\n  // sugar\n  this.accepted = 202 == status;\n  this.noContent = 204 == status;\n  this.badRequest = 400 == status;\n  this.unauthorized = 401 == status;\n  this.notAcceptable = 406 == status;\n  this.notFound = 404 == status;\n  this.forbidden = 403 == status;\n};\n\n/**\n * Return an `Error` representative of this response.\n *\n * @return {Error}\n * @api public\n */\n\nResponse.prototype.toError = function(){\n  var req = this.req;\n  var method = req.method;\n  var url = req.url;\n\n  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';\n  var err = new Error(msg);\n  err.status = this.status;\n  err.method = method;\n  err.url = url;\n\n  return err;\n};\n\n/**\n * Expose `Response`.\n */\n\nrequest.Response = Response;\n\n/**\n * Initialize a new `Request` with the given `method` and `url`.\n *\n * @param {String} method\n * @param {String} url\n * @api public\n */\n\nfunction Request(method, url) {\n  var self = this;\n  this._query = this._query || [];\n  this.method = method;\n  this.url = url;\n  this.header = {}; // preserves header name case\n  this._header = {}; // coerces header names to lowercase\n  this.on('end', function(){\n    var err = null;\n    var res = null;\n\n    try {\n      res = new Response(self);\n    } catch(e) {\n      err = new Error('Parser is unable to parse the response');\n      err.parse = true;\n      err.original = e;\n      // issue #675: return the raw response if the response parsing fails\n      err.rawResponse = self.xhr && self.xhr.responseText ? self.xhr.responseText : null;\n      // issue #876: return the http status code if the response parsing fails\n      err.statusCode = self.xhr && self.xhr.status ? self.xhr.status : null;\n      return self.callback(err);\n    }\n\n    self.emit('response', res);\n\n    var new_err;\n    try {\n      if (res.status < 200 || res.status >= 300) {\n        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');\n        new_err.original = err;\n        new_err.response = res;\n        new_err.status = res.status;\n      }\n    } catch(e) {\n      new_err = e; // #985 touching res may cause INVALID_STATE_ERR on old Android\n    }\n\n    // #1000 don't catch errors from the callback to avoid double calling it\n    if (new_err) {\n      self.callback(new_err, res);\n    } else {\n      self.callback(null, res);\n    }\n  });\n}\n\n/**\n * Mixin `Emitter` and `requestBase`.\n */\n\nEmitter(Request.prototype);\nfor (var key in requestBase) {\n  Request.prototype[key] = requestBase[key];\n}\n\n/**\n * Set Content-Type to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.xml = 'application/xml';\n *\n *      request.post('/')\n *        .type('xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n *      request.post('/')\n *        .type('application/xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n * @param {String} type\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.type = function(type){\n  this.set('Content-Type', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set responseType to `val`. Presently valid responseTypes are 'blob' and\n * 'arraybuffer'.\n *\n * Examples:\n *\n *      req.get('/')\n *        .responseType('blob')\n *        .end(callback);\n *\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.responseType = function(val){\n  this._responseType = val;\n  return this;\n};\n\n/**\n * Set Accept to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.json = 'application/json';\n *\n *      request.get('/agent')\n *        .accept('json')\n *        .end(callback);\n *\n *      request.get('/agent')\n *        .accept('application/json')\n *        .end(callback);\n *\n * @param {String} accept\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.accept = function(type){\n  this.set('Accept', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Authorization field value with `user` and `pass`.\n *\n * @param {String} user\n * @param {String} pass\n * @param {Object} options with 'type' property 'auto' or 'basic' (default 'basic')\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.auth = function(user, pass, options){\n  if (!options) {\n    options = {\n      type: 'basic'\n    }\n  }\n\n  switch (options.type) {\n    case 'basic':\n      var str = btoa(user + ':' + pass);\n      this.set('Authorization', 'Basic ' + str);\n    break;\n\n    case 'auto':\n      this.username = user;\n      this.password = pass;\n    break;\n  }\n  return this;\n};\n\n/**\n* Add query-string `val`.\n*\n* Examples:\n*\n*   request.get('/shoes')\n*     .query('size=10')\n*     .query({ color: 'blue' })\n*\n* @param {Object|String} val\n* @return {Request} for chaining\n* @api public\n*/\n\nRequest.prototype.query = function(val){\n  if ('string' != typeof val) val = serialize(val);\n  if (val) this._query.push(val);\n  return this;\n};\n\n/**\n * Queue the given `file` as an attachment to the specified `field`,\n * with optional `filename`.\n *\n * ``` js\n * request.post('/upload')\n *   .attach('content', new Blob(['<a id=\"a\"><b id=\"b\">hey!</b></a>'], { type: \"text/html\"}))\n *   .end(callback);\n * ```\n *\n * @param {String} field\n * @param {Blob|File} file\n * @param {String} filename\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.attach = function(field, file, filename){\n  this._getFormData().append(field, file, filename || file.name);\n  return this;\n};\n\nRequest.prototype._getFormData = function(){\n  if (!this._formData) {\n    this._formData = new root.FormData();\n  }\n  return this._formData;\n};\n\n/**\n * Invoke the callback with `err` and `res`\n * and handle arity check.\n *\n * @param {Error} err\n * @param {Response} res\n * @api private\n */\n\nRequest.prototype.callback = function(err, res){\n  var fn = this._callback;\n  this.clearTimeout();\n  fn(err, res);\n};\n\n/**\n * Invoke callback with x-domain error.\n *\n * @api private\n */\n\nRequest.prototype.crossDomainError = function(){\n  var err = new Error('Request has been terminated\\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');\n  err.crossDomain = true;\n\n  err.status = this.status;\n  err.method = this.method;\n  err.url = this.url;\n\n  this.callback(err);\n};\n\n/**\n * Invoke callback with timeout error.\n *\n * @api private\n */\n\nRequest.prototype._timeoutError = function(){\n  var timeout = this._timeout;\n  var err = new Error('timeout of ' + timeout + 'ms exceeded');\n  err.timeout = timeout;\n  this.callback(err);\n};\n\n/**\n * Compose querystring to append to req.url\n *\n * @api private\n */\n\nRequest.prototype._appendQueryString = function(){\n  var query = this._query.join('&');\n  if (query) {\n    this.url += ~this.url.indexOf('?')\n      ? '&' + query\n      : '?' + query;\n  }\n};\n\n/**\n * Initiate request, invoking callback `fn(res)`\n * with an instanceof `Response`.\n *\n * @param {Function} fn\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.end = function(fn){\n  var self = this;\n  var xhr = this.xhr = request.getXHR();\n  var timeout = this._timeout;\n  var data = this._formData || this._data;\n\n  // store callback\n  this._callback = fn || noop;\n\n  // state change\n  xhr.onreadystatechange = function(){\n    if (4 != xhr.readyState) return;\n\n    // In IE9, reads to any property (e.g. status) off of an aborted XHR will\n    // result in the error \"Could not complete the operation due to error c00c023f\"\n    var status;\n    try { status = xhr.status } catch(e) { status = 0; }\n\n    if (0 == status) {\n      if (self.timedout) return self._timeoutError();\n      if (self._aborted) return;\n      return self.crossDomainError();\n    }\n    self.emit('end');\n  };\n\n  // progress\n  var handleProgress = function(direction, e) {\n    if (e.total > 0) {\n      e.percent = e.loaded / e.total * 100;\n    }\n    e.direction = direction;\n    self.emit('progress', e);\n  }\n  if (this.hasListeners('progress')) {\n    try {\n      xhr.onprogress = handleProgress.bind(null, 'download');\n      if (xhr.upload) {\n        xhr.upload.onprogress = handleProgress.bind(null, 'upload');\n      }\n    } catch(e) {\n      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.\n      // Reported here:\n      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context\n    }\n  }\n\n  // timeout\n  if (timeout && !this._timer) {\n    this._timer = setTimeout(function(){\n      self.timedout = true;\n      self.abort();\n    }, timeout);\n  }\n\n  // querystring\n  this._appendQueryString();\n\n  // initiate request\n  if (this.username && this.password) {\n    xhr.open(this.method, this.url, true, this.username, this.password);\n  } else {\n    xhr.open(this.method, this.url, true);\n  }\n\n  // CORS\n  if (this._withCredentials) xhr.withCredentials = true;\n\n  // body\n  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {\n    // serialize stuff\n    var contentType = this._header['content-type'];\n    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];\n    if (!serialize && isJSON(contentType)) serialize = request.serialize['application/json'];\n    if (serialize) data = serialize(data);\n  }\n\n  // set header fields\n  for (var field in this.header) {\n    if (null == this.header[field]) continue;\n    xhr.setRequestHeader(field, this.header[field]);\n  }\n\n  if (this._responseType) {\n    xhr.responseType = this._responseType;\n  }\n\n  // send stuff\n  this.emit('request', this);\n\n  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)\n  // We need null here if data is undefined\n  xhr.send(typeof data !== 'undefined' ? data : null);\n  return this;\n};\n\n\n/**\n * Expose `Request`.\n */\n\nrequest.Request = Request;\n\n/**\n * GET `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.get = function(url, data, fn){\n  var req = request('GET', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.query(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * HEAD `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.head = function(url, data, fn){\n  var req = request('HEAD', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * OPTIONS query to `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.options = function(url, data, fn){\n  var req = request('OPTIONS', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * DELETE `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nfunction del(url, fn){\n  var req = request('DELETE', url);\n  if (fn) req.end(fn);\n  return req;\n};\n\nrequest['del'] = del;\nrequest['delete'] = del;\n\n/**\n * PATCH `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} [data]\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.patch = function(url, data, fn){\n  var req = request('PATCH', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * POST `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} [data]\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.post = function(url, data, fn){\n  var req = request('POST', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * PUT `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.put = function(url, data, fn){\n  var req = request('PUT', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/superagent/lib/client.js\n ** module id = 20\n ** module chunks = 0\n **/","\r\n/**\r\n * Expose `Emitter`.\r\n */\r\n\r\nif (typeof module !== 'undefined') {\r\n  module.exports = Emitter;\r\n}\r\n\r\n/**\r\n * Initialize a new `Emitter`.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction Emitter(obj) {\r\n  if (obj) return mixin(obj);\r\n};\r\n\r\n/**\r\n * Mixin the emitter properties.\r\n *\r\n * @param {Object} obj\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction mixin(obj) {\r\n  for (var key in Emitter.prototype) {\r\n    obj[key] = Emitter.prototype[key];\r\n  }\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Listen on the given `event` with `fn`.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.on =\r\nEmitter.prototype.addEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\r\n    .push(fn);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Adds an `event` listener that will be invoked a single\r\n * time then automatically removed.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.once = function(event, fn){\r\n  function on() {\r\n    this.off(event, on);\r\n    fn.apply(this, arguments);\r\n  }\r\n\r\n  on.fn = fn;\r\n  this.on(event, on);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Remove the given callback for `event` or all\r\n * registered callbacks.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.off =\r\nEmitter.prototype.removeListener =\r\nEmitter.prototype.removeAllListeners =\r\nEmitter.prototype.removeEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n\r\n  // all\r\n  if (0 == arguments.length) {\r\n    this._callbacks = {};\r\n    return this;\r\n  }\r\n\r\n  // specific event\r\n  var callbacks = this._callbacks['$' + event];\r\n  if (!callbacks) return this;\r\n\r\n  // remove all handlers\r\n  if (1 == arguments.length) {\r\n    delete this._callbacks['$' + event];\r\n    return this;\r\n  }\r\n\r\n  // remove specific handler\r\n  var cb;\r\n  for (var i = 0; i < callbacks.length; i++) {\r\n    cb = callbacks[i];\r\n    if (cb === fn || cb.fn === fn) {\r\n      callbacks.splice(i, 1);\r\n      break;\r\n    }\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Emit `event` with the given args.\r\n *\r\n * @param {String} event\r\n * @param {Mixed} ...\r\n * @return {Emitter}\r\n */\r\n\r\nEmitter.prototype.emit = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  var args = [].slice.call(arguments, 1)\r\n    , callbacks = this._callbacks['$' + event];\r\n\r\n  if (callbacks) {\r\n    callbacks = callbacks.slice(0);\r\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\r\n      callbacks[i].apply(this, args);\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Return array of callbacks for `event`.\r\n *\r\n * @param {String} event\r\n * @return {Array}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.listeners = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  return this._callbacks['$' + event] || [];\r\n};\r\n\r\n/**\r\n * Check if this emitter has `event` handlers.\r\n *\r\n * @param {String} event\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.hasListeners = function(event){\r\n  return !! this.listeners(event).length;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/component-emitter/index.js\n ** module id = 21\n ** module chunks = 0\n **/","/**\n * Module of mixed-in functions shared between node and client code\n */\nvar isObject = require('./is-object');\n\n/**\n * Clear previous timeout.\n *\n * @return {Request} for chaining\n * @api public\n */\n\nexports.clearTimeout = function _clearTimeout(){\n  this._timeout = 0;\n  clearTimeout(this._timer);\n  return this;\n};\n\n/**\n * Override default response body parser\n *\n * This function will be called to convert incoming data into request.body\n *\n * @param {Function}\n * @api public\n */\n\nexports.parse = function parse(fn){\n  this._parser = fn;\n  return this;\n};\n\n/**\n * Override default request body serializer\n *\n * This function will be called to convert data set via .send or .attach into payload to send\n *\n * @param {Function}\n * @api public\n */\n\nexports.serialize = function serialize(fn){\n  this._serializer = fn;\n  return this;\n};\n\n/**\n * Set timeout to `ms`.\n *\n * @param {Number} ms\n * @return {Request} for chaining\n * @api public\n */\n\nexports.timeout = function timeout(ms){\n  this._timeout = ms;\n  return this;\n};\n\n/**\n * Promise support\n *\n * @param {Function} resolve\n * @param {Function} reject\n * @return {Request}\n */\n\nexports.then = function then(resolve, reject) {\n  if (!this._fullfilledPromise) {\n    var self = this;\n    this._fullfilledPromise = new Promise(function(innerResolve, innerReject){\n      self.end(function(err, res){\n        if (err) innerReject(err); else innerResolve(res);\n      });\n    });\n  }\n  return this._fullfilledPromise.then(resolve, reject);\n}\n\nexports.catch = function(cb) {\n  return this.then(undefined, cb);\n};\n\n/**\n * Allow for extension\n */\n\nexports.use = function use(fn) {\n  fn(this);\n  return this;\n}\n\n\n/**\n * Get request header `field`.\n * Case-insensitive.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nexports.get = function(field){\n  return this._header[field.toLowerCase()];\n};\n\n/**\n * Get case-insensitive header `field` value.\n * This is a deprecated internal API. Use `.get(field)` instead.\n *\n * (getHeader is no longer used internally by the superagent code base)\n *\n * @param {String} field\n * @return {String}\n * @api private\n * @deprecated\n */\n\nexports.getHeader = exports.get;\n\n/**\n * Set header `field` to `val`, or multiple fields with one object.\n * Case-insensitive.\n *\n * Examples:\n *\n *      req.get('/')\n *        .set('Accept', 'application/json')\n *        .set('X-API-Key', 'foobar')\n *        .end(callback);\n *\n *      req.get('/')\n *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })\n *        .end(callback);\n *\n * @param {String|Object} field\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nexports.set = function(field, val){\n  if (isObject(field)) {\n    for (var key in field) {\n      this.set(key, field[key]);\n    }\n    return this;\n  }\n  this._header[field.toLowerCase()] = val;\n  this.header[field] = val;\n  return this;\n};\n\n/**\n * Remove header `field`.\n * Case-insensitive.\n *\n * Example:\n *\n *      req.get('/')\n *        .unset('User-Agent')\n *        .end(callback);\n *\n * @param {String} field\n */\nexports.unset = function(field){\n  delete this._header[field.toLowerCase()];\n  delete this.header[field];\n  return this;\n};\n\n/**\n * Write the field `name` and `val`, or multiple fields with one object\n * for \"multipart/form-data\" request bodies.\n *\n * ``` js\n * request.post('/upload')\n *   .field('foo', 'bar')\n *   .end(callback);\n *\n * request.post('/upload')\n *   .field({ foo: 'bar', baz: 'qux' })\n *   .end(callback);\n * ```\n *\n * @param {String|Object} name\n * @param {String|Blob|File|Buffer|fs.ReadStream} val\n * @return {Request} for chaining\n * @api public\n */\nexports.field = function(name, val) {\n\n  // name should be either a string or an object.\n  if (null === name ||  undefined === name) {\n    throw new Error('.field(name, val) name can not be empty');\n  }\n\n  if (isObject(name)) {\n    for (var key in name) {\n      this.field(key, name[key]);\n    }\n    return this;\n  }\n\n  // val should be defined now\n  if (null === val || undefined === val) {\n    throw new Error('.field(name, val) val can not be empty');\n  }\n  this._getFormData().append(name, val);\n  return this;\n};\n\n/**\n * Abort the request, and clear potential timeout.\n *\n * @return {Request}\n * @api public\n */\nexports.abort = function(){\n  if (this._aborted) {\n    return this;\n  }\n  this._aborted = true;\n  this.xhr && this.xhr.abort(); // browser\n  this.req && this.req.abort(); // node\n  this.clearTimeout();\n  this.emit('abort');\n  return this;\n};\n\n/**\n * Enable transmission of cookies with x-domain requests.\n *\n * Note that for this to work the origin must not be\n * using \"Access-Control-Allow-Origin\" with a wildcard,\n * and also must set \"Access-Control-Allow-Credentials\"\n * to \"true\".\n *\n * @api public\n */\n\nexports.withCredentials = function(){\n  // This is browser-only functionality. Node side is no-op.\n  this._withCredentials = true;\n  return this;\n};\n\n/**\n * Set the max redirects to `n`. Does noting in browser XHR implementation.\n *\n * @param {Number} n\n * @return {Request} for chaining\n * @api public\n */\n\nexports.redirects = function(n){\n  this._maxRedirects = n;\n  return this;\n};\n\n/**\n * Convert to a plain javascript object (not JSON string) of scalar properties.\n * Note as this method is designed to return a useful non-this value,\n * it cannot be chained.\n *\n * @return {Object} describing method, url, and data of this request\n * @api public\n */\n\nexports.toJSON = function(){\n  return {\n    method: this.method,\n    url: this.url,\n    data: this._data,\n    headers: this._header\n  };\n};\n\n/**\n * Check if `obj` is a host object,\n * we don't want to serialize these :)\n *\n * TODO: future proof, move to compoent land\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nexports._isHost = function _isHost(obj) {\n  var str = {}.toString.call(obj);\n\n  switch (str) {\n    case '[object File]':\n    case '[object Blob]':\n    case '[object FormData]':\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Send `data` as the request body, defaulting the `.type()` to \"json\" when\n * an object is given.\n *\n * Examples:\n *\n *       // manual json\n *       request.post('/user')\n *         .type('json')\n *         .send('{\"name\":\"tj\"}')\n *         .end(callback)\n *\n *       // auto json\n *       request.post('/user')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // manual x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send('name=tj')\n *         .end(callback)\n *\n *       // auto x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // defaults to x-www-form-urlencoded\n *      request.post('/user')\n *        .send('name=tobi')\n *        .send('species=ferret')\n *        .end(callback)\n *\n * @param {String|Object} data\n * @return {Request} for chaining\n * @api public\n */\n\nexports.send = function(data){\n  var obj = isObject(data);\n  var type = this._header['content-type'];\n\n  // merge\n  if (obj && isObject(this._data)) {\n    for (var key in data) {\n      this._data[key] = data[key];\n    }\n  } else if ('string' == typeof data) {\n    // default to x-www-form-urlencoded\n    if (!type) this.type('form');\n    type = this._header['content-type'];\n    if ('application/x-www-form-urlencoded' == type) {\n      this._data = this._data\n        ? this._data + '&' + data\n        : data;\n    } else {\n      this._data = (this._data || '') + data;\n    }\n  } else {\n    this._data = data;\n  }\n\n  if (!obj || this._isHost(data)) return this;\n\n  // default to json\n  if (!type) this.type('json');\n  return this;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/superagent/lib/request-base.js\n ** module id = 22\n ** module chunks = 0\n **/","/**\n * Check if `obj` is an object.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isObject(obj) {\n  return null !== obj && 'object' === typeof obj;\n}\n\nmodule.exports = isObject;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/superagent/lib/is-object.js\n ** module id = 23\n ** module chunks = 0\n **/","// The node and browser modules expose versions of this with the\n// appropriate constructor function bound as first argument\n/**\n * Issue a request:\n *\n * Examples:\n *\n *    request('GET', '/users').end(callback)\n *    request('/users').end(callback)\n *    request('/users', callback)\n *\n * @param {String} method\n * @param {String|Function} url or callback\n * @return {Request}\n * @api public\n */\n\nfunction request(RequestConstructor, method, url) {\n  // callback\n  if ('function' == typeof url) {\n    return new RequestConstructor('GET', method).end(url);\n  }\n\n  // url first\n  if (2 == arguments.length) {\n    return new RequestConstructor('GET', method);\n  }\n\n  return new RequestConstructor(method, url);\n}\n\nmodule.exports = request;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/superagent/lib/request.js\n ** module id = 24\n ** module chunks = 0\n **/",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Initialization and round constants tables\n\t    var H = [];\n\t    var K = [];\n\n\t    // Compute constants\n\t    (function () {\n\t        function isPrime(n) {\n\t            var sqrtN = Math.sqrt(n);\n\t            for (var factor = 2; factor <= sqrtN; factor++) {\n\t                if (!(n % factor)) {\n\t                    return false;\n\t                }\n\t            }\n\n\t            return true;\n\t        }\n\n\t        function getFractionalBits(n) {\n\t            return ((n - (n | 0)) * 0x100000000) | 0;\n\t        }\n\n\t        var n = 2;\n\t        var nPrime = 0;\n\t        while (nPrime < 64) {\n\t            if (isPrime(n)) {\n\t                if (nPrime < 8) {\n\t                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n\t                }\n\t                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\n\t                nPrime++;\n\t            }\n\n\t            n++;\n\t        }\n\t    }());\n\n\t    // Reusable object\n\t    var W = [];\n\n\t    /**\n\t     * SHA-256 hash algorithm.\n\t     */\n\t    var SHA256 = C_algo.SHA256 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init(H.slice(0));\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var H = this._hash.words;\n\n\t            // Working variables\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\t            var e = H[4];\n\t            var f = H[5];\n\t            var g = H[6];\n\t            var h = H[7];\n\n\t            // Computation\n\t            for (var i = 0; i < 64; i++) {\n\t                if (i < 16) {\n\t                    W[i] = M[offset + i] | 0;\n\t                } else {\n\t                    var gamma0x = W[i - 15];\n\t                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n\t                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n\t                                   (gamma0x >>> 3);\n\n\t                    var gamma1x = W[i - 2];\n\t                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n\t                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n\t                                   (gamma1x >>> 10);\n\n\t                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n\t                }\n\n\t                var ch  = (e & f) ^ (~e & g);\n\t                var maj = (a & b) ^ (a & c) ^ (b & c);\n\n\t                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n\t                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n\t                var t1 = h + sigma1 + ch + K[i] + W[i];\n\t                var t2 = sigma0 + maj;\n\n\t                h = g;\n\t                g = f;\n\t                f = e;\n\t                e = (d + t1) | 0;\n\t                d = c;\n\t                c = b;\n\t                b = a;\n\t                a = (t1 + t2) | 0;\n\t            }\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t            H[4] = (H[4] + e) | 0;\n\t            H[5] = (H[5] + f) | 0;\n\t            H[6] = (H[6] + g) | 0;\n\t            H[7] = (H[7] + h) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Return final computed hash\n\t            return this._hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA256('message');\n\t     *     var hash = CryptoJS.SHA256(wordArray);\n\t     */\n\t    C.SHA256 = Hasher._createHelper(SHA256);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA256(message, key);\n\t     */\n\t    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n\t}(Math));\n\n\n\treturn CryptoJS.SHA256;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/crypto-js/sha256.js\n ** module id = 25\n ** module chunks = 0\n **/",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory();\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\troot.CryptoJS = factory();\n\t}\n}(this, function () {\n\n\t/**\n\t * CryptoJS core components.\n\t */\n\tvar CryptoJS = CryptoJS || (function (Math, undefined) {\n\t    /*\n\t     * Local polyfil of Object.create\n\t     */\n\t    var create = Object.create || (function () {\n\t        function F() {};\n\n\t        return function (obj) {\n\t            var subtype;\n\n\t            F.prototype = obj;\n\n\t            subtype = new F();\n\n\t            F.prototype = null;\n\n\t            return subtype;\n\t        };\n\t    }())\n\n\t    /**\n\t     * CryptoJS namespace.\n\t     */\n\t    var C = {};\n\n\t    /**\n\t     * Library namespace.\n\t     */\n\t    var C_lib = C.lib = {};\n\n\t    /**\n\t     * Base object for prototypal inheritance.\n\t     */\n\t    var Base = C_lib.Base = (function () {\n\n\n\t        return {\n\t            /**\n\t             * Creates a new object that inherits from this object.\n\t             *\n\t             * @param {Object} overrides Properties to copy into the new object.\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         field: 'value',\n\t             *\n\t             *         method: function () {\n\t             *         }\n\t             *     });\n\t             */\n\t            extend: function (overrides) {\n\t                // Spawn\n\t                var subtype = create(this);\n\n\t                // Augment\n\t                if (overrides) {\n\t                    subtype.mixIn(overrides);\n\t                }\n\n\t                // Create default initializer\n\t                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {\n\t                    subtype.init = function () {\n\t                        subtype.$super.init.apply(this, arguments);\n\t                    };\n\t                }\n\n\t                // Initializer's prototype is the subtype object\n\t                subtype.init.prototype = subtype;\n\n\t                // Reference supertype\n\t                subtype.$super = this;\n\n\t                return subtype;\n\t            },\n\n\t            /**\n\t             * Extends this object and runs the init method.\n\t             * Arguments to create() will be passed to init().\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var instance = MyType.create();\n\t             */\n\t            create: function () {\n\t                var instance = this.extend();\n\t                instance.init.apply(instance, arguments);\n\n\t                return instance;\n\t            },\n\n\t            /**\n\t             * Initializes a newly created object.\n\t             * Override this method to add some logic when your objects are created.\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         init: function () {\n\t             *             // ...\n\t             *         }\n\t             *     });\n\t             */\n\t            init: function () {\n\t            },\n\n\t            /**\n\t             * Copies properties into this object.\n\t             *\n\t             * @param {Object} properties The properties to mix in.\n\t             *\n\t             * @example\n\t             *\n\t             *     MyType.mixIn({\n\t             *         field: 'value'\n\t             *     });\n\t             */\n\t            mixIn: function (properties) {\n\t                for (var propertyName in properties) {\n\t                    if (properties.hasOwnProperty(propertyName)) {\n\t                        this[propertyName] = properties[propertyName];\n\t                    }\n\t                }\n\n\t                // IE won't copy toString using the loop above\n\t                if (properties.hasOwnProperty('toString')) {\n\t                    this.toString = properties.toString;\n\t                }\n\t            },\n\n\t            /**\n\t             * Creates a copy of this object.\n\t             *\n\t             * @return {Object} The clone.\n\t             *\n\t             * @example\n\t             *\n\t             *     var clone = instance.clone();\n\t             */\n\t            clone: function () {\n\t                return this.init.prototype.extend(this);\n\t            }\n\t        };\n\t    }());\n\n\t    /**\n\t     * An array of 32-bit words.\n\t     *\n\t     * @property {Array} words The array of 32-bit words.\n\t     * @property {number} sigBytes The number of significant bytes in this word array.\n\t     */\n\t    var WordArray = C_lib.WordArray = Base.extend({\n\t        /**\n\t         * Initializes a newly created word array.\n\t         *\n\t         * @param {Array} words (Optional) An array of 32-bit words.\n\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.create();\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n\t         */\n\t        init: function (words, sigBytes) {\n\t            words = this.words = words || [];\n\n\t            if (sigBytes != undefined) {\n\t                this.sigBytes = sigBytes;\n\t            } else {\n\t                this.sigBytes = words.length * 4;\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts this word array to a string.\n\t         *\n\t         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n\t         *\n\t         * @return {string} The stringified word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = wordArray + '';\n\t         *     var string = wordArray.toString();\n\t         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n\t         */\n\t        toString: function (encoder) {\n\t            return (encoder || Hex).stringify(this);\n\t        },\n\n\t        /**\n\t         * Concatenates a word array to this word array.\n\t         *\n\t         * @param {WordArray} wordArray The word array to append.\n\t         *\n\t         * @return {WordArray} This word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray1.concat(wordArray2);\n\t         */\n\t        concat: function (wordArray) {\n\t            // Shortcuts\n\t            var thisWords = this.words;\n\t            var thatWords = wordArray.words;\n\t            var thisSigBytes = this.sigBytes;\n\t            var thatSigBytes = wordArray.sigBytes;\n\n\t            // Clamp excess bits\n\t            this.clamp();\n\n\t            // Concat\n\t            if (thisSigBytes % 4) {\n\t                // Copy one byte at a time\n\t                for (var i = 0; i < thatSigBytes; i++) {\n\t                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n\t                }\n\t            } else {\n\t                // Copy one word at a time\n\t                for (var i = 0; i < thatSigBytes; i += 4) {\n\t                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n\t                }\n\t            }\n\t            this.sigBytes += thatSigBytes;\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Removes insignificant bits.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray.clamp();\n\t         */\n\t        clamp: function () {\n\t            // Shortcuts\n\t            var words = this.words;\n\t            var sigBytes = this.sigBytes;\n\n\t            // Clamp\n\t            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n\t            words.length = Math.ceil(sigBytes / 4);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this word array.\n\t         *\n\t         * @return {WordArray} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = wordArray.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone.words = this.words.slice(0);\n\n\t            return clone;\n\t        },\n\n\t        /**\n\t         * Creates a word array filled with random bytes.\n\t         *\n\t         * @param {number} nBytes The number of random bytes to generate.\n\t         *\n\t         * @return {WordArray} The random word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n\t         */\n\t        random: function (nBytes) {\n\t            var words = [];\n\n\t            var r = (function (m_w) {\n\t                var m_w = m_w;\n\t                var m_z = 0x3ade68b1;\n\t                var mask = 0xffffffff;\n\n\t                return function () {\n\t                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;\n\t                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;\n\t                    var result = ((m_z << 0x10) + m_w) & mask;\n\t                    result /= 0x100000000;\n\t                    result += 0.5;\n\t                    return result * (Math.random() > .5 ? 1 : -1);\n\t                }\n\t            });\n\n\t            for (var i = 0, rcache; i < nBytes; i += 4) {\n\t                var _r = r((rcache || Math.random()) * 0x100000000);\n\n\t                rcache = _r() * 0x3ade67b7;\n\t                words.push((_r() * 0x100000000) | 0);\n\t            }\n\n\t            return new WordArray.init(words, nBytes);\n\t        }\n\t    });\n\n\t    /**\n\t     * Encoder namespace.\n\t     */\n\t    var C_enc = C.enc = {};\n\n\t    /**\n\t     * Hex encoding strategy.\n\t     */\n\t    var Hex = C_enc.Hex = {\n\t        /**\n\t         * Converts a word array to a hex string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The hex string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var hexChars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                hexChars.push((bite >>> 4).toString(16));\n\t                hexChars.push((bite & 0x0f).toString(16));\n\t            }\n\n\t            return hexChars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a hex string to a word array.\n\t         *\n\t         * @param {string} hexStr The hex string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n\t         */\n\t        parse: function (hexStr) {\n\t            // Shortcut\n\t            var hexStrLength = hexStr.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < hexStrLength; i += 2) {\n\t                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n\t            }\n\n\t            return new WordArray.init(words, hexStrLength / 2);\n\t        }\n\t    };\n\n\t    /**\n\t     * Latin1 encoding strategy.\n\t     */\n\t    var Latin1 = C_enc.Latin1 = {\n\t        /**\n\t         * Converts a word array to a Latin1 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Latin1 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var latin1Chars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                latin1Chars.push(String.fromCharCode(bite));\n\t            }\n\n\t            return latin1Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Latin1 string to a word array.\n\t         *\n\t         * @param {string} latin1Str The Latin1 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n\t         */\n\t        parse: function (latin1Str) {\n\t            // Shortcut\n\t            var latin1StrLength = latin1Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < latin1StrLength; i++) {\n\t                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n\t            }\n\n\t            return new WordArray.init(words, latin1StrLength);\n\t        }\n\t    };\n\n\t    /**\n\t     * UTF-8 encoding strategy.\n\t     */\n\t    var Utf8 = C_enc.Utf8 = {\n\t        /**\n\t         * Converts a word array to a UTF-8 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-8 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            try {\n\t                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n\t            } catch (e) {\n\t                throw new Error('Malformed UTF-8 data');\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts a UTF-8 string to a word array.\n\t         *\n\t         * @param {string} utf8Str The UTF-8 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n\t         */\n\t        parse: function (utf8Str) {\n\t            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n\t        }\n\t    };\n\n\t    /**\n\t     * Abstract buffered block algorithm template.\n\t     *\n\t     * The property blockSize must be implemented in a concrete subtype.\n\t     *\n\t     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n\t     */\n\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n\t        /**\n\t         * Resets this block algorithm's data buffer to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm.reset();\n\t         */\n\t        reset: function () {\n\t            // Initial values\n\t            this._data = new WordArray.init();\n\t            this._nDataBytes = 0;\n\t        },\n\n\t        /**\n\t         * Adds new data to this block algorithm's buffer.\n\t         *\n\t         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm._append('data');\n\t         *     bufferedBlockAlgorithm._append(wordArray);\n\t         */\n\t        _append: function (data) {\n\t            // Convert string to WordArray, else assume WordArray already\n\t            if (typeof data == 'string') {\n\t                data = Utf8.parse(data);\n\t            }\n\n\t            // Append\n\t            this._data.concat(data);\n\t            this._nDataBytes += data.sigBytes;\n\t        },\n\n\t        /**\n\t         * Processes available data blocks.\n\t         *\n\t         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n\t         *\n\t         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n\t         *\n\t         * @return {WordArray} The processed data.\n\t         *\n\t         * @example\n\t         *\n\t         *     var processedData = bufferedBlockAlgorithm._process();\n\t         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n\t         */\n\t        _process: function (doFlush) {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\t            var dataSigBytes = data.sigBytes;\n\t            var blockSize = this.blockSize;\n\t            var blockSizeBytes = blockSize * 4;\n\n\t            // Count blocks ready\n\t            var nBlocksReady = dataSigBytes / blockSizeBytes;\n\t            if (doFlush) {\n\t                // Round up to include partial blocks\n\t                nBlocksReady = Math.ceil(nBlocksReady);\n\t            } else {\n\t                // Round down to include only full blocks,\n\t                // less the number of blocks that must remain in the buffer\n\t                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n\t            }\n\n\t            // Count words ready\n\t            var nWordsReady = nBlocksReady * blockSize;\n\n\t            // Count bytes ready\n\t            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n\t            // Process blocks\n\t            if (nWordsReady) {\n\t                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n\t                    // Perform concrete-algorithm logic\n\t                    this._doProcessBlock(dataWords, offset);\n\t                }\n\n\t                // Remove processed words\n\t                var processedWords = dataWords.splice(0, nWordsReady);\n\t                data.sigBytes -= nBytesReady;\n\t            }\n\n\t            // Return processed words\n\t            return new WordArray.init(processedWords, nBytesReady);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this object.\n\t         *\n\t         * @return {Object} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = bufferedBlockAlgorithm.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone._data = this._data.clone();\n\n\t            return clone;\n\t        },\n\n\t        _minBufferSize: 0\n\t    });\n\n\t    /**\n\t     * Abstract hasher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n\t     */\n\t    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n\t        /**\n\t         * Configuration options.\n\t         */\n\t        cfg: Base.extend(),\n\n\t        /**\n\t         * Initializes a newly created hasher.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hasher = CryptoJS.algo.SHA256.create();\n\t         */\n\t        init: function (cfg) {\n\t            // Apply config defaults\n\t            this.cfg = this.cfg.extend(cfg);\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this hasher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.reset();\n\t         */\n\t        reset: function () {\n\t            // Reset data buffer\n\t            BufferedBlockAlgorithm.reset.call(this);\n\n\t            // Perform concrete-hasher logic\n\t            this._doReset();\n\t        },\n\n\t        /**\n\t         * Updates this hasher with a message.\n\t         *\n\t         * @param {WordArray|string} messageUpdate The message to append.\n\t         *\n\t         * @return {Hasher} This hasher.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.update('message');\n\t         *     hasher.update(wordArray);\n\t         */\n\t        update: function (messageUpdate) {\n\t            // Append\n\t            this._append(messageUpdate);\n\n\t            // Update the hash\n\t            this._process();\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Finalizes the hash computation.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t         *\n\t         * @return {WordArray} The hash.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hash = hasher.finalize();\n\t         *     var hash = hasher.finalize('message');\n\t         *     var hash = hasher.finalize(wordArray);\n\t         */\n\t        finalize: function (messageUpdate) {\n\t            // Final message update\n\t            if (messageUpdate) {\n\t                this._append(messageUpdate);\n\t            }\n\n\t            // Perform concrete-hasher logic\n\t            var hash = this._doFinalize();\n\n\t            return hash;\n\t        },\n\n\t        blockSize: 512/32,\n\n\t        /**\n\t         * Creates a shortcut function to a hasher's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to create a helper for.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHelper: function (hasher) {\n\t            return function (message, cfg) {\n\t                return new hasher.init(cfg).finalize(message);\n\t            };\n\t        },\n\n\t        /**\n\t         * Creates a shortcut function to the HMAC's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHmacHelper: function (hasher) {\n\t            return function (message, key) {\n\t                return new C_algo.HMAC.init(hasher, key).finalize(message);\n\t            };\n\t        }\n\t    });\n\n\t    /**\n\t     * Algorithm namespace.\n\t     */\n\t    var C_algo = C.algo = {};\n\n\t    return C;\n\t}(Math));\n\n\n\treturn CryptoJS;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/crypto-js/core.js\n ** module id = 26\n ** module chunks = 0\n **/","import olog from 'loglevel';\n\nvar originalFactory = olog.methodFactory;\n\nolog.methodFactory = function (methodName, logLevel) {\n  var rawMethod = originalFactory(methodName, logLevel);\n\n  return function (message) {\n    rawMethod('Telepat: ' + message);\n  };\n};\nolog.setLevel('warn');\n\nexport default olog;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/logger.js\n **/","/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n\n    function realMethod(methodName) {\n        if (typeof console === undefinedType) {\n            return false; // We can't build a real method without a console to log to\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // these private functions always need `this` to be set properly\n\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n    }\n\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = \"loglevel\";\n      if (name) {\n        storageKey += \":\" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public API\n       *\n       */\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Package-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"string\" || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    return defaultLogger;\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/loglevel/lib/loglevel.js\n ** module id = 28\n ** module chunks = 0\n **/","import log from './logger';\n\nexport default function error(string) {\n  log.error(string);\n  return new Error(string);\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/error.js\n **/","import log from './logger';\n\nexport default class Event {\n  constructor() {\n    this.eventFunctions = {};\n  }\n\n  on(name, callback) {\n    if (typeof this.eventFunctions[name] !== 'object') {\n      this.eventFunctions[name] = {};\n    }\n\n    let index = Date.now() + Object.keys(this.eventFunctions[name]).length;\n\n    this.eventFunctions[name][index] = callback;\n    return index;\n  }\n\n  removeCallback(name, index) {\n    delete this.eventFunctions[name][index];\n  }\n\n  emit(args) {\n    log.debug('Emitting ' + arguments[0] + ' event');\n    let params = Array.prototype.slice.call(arguments);\n\n    params.shift();\n    if (typeof this.eventFunctions[arguments[0]] !== 'undefined') {\n      let callbacks = this.eventFunctions[arguments[0]];\n\n      for (let index in callbacks) {\n        callbacks[index].apply(this, params);\n      }\n    }\n  };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/event.js\n **/","import EventObject from './event';\nimport API from './api';\nimport log from './logger';\nimport error from './error';\nimport JDP from 'jsondiffpatch';\n\nvar jsondiffpatch = JDP.create({\n  objectHash: function (obj) {\n    if (obj.id) {\n      return obj.id;\n    }\n    return JSON.stringify(obj);\n  }, textDiff: {\n    minLength: 10000\n  }\n});\n\nexport default class Monitor {\n  constructor(interval = 150) {\n    function objectPropertyTrimFilter(context) {\n      function trimObject(obj) {\n        var trimmedObject = {};\n\n        for (var name in obj) {\n          if (name.slice(0, 2) !== '$$' && typeof obj[name] !== 'function') {\n            trimmedObject[name] = obj[name];\n          }\n        }\n        return trimmedObject;\n      }\n      if (!context.leftIsArray && context.leftType === 'object') {\n        context.left = trimObject(context.left);\n      }\n      if (!context.rightIsArray && context.rightType === 'object') {\n        context.right = trimObject(context.right);\n      }\n    }\n\n    jsondiffpatch.processor.pipes.diff.before('objects', objectPropertyTrimFilter);\n\n    this._updateRunning = false;\n    this._processingPatch = false;\n    this._timer = null;\n    this._lastObjects = {};\n    this._events = {};\n\n    this.objects = {};\n    this.options = {};\n    this.callbacks = {};\n    this.timerInterval = interval;\n  }\n\n  static subscriptionKeyForOptions(options) {\n    var key = 'blg:' + API.appId;\n\n    if (!options.channel.id && options.channel.context) {\n      key += ':context:' + options.channel.context;\n    }\n    if (options.channel.parent) {\n      key += ':' + options.channel.parent.model + ':' + options.channel.parent.id;\n    }\n    if (options.channel.user) {\n      key += ':users:' + options.channel.user;\n    }\n    key += ':' + options.channel.model;\n    if (options.channel.id) {\n      key += ':' + options.channel.id;\n    }\n    if (options.filters) {\n      key += ':filter:' + (new Buffer(JSON.stringify(options.filters)).toString('base64'));\n    }\n    return key;\n  };\n\n  remove(subscriptionOptions) {\n    var subscriptionKey = Monitor.subscriptionKeyForOptions(subscriptionOptions);\n\n    delete this.objects[subscriptionKey];\n    delete this._lastObjects[subscriptionKey];\n    delete this.options[subscriptionKey];\n    delete this.callbacks[subscriptionKey];\n    delete this._events[subscriptionKey];\n  };\n\n  add(subscriptionOptions, objects, event, addCallback, removeCallback, updateCallback) {\n    let processDeltaObject = (object) => {\n      if (Array.isArray(object) || object['_t'] === 'a') {\n        return true;\n      }\n      for (var key in object) {\n        if (typeof object[key] === 'object' && processDeltaObject(object[key])) {\n          delete object[key];\n        }\n      }\n      if (Object.keys(object).length === 0) {\n        return true;\n      }\n      return false;\n    };\n\n    let timerFunction = () => {\n      if (this._processingPatch || this._updateRunning) {\n        return;\n      }\n      let totalDiff = jsondiffpatch.diff(this._lastObjects, this.objects);\n\n      if (totalDiff !== undefined) {\n        log.debug('Found diff: ' + JSON.stringify(totalDiff));\n        for (let subKey in totalDiff) {\n          let root = this._lastObjects[subKey];\n          let diff = totalDiff[subKey];\n          let options = this.options[subKey];\n          let callbacks = this.callbacks[subKey];\n          let diffKeys = Object.keys(diff);\n\n          for (let i = 0; i < diffKeys.length; i++) {\n            var key = diffKeys[i];\n\n            if (key !== '_t') {\n              var obj = diff[key];\n\n              if (Array.isArray(obj)) {\n                if (obj.length === 1) {\n                  callbacks.add(this.objects[subKey][key]);\n                  delete root[key];\n                  delete this.objects[subKey][key];\n                  log.debug('Adding object to ' + subKey + ' channel');\n                } else if (obj.length === 3) {\n                  callbacks.remove(key);\n                  delete root[key];\n                  log.debug('Removing object from ' + subKey + ' channel');\n                }\n              } else {\n                var objKeys = Object.keys(obj);\n                var patch = [];\n                var publicKey = key;\n\n                if (Array.isArray(this.objects[subKey]) && this.objects[subKey][key].id) {\n                  publicKey = this.objects[subKey][key].id;\n                }\n\n                for (var j = 0; j < objKeys.length; j++) {\n                  var objKey = objKeys[j];\n                  var delta = obj[objKey];\n\n                  if (!processDeltaObject(delta)) {\n                    if (typeof delta === 'object') {\n                      patch.push({'op': 'replace', 'path': options.channel.model + '/' + publicKey + '/' + objKey, 'value': this.objects[subKey][key][objKey]});\n                      log.debug('Modified ' + objKey + ' property on object ' + key + ', ' + options.channel.model + ' channel');\n                    } else if (delta.length === 1) {\n                      patch.push({'op': 'replace', 'path': options.channel.model + '/' + publicKey + '/' + objKey, 'value': delta[0]});\n                      log.debug('Added ' + objKey + ' property to object ' + key + ', ' + options.channel.model + ' channel');\n                    } else if (delta.length === 2) {\n                      patch.push({'op': 'replace', 'path': options.channel.model + '/' + publicKey + '/' + objKey, 'value': delta[1]});\n                      log.debug('Modified ' + objKey + ' property on object ' + key + ', ' + options.channel.model + ' channel');\n                    } else if (delta.length === 3) {\n                      log.info('Removing object properties is not supported in this version. Try setting to an empty value instead.');\n                    }\n                  } else {\n                    patch.push({'op': 'replace', 'path': options.channel.model + '/' + publicKey + '/' + objKey, 'value': this.objects[subKey][key][objKey]});\n                    log.debug('Modified ' + objKey + ' property on object ' + key + ', ' + options.channel.model + ' channel');\n                  }\n\n                  root[key][objKey] = JSON.parse(JSON.stringify(this.objects[subKey][key][objKey]));\n                }\n\n                if (patch.length) {\n                  callbacks.update(publicKey, patch);\n                }\n                log.debug('Sending patch to object ' + key + ' on ' + options.channel.model + ' channel: ' + JSON.stringify(patch));\n              }\n            }\n          }\n        }\n      }\n    };\n\n    var subscriptionKey = Monitor.subscriptionKeyForOptions(subscriptionOptions);\n\n    this.objects[subscriptionKey] = objects;\n    this.options[subscriptionKey] = subscriptionOptions;\n    this.callbacks[subscriptionKey] = {\n      add: addCallback,\n      remove: removeCallback,\n      update: updateCallback\n    };\n    this._events[subscriptionKey] = event;\n    this._lastObjects[subscriptionKey] = JSON.parse(JSON.stringify(this.objects[subscriptionKey]));\n\n    if (this._timer === null) {\n      this._timer = setInterval(timerFunction, this.timerInterval);\n    }\n  };\n\n  // ## Getting notified of object modifications\n  // Use the `Channel.on('update', ...)` function to subscribe to object updates.\n  //  This will only notify you of changes received from the 'outside' - you'll only see events when the backend\n  //  notifies the client that there are updates available, either made by you or by someone else.\n  //\n  //     Channel.on('update', function(operation, parentId, parentObject, delta) {\n  //       // operation can be one of 'replace', 'delete' or 'add'.\n  //       // parentId is the id of the Telepat object being modified.\n  //       // parentObject is the Telepat object being modified.\n  //       // delta is available just for the 'replace' operation, and is an object that contains two properties:\n  //  'path' (the name of the modified property on the object) and 'oldValue'.\n  //     });\n\n  processMessage(message) {\n    let process = (operation) => {\n      for (let i = 0; i < operation.subscriptions.length; i++) {\n        let subscription = operation.subscriptions[i];\n\n        let subscriptionComponents = subscription.split(':');\n\n        // Handle collection updates\n        if (subscriptionComponents[2] === 'context' && subscriptionComponents.length === 4) {\n          subscriptionComponents.pop();\n          subscription = subscriptionComponents.join(':');\n        }\n\n        let root = this.objects[subscription];\n        let lastRoot = this._lastObjects[subscription];\n        let event = this._events[subscription];\n\n        if (root) {\n          if (operation.op === 'new') {\n            if (!root.hasOwnProperty(operation.object.id)) {\n              operation.object.$$event = new EventObject(log);\n              root[operation.object.id] = operation.object;\n              lastRoot[operation.object.id] = JSON.parse(JSON.stringify(operation.object));\n              event.emit('update', 'add', operation.object.id, operation.object);\n              log.debug('Added object with id ' + operation.object.id);\n            } else {\n              event.emit('error', error('Object id already exists ' + operation.object.id), operation.object.id, root[operation.object.id]);\n            }\n          } else if (operation.op === 'update') {\n            let pathComponents = operation.patch.path.split('/');\n            let objectId = pathComponents[1];\n            let changedProperty = pathComponents[2];\n            let newValue = operation.patch.value;\n\n            if (!root.hasOwnProperty(objectId)) {\n              event.emit('error', error('Object id doesn\\'t exist ' + objectId), objectId, changedProperty, newValue);\n            } else if (typeof newValue !== 'undefined') {\n              let parent = root[objectId];\n              let oldValue;\n\n              if (typeof parent[changedProperty] !== 'undefined') {\n                oldValue = JSON.parse(JSON.stringify(parent[changedProperty]));\n              }\n\n              parent[changedProperty] = newValue;\n              lastRoot[objectId][changedProperty] = JSON.parse(JSON.stringify(newValue));\n              event.emit('update', 'replace', objectId, parent, { path: changedProperty, oldValue: oldValue });\n              log.debug('Replaced property ' + changedProperty + ' of object id ' + objectId + ' with  value ' + newValue);\n            } else {\n              event.emit('error', error('Invalid operation ' + JSON.stringify(operation)));\n            }\n          } else {\n            let oldValue = root[operation.object.id];\n\n            delete root[operation.object.id];\n            delete lastRoot[operation.object.id];\n            event.emit('update', 'delete', operation.object.id, oldValue);\n            log.debug('Removed object id ' + operation.object.id);\n          }\n        } else {\n          log.warn('Subscription not found ' + subscription);\n        }\n      }\n    };\n\n    this._processingPatch = true;\n    log.debug('Received update: ' + JSON.stringify(message));\n    var i, operation;\n\n    for (i = 0; i < message.data.new.length; i++) {\n      operation = message.data.new[i];\n      operation.op = 'new';\n      process(operation);\n    }\n    for (i = 0; i < message.data.updated.length; i++) {\n      operation = message.data.updated[i];\n      operation.op = 'update';\n      process(operation);\n    }\n    for (i = 0; i < message.data.deleted.length; i++) {\n      operation = message.data.deleted[i];\n      operation.op = 'remove';\n      process(operation);\n    }\n    this._processingPatch = false;\n  };\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/monitor.js\n **/","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/buffer/index.js\n ** module id = 32\n ** module chunks = 0\n **/","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr((len * 3 / 4) - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0; i < l; i += 4) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/base64-js/index.js\n ** module id = 33\n ** module chunks = 0\n **/","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ieee754/index.js\n ** module id = 34\n ** module chunks = 0\n **/","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/isarray/index.js\n ** module id = 35\n ** module chunks = 0\n **/","\nvar environment = require('./environment');\n\nvar DiffPatcher = require('./diffpatcher').DiffPatcher;\nexports.DiffPatcher = DiffPatcher;\n\nexports.create = function(options){\n  return new DiffPatcher(options);\n};\n\nexports.dateReviver = require('./date-reviver');\n\nvar defaultInstance;\n\nexports.diff = function() {\n  if (!defaultInstance) {\n    defaultInstance = new DiffPatcher();\n  }\n  return defaultInstance.diff.apply(defaultInstance, arguments);\n};\n\nexports.patch = function() {\n  if (!defaultInstance) {\n    defaultInstance = new DiffPatcher();\n  }\n  return defaultInstance.patch.apply(defaultInstance, arguments);\n};\n\nexports.unpatch = function() {\n  if (!defaultInstance) {\n    defaultInstance = new DiffPatcher();\n  }\n  return defaultInstance.unpatch.apply(defaultInstance, arguments);\n};\n\nexports.reverse = function() {\n  if (!defaultInstance) {\n    defaultInstance = new DiffPatcher();\n  }\n  return defaultInstance.reverse.apply(defaultInstance, arguments);\n};\n\nexports.clone = function() {\n  if (!defaultInstance) {\n    defaultInstance = new DiffPatcher();\n  }\n  return defaultInstance.clone.apply(defaultInstance, arguments);\n};\n\n\nif (environment.isBrowser) {\n  exports.homepage = '{{package-homepage}}';\n  exports.version = '{{package-version}}';\n} else {\n  var packageInfoModuleName = '../package.json';\n  var packageInfo = require(packageInfoModuleName);\n  exports.homepage = packageInfo.homepage;\n  exports.version = packageInfo.version;\n\n  var formatterModuleName = './formatters';\n  var formatters = require(formatterModuleName);\n  exports.formatters = formatters;\n  // shortcut for console\n  exports.console = formatters.console;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/main.js\n ** module id = 36\n ** module chunks = 0\n **/","\nexports.isBrowser = typeof window !== 'undefined';\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/environment.js\n ** module id = 37\n ** module chunks = 0\n **/","var Processor = require('./processor').Processor;\nvar Pipe = require('./pipe').Pipe;\nvar DiffContext = require('./contexts/diff').DiffContext;\nvar PatchContext = require('./contexts/patch').PatchContext;\nvar ReverseContext = require('./contexts/reverse').ReverseContext;\n\nvar clone = require('./clone');\n\nvar trivial = require('./filters/trivial');\nvar nested = require('./filters/nested');\nvar arrays = require('./filters/arrays');\nvar dates = require('./filters/dates');\nvar texts = require('./filters/texts');\n\nvar DiffPatcher = function DiffPatcher(options) {\n  this.processor = new Processor(options);\n  this.processor.pipe(new Pipe('diff').append(\n    nested.collectChildrenDiffFilter,\n    trivial.diffFilter,\n    dates.diffFilter,\n    texts.diffFilter,\n    nested.objectsDiffFilter,\n    arrays.diffFilter\n  ).shouldHaveResult());\n  this.processor.pipe(new Pipe('patch').append(\n    nested.collectChildrenPatchFilter,\n    arrays.collectChildrenPatchFilter,\n    trivial.patchFilter,\n    texts.patchFilter,\n    nested.patchFilter,\n    arrays.patchFilter\n  ).shouldHaveResult());\n  this.processor.pipe(new Pipe('reverse').append(\n    nested.collectChildrenReverseFilter,\n    arrays.collectChildrenReverseFilter,\n    trivial.reverseFilter,\n    texts.reverseFilter,\n    nested.reverseFilter,\n    arrays.reverseFilter\n  ).shouldHaveResult());\n};\n\nDiffPatcher.prototype.options = function() {\n  return this.processor.options.apply(this.processor, arguments);\n};\n\nDiffPatcher.prototype.diff = function(left, right) {\n  return this.processor.process(new DiffContext(left, right));\n};\n\nDiffPatcher.prototype.patch = function(left, delta) {\n  return this.processor.process(new PatchContext(left, delta));\n};\n\nDiffPatcher.prototype.reverse = function(delta) {\n  return this.processor.process(new ReverseContext(delta));\n};\n\nDiffPatcher.prototype.unpatch = function(right, delta) {\n  return this.patch(right, this.reverse(delta));\n};\n\nDiffPatcher.prototype.clone = function(value) {\n  return clone(value);\n};\n\nexports.DiffPatcher = DiffPatcher;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/diffpatcher.js\n ** module id = 38\n ** module chunks = 0\n **/","\nvar Processor = function Processor(options){\n  this.selfOptions = options || {};\n  this.pipes = {};\n};\n\nProcessor.prototype.options = function(options) {\n  if (options) {\n    this.selfOptions = options;\n  }\n  return this.selfOptions;\n};\n\nProcessor.prototype.pipe = function(name, pipe) {\n  if (typeof name === 'string') {\n    if (typeof pipe === 'undefined') {\n      return this.pipes[name];\n    } else {\n      this.pipes[name] = pipe;\n    }\n  }\n  if (name && name.name) {\n    pipe = name;\n    if (pipe.processor === this) { return pipe; }\n    this.pipes[pipe.name] = pipe;\n  }\n  pipe.processor = this;\n  return pipe;\n};\n\nProcessor.prototype.process = function(input, pipe) {\n  var context = input;\n  context.options = this.options();\n  var nextPipe = pipe || input.pipe || 'default';\n  var lastPipe, lastContext;\n  while (nextPipe) {\n    if (typeof context.nextAfterChildren !== 'undefined') {\n      // children processed and coming back to parent\n      context.next = context.nextAfterChildren;\n      context.nextAfterChildren = null;\n    }\n\n    if (typeof nextPipe === 'string') {\n      nextPipe = this.pipe(nextPipe);\n    }\n    nextPipe.process(context);\n    lastContext = context;\n    lastPipe = nextPipe;\n    nextPipe = null;\n    if (context) {\n      if (context.next) {\n        context = context.next;\n        nextPipe = lastContext.nextPipe || context.pipe || lastPipe;\n      }\n    }\n  }\n  return context.hasResult ? context.result : undefined;\n};\n\nexports.Processor = Processor;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/processor.js\n ** module id = 39\n ** module chunks = 0\n **/","var Pipe = function Pipe(name) {\n  this.name = name;\n  this.filters = [];\n};\n\nPipe.prototype.process = function(input) {\n  if (!this.processor) {\n    throw new Error('add this pipe to a processor before using it');\n  }\n  var debug = this.debug;\n  var length = this.filters.length;\n  var context = input;\n  for (var index = 0; index < length; index++) {\n    var filter = this.filters[index];\n    if (debug) {\n      this.log('filter: ' + filter.filterName);\n    }\n    filter(context);\n    if (typeof context === 'object' && context.exiting) {\n      context.exiting = false;\n      break;\n    }\n  }\n  if (!context.next && this.resultCheck) {\n    this.resultCheck(context);\n  }\n};\n\nPipe.prototype.log = function(msg) {\n  console.log('[jsondiffpatch] ' + this.name + ' pipe, ' + msg);\n};\n\nPipe.prototype.append = function() {\n  this.filters.push.apply(this.filters, arguments);\n  return this;\n};\n\nPipe.prototype.prepend = function() {\n  this.filters.unshift.apply(this.filters, arguments);\n  return this;\n};\n\nPipe.prototype.indexOf = function(filterName) {\n  if (!filterName) {\n    throw new Error('a filter name is required');\n  }\n  for (var index = 0; index < this.filters.length; index++) {\n    var filter = this.filters[index];\n    if (filter.filterName === filterName) {\n      return index;\n    }\n  }\n  throw new Error('filter not found: ' + filterName);\n};\n\nPipe.prototype.list = function() {\n  var names = [];\n  for (var index = 0; index < this.filters.length; index++) {\n    var filter = this.filters[index];\n    names.push(filter.filterName);\n  }\n  return names;\n};\n\nPipe.prototype.after = function(filterName) {\n  var index = this.indexOf(filterName);\n  var params = Array.prototype.slice.call(arguments, 1);\n  if (!params.length) {\n    throw new Error('a filter is required');\n  }\n  params.unshift(index + 1, 0);\n  Array.prototype.splice.apply(this.filters, params);\n  return this;\n};\n\nPipe.prototype.before = function(filterName) {\n  var index = this.indexOf(filterName);\n  var params = Array.prototype.slice.call(arguments, 1);\n  if (!params.length) {\n    throw new Error('a filter is required');\n  }\n  params.unshift(index, 0);\n  Array.prototype.splice.apply(this.filters, params);\n  return this;\n};\n\nPipe.prototype.clear = function() {\n  this.filters.length = 0;\n  return this;\n};\n\nPipe.prototype.shouldHaveResult = function(should) {\n  if (should === false) {\n    this.resultCheck = null;\n    return;\n  }\n  if (this.resultCheck) {\n    return;\n  }\n  var pipe = this;\n  this.resultCheck = function(context) {\n    if (!context.hasResult) {\n      console.log(context);\n      var error = new Error(pipe.name + ' failed');\n      error.noResult = true;\n      throw error;\n    }\n  };\n  return this;\n};\n\nexports.Pipe = Pipe;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/pipe.js\n ** module id = 40\n ** module chunks = 0\n **/","var Context = require('./context').Context;\nvar defaultClone = require('../clone');\n\nvar DiffContext = function DiffContext(left, right) {\n  this.left = left;\n  this.right = right;\n  this.pipe = 'diff';\n};\n\nDiffContext.prototype = new Context();\n\nDiffContext.prototype.setResult = function(result) {\n  if (this.options.cloneDiffValues && typeof result === 'object') {\n    var clone = typeof this.options.cloneDiffValues === 'function' ?\n      this.options.cloneDiffValues : defaultClone;\n    if (typeof result[0] === 'object') {\n      result[0] = clone(result[0]);\n    }\n    if (typeof result[1] === 'object') {\n      result[1] = clone(result[1]);\n    }\n  }\n  return Context.prototype.setResult.apply(this, arguments);\n};\n\nexports.DiffContext = DiffContext;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/contexts/diff.js\n ** module id = 41\n ** module chunks = 0\n **/","\nvar Pipe = require('../pipe').Pipe;\n\nvar Context = function Context(){\n};\n\nContext.prototype.setResult = function(result) {\n\tthis.result = result;\n\tthis.hasResult = true;\n\treturn this;\n};\n\nContext.prototype.exit = function() {\n\tthis.exiting = true;\n\treturn this;\n};\n\nContext.prototype.switchTo = function(next, pipe) {\n\tif (typeof next === 'string' || next instanceof Pipe) {\n\t\tthis.nextPipe = next;\n\t} else {\n\t\tthis.next = next;\n\t\tif (pipe) {\n\t\t\tthis.nextPipe = pipe;\n\t\t}\n\t}\n\treturn this;\n};\n\nContext.prototype.push = function(child, name) {\n\tchild.parent = this;\n\tif (typeof name !== 'undefined') {\n\t\tchild.childName = name;\n\t}\n\tchild.root = this.root || this;\n\tchild.options = child.options || this.options;\n\tif (!this.children) {\n\t\tthis.children = [child];\n\t\tthis.nextAfterChildren = this.next || null;\n\t\tthis.next = child;\n\t} else {\n\t\tthis.children[this.children.length - 1].next = child;\n\t\tthis.children.push(child);\n\t}\n\tchild.next = this;\n\treturn this;\n};\n\nexports.Context = Context;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/contexts/context.js\n ** module id = 42\n ** module chunks = 0\n **/","\nvar isArray = (typeof Array.isArray === 'function') ?\n  // use native function\n  Array.isArray :\n  // use instanceof operator\n  function(a) {\n    return a instanceof Array;\n  };\n\nfunction cloneRegExp(re) {\n  var regexMatch = /^\\/(.*)\\/([gimyu]*)$/.exec(re.toString());\n  return new RegExp(regexMatch[1], regexMatch[2]);\n}\n\nfunction clone(arg) {\n  if (typeof arg !== 'object') {\n    return arg;\n  }\n  if (arg === null) {\n    return null;\n  }\n  if (isArray(arg)) {\n    return arg.map(clone);\n  }\n  if (arg instanceof Date) {\n    return new Date(arg.getTime());\n  }\n  if (arg instanceof RegExp) {\n    return cloneRegExp(arg);\n  }\n  var cloned = {};\n  for (var name in arg) {\n    if (Object.prototype.hasOwnProperty.call(arg, name)) {\n      cloned[name] = clone(arg[name]);\n    }\n  }\n  return cloned;\n}\n\nmodule.exports = clone;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/clone.js\n ** module id = 43\n ** module chunks = 0\n **/","var Context = require('./context').Context;\n\nvar PatchContext = function PatchContext(left, delta) {\n  this.left = left;\n  this.delta = delta;\n  this.pipe = 'patch';\n};\n\nPatchContext.prototype = new Context();\n\nexports.PatchContext = PatchContext;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/contexts/patch.js\n ** module id = 44\n ** module chunks = 0\n **/","var Context = require('./context').Context;\n\nvar ReverseContext = function ReverseContext(delta) {\n  this.delta = delta;\n  this.pipe = 'reverse';\n};\n\nReverseContext.prototype = new Context();\n\nexports.ReverseContext = ReverseContext;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/contexts/reverse.js\n ** module id = 45\n ** module chunks = 0\n **/","var isArray = (typeof Array.isArray === 'function') ?\n  // use native function\n  Array.isArray :\n  // use instanceof operator\n  function(a) {\n    return a instanceof Array;\n  };\n\nvar diffFilter = function trivialMatchesDiffFilter(context) {\n  if (context.left === context.right) {\n    context.setResult(undefined).exit();\n    return;\n  }\n  if (typeof context.left === 'undefined') {\n    if (typeof context.right === 'function') {\n      throw new Error('functions are not supported');\n    }\n    context.setResult([context.right]).exit();\n    return;\n  }\n  if (typeof context.right === 'undefined') {\n    context.setResult([context.left, 0, 0]).exit();\n    return;\n  }\n  if (typeof context.left === 'function' || typeof context.right === 'function') {\n    throw new Error('functions are not supported');\n  }\n  context.leftType = context.left === null ? 'null' : typeof context.left;\n  context.rightType = context.right === null ? 'null' : typeof context.right;\n  if (context.leftType !== context.rightType) {\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n  if (context.leftType === 'boolean' || context.leftType === 'number') {\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n  if (context.leftType === 'object') {\n    context.leftIsArray = isArray(context.left);\n  }\n  if (context.rightType === 'object') {\n    context.rightIsArray = isArray(context.right);\n  }\n  if (context.leftIsArray !== context.rightIsArray) {\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n\n  if (context.left instanceof RegExp) {\n    if (context.right instanceof RegExp) {\n      context.setResult([context.left.toString(), context.right.toString()]).exit();\n    } else {\n      context.setResult([context.left, context.right]).exit();\n      return;\n    }\n  }\n};\ndiffFilter.filterName = 'trivial';\n\nvar patchFilter = function trivialMatchesPatchFilter(context) {\n  if (typeof context.delta === 'undefined') {\n    context.setResult(context.left).exit();\n    return;\n  }\n  context.nested = !isArray(context.delta);\n  if (context.nested) {\n    return;\n  }\n  if (context.delta.length === 1) {\n    context.setResult(context.delta[0]).exit();\n    return;\n  }\n  if (context.delta.length === 2) {\n    if (context.left instanceof RegExp) {\n      var regexArgs = /^\\/(.*)\\/([gimyu]+)$/.exec(context.delta[1]);\n      if (regexArgs) {\n        context.setResult(new RegExp(regexArgs[1], regexArgs[2])).exit();\n        return;\n      }\n    }\n    context.setResult(context.delta[1]).exit();\n    return;\n  }\n  if (context.delta.length === 3 && context.delta[2] === 0) {\n    context.setResult(undefined).exit();\n    return;\n  }\n};\npatchFilter.filterName = 'trivial';\n\nvar reverseFilter = function trivialReferseFilter(context) {\n  if (typeof context.delta === 'undefined') {\n    context.setResult(context.delta).exit();\n    return;\n  }\n  context.nested = !isArray(context.delta);\n  if (context.nested) {\n    return;\n  }\n  if (context.delta.length === 1) {\n    context.setResult([context.delta[0], 0, 0]).exit();\n    return;\n  }\n  if (context.delta.length === 2) {\n    context.setResult([context.delta[1], context.delta[0]]).exit();\n    return;\n  }\n  if (context.delta.length === 3 && context.delta[2] === 0) {\n    context.setResult([context.delta[0]]).exit();\n    return;\n  }\n};\nreverseFilter.filterName = 'trivial';\n\nexports.diffFilter = diffFilter;\nexports.patchFilter = patchFilter;\nexports.reverseFilter = reverseFilter;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/filters/trivial.js\n ** module id = 46\n ** module chunks = 0\n **/","var DiffContext = require('../contexts/diff').DiffContext;\nvar PatchContext = require('../contexts/patch').PatchContext;\nvar ReverseContext = require('../contexts/reverse').ReverseContext;\n\nvar collectChildrenDiffFilter = function collectChildrenDiffFilter(context) {\n  if (!context || !context.children) {\n    return;\n  }\n  var length = context.children.length;\n  var child;\n  var result = context.result;\n  for (var index = 0; index < length; index++) {\n    child = context.children[index];\n    if (typeof child.result === 'undefined') {\n      continue;\n    }\n    result = result || {};\n    result[child.childName] = child.result;\n  }\n  if (result && context.leftIsArray) {\n    result._t = 'a';\n  }\n  context.setResult(result).exit();\n};\ncollectChildrenDiffFilter.filterName = 'collectChildren';\n\nvar objectsDiffFilter = function objectsDiffFilter(context) {\n  if (context.leftIsArray || context.leftType !== 'object') {\n    return;\n  }\n\n  var name, child, propertyFilter = context.options.propertyFilter;\n  for (name in context.left) {\n    if (!Object.prototype.hasOwnProperty.call(context.left, name)) {\n      continue;\n    }\n    if (propertyFilter && !propertyFilter(name, context)) {\n      continue;\n    }\n    child = new DiffContext(context.left[name], context.right[name]);\n    context.push(child, name);\n  }\n  for (name in context.right) {\n    if (!Object.prototype.hasOwnProperty.call(context.right, name)) {\n      continue;\n    }\n    if (propertyFilter && !propertyFilter(name, context)) {\n      continue;\n    }\n    if (typeof context.left[name] === 'undefined') {\n      child = new DiffContext(undefined, context.right[name]);\n      context.push(child, name);\n    }\n  }\n\n  if (!context.children || context.children.length === 0) {\n    context.setResult(undefined).exit();\n    return;\n  }\n  context.exit();\n};\nobjectsDiffFilter.filterName = 'objects';\n\nvar patchFilter = function nestedPatchFilter(context) {\n  if (!context.nested) {\n    return;\n  }\n  if (context.delta._t) {\n    return;\n  }\n  var name, child;\n  for (name in context.delta) {\n    child = new PatchContext(context.left[name], context.delta[name]);\n    context.push(child, name);\n  }\n  context.exit();\n};\npatchFilter.filterName = 'objects';\n\nvar collectChildrenPatchFilter = function collectChildrenPatchFilter(context) {\n  if (!context || !context.children) {\n    return;\n  }\n  if (context.delta._t) {\n    return;\n  }\n  var length = context.children.length;\n  var child;\n  for (var index = 0; index < length; index++) {\n    child = context.children[index];\n    if (Object.prototype.hasOwnProperty.call(context.left, child.childName) && child.result === undefined) {\n      delete context.left[child.childName];\n    } else if (context.left[child.childName] !== child.result) {\n      context.left[child.childName] = child.result;\n    }\n  }\n  context.setResult(context.left).exit();\n};\ncollectChildrenPatchFilter.filterName = 'collectChildren';\n\nvar reverseFilter = function nestedReverseFilter(context) {\n  if (!context.nested) {\n    return;\n  }\n  if (context.delta._t) {\n    return;\n  }\n  var name, child;\n  for (name in context.delta) {\n    child = new ReverseContext(context.delta[name]);\n    context.push(child, name);\n  }\n  context.exit();\n};\nreverseFilter.filterName = 'objects';\n\nvar collectChildrenReverseFilter = function collectChildrenReverseFilter(context) {\n  if (!context || !context.children) {\n    return;\n  }\n  if (context.delta._t) {\n    return;\n  }\n  var length = context.children.length;\n  var child;\n  var delta = {};\n  for (var index = 0; index < length; index++) {\n    child = context.children[index];\n    if (delta[child.childName] !== child.result) {\n      delta[child.childName] = child.result;\n    }\n  }\n  context.setResult(delta).exit();\n};\ncollectChildrenReverseFilter.filterName = 'collectChildren';\n\nexports.collectChildrenDiffFilter = collectChildrenDiffFilter;\nexports.objectsDiffFilter = objectsDiffFilter;\nexports.patchFilter = patchFilter;\nexports.collectChildrenPatchFilter = collectChildrenPatchFilter;\nexports.reverseFilter = reverseFilter;\nexports.collectChildrenReverseFilter = collectChildrenReverseFilter;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/filters/nested.js\n ** module id = 47\n ** module chunks = 0\n **/","var DiffContext = require('../contexts/diff').DiffContext;\nvar PatchContext = require('../contexts/patch').PatchContext;\nvar ReverseContext = require('../contexts/reverse').ReverseContext;\n\nvar lcs = require('./lcs');\n\nvar ARRAY_MOVE = 3;\n\nvar isArray = (typeof Array.isArray === 'function') ?\n  // use native function\n  Array.isArray :\n  // use instanceof operator\n  function(a) {\n    return a instanceof Array;\n  };\n\nvar arrayIndexOf = typeof Array.prototype.indexOf === 'function' ?\n  function(array, item) {\n    return array.indexOf(item);\n  } : function(array, item) {\n    var length = array.length;\n    for (var i = 0; i < length; i++) {\n      if (array[i] === item) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\nfunction arraysHaveMatchByRef(array1, array2, len1, len2) {\n  for (var index1 = 0; index1 < len1; index1++) {\n    var val1 = array1[index1];\n    for (var index2 = 0; index2 < len2; index2++) {\n      var val2 = array2[index2];\n      if (index1 !== index2 && val1 === val2) {\n        return true;\n      }\n    }\n  }\n}\n\nfunction matchItems(array1, array2, index1, index2, context) {\n  var value1 = array1[index1];\n  var value2 = array2[index2];\n  if (value1 === value2) {\n    return true;\n  }\n  if (typeof value1 !== 'object' || typeof value2 !== 'object') {\n    return false;\n  }\n  var objectHash = context.objectHash;\n  if (!objectHash) {\n    // no way to match objects was provided, try match by position\n    return context.matchByPosition && index1 === index2;\n  }\n  var hash1;\n  var hash2;\n  if (typeof index1 === 'number') {\n    context.hashCache1 = context.hashCache1 || [];\n    hash1 = context.hashCache1[index1];\n    if (typeof hash1 === 'undefined') {\n      context.hashCache1[index1] = hash1 = objectHash(value1, index1);\n    }\n  } else {\n    hash1 = objectHash(value1);\n  }\n  if (typeof hash1 === 'undefined') {\n    return false;\n  }\n  if (typeof index2 === 'number') {\n    context.hashCache2 = context.hashCache2 || [];\n    hash2 = context.hashCache2[index2];\n    if (typeof hash2 === 'undefined') {\n      context.hashCache2[index2] = hash2 = objectHash(value2, index2);\n    }\n  } else {\n    hash2 = objectHash(value2);\n  }\n  if (typeof hash2 === 'undefined') {\n    return false;\n  }\n  return hash1 === hash2;\n}\n\nvar diffFilter = function arraysDiffFilter(context) {\n  if (!context.leftIsArray) {\n    return;\n  }\n\n  var matchContext = {\n    objectHash: context.options && context.options.objectHash,\n    matchByPosition: context.options && context.options.matchByPosition\n  };\n  var commonHead = 0;\n  var commonTail = 0;\n  var index;\n  var index1;\n  var index2;\n  var array1 = context.left;\n  var array2 = context.right;\n  var len1 = array1.length;\n  var len2 = array2.length;\n\n  var child;\n\n  if (len1 > 0 && len2 > 0 && !matchContext.objectHash &&\n    typeof matchContext.matchByPosition !== 'boolean') {\n    matchContext.matchByPosition = !arraysHaveMatchByRef(array1, array2, len1, len2);\n  }\n\n  // separate common head\n  while (commonHead < len1 && commonHead < len2 &&\n    matchItems(array1, array2, commonHead, commonHead, matchContext)) {\n    index = commonHead;\n    child = new DiffContext(context.left[index], context.right[index]);\n    context.push(child, index);\n    commonHead++;\n  }\n  // separate common tail\n  while (commonTail + commonHead < len1 && commonTail + commonHead < len2 &&\n    matchItems(array1, array2, len1 - 1 - commonTail, len2 - 1 - commonTail, matchContext)) {\n    index1 = len1 - 1 - commonTail;\n    index2 = len2 - 1 - commonTail;\n    child = new DiffContext(context.left[index1], context.right[index2]);\n    context.push(child, index2);\n    commonTail++;\n  }\n  var result;\n  if (commonHead + commonTail === len1) {\n    if (len1 === len2) {\n      // arrays are identical\n      context.setResult(undefined).exit();\n      return;\n    }\n    // trivial case, a block (1 or more consecutive items) was added\n    result = result || {\n      _t: 'a'\n    };\n    for (index = commonHead; index < len2 - commonTail; index++) {\n      result[index] = [array2[index]];\n    }\n    context.setResult(result).exit();\n    return;\n  }\n  if (commonHead + commonTail === len2) {\n    // trivial case, a block (1 or more consecutive items) was removed\n    result = result || {\n      _t: 'a'\n    };\n    for (index = commonHead; index < len1 - commonTail; index++) {\n      result['_' + index] = [array1[index], 0, 0];\n    }\n    context.setResult(result).exit();\n    return;\n  }\n  // reset hash cache\n  delete matchContext.hashCache1;\n  delete matchContext.hashCache2;\n\n  // diff is not trivial, find the LCS (Longest Common Subsequence)\n  var trimmed1 = array1.slice(commonHead, len1 - commonTail);\n  var trimmed2 = array2.slice(commonHead, len2 - commonTail);\n  var seq = lcs.get(\n    trimmed1, trimmed2,\n    matchItems,\n    matchContext\n  );\n  var removedItems = [];\n  result = result || {\n    _t: 'a'\n  };\n  for (index = commonHead; index < len1 - commonTail; index++) {\n    if (arrayIndexOf(seq.indices1, index - commonHead) < 0) {\n      // removed\n      result['_' + index] = [array1[index], 0, 0];\n      removedItems.push(index);\n    }\n  }\n\n  var detectMove = true;\n  if (context.options && context.options.arrays && context.options.arrays.detectMove === false) {\n    detectMove = false;\n  }\n  var includeValueOnMove = false;\n  if (context.options && context.options.arrays && context.options.arrays.includeValueOnMove) {\n    includeValueOnMove = true;\n  }\n\n  var removedItemsLength = removedItems.length;\n  for (index = commonHead; index < len2 - commonTail; index++) {\n    var indexOnArray2 = arrayIndexOf(seq.indices2, index - commonHead);\n    if (indexOnArray2 < 0) {\n      // added, try to match with a removed item and register as position move\n      var isMove = false;\n      if (detectMove && removedItemsLength > 0) {\n        for (var removeItemIndex1 = 0; removeItemIndex1 < removedItemsLength; removeItemIndex1++) {\n          index1 = removedItems[removeItemIndex1];\n          if (matchItems(trimmed1, trimmed2, index1 - commonHead,\n            index - commonHead, matchContext)) {\n            // store position move as: [originalValue, newPosition, ARRAY_MOVE]\n            result['_' + index1].splice(1, 2, index, ARRAY_MOVE);\n            if (!includeValueOnMove) {\n              // don't include moved value on diff, to save bytes\n              result['_' + index1][0] = '';\n            }\n\n            index2 = index;\n            child = new DiffContext(context.left[index1], context.right[index2]);\n            context.push(child, index2);\n            removedItems.splice(removeItemIndex1, 1);\n            isMove = true;\n            break;\n          }\n        }\n      }\n      if (!isMove) {\n        // added\n        result[index] = [array2[index]];\n      }\n    } else {\n      // match, do inner diff\n      index1 = seq.indices1[indexOnArray2] + commonHead;\n      index2 = seq.indices2[indexOnArray2] + commonHead;\n      child = new DiffContext(context.left[index1], context.right[index2]);\n      context.push(child, index2);\n    }\n  }\n\n  context.setResult(result).exit();\n\n};\ndiffFilter.filterName = 'arrays';\n\nvar compare = {\n  numerically: function(a, b) {\n    return a - b;\n  },\n  numericallyBy: function(name) {\n    return function(a, b) {\n      return a[name] - b[name];\n    };\n  }\n};\n\nvar patchFilter = function nestedPatchFilter(context) {\n  if (!context.nested) {\n    return;\n  }\n  if (context.delta._t !== 'a') {\n    return;\n  }\n  var index, index1;\n\n  var delta = context.delta;\n  var array = context.left;\n\n  // first, separate removals, insertions and modifications\n  var toRemove = [];\n  var toInsert = [];\n  var toModify = [];\n  for (index in delta) {\n    if (index !== '_t') {\n      if (index[0] === '_') {\n        // removed item from original array\n        if (delta[index][2] === 0 || delta[index][2] === ARRAY_MOVE) {\n          toRemove.push(parseInt(index.slice(1), 10));\n        } else {\n          throw new Error('only removal or move can be applied at original array indices' +\n            ', invalid diff type: ' + delta[index][2]);\n        }\n      } else {\n        if (delta[index].length === 1) {\n          // added item at new array\n          toInsert.push({\n            index: parseInt(index, 10),\n            value: delta[index][0]\n          });\n        } else {\n          // modified item at new array\n          toModify.push({\n            index: parseInt(index, 10),\n            delta: delta[index]\n          });\n        }\n      }\n    }\n  }\n\n  // remove items, in reverse order to avoid sawing our own floor\n  toRemove = toRemove.sort(compare.numerically);\n  for (index = toRemove.length - 1; index >= 0; index--) {\n    index1 = toRemove[index];\n    var indexDiff = delta['_' + index1];\n    var removedValue = array.splice(index1, 1)[0];\n    if (indexDiff[2] === ARRAY_MOVE) {\n      // reinsert later\n      toInsert.push({\n        index: indexDiff[1],\n        value: removedValue\n      });\n    }\n  }\n\n  // insert items, in reverse order to avoid moving our own floor\n  toInsert = toInsert.sort(compare.numericallyBy('index'));\n  var toInsertLength = toInsert.length;\n  for (index = 0; index < toInsertLength; index++) {\n    var insertion = toInsert[index];\n    array.splice(insertion.index, 0, insertion.value);\n  }\n\n  // apply modifications\n  var toModifyLength = toModify.length;\n  var child;\n  if (toModifyLength > 0) {\n    for (index = 0; index < toModifyLength; index++) {\n      var modification = toModify[index];\n      child = new PatchContext(context.left[modification.index], modification.delta);\n      context.push(child, modification.index);\n    }\n  }\n\n  if (!context.children) {\n    context.setResult(context.left).exit();\n    return;\n  }\n  context.exit();\n};\npatchFilter.filterName = 'arrays';\n\nvar collectChildrenPatchFilter = function collectChildrenPatchFilter(context) {\n  if (!context || !context.children) {\n    return;\n  }\n  if (context.delta._t !== 'a') {\n    return;\n  }\n  var length = context.children.length;\n  var child;\n  for (var index = 0; index < length; index++) {\n    child = context.children[index];\n    context.left[child.childName] = child.result;\n  }\n  context.setResult(context.left).exit();\n};\ncollectChildrenPatchFilter.filterName = 'arraysCollectChildren';\n\nvar reverseFilter = function arraysReverseFilter(context) {\n  if (!context.nested) {\n    if (context.delta[2] === ARRAY_MOVE) {\n      context.newName = '_' + context.delta[1];\n      context.setResult([context.delta[0], parseInt(context.childName.substr(1), 10), ARRAY_MOVE]).exit();\n    }\n    return;\n  }\n  if (context.delta._t !== 'a') {\n    return;\n  }\n  var name, child;\n  for (name in context.delta) {\n    if (name === '_t') {\n      continue;\n    }\n    child = new ReverseContext(context.delta[name]);\n    context.push(child, name);\n  }\n  context.exit();\n};\nreverseFilter.filterName = 'arrays';\n\nvar reverseArrayDeltaIndex = function(delta, index, itemDelta) {\n  if (typeof index === 'string' && index[0] === '_') {\n    return parseInt(index.substr(1), 10);\n  } else if (isArray(itemDelta) && itemDelta[2] === 0) {\n    return '_' + index;\n  }\n\n  var reverseIndex = +index;\n  for (var deltaIndex in delta) {\n    var deltaItem = delta[deltaIndex];\n    if (isArray(deltaItem)) {\n      if (deltaItem[2] === ARRAY_MOVE) {\n        var moveFromIndex = parseInt(deltaIndex.substr(1), 10);\n        var moveToIndex = deltaItem[1];\n        if (moveToIndex === +index) {\n          return moveFromIndex;\n        }\n        if (moveFromIndex <= reverseIndex && moveToIndex > reverseIndex) {\n          reverseIndex++;\n        } else if (moveFromIndex >= reverseIndex && moveToIndex < reverseIndex) {\n          reverseIndex--;\n        }\n      } else if (deltaItem[2] === 0) {\n        var deleteIndex = parseInt(deltaIndex.substr(1), 10);\n        if (deleteIndex <= reverseIndex) {\n          reverseIndex++;\n        }\n      } else if (deltaItem.length === 1 && deltaIndex <= reverseIndex) {\n        reverseIndex--;\n      }\n    }\n  }\n\n  return reverseIndex;\n};\n\nvar collectChildrenReverseFilter = function collectChildrenReverseFilter(context) {\n  if (!context || !context.children) {\n    return;\n  }\n  if (context.delta._t !== 'a') {\n    return;\n  }\n  var length = context.children.length;\n  var child;\n  var delta = {\n    _t: 'a'\n  };\n\n  for (var index = 0; index < length; index++) {\n    child = context.children[index];\n    var name = child.newName;\n    if (typeof name === 'undefined') {\n      name = reverseArrayDeltaIndex(context.delta, child.childName, child.result);\n    }\n    if (delta[name] !== child.result) {\n      delta[name] = child.result;\n    }\n  }\n  context.setResult(delta).exit();\n};\ncollectChildrenReverseFilter.filterName = 'arraysCollectChildren';\n\nexports.diffFilter = diffFilter;\nexports.patchFilter = patchFilter;\nexports.collectChildrenPatchFilter = collectChildrenPatchFilter;\nexports.reverseFilter = reverseFilter;\nexports.collectChildrenReverseFilter = collectChildrenReverseFilter;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/filters/arrays.js\n ** module id = 48\n ** module chunks = 0\n **/","/*\n\nLCS implementation that supports arrays or strings\n\nreference: http://en.wikipedia.org/wiki/Longest_common_subsequence_problem\n\n*/\n\nvar defaultMatch = function(array1, array2, index1, index2) {\n  return array1[index1] === array2[index2];\n};\n\nvar lengthMatrix = function(array1, array2, match, context) {\n  var len1 = array1.length;\n  var len2 = array2.length;\n  var x, y;\n\n  // initialize empty matrix of len1+1 x len2+1\n  var matrix = [len1 + 1];\n  for (x = 0; x < len1 + 1; x++) {\n    matrix[x] = [len2 + 1];\n    for (y = 0; y < len2 + 1; y++) {\n      matrix[x][y] = 0;\n    }\n  }\n  matrix.match = match;\n  // save sequence lengths for each coordinate\n  for (x = 1; x < len1 + 1; x++) {\n    for (y = 1; y < len2 + 1; y++) {\n      if (match(array1, array2, x - 1, y - 1, context)) {\n        matrix[x][y] = matrix[x - 1][y - 1] + 1;\n      } else {\n        matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1]);\n      }\n    }\n  }\n  return matrix;\n};\n\nvar backtrack = function(matrix, array1, array2, index1, index2, context) {\n  if (index1 === 0 || index2 === 0) {\n    return {\n      sequence: [],\n      indices1: [],\n      indices2: []\n    };\n  }\n\n  if (matrix.match(array1, array2, index1 - 1, index2 - 1, context)) {\n    var subsequence = backtrack(matrix, array1, array2, index1 - 1, index2 - 1, context);\n    subsequence.sequence.push(array1[index1 - 1]);\n    subsequence.indices1.push(index1 - 1);\n    subsequence.indices2.push(index2 - 1);\n    return subsequence;\n  }\n\n  if (matrix[index1][index2 - 1] > matrix[index1 - 1][index2]) {\n    return backtrack(matrix, array1, array2, index1, index2 - 1, context);\n  } else {\n    return backtrack(matrix, array1, array2, index1 - 1, index2, context);\n  }\n};\n\nvar get = function(array1, array2, match, context) {\n  context = context || {};\n  var matrix = lengthMatrix(array1, array2, match || defaultMatch, context);\n  var result = backtrack(matrix, array1, array2, array1.length, array2.length, context);\n  if (typeof array1 === 'string' && typeof array2 === 'string') {\n    result.sequence = result.sequence.join('');\n  }\n  return result;\n};\n\nexports.get = get;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/filters/lcs.js\n ** module id = 49\n ** module chunks = 0\n **/","var diffFilter = function datesDiffFilter(context) {\n  if (context.left instanceof Date) {\n    if (context.right instanceof Date) {\n      if (context.left.getTime() !== context.right.getTime()) {\n        context.setResult([context.left, context.right]);\n      } else {\n        context.setResult(undefined);\n      }\n    } else {\n      context.setResult([context.left, context.right]);\n    }\n    context.exit();\n  } else if (context.right instanceof Date) {\n    context.setResult([context.left, context.right]).exit();\n  }\n};\ndiffFilter.filterName = 'dates';\n\nexports.diffFilter = diffFilter;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/filters/dates.js\n ** module id = 50\n ** module chunks = 0\n **/","/* global diff_match_patch */\nvar TEXT_DIFF = 2;\nvar DEFAULT_MIN_LENGTH = 60;\nvar cachedDiffPatch = null;\n\nvar getDiffMatchPatch = function(required) {\n  /*jshint camelcase: false */\n\n  if (!cachedDiffPatch) {\n    var instance;\n    if (typeof diff_match_patch !== 'undefined') {\n      // already loaded, probably a browser\n      instance = typeof diff_match_patch === 'function' ?\n        new diff_match_patch() : new diff_match_patch.diff_match_patch();\n    } else if (typeof require === 'function') {\n      try {\n        var dmpModuleName = 'diff_match_patch_uncompressed';\n        var dmp = require('../../public/external/' + dmpModuleName);\n        instance = new dmp.diff_match_patch();\n      } catch (err) {\n        instance = null;\n      }\n    }\n    if (!instance) {\n      if (!required) {\n        return null;\n      }\n      var error = new Error('text diff_match_patch library not found');\n      error.diff_match_patch_not_found = true;\n      throw error;\n    }\n    cachedDiffPatch = {\n      diff: function(txt1, txt2) {\n        return instance.patch_toText(instance.patch_make(txt1, txt2));\n      },\n      patch: function(txt1, patch) {\n        var results = instance.patch_apply(instance.patch_fromText(patch), txt1);\n        for (var i = 0; i < results[1].length; i++) {\n          if (!results[1][i]) {\n            var error = new Error('text patch failed');\n            error.textPatchFailed = true;\n          }\n        }\n        return results[0];\n      }\n    };\n  }\n  return cachedDiffPatch;\n};\n\nvar diffFilter = function textsDiffFilter(context) {\n  if (context.leftType !== 'string') {\n    return;\n  }\n  var minLength = (context.options && context.options.textDiff &&\n    context.options.textDiff.minLength) || DEFAULT_MIN_LENGTH;\n  if (context.left.length < minLength ||\n    context.right.length < minLength) {\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n  // large text, try to use a text-diff algorithm\n  var diffMatchPatch = getDiffMatchPatch();\n  if (!diffMatchPatch) {\n    // diff-match-patch library not available, fallback to regular string replace\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n  var diff = diffMatchPatch.diff;\n  context.setResult([diff(context.left, context.right), 0, TEXT_DIFF]).exit();\n};\ndiffFilter.filterName = 'texts';\n\nvar patchFilter = function textsPatchFilter(context) {\n  if (context.nested) {\n    return;\n  }\n  if (context.delta[2] !== TEXT_DIFF) {\n    return;\n  }\n\n  // text-diff, use a text-patch algorithm\n  var patch = getDiffMatchPatch(true).patch;\n  context.setResult(patch(context.left, context.delta[0])).exit();\n};\npatchFilter.filterName = 'texts';\n\nvar textDeltaReverse = function(delta) {\n  var i, l, lines, line, lineTmp, header = null,\n    headerRegex = /^@@ +\\-(\\d+),(\\d+) +\\+(\\d+),(\\d+) +@@$/,\n    lineHeader, lineAdd, lineRemove;\n  lines = delta.split('\\n');\n  for (i = 0, l = lines.length; i < l; i++) {\n    line = lines[i];\n    var lineStart = line.slice(0, 1);\n    if (lineStart === '@') {\n      header = headerRegex.exec(line);\n      lineHeader = i;\n      lineAdd = null;\n      lineRemove = null;\n\n      // fix header\n      lines[lineHeader] = '@@ -' + header[3] + ',' + header[4] + ' +' + header[1] + ',' + header[2] + ' @@';\n    } else if (lineStart === '+') {\n      lineAdd = i;\n      lines[i] = '-' + lines[i].slice(1);\n      if (lines[i - 1].slice(0, 1) === '+') {\n        // swap lines to keep default order (-+)\n        lineTmp = lines[i];\n        lines[i] = lines[i - 1];\n        lines[i - 1] = lineTmp;\n      }\n    } else if (lineStart === '-') {\n      lineRemove = i;\n      lines[i] = '+' + lines[i].slice(1);\n    }\n  }\n  return lines.join('\\n');\n};\n\nvar reverseFilter = function textsReverseFilter(context) {\n  if (context.nested) {\n    return;\n  }\n  if (context.delta[2] !== TEXT_DIFF) {\n    return;\n  }\n\n  // text-diff, use a text-diff algorithm\n  context.setResult([textDeltaReverse(context.delta[0]), 0, TEXT_DIFF]).exit();\n};\nreverseFilter.filterName = 'texts';\n\nexports.diffFilter = diffFilter;\nexports.patchFilter = patchFilter;\nexports.reverseFilter = reverseFilter;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/filters/texts.js\n ** module id = 51\n ** module chunks = 0\n **/","var map = {\n\t\"../package.json\": 53,\n\t\"./console\": 54,\n\t\"./formatters\": 63\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 52;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch ^\\.\\/.*$\n ** module id = 52\n ** module chunks = 0\n **/","module.exports = {\"_args\":[[\"jsondiffpatch@0.2.4\",\"/home/adelina/telepat-js\"]],\"_from\":\"jsondiffpatch@0.2.4\",\"_id\":\"jsondiffpatch@0.2.4\",\"_inBundle\":false,\"_integrity\":\"sha1-1LbFOz/H2htLkcHCrsi5MrdRHVw=\",\"_location\":\"/jsondiffpatch\",\"_phantomChildren\":{},\"_requested\":{\"type\":\"version\",\"registry\":true,\"raw\":\"jsondiffpatch@0.2.4\",\"name\":\"jsondiffpatch\",\"escapedName\":\"jsondiffpatch\",\"rawSpec\":\"0.2.4\",\"saveSpec\":null,\"fetchSpec\":\"0.2.4\"},\"_requiredBy\":[\"/\"],\"_resolved\":\"https://registry.npmjs.org/jsondiffpatch/-/jsondiffpatch-0.2.4.tgz\",\"_spec\":\"0.2.4\",\"_where\":\"/home/adelina/telepat-js\",\"author\":{\"name\":\"Benjamin Eidelman\",\"email\":\"beneidel@gmail.com\"},\"bin\":{\"jsondiffpatch\":\"./bin/jsondiffpatch\"},\"bugs\":{\"url\":\"https://github.com/benjamine/jsondiffpatch/issues\"},\"bundleDependencies\":[],\"contributors\":[{\"name\":\"Benjamin Eidelman\",\"email\":\"beneidel@gmail.com\"}],\"dependencies\":{\"chalk\":\"^0.5.1\"},\"description\":\"Diff & Patch for Javascript objects\",\"devDependencies\":{\"bulk-require\":\"^0.2.1\",\"codeclimate-test-reporter\":\"0.0.3\",\"expect.js\":\"~0.3.1\",\"fiberglass\":\"0.0.22\",\"gulp\":\"^3.8.8\",\"istanbul\":\"^0.3.2\",\"mocha\":\"^1.21.4\"},\"engine\":{\"node\":\">=0.10\"},\"engines\":{\"node\":\"*\"},\"homepage\":\"https://github.com/benjamine/jsondiffpatch\",\"keywords\":[\"json\",\"diff\",\"patch\"],\"license\":\"MIT\",\"main\":\"./src/main\",\"name\":\"jsondiffpatch\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/benjamine/jsondiffpatch.git\"},\"scripts\":{\"bump\":\"gulp bump\",\"cover\":\"istanbul cover --root src gulp test\",\"cover-publish\":\"istanbul cover _mocha --report lcovonly && codeclimate < coverage/lcov.info\",\"cover-report\":\"open coverage/lcov-report/index.html\",\"test\":\"gulp test && gulp test-browser\"},\"testling\":{\"harness\":\"mocha\",\"files\":\"test/index.js\",\"scripts\":[\"build/jsondiffpatch.js\",\"external/diff_match_patch_uncompressed.js\"],\"browsers\":[\"ie/8..latest\",\"chrome/27..latest\",\"firefox/22..latest\",\"safari/5.1..latest\",\"opera/12..latest\",\"iphone/6..latest\",\"ipad/6..latest\",\"android-browser/4.2..latest\"]},\"version\":\"0.2.4\"}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/package.json\n ** module id = 53\n ** module chunks = 0\n **/","var chalk = require('chalk');\nvar base = require('./base');\nvar BaseFormatter = base.BaseFormatter;\n\nvar colors = {\n  added: chalk.green,\n  deleted: chalk.red,\n  movedestination: chalk.gray,\n  moved: chalk.yellow,\n  unchanged: chalk.gray,\n  error: chalk.white.bgRed,\n  textDiffLine: chalk.gray\n};\n\nvar ConsoleFormatter = function ConsoleFormatter() {\n  this.includeMoveDestinations = false;\n};\n\nConsoleFormatter.prototype = new BaseFormatter();\n\nConsoleFormatter.prototype.prepareContext = function(context) {\n  BaseFormatter.prototype.prepareContext.call(this, context);\n  context.indent = function(levels) {\n    this.indentLevel = (this.indentLevel || 0) +\n      (typeof levels === 'undefined' ? 1 : levels);\n    this.indentPad = new Array(this.indentLevel + 1).join('  ');\n    this.outLine();\n  };\n  context.outLine = function() {\n    this.buffer.push('\\n' + (this.indentPad || ''));\n  };\n  context.out = function() {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      var lines = arguments[i].split('\\n');\n      var text = lines.join('\\n' + (this.indentPad || ''));\n      if (this.color && this.color[0]) {\n        text = this.color[0](text);\n      }\n      this.buffer.push(text);\n    }\n  };\n  context.pushColor = function(color) {\n    this.color = this.color || [];\n    this.color.unshift(color);\n  };\n  context.popColor = function() {\n    this.color = this.color || [];\n    this.color.shift();\n  };\n};\n\nConsoleFormatter.prototype.typeFormattterErrorFormatter = function(context, err) {\n  context.pushColor(colors.error);\n  context.out('[ERROR]' + err);\n  context.popColor();\n};\n\nConsoleFormatter.prototype.formatValue = function(context, value) {\n  context.out(JSON.stringify(value, null, 2));\n};\n\nConsoleFormatter.prototype.formatTextDiffString = function(context, value) {\n  var lines = this.parseTextDiff(value);\n  context.indent();\n  for (var i = 0, l = lines.length; i < l; i++) {\n    var line = lines[i];\n    context.pushColor(colors.textDiffLine);\n    context.out(line.location.line + ',' + line.location.chr + ' ');\n    context.popColor();\n    var pieces = line.pieces;\n    for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {\n      var piece = pieces[pieceIndex];\n      context.pushColor(colors[piece.type]);\n      context.out(piece.text);\n      context.popColor();\n    }\n    if (i < l - 1) {\n      context.outLine();\n    }\n  }\n  context.indent(-1);\n};\n\nConsoleFormatter.prototype.rootBegin = function(context, type, nodeType) {\n  context.pushColor(colors[type]);\n  if (type === 'node') {\n    context.out(nodeType === 'array' ? '[' : '{');\n    context.indent();\n  }\n};\n\nConsoleFormatter.prototype.rootEnd = function(context, type, nodeType) {\n  if (type === 'node') {\n    context.indent(-1);\n    context.out(nodeType === 'array' ? ']' : '}');\n  }\n  context.popColor();\n};\n\nConsoleFormatter.prototype.nodeBegin = function(context, key, leftKey, type, nodeType) {\n  context.pushColor(colors[type]);\n  context.out(leftKey + ': ');\n  if (type === 'node') {\n    context.out(nodeType === 'array' ? '[' : '{');\n    context.indent();\n  }\n};\n\nConsoleFormatter.prototype.nodeEnd = function(context, key, leftKey, type, nodeType, isLast) {\n  if (type === 'node') {\n    context.indent(-1);\n    context.out(nodeType === 'array' ? ']' : '}' +\n      (isLast ? '' : ','));\n  }\n  if (!isLast) {\n    context.outLine();\n  }\n  context.popColor();\n};\n\n/* jshint camelcase: false */\n\nConsoleFormatter.prototype.format_unchanged = function(context, delta, left) {\n  if (typeof left === 'undefined') {\n    return;\n  }\n  this.formatValue(context, left);\n};\n\nConsoleFormatter.prototype.format_movedestination = function(context, delta, left) {\n  if (typeof left === 'undefined') {\n    return;\n  }\n  this.formatValue(context, left);\n};\n\nConsoleFormatter.prototype.format_node = function(context, delta, left) {\n  // recurse\n  this.formatDeltaChildren(context, delta, left);\n};\n\nConsoleFormatter.prototype.format_added = function(context, delta) {\n  this.formatValue(context, delta[0]);\n};\n\nConsoleFormatter.prototype.format_modified = function(context, delta) {\n  context.pushColor(colors.deleted);\n  this.formatValue(context, delta[0]);\n  context.popColor();\n  context.out(' => ');\n  context.pushColor(colors.added);\n  this.formatValue(context, delta[1]);\n  context.popColor();\n};\n\nConsoleFormatter.prototype.format_deleted = function(context, delta) {\n  this.formatValue(context, delta[0]);\n};\n\nConsoleFormatter.prototype.format_moved = function(context, delta) {\n  context.out('==> ' + delta[1]);\n};\n\nConsoleFormatter.prototype.format_textdiff = function(context, delta) {\n  this.formatTextDiffString(context, delta[0]);\n};\n\n/* jshint camelcase: true */\n\nexports.ConsoleFormatter = ConsoleFormatter;\n\nvar defaultInstance;\n\nvar format = function(delta, left) {\n  if (!defaultInstance) {\n    defaultInstance = new ConsoleFormatter();\n  }\n  return defaultInstance.format(delta, left);\n};\n\nexports.log = function(delta, left) {\n  console.log(format(delta, left));\n};\n\nexports.format = format;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/formatters/console.js\n ** module id = 54\n ** module chunks = 0\n **/","'use strict';\nvar escapeStringRegexp = require('escape-string-regexp');\nvar ansiStyles = require('ansi-styles');\nvar stripAnsi = require('strip-ansi');\nvar hasAnsi = require('has-ansi');\nvar supportsColor = require('supports-color');\nvar defineProps = Object.defineProperties;\nvar chalk = module.exports;\n\nfunction build(_styles) {\n\tvar builder = function builder() {\n\t\treturn applyStyle.apply(builder, arguments);\n\t};\n\tbuilder._styles = _styles;\n\t// __proto__ is used because we must return a function, but there is\n\t// no way to create a function with a different prototype.\n\tbuilder.__proto__ = proto;\n\treturn builder;\n}\n\nvar styles = (function () {\n\tvar ret = {};\n\n\tansiStyles.grey = ansiStyles.gray;\n\n\tObject.keys(ansiStyles).forEach(function (key) {\n\t\tansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');\n\n\t\tret[key] = {\n\t\t\tget: function () {\n\t\t\t\treturn build(this._styles.concat(key));\n\t\t\t}\n\t\t};\n\t});\n\n\treturn ret;\n})();\n\nvar proto = defineProps(function chalk() {}, styles);\n\nfunction applyStyle() {\n\t// support varags, but simply cast to string in case there's only one arg\n\tvar args = arguments;\n\tvar argsLen = args.length;\n\tvar str = argsLen !== 0 && String(arguments[0]);\n\tif (argsLen > 1) {\n\t\t// don't slice `arguments`, it prevents v8 optimizations\n\t\tfor (var a = 1; a < argsLen; a++) {\n\t\t\tstr += ' ' + args[a];\n\t\t}\n\t}\n\n\tif (!chalk.enabled || !str) {\n\t\treturn str;\n\t}\n\n\t/*jshint validthis: true*/\n\tvar nestedStyles = this._styles;\n\n\tfor (var i = 0; i < nestedStyles.length; i++) {\n\t\tvar code = ansiStyles[nestedStyles[i]];\n\t\t// Replace any instances already present with a re-opening code\n\t\t// otherwise only the part of the string until said closing code\n\t\t// will be colored, and the rest will simply be 'plain'.\n\t\tstr = code.open + str.replace(code.closeRe, code.open) + code.close;\n\t}\n\n\treturn str;\n}\n\nfunction init() {\n\tvar ret = {};\n\n\tObject.keys(styles).forEach(function (name) {\n\t\tret[name] = {\n\t\t\tget: function () {\n\t\t\t\treturn build([name]);\n\t\t\t}\n\t\t};\n\t});\n\n\treturn ret;\n}\n\ndefineProps(chalk, init());\n\nchalk.styles = ansiStyles;\nchalk.hasColor = hasAnsi;\nchalk.stripColor = stripAnsi;\nchalk.supportsColor = supportsColor;\n\n// detect mode if not set manually\nif (chalk.enabled === undefined) {\n\tchalk.enabled = chalk.supportsColor;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chalk/index.js\n ** module id = 55\n ** module chunks = 0\n **/","'use strict';\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\nmodule.exports = function (str) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn str.replace(matchOperatorsRe, '\\\\$&');\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escape-string-regexp/index.js\n ** module id = 56\n ** module chunks = 0\n **/","'use strict';\nvar styles = module.exports;\n\nvar codes = {\n\treset: [0, 0],\n\n\tbold: [1, 22], // 21 isn't widely supported and 22 does the same thing\n\tdim: [2, 22],\n\titalic: [3, 23],\n\tunderline: [4, 24],\n\tinverse: [7, 27],\n\thidden: [8, 28],\n\tstrikethrough: [9, 29],\n\n\tblack: [30, 39],\n\tred: [31, 39],\n\tgreen: [32, 39],\n\tyellow: [33, 39],\n\tblue: [34, 39],\n\tmagenta: [35, 39],\n\tcyan: [36, 39],\n\twhite: [37, 39],\n\tgray: [90, 39],\n\n\tbgBlack: [40, 49],\n\tbgRed: [41, 49],\n\tbgGreen: [42, 49],\n\tbgYellow: [43, 49],\n\tbgBlue: [44, 49],\n\tbgMagenta: [45, 49],\n\tbgCyan: [46, 49],\n\tbgWhite: [47, 49]\n};\n\nObject.keys(codes).forEach(function (key) {\n\tvar val = codes[key];\n\tvar style = styles[key] = {};\n\tstyle.open = '\\u001b[' + val[0] + 'm';\n\tstyle.close = '\\u001b[' + val[1] + 'm';\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ansi-styles/index.js\n ** module id = 57\n ** module chunks = 0\n **/","'use strict';\nvar ansiRegex = require('ansi-regex')();\n\nmodule.exports = function (str) {\n\treturn typeof str === 'string' ? str.replace(ansiRegex, '') : str;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/strip-ansi/index.js\n ** module id = 58\n ** module chunks = 0\n **/","'use strict';\nmodule.exports = function () {\n\treturn /\\u001b\\[(?:[0-9]{1,3}(?:;[0-9]{1,3})*)?[m|K]/g;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ansi-regex/index.js\n ** module id = 59\n ** module chunks = 0\n **/","'use strict';\nvar ansiRegex = require('ansi-regex');\nvar re = new RegExp(ansiRegex().source); // remove the `g` flag\nmodule.exports = re.test.bind(re);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/has-ansi/index.js\n ** module id = 60\n ** module chunks = 0\n **/","'use strict';\nmodule.exports = (function () {\n\tif (process.argv.indexOf('--no-color') !== -1) {\n\t\treturn false;\n\t}\n\n\tif (process.argv.indexOf('--color') !== -1) {\n\t\treturn true;\n\t}\n\n\tif (process.stdout && !process.stdout.isTTY) {\n\t\treturn false;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\treturn true;\n\t}\n\n\tif ('COLORTERM' in process.env) {\n\t\treturn true;\n\t}\n\n\tif (process.env.TERM === 'dumb') {\n\t\treturn false;\n\t}\n\n\tif (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/supports-color/index.js\n ** module id = 61\n ** module chunks = 0\n **/","var isArray = (typeof Array.isArray === 'function') ?\n  // use native function\n  Array.isArray :\n  // use instanceof operator\n  function(a) {\n    return a instanceof Array;\n  };\n\nvar getObjectKeys = typeof Object.keys === 'function' ?\n  function(obj) {\n    return Object.keys(obj);\n  } : function(obj) {\n    var names = [];\n    for (var property in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, property)) {\n        names.push(property);\n      }\n    }\n    return names;\n  };\n\nvar trimUnderscore = function(str) {\n  if (str.substr(0, 1) === '_') {\n    return str.slice(1);\n  }\n  return str;\n};\n\nvar arrayKeyToSortNumber = function(key) {\n  if (key === '_t') {\n    return -1;\n  } else {\n    if (key.substr(0, 1) === '_') {\n      return parseInt(key.slice(1), 10);\n    } else {\n      return parseInt(key, 10) + 0.1;\n    }\n  }\n};\n\nvar arrayKeyComparer = function(key1, key2) {\n  return arrayKeyToSortNumber(key1) - arrayKeyToSortNumber(key2);\n};\n\nvar BaseFormatter = function BaseFormatter() {};\n\nBaseFormatter.prototype.format = function(delta, left) {\n  var context = {};\n  this.prepareContext(context);\n  this.recurse(context, delta, left);\n  return this.finalize(context);\n};\n\nBaseFormatter.prototype.prepareContext = function(context) {\n  context.buffer = [];\n  context.out = function() {\n    this.buffer.push.apply(this.buffer, arguments);\n  };\n};\n\nBaseFormatter.prototype.typeFormattterNotFound = function(context, deltaType) {\n  throw new Error('cannot format delta type: ' + deltaType);\n};\n\nBaseFormatter.prototype.typeFormattterErrorFormatter = function(context, err) {\n  return err.toString();\n};\n\nBaseFormatter.prototype.finalize = function(context) {\n  if (isArray(context.buffer)) {\n    return context.buffer.join('');\n  }\n};\n\nBaseFormatter.prototype.recurse = function(context, delta, left, key, leftKey, movedFrom, isLast) {\n\n  var useMoveOriginHere = delta && movedFrom;\n  var leftValue = useMoveOriginHere ? movedFrom.value : left;\n\n  if (typeof delta === 'undefined' && typeof key === 'undefined') {\n    return undefined;\n  }\n\n  var type = this.getDeltaType(delta, movedFrom);\n  var nodeType = type === 'node' ? (delta._t === 'a' ? 'array' : 'object') : '';\n\n  if (typeof key !== 'undefined') {\n    this.nodeBegin(context, key, leftKey, type, nodeType, isLast);\n  } else {\n    this.rootBegin(context, type, nodeType);\n  }\n\n  var typeFormattter;\n  try {\n    typeFormattter = this['format_' + type] || this.typeFormattterNotFound(context, type);\n    typeFormattter.call(this, context, delta, leftValue, key, leftKey, movedFrom);\n  } catch (err) {\n    this.typeFormattterErrorFormatter(context, err, delta, leftValue, key, leftKey, movedFrom);\n    if (typeof console !== 'undefined' && console.error) {\n      console.error(err.stack);\n    }\n  }\n\n  if (typeof key !== 'undefined') {\n    this.nodeEnd(context, key, leftKey, type, nodeType, isLast);\n  } else {\n    this.rootEnd(context, type, nodeType);\n  }\n};\n\nBaseFormatter.prototype.formatDeltaChildren = function(context, delta, left) {\n  var self = this;\n  this.forEachDeltaKey(delta, left, function(key, leftKey, movedFrom, isLast) {\n    self.recurse(context, delta[key], left ? left[leftKey] : undefined,\n      key, leftKey, movedFrom, isLast);\n  });\n};\n\nBaseFormatter.prototype.forEachDeltaKey = function(delta, left, fn) {\n  var keys = getObjectKeys(delta);\n  var arrayKeys = delta._t === 'a';\n  var moveDestinations = {};\n  var name;\n  if (typeof left !== 'undefined') {\n    for (name in left) {\n      if (Object.prototype.hasOwnProperty.call(left, name)) {\n        if (typeof delta[name] === 'undefined' &&\n          ((!arrayKeys) || typeof delta['_' + name] === 'undefined')) {\n          keys.push(name);\n        }\n      }\n    }\n  }\n  // look for move destinations\n  for (name in delta) {\n    if (Object.prototype.hasOwnProperty.call(delta, name)) {\n      var value = delta[name];\n      if (isArray(value) && value[2] === 3) {\n        moveDestinations[value[1].toString()] = {\n          key: name,\n          value: left && left[parseInt(name.substr(1))]\n        };\n        if (this.includeMoveDestinations !== false) {\n          if ((typeof left === 'undefined') &&\n            (typeof delta[value[1]] === 'undefined')) {\n            keys.push(value[1].toString());\n          }\n        }\n      }\n    }\n  }\n  if (arrayKeys) {\n    keys.sort(arrayKeyComparer);\n  } else {\n    keys.sort();\n  }\n  for (var index = 0, length = keys.length; index < length; index++) {\n    var key = keys[index];\n    if (arrayKeys && key === '_t') {\n      continue;\n    }\n    var leftKey = arrayKeys ?\n      (typeof key === 'number' ? key : parseInt(trimUnderscore(key), 10)) :\n      key;\n    var isLast = (index === length - 1);\n    fn(key, leftKey, moveDestinations[leftKey], isLast);\n  }\n};\n\nBaseFormatter.prototype.getDeltaType = function(delta, movedFrom) {\n  if (typeof delta === 'undefined') {\n    if (typeof movedFrom !== 'undefined') {\n      return 'movedestination';\n    }\n    return 'unchanged';\n  }\n  if (isArray(delta)) {\n    if (delta.length === 1) {\n      return 'added';\n    }\n    if (delta.length === 2) {\n      return 'modified';\n    }\n    if (delta.length === 3 && delta[2] === 0) {\n      return 'deleted';\n    }\n    if (delta.length === 3 && delta[2] === 2) {\n      return 'textdiff';\n    }\n    if (delta.length === 3 && delta[2] === 3) {\n      return 'moved';\n    }\n  } else if (typeof delta === 'object') {\n    return 'node';\n  }\n  return 'unknown';\n};\n\nBaseFormatter.prototype.parseTextDiff = function(value) {\n  var output = [];\n  var lines = value.split('\\n@@ ');\n  for (var i = 0, l = lines.length; i < l; i++) {\n    var line = lines[i];\n    var lineOutput = {\n      pieces: []\n    };\n    var location = /^(?:@@ )?[-+]?(\\d+),(\\d+)/.exec(line).slice(1);\n    lineOutput.location = {\n      line: location[0],\n      chr: location[1]\n    };\n    var pieces = line.split('\\n').slice(1);\n    for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {\n      var piece = pieces[pieceIndex];\n      if (!piece.length) {\n        continue;\n      }\n      var pieceOutput = {\n        type: 'context'\n      };\n      if (piece.substr(0, 1) === '+') {\n        pieceOutput.type = 'added';\n      } else if (piece.substr(0, 1) === '-') {\n        pieceOutput.type = 'deleted';\n      }\n      pieceOutput.text = piece.slice(1);\n      lineOutput.pieces.push(pieceOutput);\n    }\n    output.push(lineOutput);\n  }\n  return output;\n};\n\nexports.BaseFormatter = BaseFormatter;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/formatters/base.js\n ** module id = 62\n ** module chunks = 0\n **/","var environment = require('../environment');\n\nexports.base = require('./base');\nexports.html = require('./html');\nexports.annotated = require('./annotated');\nexports.jsonpatch = require('./jsonpatch');\n\nif (!environment.isBrowser) {\n  var consoleModuleName = './console';\n  exports.console = require(consoleModuleName);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/formatters/index.js\n ** module id = 63\n ** module chunks = 0\n **/","var base = require('./base');\nvar BaseFormatter = base.BaseFormatter;\n\nvar HtmlFormatter = function HtmlFormatter() {};\n\nHtmlFormatter.prototype = new BaseFormatter();\n\nfunction htmlEscape(text) {\n  var html = text;\n  var replacements = [\n    [/&/g, '&amp;'],\n    [/</g, '&lt;'],\n    [/>/g, '&gt;'],\n    [/'/g, '&apos;'],\n    [/\"/g, '&quot;']\n  ];\n  for (var i = 0; i < replacements.length; i++) {\n    html = html.replace(replacements[i][0], replacements[i][1]);\n  }\n  return html;\n}\n\nHtmlFormatter.prototype.typeFormattterErrorFormatter = function(context, err) {\n  context.out('<pre class=\"jsondiffpatch-error\">' + err + '</pre>');\n};\n\nHtmlFormatter.prototype.formatValue = function(context, value) {\n  context.out('<pre>' + htmlEscape(JSON.stringify(value, null, 2)) + '</pre>');\n};\n\nHtmlFormatter.prototype.formatTextDiffString = function(context, value) {\n  var lines = this.parseTextDiff(value);\n  context.out('<ul class=\"jsondiffpatch-textdiff\">');\n  for (var i = 0, l = lines.length; i < l; i++) {\n    var line = lines[i];\n    context.out('<li>' +\n      '<div class=\"jsondiffpatch-textdiff-location\">' +\n      '<span class=\"jsondiffpatch-textdiff-line-number\">' +\n      line.location.line +\n      '</span>' +\n      '<span class=\"jsondiffpatch-textdiff-char\">' +\n      line.location.chr +\n      '</span>' +\n      '</div>' +\n      '<div class=\"jsondiffpatch-textdiff-line\">');\n    var pieces = line.pieces;\n    for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {\n      /* global unescape */\n      var piece = pieces[pieceIndex];\n      context.out('<span class=\"jsondiffpatch-textdiff-' + piece.type + '\">' +\n        htmlEscape(unescape(piece.text)) + '</span>');\n    }\n    context.out('</div></li>');\n  }\n  context.out('</ul>');\n};\n\nvar adjustArrows = function jsondiffpatchHtmlFormatterAdjustArrows(node) {\n  node = node || document;\n  var getElementText = function(el) {\n    return el.textContent || el.innerText;\n  };\n  var eachByQuery = function(el, query, fn) {\n    var elems = el.querySelectorAll(query);\n    for (var i = 0, l = elems.length; i < l; i++) {\n      fn(elems[i]);\n    }\n  };\n  var eachChildren = function(el, fn) {\n    for (var i = 0, l = el.children.length; i < l; i++) {\n      fn(el.children[i], i);\n    }\n  };\n  eachByQuery(node, '.jsondiffpatch-arrow', function(arrow) {\n    var arrowParent = arrow.parentNode;\n    var svg = arrow.children[0],\n      path = svg.children[1];\n    svg.style.display = 'none';\n    var destination = getElementText(arrowParent.querySelector('.jsondiffpatch-moved-destination'));\n    var container = arrowParent.parentNode;\n    var destinationElem;\n    eachChildren(container, function(child) {\n      if (child.getAttribute('data-key') === destination) {\n        destinationElem = child;\n      }\n    });\n    if (!destinationElem) {\n      return;\n    }\n    try {\n      var distance = destinationElem.offsetTop - arrowParent.offsetTop;\n      svg.setAttribute('height', Math.abs(distance) + 6);\n      arrow.style.top = (-8 + (distance > 0 ? 0 : distance)) + 'px';\n      var curve = distance > 0 ?\n        'M30,0 Q-10,' + Math.round(distance / 2) + ' 26,' + (distance - 4) :\n        'M30,' + (-distance) + ' Q-10,' + Math.round(-distance / 2) + ' 26,4';\n      path.setAttribute('d', curve);\n      svg.style.display = '';\n    } catch (err) {\n      return;\n    }\n  });\n};\n\nHtmlFormatter.prototype.rootBegin = function(context, type, nodeType) {\n  var nodeClass = 'jsondiffpatch-' + type +\n    (nodeType ? ' jsondiffpatch-child-node-type-' + nodeType : '');\n  context.out('<div class=\"jsondiffpatch-delta ' + nodeClass + '\">');\n};\n\nHtmlFormatter.prototype.rootEnd = function(context) {\n  context.out('</div>' + (context.hasArrows ?\n    ('<script type=\"text/javascript\">setTimeout(' +\n      adjustArrows.toString() +\n      ',10);</script>') : ''));\n};\n\nHtmlFormatter.prototype.nodeBegin = function(context, key, leftKey, type, nodeType) {\n  var nodeClass = 'jsondiffpatch-' + type +\n    (nodeType ? ' jsondiffpatch-child-node-type-' + nodeType : '');\n  context.out('<li class=\"' + nodeClass + '\" data-key=\"' + leftKey + '\">' +\n    '<div class=\"jsondiffpatch-property-name\">' + leftKey + '</div>');\n};\n\n\nHtmlFormatter.prototype.nodeEnd = function(context) {\n  context.out('</li>');\n};\n\n/* jshint camelcase: false */\n\nHtmlFormatter.prototype.format_unchanged = function(context, delta, left) {\n  if (typeof left === 'undefined') {\n    return;\n  }\n  context.out('<div class=\"jsondiffpatch-value\">');\n  this.formatValue(context, left);\n  context.out('</div>');\n};\n\nHtmlFormatter.prototype.format_movedestination = function(context, delta, left) {\n  if (typeof left === 'undefined') {\n    return;\n  }\n  context.out('<div class=\"jsondiffpatch-value\">');\n  this.formatValue(context, left);\n  context.out('</div>');\n};\n\nHtmlFormatter.prototype.format_node = function(context, delta, left) {\n  // recurse\n  var nodeType = (delta._t === 'a') ? 'array' : 'object';\n  context.out('<ul class=\"jsondiffpatch-node jsondiffpatch-node-type-' + nodeType + '\">');\n  this.formatDeltaChildren(context, delta, left);\n  context.out('</ul>');\n};\n\nHtmlFormatter.prototype.format_added = function(context, delta) {\n  context.out('<div class=\"jsondiffpatch-value\">');\n  this.formatValue(context, delta[0]);\n  context.out('</div>');\n};\n\nHtmlFormatter.prototype.format_modified = function(context, delta) {\n  context.out('<div class=\"jsondiffpatch-value jsondiffpatch-left-value\">');\n  this.formatValue(context, delta[0]);\n  context.out('</div>' +\n    '<div class=\"jsondiffpatch-value jsondiffpatch-right-value\">');\n  this.formatValue(context, delta[1]);\n  context.out('</div>');\n};\n\nHtmlFormatter.prototype.format_deleted = function(context, delta) {\n  context.out('<div class=\"jsondiffpatch-value\">');\n  this.formatValue(context, delta[0]);\n  context.out('</div>');\n};\n\nHtmlFormatter.prototype.format_moved = function(context, delta) {\n  context.out('<div class=\"jsondiffpatch-value\">');\n  this.formatValue(context, delta[0]);\n  context.out('</div><div class=\"jsondiffpatch-moved-destination\">' + delta[1] + '</div>');\n\n  // draw an SVG arrow from here to move destination\n  context.out(\n    /*jshint multistr: true */\n    '<div class=\"jsondiffpatch-arrow\" style=\"position: relative; left: -34px;\">\\\n        <svg width=\"30\" height=\"60\" style=\"position: absolute; display: none;\">\\\n        <defs>\\\n            <marker id=\"markerArrow\" markerWidth=\"8\" markerHeight=\"8\" refx=\"2\" refy=\"4\"\\\n                   orient=\"auto\" markerUnits=\"userSpaceOnUse\">\\\n                <path d=\"M1,1 L1,7 L7,4 L1,1\" style=\"fill: #339;\" />\\\n            </marker>\\\n        </defs>\\\n        <path d=\"M30,0 Q-10,25 26,50\" style=\"stroke: #88f; stroke-width: 2px; fill: none;\\\n        stroke-opacity: 0.5; marker-end: url(#markerArrow);\"></path>\\\n        </svg>\\\n        </div>');\n  context.hasArrows = true;\n};\n\nHtmlFormatter.prototype.format_textdiff = function(context, delta) {\n  context.out('<div class=\"jsondiffpatch-value\">');\n  this.formatTextDiffString(context, delta[0]);\n  context.out('</div>');\n};\n\n/* jshint camelcase: true */\n\nvar showUnchanged = function(show, node, delay) {\n  var el = node || document.body;\n  var prefix = 'jsondiffpatch-unchanged-';\n  var classes = {\n    showing: prefix + 'showing',\n    hiding: prefix + 'hiding',\n    visible: prefix + 'visible',\n    hidden: prefix + 'hidden',\n  };\n  var list = el.classList;\n  if (!list) {\n    return;\n  }\n  if (!delay) {\n    list.remove(classes.showing);\n    list.remove(classes.hiding);\n    list.remove(classes.visible);\n    list.remove(classes.hidden);\n    if (show === false) {\n      list.add(classes.hidden);\n    }\n    return;\n  }\n  if (show === false) {\n    list.remove(classes.showing);\n    list.add(classes.visible);\n    setTimeout(function() {\n      list.add(classes.hiding);\n    }, 10);\n  } else {\n    list.remove(classes.hiding);\n    list.add(classes.showing);\n    list.remove(classes.hidden);\n  }\n  var intervalId = setInterval(function() {\n    adjustArrows(el);\n  }, 100);\n  setTimeout(function() {\n    list.remove(classes.showing);\n    list.remove(classes.hiding);\n    if (show === false) {\n      list.add(classes.hidden);\n      list.remove(classes.visible);\n    } else {\n      list.add(classes.visible);\n      list.remove(classes.hidden);\n    }\n    setTimeout(function() {\n      list.remove(classes.visible);\n      clearInterval(intervalId);\n    }, delay + 400);\n  }, delay);\n};\n\nvar hideUnchanged = function(node, delay) {\n  return showUnchanged(false, node, delay);\n};\n\nexports.HtmlFormatter = HtmlFormatter;\n\nexports.showUnchanged = showUnchanged;\n\nexports.hideUnchanged = hideUnchanged;\n\nvar defaultInstance;\n\nexports.format = function(delta, left) {\n  if (!defaultInstance) {\n    defaultInstance = new HtmlFormatter();\n  }\n  return defaultInstance.format(delta, left);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/formatters/html.js\n ** module id = 64\n ** module chunks = 0\n **/","var base = require('./base');\nvar BaseFormatter = base.BaseFormatter;\n\nvar AnnotatedFormatter = function AnnotatedFormatter() {\n  this.includeMoveDestinations = false;\n};\n\nAnnotatedFormatter.prototype = new BaseFormatter();\n\nAnnotatedFormatter.prototype.prepareContext = function(context) {\n  BaseFormatter.prototype.prepareContext.call(this, context);\n  context.indent = function(levels) {\n    this.indentLevel = (this.indentLevel || 0) +\n      (typeof levels === 'undefined' ? 1 : levels);\n    this.indentPad = new Array(this.indentLevel + 1).join('&nbsp;&nbsp;');\n  };\n  context.row = function(json, htmlNote) {\n    context.out('<tr><td style=\"white-space: nowrap;\">' +\n      '<pre class=\"jsondiffpatch-annotated-indent\" style=\"display: inline-block\">');\n    context.out(context.indentPad);\n    context.out('</pre><pre style=\"display: inline-block\">');\n    context.out(json);\n    context.out('</pre></td><td class=\"jsondiffpatch-delta-note\"><div>');\n    context.out(htmlNote);\n    context.out('</div></td></tr>');\n  };\n};\n\nAnnotatedFormatter.prototype.typeFormattterErrorFormatter = function(context, err) {\n  context.row('', '<pre class=\"jsondiffpatch-error\">' + err + '</pre>');\n};\n\nAnnotatedFormatter.prototype.formatTextDiffString = function(context, value) {\n  var lines = this.parseTextDiff(value);\n  context.out('<ul class=\"jsondiffpatch-textdiff\">');\n  for (var i = 0, l = lines.length; i < l; i++) {\n    var line = lines[i];\n    context.out('<li>' +\n      '<div class=\"jsondiffpatch-textdiff-location\">' +\n      '<span class=\"jsondiffpatch-textdiff-line-number\">' +\n      line.location.line +\n      '</span>' +\n      '<span class=\"jsondiffpatch-textdiff-char\">' +\n      line.location.chr +\n      '</span>' +\n      '</div>' +\n      '<div class=\"jsondiffpatch-textdiff-line\">');\n    var pieces = line.pieces;\n    for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {\n      var piece = pieces[pieceIndex];\n      context.out('<span class=\"jsondiffpatch-textdiff-' + piece.type + '\">' +\n        piece.text + '</span>');\n    }\n    context.out('</div></li>');\n  }\n  context.out('</ul>');\n};\n\nAnnotatedFormatter.prototype.rootBegin = function(context, type, nodeType) {\n  context.out('<table class=\"jsondiffpatch-annotated-delta\">');\n  if (type === 'node') {\n    context.row('{');\n    context.indent();\n  }\n  if (nodeType === 'array') {\n    context.row('\"_t\": \"a\",', 'Array delta (member names indicate array indices)');\n  }\n};\n\nAnnotatedFormatter.prototype.rootEnd = function(context, type) {\n  if (type === 'node') {\n    context.indent(-1);\n    context.row('}');\n  }\n  context.out('</table>');\n};\n\nAnnotatedFormatter.prototype.nodeBegin = function(context, key, leftKey, type, nodeType) {\n  context.row('&quot;' + key + '&quot;: {');\n  if (type === 'node') {\n    context.indent();\n  }\n  if (nodeType === 'array') {\n    context.row('\"_t\": \"a\",', 'Array delta (member names indicate array indices)');\n  }\n};\n\nAnnotatedFormatter.prototype.nodeEnd = function(context, key, leftKey, type, nodeType, isLast) {\n  if (type === 'node') {\n    context.indent(-1);\n  }\n  context.row('}' + (isLast ? '' : ','));\n};\n\n/* jshint camelcase: false */\n\nAnnotatedFormatter.prototype.format_unchanged = function() {\n  return;\n};\n\nAnnotatedFormatter.prototype.format_movedestination = function() {\n  return;\n};\n\n\nAnnotatedFormatter.prototype.format_node = function(context, delta, left) {\n  // recurse\n  this.formatDeltaChildren(context, delta, left);\n};\n\nvar wrapPropertyName = function(name) {\n  return '<pre style=\"display:inline-block\">&quot;' + name + '&quot;</pre>';\n};\n\nvar deltaAnnotations = {\n  added: function(delta, left, key, leftKey) {\n    var formatLegend = ' <pre>([newValue])</pre>';\n    if (typeof leftKey === 'undefined') {\n      return 'new value' + formatLegend;\n    }\n    if (typeof leftKey === 'number') {\n      return 'insert at index ' + leftKey + formatLegend;\n    }\n    return 'add property ' + wrapPropertyName(leftKey) + formatLegend;\n  },\n  modified: function(delta, left, key, leftKey) {\n    var formatLegend = ' <pre>([previousValue, newValue])</pre>';\n    if (typeof leftKey === 'undefined') {\n      return 'modify value' + formatLegend;\n    }\n    if (typeof leftKey === 'number') {\n      return 'modify at index ' + leftKey + formatLegend;\n    }\n    return 'modify property ' + wrapPropertyName(leftKey) + formatLegend;\n  },\n  deleted: function(delta, left, key, leftKey) {\n    var formatLegend = ' <pre>([previousValue, 0, 0])</pre>';\n    if (typeof leftKey === 'undefined') {\n      return 'delete value' + formatLegend;\n    }\n    if (typeof leftKey === 'number') {\n      return 'remove index ' + leftKey + formatLegend;\n    }\n    return 'delete property ' + wrapPropertyName(leftKey) + formatLegend;\n  },\n  moved: function(delta, left, key, leftKey) {\n    return 'move from <span title=\"(position to remove at original state)\">index ' +\n      leftKey + '</span> to ' +\n      '<span title=\"(position to insert at final state)\">index ' +\n      delta[1] + '</span>';\n  },\n  textdiff: function(delta, left, key, leftKey) {\n    var location = (typeof leftKey === 'undefined') ?\n      '' : (\n        (typeof leftKey === 'number') ?\n        ' at index ' + leftKey :\n        ' at property ' + wrapPropertyName(leftKey)\n      );\n    return 'text diff' + location + ', format is ' +\n      '<a href=\"https://code.google.com/p/google-diff-match-patch/wiki/Unidiff\">' +\n      'a variation of Unidiff</a>';\n  }\n};\n\nvar formatAnyChange = function(context, delta) {\n  var deltaType = this.getDeltaType(delta);\n  var annotator = deltaAnnotations[deltaType];\n  var htmlNote = annotator && annotator.apply(annotator,\n    Array.prototype.slice.call(arguments, 1));\n  var json = JSON.stringify(delta, null, 2);\n  if (deltaType === 'textdiff') {\n    // split text diffs lines\n    json = json.split('\\\\n').join('\\\\n\"+\\n   \"');\n  }\n  context.indent();\n  context.row(json, htmlNote);\n  context.indent(-1);\n};\n\nAnnotatedFormatter.prototype.format_added = formatAnyChange;\nAnnotatedFormatter.prototype.format_modified = formatAnyChange;\nAnnotatedFormatter.prototype.format_deleted = formatAnyChange;\nAnnotatedFormatter.prototype.format_moved = formatAnyChange;\nAnnotatedFormatter.prototype.format_textdiff = formatAnyChange;\n\n/* jshint camelcase: true */\n\nexports.AnnotatedFormatter = AnnotatedFormatter;\n\nvar defaultInstance;\n\nexports.format = function(delta, left) {\n  if (!defaultInstance) {\n    defaultInstance = new AnnotatedFormatter();\n  }\n  return defaultInstance.format(delta, left);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/formatters/annotated.js\n ** module id = 65\n ** module chunks = 0\n **/","(function () {\n  var base = require('./base');\n  var BaseFormatter = base.BaseFormatter;\n\n  var named = {\n    added: 'add',\n    deleted: 'remove',\n    modified: 'replace',\n    moved: 'moved',\n    movedestination: 'movedestination',\n    unchanged: 'unchanged',\n    error: 'error',\n    textDiffLine: 'textDiffLine'\n  };\n\n  function JSONFormatter() {\n    this.includeMoveDestinations = false;\n  }\n\n  JSONFormatter.prototype = new BaseFormatter();\n\n  JSONFormatter.prototype.prepareContext = function (context) {\n    BaseFormatter.prototype.prepareContext.call(this, context);\n    context.result = [];\n    context.path = [];\n    context.pushCurrentOp = function (op, value) {\n      var val = {\n        op: op,\n        path: this.currentPath()\n      };\n      if (typeof value !== 'undefined') {\n        val.value = value;\n      }\n      this.result.push(val);\n    };\n\n    context.currentPath = function () {\n      return '/' + this.path.join('/');\n    };\n  };\n\n  JSONFormatter.prototype.typeFormattterErrorFormatter = function (context, err) {\n    context.out('[ERROR]' + err);\n  };\n\n  JSONFormatter.prototype.rootBegin = function () {\n  };\n\n  JSONFormatter.prototype.rootEnd = function () {\n  };\n\n  JSONFormatter.prototype.nodeBegin = function (context, key, leftKey) {\n    context.path.push(leftKey);\n  };\n\n  JSONFormatter.prototype.nodeEnd = function (context) {\n    context.path.pop();\n  };\n\n  /* jshint camelcase: false */\n\n  JSONFormatter.prototype.format_unchanged = function (context, delta, left) {\n    if (typeof left === 'undefined') {\n      return;\n    }\n    context.pushCurrentOp(named.unchanged, left);\n  };\n\n  JSONFormatter.prototype.format_movedestination = function (context, delta, left) {\n    if (typeof left === 'undefined') {\n      return;\n    }\n    context.pushCurrentOp(named.movedestination, left);\n  };\n\n  JSONFormatter.prototype.format_node = function (context, delta, left) {\n    this.formatDeltaChildren(context, delta, left);\n  };\n\n  JSONFormatter.prototype.format_added = function (context, delta) {\n    context.pushCurrentOp(named.added, delta[0]);\n  };\n\n  JSONFormatter.prototype.format_modified = function (context, delta) {\n    context.pushCurrentOp(named.modified, delta[1]);\n  };\n\n  JSONFormatter.prototype.format_deleted = function (context) {\n    context.pushCurrentOp(named.deleted);\n  };\n\n  JSONFormatter.prototype.format_moved = function (context, delta) {\n    context.pushCurrentOp(named.moved, delta[1]);\n  };\n\n  JSONFormatter.prototype.format_textdiff = function () {\n    throw 'not implimented';\n  };\n\n  JSONFormatter.prototype.format = function (delta, left) {\n    var context = {};\n    this.prepareContext(context);\n    this.recurse(context, delta, left);\n    return context.result;\n  };\n  /* jshint camelcase: true */\n\n  exports.JSONFormatter = JSONFormatter;\n\n  var defaultInstance;\n\n  function last(arr) {\n    return arr[arr.length - 1];\n  }\n\n  function sortBy(arr, pred) {\n    arr.sort(pred);\n    return arr;\n  }\n\n  var compareByIndexDesc = function (indexA, indexB) {\n    var lastA = parseInt(indexA, 10);\n    var lastB = parseInt(indexB, 10);\n    if (!(isNaN(lastA) || isNaN(lastB))) {\n      return lastB - lastA;\n    } else {\n      return 0;\n    }\n  };\n\n  function opsByDescendingOrder(removeOps) {\n    return sortBy(removeOps, function (a, b) {\n      var splitA = a.path.split('/');\n      var splitB = b.path.split('/');\n      if (splitA.length !== splitB.length) {\n        return splitA.length - splitB.length;\n      } else {\n        return compareByIndexDesc(last(splitA), last(splitB));\n      }\n    });\n  }\n\n  function partition(arr, pred) {\n    var left = [];\n    var right = [];\n\n    arr.forEach(function (el) {\n      var coll = pred(el) ? left : right;\n      coll.push(el);\n    });\n    return [left, right];\n  }\n\n  function reorderOps(jsonFormattedDiff) {\n    var removeOpsOtherOps = partition(jsonFormattedDiff, function (operation) {\n      return operation.op === 'remove';\n    });\n    var removeOps = removeOpsOtherOps[0];\n    var otherOps = removeOpsOtherOps[1];\n\n    var removeOpsReverse = opsByDescendingOrder(removeOps);\n    return removeOpsReverse.concat(otherOps);\n  }\n\n\n  var format = function (delta, left) {\n    if (!defaultInstance) {\n      defaultInstance = new JSONFormatter();\n    }\n    return reorderOps(defaultInstance.format(delta, left));\n  };\n\n  exports.log = function (delta, left) {\n    console.log(format(delta, left));\n  };\n\n  exports.format = format;\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/formatters/jsonpatch.js\n ** module id = 66\n ** module chunks = 0\n **/","// use as 2nd parameter for JSON.parse to revive Date instances\nmodule.exports = function dateReviver(key, value) {\n  var parts;\n  if (typeof value === 'string') {\n    parts = /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d*))?(Z|([+\\-])(\\d{2}):(\\d{2}))$/.exec(value);\n    if (parts) {\n      return new Date(Date.UTC(+parts[1], +parts[2] - 1, +parts[3], +parts[4], +parts[5], +parts[6], +(parts[7] || 0)));\n    }\n  }\n  return value;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/date-reviver.js\n ** module id = 67\n ** module chunks = 0\n **/","import EventObject from './event';\nimport API from './api';\nimport log from './logger';\nimport error from './error';\n\n/**\n * Use Channels to create, update and remove Telepat objects. You can create new Channels using the {@link #Telepat#subscribe subscribe}\n * or the {@link #Telepat#getChannel getChannel} methods of the main {@link Telepat} object.\n *\n * @class Channel\n *\n * @example\n * let articleChannel = telepat.subscribe({\n *  channel: {\n *    context: 'context-unique-identifier',\n *    model: 'article'\n *  }\n * }, () => {\n *  console.log(articleChannel.objectsArray);\n *\n *  // Create a new article object\n *  articleChannel.objects['new'] = {\n *    title: 'New article',\n *    text: 'Article body'\n *  };\n *\n *  // Update a specific article\n *  articleChannel.objects['article-unique-id'].title = 'New title';\n *\n *  // Delete a specific article\n *  delete articleChannel.objects['article-unique-id'];\n *\n *  // React to object updates\n *  articleChannel.on('update', (operationType, objectId, object, oldObject) => {\n *    console.log(`Received article update of type ${operationType}, for object with id ${objectId}`);\n *    // Objects are already updated\n *    console.log(articleChannel.objects);\n *  });\n *\n *  // Unsubscribe and clear objects\n *  articleChannel.unsubscribe();\n * });\n */\nexport default class Channel {\n  constructor(monitor, options, addCallback = null, updateCallback = null, removeCallback = null) {\n    this._event = new EventObject(log);\n    this._monitor = monitor;\n    this._options = options;\n    this._addCallback = addCallback;\n    this._updateCallback = updateCallback;\n    this._removeCallback = removeCallback;\n    this._subscribed = false;\n\n    /**\n     * A container object referencing all of the objects retrieved via subscription. Each object is stored on a key equal to its own unique id.\n     * @type {Object}\n     * @memberof Channel\n     * @instance\n     */\n    this.objects = {};\n    /**\n     * A container array referencing all of the objects retrieved via subscription. The order of the objects reflects the sorting options set for the channel.\n     * @type {Array<Object>}\n     * @memberof Channel\n     * @instance\n     */\n    this.objectsArray = [];\n    /**\n     * The current object count.\n     * @type {number|null}\n     * @memberof Channel\n     * @instance\n     */\n    this.objectsCount = null;\n\n    this._event.on('update', (operation, parentId, parentObject, delta) => {\n      if (operation === 'add') {\n        this.objectsArray.push(parentObject);\n        this._sortObjectArray();\n        if (this.objectsCount) {\n          this.objectsCount++;\n        }\n      } else if (operation === 'delete') {\n        this.objectsArray = this.objectsArray.filter(object => {\n          return object.id !== parentId;\n        });\n        this._sortObjectArray();\n        if (this.objectsCount) {\n          this.objectsCount--;\n        }\n      }\n    });\n  }\n\n  _sortObjectArray() {\n    if (this._options.sort) {\n      this.objectsArray.sort((a, b) => {\n        let result = null;\n\n        Object.keys(this._options.sort).map(key => {\n          let order = this._options.sort[key];\n          let factor = (order === 'asc') ? 1 : -1;\n\n          if (a[key] && !b[key]) {\n            result = factor;\n          }\n          if (!a[key] && b[key]) {\n            result = -factor;\n          }\n          if (a[key] && b[key]) {\n            if (a[key] < b[key]) {\n              result = -factor;\n            }\n            if (a[key] > b[key]) {\n              result = factor;\n            }\n          }\n        });\n\n        if (!result) {\n          return 0;\n        }\n        return result;\n      });\n    }\n  }\n\n/**\n * Call this function to perform the actual subscribe for the configured channel. This is usually invoked by the\n * {@link #Telepat#subscribe subscribe} method on the main {@link Telepat} object.\n *\n * @param {TelepatCallback} callback Callback invoked after subscribe is finished\n */\n  subscribe(callback = () => {}) {\n    API.call('object/subscribe',\n      this._options,\n      (err, res) => {\n        if (err) {\n          this._event.emit('error', error('Subscribe failed with error: ' + err));\n          callback(err, null);\n        } else {\n          let i;\n\n          this.objects = {};\n          this.objectsArray = [];\n          this.objectsCount = 0;\n\n          for (i = 0; i < res.body.content.length; i++) {\n            this.objects[res.body.content[i].id] = res.body.content[i];\n          }\n          this.objectsArray = res.body.content;\n          this._sortObjectArray();\n          let objectKeys = Object.keys(this.objects);\n\n          for (i = 0; i < objectKeys.length; i++) {\n            this.objects[objectKeys[i]].$$event = new EventObject(log);\n          }\n          this._monitor.add(\n            this._options,\n            this.objects,\n            this._event,\n            this._addCallback || this.add.bind(this),\n            this._removeCallback || this.remove.bind(this),\n            this._updateCallback || this.update.bind(this)\n          );\n\n          if (this._subscribed) {\n            this._event.emit('update', 'resync');\n          } else {\n            this._event.emit('subscribe');\n          }\n\n          this._subscribed = true;\n          callback(null, this);\n        }\n      });\n  }\n\n/**\n * Call this function to unsubscribe from the configured channel. All channel properties will be reset to original values.\n *\n * @param {TelepatCallback} callback Callback invoked after unsubscribe is finished\n */\n  unsubscribe(callback = () => {}) {\n    API.call('object/unsubscribe',\n      this._options,\n      err => {\n        if (err) {\n          this._event.emit('error', error('Unsubscribe failed with error: ' + err));\n          callback(err, null);\n        } else {\n          this.objects = {};\n          this.objectsArray = [];\n          this.objectsCount = null;\n          this._monitor.remove(this._options);\n          this._event.emit('unsubscribe');\n          this._event.emit('_unsubscribe');\n          this._subscribed = false;\n          callback(null, this);\n        }\n      });\n  }\n\n  /**\n   * Call this to retrieve the number of objects available for this channel. Value will be available on the {@link #ChannelobjectsCount objectsCount} property.\n   *\n   * @param  {TelepatCallback} callback Callback invoked after getting object count is finished\n   */\n  getCount(callback = () => {}) {\n    API.call('object/count',\n      this._options,\n      (err, res) => {\n        if (err) {\n          this._event.emit('error', error('Get object count failed with error: ' + err));\n          callback(err, null);\n        } else {\n          this.objectsCount = res.body.content.count;\n          callback(null, this.objectsCount);\n        }\n      });\n  }\n\n/**\n * Add a new Telepat object to the current channel.\n * Instead of using this function, you can also add the object to {@link #Channelobjects Channel.objects}, on any new key.\n * The key will be automatically replaced with the new object id after the backend processes the operation.\n *\n * @param {Object} object The new object to add\n * @param {TelepatCallback} callback Callback invoked after notifying the Telepat backend of the new object\n *\n * @example\n * // This is one way of adding a new object using the channel instance.\n * // The new key will be picked up by the monitoring system, which will signal the new event creation\n * //   to the Telepat backend, and then delete the new key you just set from the objects property.\n * // After processing the request, Telepat will signal the change back to the client, and the new object will be\n * //   re-added to the objects property, but this time on the right key (equal to the new object's assigned id).\n * //   This is when the 'update' event will get triggered on the channel.\n * channel.objects['new'] = newObject;\n *\n * // Alternatively, you can call the add method:\n * channel.add(newObject, err => {\n *  if (err) {\n *    // There's been a server error, check err. The object will not be added.\n *  } else {\n *    // We've successfully signaled that we want to add the object.\n *    // Keep in mind that this is not a sync process, so we still have to wait for the 'update'\n *    //   event on the channel, signaling the availability of the new object on the channel.objects property.\n *  }\n * });\n */\n  add(object, callback = () => {}) {\n    API.call('object/create',\n      {\n        model: this._options.channel.model,\n        context: this._options.channel.context || object.context_id,\n        content: object\n      },\n      err => {\n        if (err) {\n          this._event.emit('error', error('Adding object failed with error: ' + err));\n          callback(err, null);\n        } else {\n          callback(null, object);\n        }\n      });\n  }\n\n/**\n * Remove a Telepat object from the current channel.\n * Instead of using this function, you can also delete the object from {@link #Channelobjects Channel.objects}.\n *\n * @param {string} id The id of the object to delete\n * @param {TelepatCallback} callback Callback invoked after notifying the Telepat backend of the deleted object\n *\n * @example\n * // This is one way of deleting an object using the channel instance.\n * // The deleted key will be picked up by the monitoring system, which will signal the object removal\n * //   to the Telepat backend. The change will be then signaled back to the client as confirmation, triggering\n * //   the channel's 'update' event.\n * // This is the optimistic way of doing a delete, as the removed object will be instantly gone from the local\n * //   state, before the 'update' event is triggered (and even if it is not).\n * delete channel.objects[objectId];\n *\n * // Alternatively, the pessimistic approach is to call the remove method:\n * channel.remove(objectId, err => {\n *  if (err) {\n *    // There's been a server error, check err. The object will not be deleted.\n *  } else {\n *    // We've successfully signaled that we want to delete the object.\n *    // Keep in mind that this is not a sync process, so we still have to wait for the 'update'\n *    //   event on the channel, signaling that the object has been removed from the channel.objects property.\n *  }\n * });\n */\n  remove(id, callback = () => {}) {\n    API.del('object/delete',\n      {\n        model: this._options.channel.model,\n        context: this._options.channel.context || this.objects[id].context_id,\n        id: id\n      },\n      err => {\n        if (err) {\n          this._event.emit('error', error('Removing object failed with error: ' + err));\n          callback(err, null);\n        } else {\n          callback(null, id);\n        }\n      });\n  }\n\n/**\n * Updates a Telepat object from the current channel.\n * To call this function, you need to create an  array containing 'patch' objects, representing the\n  modifications that need to be persisted. The structure of a patch object is:\n *\n * `{'op': 'replace', 'path': channel + '/' + object_id + '/' + object_property, 'value': modified_value}`\n *\n * Instead of using this function, you can also update the object directly from {@link #Channelobjects Channel.objects}.\n *\n * @param {number} id The id of the object to update\n * @param {Array<Object>} patches The array of patches representing the modifications that need to be persisted.\n * @param {TelepatCallback} callback Callback invoked after notifying the Telepat backend of the updated object\n *\n * @example\n * // This is one way of updating an object using the channel instance.\n * // The updated key will be picked up by the monitoring system, which will signal the object update\n * //   to the Telepat backend. The change will be then signaled back to the client as confirmation, triggering\n * //   the channel's 'update' event.\n * // This is the optimistic way of doing a delete, as the updated object will be instantly modified within the local\n * //   state, before the 'update' event is triggered (and even if it is not).\n * channel.objects[objectId].title = \"New title\";\n *\n * // Alternatively, the pessimistic approach is to call the update method:\n * channel.update(objectId, [\n *  {\n *    'op': 'replace',\n *    'path': `article/${objectId}/title`,\n *    'value': 'New title'\n *  }\n * ], err => {\n *  if (err) {\n *    // There's been a server error, check err. The object will not be updated.\n *  } else {\n *    // We've successfully signaled that we want to update the object.\n *    // Keep in mind that this is not a sync process, so we still have to wait for the 'update'\n *    //   event on the channel, signaling that the object has been updated within the channel.objects property.\n *  }\n * });\n */\n  update(id, patches, callback = () => {}) {\n    API.call('object/update',\n      {\n        model: this._options.channel.model,\n        context: this._options.channel.context || this.objects[id].context_id,\n        id: id,\n        patches: patches\n      },\n      err => {\n        if (err) {\n          this._event.emit('error', error('Updating object failed with error: ' + err));\n        } else {\n        }\n      });\n  }\n\n/**\n * Invoked when there was an error processing the requested operation.\n *\n * @event error\n * @type {Error}\n */\n/**\n * Invoked when channel subscription is successful.\n *\n * @event subscribe\n */\n/**\n * Invoked when channel unsubscription is successful.\n *\n * @event unsubscribe\n */\n/**\n * Invoked when objects in the subscription have been modified (there was an update of an existing object, a new object has been added or an object has been deleted).\n * Also invoked when all objects in the subscription have been resync'd with the server. This can happen\n * when the volatile transport is reconnected (after an offline period), or on manual re-calls of the `subscribe` method.\n *\n * @event update\n * @param {string} eventType One of 'add', 'delete', 'replace', 'resync'\n * @param {string} objectId The id of the affected object\n * @param {Object} object The affected object itself\n * @param {Object} oldObject Present only for the 'replace' eventType, the old state of the affected object\n */\n\n/**\n * Call this function to add callbacks to be invoked on event triggers.\n * Available callbacks:\n *\n * | Name                                               | Description           |\n * | -------------------------------------------------- | --------------------- |\n * | {@link #Channel.event:error error}                 | Invoked when there was an error processing the requested operation |\n * | {@link #Channel.event:subscribe subscribe}         | Invoked when channel subscription is successful |\n * | {@link #Channel.event:resync resync}               | Invoked when channel objects are resync'd with server |\n * | {@link #Channel.event:unsubscribe unsubscribe}     | Invoked when channel unsubscription is successful |\n * | {@link #Channel.event:update update}               | Invoked when objects in the subscription have been modified (update of an existing object, new object or deleted object) |\n *\n * @param {string} name The name of the event to associate the callback with\n * @param {function} callback The callback to be executed\n * @return {number} A callback id. Save this in order to later remove the callback from the event (using {@link #Channel#removeCallback removeCallback})\n * @example\n * // React to object updates\n *  articleChannel.on('update', (operationType, objectId, object, oldObject) => {\n *    console.log(`Received article update of type ${operationType}, for object with id ${objectId}`);\n *    // Objects are already updated\n *    console.log(articleChannel.objects);\n *  });\n */\n  on(name, callback) {\n    return this._event.on(name, callback);\n  }\n\n  /**\n   * Call this function to remove callbacks that have been set using {@link #Channel#on on}.\n   *\n   * @param {string} name The name of the event the callback was associated with\n   * @param {number} callbackId The callback id returned by calling {@link #Channel#on on}\n   * @example\n   * let updateCallbackId = channel.on('update', () => {\n   *  // Remove the callback after the first update event\n   *  channel.removeCallback(updateCallbackId);\n   * });\n   */\n  removeCallback(name, index) {\n    return this._event.removeCallback(name, index);\n  };\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/channel.js\n **/","import API from './api';\nimport log from './logger';\nimport error from './error';\nimport Admin from './admin';\n\n/**\n * You can access an instance of this class using the {@link #Telepatuser user} property of the Telepat object.\n *\n * @class User\n *\n * @example\n * telepat.user.login('email', 'password', (err) => {\n *  if (err) {\n *    // Treat login error\n *  } else {\n *    // Treat successful login\n *    console.log(telepat.user.data);\n *\n *    // Update user data\n *    telepat.user.data.points++;\n *  }\n * });\n */\nexport default class User {\n  constructor(db, event, monitor, setAdmin, callback = () => {}) {\n    this._event = event;\n    this._monitor = monitor;\n    this._setAdmin = setAdmin;\n    this._db = db;\n    this._customProperties = [];\n    this._userChannel = null;\n\n    /**\n     * Indicates if the currently logged in user is an admin\n     * @type {boolean}\n     * @memberof User\n     * @instance\n     */\n    this.isAdmin = false;\n    /**\n     * Indicates if there's a saved authentication token that can be used to re-login\n     * @type {boolean}\n     * @memberof User\n     * @instance\n     */\n    this.canReauth = null;\n    /**\n     * Object that holds all key-value data about the currently logged in user\n     * @type {Object}\n     * @memberof User\n     * @instance\n     */\n    this.data = {};\n\n    /**\n     * Indicates if there is a currently logged-in user\n     */\n    this.isLoggedIn = false;\n\n    API.tokenUpdateCallback = (newToken) => {\n      this._saveToken(newToken);\n    };\n\n    this._db.get(':userToken').then(doc => {\n      this.canReauth = true;\n      callback();\n    }).catch(() => {\n      this.canReauth = false;\n      callback();\n    });\n  }\n\n  _saveToken(token) {\n    var newObject = {\n      _id: ':userToken',\n      value: {\n        token: token,\n        admin: this.isAdmin\n      }\n    };\n\n    this._db.get(':userToken').then(doc => {\n      newObject._rev = doc._rev;\n      log.info('Replacing existing authentication token');\n      this._db.put(newObject).then(doc => {\n        this.canReauth = true;\n      }).catch(err => {\n        this.canReauth = false;\n        log.warn('Could not persist authentication token. Error: ' + err);\n      });\n    }).catch(() => {\n      this._db.put(newObject).then(doc => {\n        this.canReauth = true;\n      }).catch(err => {\n        this.canReauth = false;\n        log.warn('Could not persist authentication token. Error: ' + err);\n      });\n    });\n  }\n\n  _login(endpoint, options, isAdmin, callback = () => {}) {\n    let success = (res) => {\n      let userContainer = {};\n\n      this.isLoggedIn = true;\n\n      for (let k in res.body.content.user) {\n        this.data[k] = res.body.content.user[k];\n        this._customProperties.push(k);\n      }\n      if (isAdmin) {\n        this.isAdmin = true;\n        this._setAdmin(new Admin(this));\n      }\n\n      userContainer[this.data.id] = this.data;\n      this._monitor.add(\n        {channel: {model: (this.isAdmin ? 'admin' : 'user')}},\n        userContainer,\n        null,\n        () => {},\n        () => {},\n        this.update.bind(this)\n      );\n\n      API.authenticationToken = res.body.content.token;\n      this._saveToken(API.authenticationToken);\n      this._event.emit('login');\n      callback(null, this);\n    };\n\n    API.call(endpoint, options, (err, res) => {\n      if (err) {\n        if (err.status === 404 && options.hasOwnProperty('access_token')) {\n          log.info('Got 404 on Facebook login, registering user first');\n          API.call('user/register-facebook', options, (err, res) => {\n            if (err) {\n              log.error('Failed to login with Facebook. Could not register or login user.');\n              this._event.emit('login_error', error('Login failed with error: ' + err));\n            } else {\n              API.call(endpoint, options, function (err, res) {\n                if (err) {\n                  log.error('Failed to login with Facebook. User registration was successful, but login failed.');\n                  this._event.emit('login_error', error('Login failed with error: ' + err));\n                } else {\n                  success(res);\n                }\n              });\n            }\n          });\n        } else {\n          this._event.emit('login_error', error('Login failed with error: ' + err));\n          callback(err, null);\n        }\n      } else {\n        success(res);\n      }\n    });\n  }\n\n  /**\n   * If there is a saved authentication token from previous connections, try to use it to login again.\n   * You can call this method if the {@link #UsercanReauth canReauth} property is true.\n   *\n   * @param  {TelepatCallback} callback Callback invoked after reauth operation is finished\n   */\n  reauth(callback = () => {}) {\n    this._db.get(':userToken').then(doc => {\n      log.info('Retrieved saved authentication token');\n      API.authenticationToken = doc.value.token;\n      API.get((doc.value.admin ? 'admin/me' : 'user/me'), '', function (err, res) {\n        if (err) {\n          API.authenticationToken = null;\n          this._setAdmin(null);\n          this._db.remove(doc._id, doc._rev);\n          this.canReauth = false;\n          callback(error('Saved authentication token expired'), null);\n          this._customProperties = [];\n          this.data = {};\n          this.isLoggedIn = false;\n          this._event.emit('logout');\n        } else {\n          let userContainer = {};\n\n          this.isLoggedIn = true;\n\n          for (let k in res.body.content) {\n            this.data[k] = res.body.content[k];\n            this._customProperties.push(k);\n          }\n          if (res.body.content.type === 'admin') {\n            this.isAdmin = true;\n            this._saveToken(API.authenticationToken);\n            this._setAdmin(new Admin(this));\n          }\n\n          userContainer[this.data.id] = this.data;\n          this._monitor.add(\n            {channel: {model: (this.isAdmin ? 'admin' : 'user')}},\n            userContainer,\n            null,\n            () => {},\n            () => {},\n            this.update.bind(this)\n          );\n          callback(null, res);\n          this._event.emit('login');\n        }\n      }.bind(this));\n    }).catch(function (err) {\n      callback(error('Error retrieving authentication token: ' + err), null);\n    });\n  }\n\n  /**\n   * Call this to update your profile.\n   *\n   * To call this method, you need to create an  array containing 'patch' objects, representing the\n   * modifications that need to be persisted. The structure of a patch object is:\n   *\n   * `{'op': 'replace', 'path': user or admin + '/' + user_id + '/' + property, 'value': modified_value}`\n   *\n   * Instead of using this function, you can also update the user directly from {@link #Userdata User.data}.\n   *\n   * @param {string} id The user id of the updated user profile\n   * @param  {Array<Object>} patches The array of patches representing the modifications that need to be persisted\n   * @param {TelepatCallback} callback Callback invoked after operation is finished\n   */\n  update(id, patches, callback = () => {}) {\n    API.call(this.isAdmin ? 'admin/update' : 'user/update', {patches: patches}, (err, res) => {\n      if (err) {\n        callback(error('Failed updating user: ' + res.body.message));\n      } else {\n        callback();\n      }\n    });\n  }\n\n  /**\n   * Call this to request a password reset for the logged in user.\n   * The process involves a confirmation email, with a link that needs to be clicked on in order to get a unique pass reset token.\n   * You then use that token to call the {@link #User#resetPassword resetPassword} method that finishes the process by setting a new password.\n   *\n   * @param  {string} email The email/username of the user to reset the pass for\n   * @param  {string} callbackURL The URL the user will be pointed to after verifying the request by clicking the link in the sent email\n   * @param  {TelepatCallback} callback Callback invoked after the operation is finished\n   */\n  requestPasswordReset(email, callbackURL, callback = () => {}) {\n    if (!email) {\n      if (this.email) {\n        email = this.email;\n      } else {\n        callback(error('You must provide a valid email address for the account that needs the password reset'), null);\n        return;\n      }\n    }\n\n    API.call('user/request_password_reset',\n      {\n        callbackUrl: callbackURL,\n        username: email\n      },\n    (err, res) => {\n      if (err) {\n        callback(error('Password reset request failed with error: ' + err), null);\n      } else {\n        callback(null, res.body.content);\n      }\n    });\n  };\n\n  /**\n   * @param  {string} userId The id of the user that needs the password reset\n   * @param  {string} token The token obtained from the redirect generated by calling {@link #User#requestPasswordReset requestPasswordReset}.\n   * @param  {string} newPassword The new password\n   * @param  {TelepatCallback} callback Callback invoked after the operation is finished\n   */\n  resetPassword(id, token, newPassword, callback = () => {}) {\n    if (!id || !token || !newPassword) {\n      callback(error('You must provide a valid user-id, pass reset token and new password for the account that needs the password reset'), null);\n      return;\n    }\n\n    API.call('user/password_reset',\n      {\n        'token': token,\n        'user_id': id,\n        'password': newPassword\n      },\n    (err, res) => {\n      if (err) {\n        callback(error('Password reset request failed with error: ' + err), null);\n      } else {\n        callback(null, res.body.content);\n      }\n    });\n  };\n\n  /**\n   * This function creates a new user profile.\n   *\n   * @param {Object} user The object representing the new user profile\n   * @param {TelepatCallback} callback Callback invoked after the operation is finished\n   */\n  register(user, callback = () => {}) {\n    API.call('user/register-username', user, callback);\n  };\n\n  /**\n   * This function creates a new admin profile.\n   *\n   * @param {Object} admin The object representing the new admin profile\n   * @param {TelepatCallback} callback Callback invoked after the operation is finished\n   */\n  registerAdmin(admin, callback = () => {}) {\n    API.call('admin/add', admin, (err, res) => {\n      if (err) {\n        callback(error('Register failed with error: ' + (res.body.message) || ''), null);\n      } else {\n        callback(null, res.body.content);\n      }\n    });\n  };\n\n  /**\n   * This function associates the current anonymous device to a Telepat user profile, using a Facebook\n    account for authentication.\n   *\n   * @param {string} facebookToken The user token obtained from Facebook after login\n   * @param {TelepatCallback} callback Callback invoked after the operation is finished\n   */\n  loginWithFacebook(facebookToken, callback = () => {}) {\n    return this._login('user/login-facebook', { 'access_token': facebookToken }, false, callback);\n  };\n\n  /**\n   * This function associates the current anonymous device to a Telepat user profile, using a password for authentication.\n   *\n   * @param {string} email The user's email address\n   * @param {string} password The user's password\n   * @param {TelepatCallback} callback Callback invoked after the operation is finished\n   * @example\n   * telepat.user.login('email', 'password', (err) => {\n   *  if (err) {\n   *    // Treat login error\n   *  } else {\n   *    // Treat successful login\n   *    console.log(telepat.user.data);\n   *  }\n   * });\n   */\n  login(email, password, callback = () => {}) {\n    return this._login('user/login_password', { username: email, password: password }, false, callback);\n  };\n\n  /**\n   * This function associates the current anonymous device to a Telepat administrator profile, using a password for authentication.\n   *\n   * @param {string} email The admin email address\n   * @param {string} password The admin password\n   * @param {TelepatCallback} callback Callback invoked after the operation is finished\n   * @example\n   * telepat.user.loginAdmin('admin@email.com', 'password', (err) => {\n   *  if (err) {\n   *    // Treat login error\n   *  } else {\n   *    telepat.admin.getAppUsers((err) => {\n   *      if (err) {\n   *        // Treat error\n   *      } else {\n   *        // Treat success\n   *        console.log(telepat.admin.users);\n   *      }\n   *    })\n   *  }\n   * });\n   */\n  loginAdmin(email, password, callback = () => {}) {\n    return this._login('admin/login', { email: email, password: password }, true, callback);\n  };\n\n  /**\n   * Call this to retrieve a specific application user object.\n   * Results will be sent as a callback argument.\n   *\n   * @param {string} userId The id of the requested user\n   * @param {TelepatCallback} callback Callback invoked after operation is finished\n   */\n  get(userId, callback = () => {}) {\n    API.get('user/get', 'user_id=' + encodeURIComponent(userId), (err, res) => {\n      if (err) {\n        callback(error('Retrieving user failed with error: ' + err), null);\n      } else {\n        callback(null, res.body.content);\n      }\n    });\n  };\n\n  /**\n   * This function retrieves the currently logged in user's information.\n   *\n   * @param {TelepatCallback} callback Callback invoked after the operation is finished\n   */\n  me(callback = () => {}) {\n    API.get((this.isAdmin ? 'admin/me' : 'user/me'), '', (err, res) => {\n      if (err) {\n        callback(console.error('Request failed with error: ' + err), null);\n      } else {\n        callback(null, JSON.parse(res.text).content);\n      }\n    });\n  };\n\n  /**\n   * Logs the current user out.\n   *\n   * @param {TelepatCallback} callback Callback invoked after the operation is finished\n   */\n  logout(callback = () => {}) {\n    this._db.get(':userToken').then(doc => {\n      this._db.remove(doc._id, doc._rev);\n    }).catch(function () {\n    });\n    this._setAdmin(null);\n    this.isAdmin = false;\n    this.isLoggedIn = false;\n    this.canReauth = false;\n    this._customProperties = [];\n    this.data = {};\n\n    API.get('user/logout', '', err => {\n      API.authenticationToken = null;\n      if (err) {\n        this._event.emit('logout_error', error('Logout failed with error: ' + err));\n        callback(err);\n      } else {\n        this._event.emit('logout');\n        callback();\n      }\n    });\n  };\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/user.js\n **/","import API from './api';\nimport error from './error';\nimport EventObject from './event';\nimport log from './logger';\n\n/**\n * You can access an instance of this class using the {@link #Telepatadmin admin} property of the Telepat object.\n * This instance becomes available after successfully logging in as an administrator.\n *\n * @class Admin\n *\n * @example\n * telepat.user.loginAdmin('admin@email.com', 'password', (err) => {\n *  if (err) {\n *    // Treat login error\n *  } else {\n *    telepat.admin.getAppUsers((err) => {\n *      if (err) {\n *        // Treat error\n *      } else {\n *        // Treat success\n *        console.log(telepat.admin.users);\n *\n *        // Update users\n *        telepat.admin.users[goodUserId].isAwesome = true;\n *        delete telepat.admin.users[badUserId];\n *\n *        // Update collection metadata\n *        telepat.collections[currentCollectionId].topic = 'Cats';\n *      }\n *    })\n *  }\n * });\n */\nexport default class Admin {\n  constructor(user) {\n    this._user = user;\n    this._monitor = user._monitor;\n    this._event = user._event;\n\n    /**\n     * This {@link Channel} instance allows registering callbacks for 'update' events on user data.\n     * @type {Object}\n     * @memberof Admin\n     * @instance\n     */\n    this.userChannel = null;\n    /**\n     * This object contains data about all of the applications the current administrator can access.\n     * Each app data is stored using a key equal to the application unique identifier.\n     * You can access this after calling {@link #Admin#getApps getApps}.\n     * Modifications to app objects stored within will be automatically synchronized with the Telepat backend.\n     * @type {Object}\n     * @memberof Admin\n     * @instance\n     */\n    this.apps = null;\n    /**\n     * This object contains data about the currently connected app.\n     * You can access this after calling {@link #Admin#getApps getApps}.\n     * Modifications to this object will be automatically synchronized with the Telepat backend.\n     * @type {Object}\n     * @memberof Admin\n     * @instance\n     */\n    this.app = null;\n    /**\n     * This object contains data about all of the users of the current app.\n     * Each user data is stored using a key equal to the user unique identifier.\n     * You can access this after calling {@link #Admin#getAppUsers getAppUsers}.\n     * Modifications to user objects stored within will be automatically synchronized with the Telepat backend.\n     * @type {Object}\n     * @memberof Admin\n     * @instance\n     */\n    this.users = null;\n  }\n\n  /**\n   * Call this to retrieve all the application objects the current administrator can access.\n   * Results will be sent as a callback argument, and persisted on the {@link #Adminapps apps} property.\n   * The object belonging to the currently connected app will also be made available, on the {@link #Adminapp app} property.\n   *\n   * @param {TelepatCallback} callback Callback invoked after operation is finished\n   */\n  getApps(callback = function () {}) {\n    API.call('admin/apps',\n      '',\n      (err, res) => {\n        if (err) {\n          callback(error('Retrieving apps failed with error: ' + err), null);\n        } else {\n          this.apps = {};\n          for (var index in res.body.content) {\n            var app = res.body.content[index];\n\n            this.apps[app.id] = app;\n          }\n          this.app = this.apps[API.appId];\n          this._monitor.add({channel: {model: 'application'}}, this.apps, new EventObject(log), () => {}, ()=>{}, this.updateApp);\n          callback(null, res.body.content);\n        }\n      }, 'get');\n  }\n\n  /**\n   * Call this to create a new application.\n   *\n   * @param {Object} properties Data about the new application. Can hold any key-value data.\n   * Must contain at least a 'keys' key, with an array of string values that will be used as valid API keys for the app.\n   * @param {TelepatCallback} callback Callback invoked after operation is finished\n   */\n  addApp(properties, callback = function () {}) {\n    API.call('admin/app/add',\n      properties,\n      (err, res) => {\n        if (err) {\n          callback(error('Adding application failed with error: ' + err), null);\n        } else {\n          this._monitor.processMessage({\n            'data': {\n              'new': [\n                {\n                  'op': 'create',\n                  'object': res.body.content,\n                  'subscriptions': [\n                    'blg:null:application'\n                  ]\n                }\n              ],\n              'updated': [],\n              'deleted': []\n            }\n          });\n          callback(null, res.body.content);\n        }\n      });\n  }\n\n  /**\n   * Updates key-value data within an application object.\n   *\n   * To call this method, you need to create an  array containing 'patch' objects, representing the\n   * modifications that need to be persisted. The structure of a patch object is:\n   *\n   * `{'op': 'replace', 'path': application + '/' + app_id + '/' + property, 'value': modified_value}`\n   *\n   * Instead of using this function, you can also update the app directly from {@link #Adminapps Admin.apps}.\n   *\n   * @param  {string} id The application id\n   * @param  {Array<Object>} patches The array of patches representing the modifications that need to be persisted\n   * @param  {TelepatCallback} callback Callback invoked after operation is finished\n   */\n  updateApp(id, patches, callback = () => {}) {\n    if (id !== API.appId) {\n      callback(error('Cannot update an app that is not active. Please reconnect to that specific app id to make updates.'));\n    }\n    API.call('admin/app/update',\n      {id: id, patches: patches},\n      (err, res) => {\n        if (err) {\n          callback(error('Updating application failed with error: ' + err));\n        } else {\n          callback();\n        }\n      });\n  }\n\n  /**\n   * Call this to delete an application.\n   * Instead of using this function, you can also delete the app directly from {@link #Adminapps Admin.apps}.\n   *\n   * @param {string} id The application id\n   * @param {TelepatCallback} callback Callback invoked after operation is finished\n   */\n  deleteApp(id, callback = function () {}) {\n    API.del('admin/app/remove',\n      {id: id},\n      (err, res) => {\n        if (err) {\n          callback(error('Removing application failed with error: ' + err), null);\n        } else {\n          this._monitor.processMessage({\n            'data': {\n              'deleted': [\n                {\n                  'op': 'delete',\n                  'object': {\n                    id: id\n                  },\n                  'subscriptions': [\n                    'blg:null:application'\n                  ]\n                }\n              ],\n              'updated': [],\n              'new': []\n            }\n          });\n          callback();\n        }\n      });\n  }\n\n  /**\n   * Call this to create a new collection.\n   *\n   * @param {Object} collection Data about the new application. Can hold any key-value data. May be empty object.\n   * @param {TelepatCallback} callback Callback invoked after operation is finished\n   */\n  addCollection(collection, callback = () => {}) {\n    API.call('admin/context/add',\n      collection,\n      (err, res) => {\n        if (err) {\n          callback(error('Creating collection failed with error: ' + err));\n        } else {\n          callback(null, res);\n        }\n      });\n  }\n\n  /**\n   * Updates key-value data within a collection object.\n   *\n   * To call this method, you need to create an  array containing 'patch' objects, representing the\n   * modifications that need to be persisted. The structure of a patch object is:\n   *\n   * `{'op': 'replace', 'path': context + '/' + collection_id + '/' + property, 'value': modified_value}`\n   *\n   * Instead of using this function, you can also update the collection directly from {@link #Telepatcollections Telepat.collections}.\n   *\n   * @param  {string} id The collection id\n   * @param  {Array<Object>} patches The array of patches representing the modifications that need to be persisted\n   * @param  {TelepatCallback} callback Callback invoked after operation is finished\n   */\n  updateCollection(id, patches, callback = () => {}) {\n    API.call('admin/context/update',\n      {id: id, patches: patches},\n      (err, res) => {\n        if (err) {\n          callback(error('Updating collection failed with error: ' + err));\n        } else {\n          callback();\n        }\n      });\n  }\n\n  /**\n   * Call this to delete a collection.\n   * Instead of using this function, you can also delete the collection directly from {@link #Telepatcollections Telepat.collections}.\n   *\n   * @param {string} id The collection id\n   * @param {TelepatCallback} callback Callback invoked after operation is finished\n   */\n  deleteCollection(id, callback = () => {}) {\n    API.del('admin/context/remove',\n      {id: id},\n      (err, res) => {\n        if (err) {\n          callback(error('Deleting collection failed with error: ' + err));\n        } else {\n          callback();\n        }\n      });\n  }\n\n  /**\n   * Call this to remove a model from the schema, together with all objects of that specific type.\n   *\n   * @param {string} type The model name\n   * @param {TelepatCallback} callback Callback invoked after operation is finished\n   */\n  deleteModel(type, callback) {\n    API.del('admin/schema/remove_model', {\n      'model_name': type\n    }, (err, res) => {\n      if (err) {\n        callback(error('Deleting model failed with error: ' + err));\n      } else {\n        callback();\n      }\n    });\n  }\n\n  /**\n   * Call this to retrieve all the current application user objects.\n   * Results will be sent as a callback argument, and persisted on the {@link #Adminusers users} property.\n   *\n   * @param {TelepatCallback} callback Callback invoked after operation is finished\n   */\n  getAppUsers(callback = function () {}) {\n    API.call('admin/users',\n    {},\n    (err, res) => {\n      if (err) {\n        callback(error('Retrieving users failed with error: ' + err), null);\n      } else {\n        this.users = {};\n        for (let index in res.body.content) {\n          this.users[res.body.content[index].id] = res.body.content[index];\n        }\n        this.userChannel = new EventObject(log);\n        this._monitor.add({channel: {model: 'user'}}, this.users, this.userChannel, this.addUser.bind(this), this.deleteUser, this.updateUser);\n        callback(null, this.users);\n      }\n    });\n  }\n\n  /**\n   * This is an alias for {@link #User#register}.\n   *\n   *  @param {Object} user The object representing the new user profile\n   *  @param {TelepatCallback} callback Callback invoked after operation is finished\n   */\n  addUser(user, callback = function () {}) {\n    this._user.register(user, callback);\n  };\n\n  /**\n   * Call this to delete a user profile.\n   * Instead of using this function, you can also delete the user directly from {@link #Adminusers Admin.users}.\n   *\n   *  @param {string} username The email address of the user profile to delete\n   *  @param {TelepatCallback} callback Callback invoked after operation is finished\n   */\n  deleteUser(id, callback = function () {}) {\n    API.del('admin/user/delete',\n    { id: id },\n    (err, res) => {\n      if (err) {\n        callback(error('Removing user failed with error: ' + err), null);\n      } else {\n        callback();\n      }\n    });\n  };\n\n  /**\n   * Call this to update a user profile.\n   *\n   * To call this method, you need to create an  array containing 'patch' objects, representing the\n   * modifications that need to be persisted. The structure of a patch object is:\n   *\n   * `{'op': 'replace', 'path': user + '/' + user_id + '/' + property, 'value': modified_value}`\n   *\n   * Instead of using this function, you can also update the user directly from {@link #Adminusers Admin.users}.\n   *\n   * @param {string} id The id of the user to be updated\n   * @param  {Array<Object>} patches The array of patches representing the modifications that need to be persisted\n   * @param {TelepatCallback} callback Callback invoked after operation is finished\n   */\n  updateUser(id, patches, callback = function () {}) {\n    API.call('admin/user/update', {\n      patches: patches\n    },\n    (err, res) => {\n      if (err) {\n        callback(error('Updating user failed with error: ' + err), null);\n      } else {\n        callback();\n      }\n    });\n  };\n\n  /**\n   * Call this to authorize access to the current app for another administrator account\n   * within the same Telepat instance.\n   *\n   * @param {string} user The email associated with the account of the new administrator\n   * @param {TelepatCallback} callback Callback invoked after operation is finished\n   */\n  authorize(user, callback) {\n    API.call('/admin/app/authorize', {\n      email: user\n    }, (err, res) => {\n      if (err) {\n        callback(error('Authorizing admin failed with error: ' + err), null);\n      } else {\n        callback();\n      }\n    });\n  };\n\n  /**\n   * Call this to deauthorize access to the current app for another administrator account\n   * within the same Telepat instance.\n   *\n   * @param {string} user The email associated with the account of the administrator to be removed\n   * @param {TelepatCallback} callback Callback invoked after operation is finished\n   */\n  deauthorize(user, callback) {\n    API.call('/admin/app/deauthorize', {\n      email: user\n    }, (err, res) => {\n      if (err) {\n        callback(error('Deauthorizing admin failed with error: ' + err), null);\n      } else {\n        callback();\n      }\n    });\n  };\n\n  unhook() {\n    this._monitor.remove({channel: {model: 'application'}});\n    this._monitor.remove({channel: {model: 'user'}});\n  };\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/admin.js\n **/","\n/**\n * Module dependencies.\n */\n\nvar url = require('./url');\nvar parser = require('socket.io-parser');\nvar Manager = require('./manager');\nvar debug = require('debug')('socket.io-client');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = lookup;\n\n/**\n * Managers cache.\n */\n\nvar cache = exports.managers = {};\n\n/**\n * Looks up an existing `Manager` for multiplexing.\n * If the user summons:\n *\n *   `io('http://localhost/a');`\n *   `io('http://localhost/b');`\n *\n * We reuse the existing instance based on same scheme/port/host,\n * and we initialize sockets for each namespace.\n *\n * @api public\n */\n\nfunction lookup (uri, opts) {\n  if (typeof uri === 'object') {\n    opts = uri;\n    uri = undefined;\n  }\n\n  opts = opts || {};\n\n  var parsed = url(uri);\n  var source = parsed.source;\n  var id = parsed.id;\n  var path = parsed.path;\n  var sameNamespace = cache[id] && path in cache[id].nsps;\n  var newConnection = opts.forceNew || opts['force new connection'] ||\n                      false === opts.multiplex || sameNamespace;\n\n  var io;\n\n  if (newConnection) {\n    debug('ignoring socket cache for %s', source);\n    io = Manager(source, opts);\n  } else {\n    if (!cache[id]) {\n      debug('new io instance for %s', source);\n      cache[id] = Manager(source, opts);\n    }\n    io = cache[id];\n  }\n  if (parsed.query && !opts.query) {\n    opts.query = parsed.query;\n  } else if (opts && 'object' === typeof opts.query) {\n    opts.query = encodeQueryString(opts.query);\n  }\n  return io.socket(parsed.path, opts);\n}\n/**\n *  Helper method to parse query objects to string.\n * @param {object} query\n * @returns {string}\n */\nfunction encodeQueryString (obj) {\n  var str = [];\n  for (var p in obj) {\n    if (obj.hasOwnProperty(p)) {\n      str.push(encodeURIComponent(p) + '=' + encodeURIComponent(obj[p]));\n    }\n  }\n  return str.join('&');\n}\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = parser.protocol;\n\n/**\n * `connect`.\n *\n * @param {String} uri\n * @api public\n */\n\nexports.connect = lookup;\n\n/**\n * Expose constructors for standalone build.\n *\n * @api public\n */\n\nexports.Manager = require('./manager');\nexports.Socket = require('./socket');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/socket.io-client/lib/index.js\n ** module id = 71\n ** module chunks = 0\n **/","\n/**\n * Module dependencies.\n */\n\nvar parseuri = require('parseuri');\nvar debug = require('debug')('socket.io-client:url');\n\n/**\n * Module exports.\n */\n\nmodule.exports = url;\n\n/**\n * URL parser.\n *\n * @param {String} url\n * @param {Object} An object meant to mimic window.location.\n *                 Defaults to window.location.\n * @api public\n */\n\nfunction url (uri, loc) {\n  var obj = uri;\n\n  // default to window.location\n  loc = loc || global.location;\n  if (null == uri) uri = loc.protocol + '//' + loc.host;\n\n  // relative path support\n  if ('string' === typeof uri) {\n    if ('/' === uri.charAt(0)) {\n      if ('/' === uri.charAt(1)) {\n        uri = loc.protocol + uri;\n      } else {\n        uri = loc.host + uri;\n      }\n    }\n\n    if (!/^(https?|wss?):\\/\\//.test(uri)) {\n      debug('protocol-less url %s', uri);\n      if ('undefined' !== typeof loc) {\n        uri = loc.protocol + '//' + uri;\n      } else {\n        uri = 'https://' + uri;\n      }\n    }\n\n    // parse\n    debug('parse %s', uri);\n    obj = parseuri(uri);\n  }\n\n  // make sure we treat `localhost:80` and `localhost` equally\n  if (!obj.port) {\n    if (/^(http|ws)$/.test(obj.protocol)) {\n      obj.port = '80';\n    } else if (/^(http|ws)s$/.test(obj.protocol)) {\n      obj.port = '443';\n    }\n  }\n\n  obj.path = obj.path || '/';\n\n  var ipv6 = obj.host.indexOf(':') !== -1;\n  var host = ipv6 ? '[' + obj.host + ']' : obj.host;\n\n  // define unique id\n  obj.id = obj.protocol + '://' + host + ':' + obj.port;\n  // define href\n  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));\n\n  return obj;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/socket.io-client/lib/url.js\n ** module id = 72\n ** module chunks = 0\n **/","/**\r\n * Parses an URI\r\n *\r\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\r\n * @api private\r\n */\r\n\r\nvar re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\r\n\r\nvar parts = [\r\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\r\n];\r\n\r\nmodule.exports = function parseuri(str) {\r\n    var src = str,\r\n        b = str.indexOf('['),\r\n        e = str.indexOf(']');\r\n\r\n    if (b != -1 && e != -1) {\r\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\r\n    }\r\n\r\n    var m = re.exec(str || ''),\r\n        uri = {},\r\n        i = 14;\r\n\r\n    while (i--) {\r\n        uri[parts[i]] = m[i] || '';\r\n    }\r\n\r\n    if (b != -1 && e != -1) {\r\n        uri.source = src;\r\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\r\n        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\r\n        uri.ipv6uri = true;\r\n    }\r\n\r\n    return uri;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/parseuri/index.js\n ** module id = 73\n ** module chunks = 0\n **/","\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && 'WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    return exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (typeof process !== 'undefined' && 'env' in process) {\n    return process.env.DEBUG;\n  }\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage(){\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/socket.io-client/~/debug/browser.js\n ** module id = 74\n ** module chunks = 0\n **/","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug.debug = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting\n    args = exports.formatArgs.apply(self, args);\n\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/[\\\\^$+?.()|[\\]{}]/g, '\\\\$&').replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/socket.io-client/~/debug/debug.js\n ** module id = 75\n ** module chunks = 0\n **/","/**\n * Helpers.\n */\n\nvar s = 1000\nvar m = s * 60\nvar h = m * 60\nvar d = h * 24\nvar y = d * 365.25\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {}\n  var type = typeof val\n  if (type === 'string' && val.length > 0) {\n    return parse(val)\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ?\n\t\t\tfmtLong(val) :\n\t\t\tfmtShort(val)\n  }\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))\n}\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str)\n  if (str.length > 10000) {\n    return\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)\n  if (!match) {\n    return\n  }\n  var n = parseFloat(match[1])\n  var type = (match[2] || 'ms').toLowerCase()\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n\n    default:\n      return undefined\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd'\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h'\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm'\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's'\n  }\n  return ms + 'ms'\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms'\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's'\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/socket.io-client/~/ms/index.js\n ** module id = 76\n ** module chunks = 0\n **/","\n/**\n * Module dependencies.\n */\n\nvar debug = require('debug')('socket.io-parser');\nvar json = require('json3');\nvar Emitter = require('component-emitter');\nvar binary = require('./binary');\nvar isBuf = require('./is-buffer');\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = 4;\n\n/**\n * Packet types.\n *\n * @api public\n */\n\nexports.types = [\n  'CONNECT',\n  'DISCONNECT',\n  'EVENT',\n  'ACK',\n  'ERROR',\n  'BINARY_EVENT',\n  'BINARY_ACK'\n];\n\n/**\n * Packet type `connect`.\n *\n * @api public\n */\n\nexports.CONNECT = 0;\n\n/**\n * Packet type `disconnect`.\n *\n * @api public\n */\n\nexports.DISCONNECT = 1;\n\n/**\n * Packet type `event`.\n *\n * @api public\n */\n\nexports.EVENT = 2;\n\n/**\n * Packet type `ack`.\n *\n * @api public\n */\n\nexports.ACK = 3;\n\n/**\n * Packet type `error`.\n *\n * @api public\n */\n\nexports.ERROR = 4;\n\n/**\n * Packet type 'binary event'\n *\n * @api public\n */\n\nexports.BINARY_EVENT = 5;\n\n/**\n * Packet type `binary ack`. For acks with binary arguments.\n *\n * @api public\n */\n\nexports.BINARY_ACK = 6;\n\n/**\n * Encoder constructor.\n *\n * @api public\n */\n\nexports.Encoder = Encoder;\n\n/**\n * Decoder constructor.\n *\n * @api public\n */\n\nexports.Decoder = Decoder;\n\n/**\n * A socket.io Encoder instance\n *\n * @api public\n */\n\nfunction Encoder() {}\n\n/**\n * Encode a packet as a single string if non-binary, or as a\n * buffer sequence, depending on packet type.\n *\n * @param {Object} obj - packet object\n * @param {Function} callback - function to handle encodings (likely engine.write)\n * @return Calls callback with Array of encodings\n * @api public\n */\n\nEncoder.prototype.encode = function(obj, callback){\n  debug('encoding packet %j', obj);\n\n  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {\n    encodeAsBinary(obj, callback);\n  }\n  else {\n    var encoding = encodeAsString(obj);\n    callback([encoding]);\n  }\n};\n\n/**\n * Encode packet as string.\n *\n * @param {Object} packet\n * @return {String} encoded\n * @api private\n */\n\nfunction encodeAsString(obj) {\n  var str = '';\n  var nsp = false;\n\n  // first is type\n  str += obj.type;\n\n  // attachments if we have them\n  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {\n    str += obj.attachments;\n    str += '-';\n  }\n\n  // if we have a namespace other than `/`\n  // we append it followed by a comma `,`\n  if (obj.nsp && '/' != obj.nsp) {\n    nsp = true;\n    str += obj.nsp;\n  }\n\n  // immediately followed by the id\n  if (null != obj.id) {\n    if (nsp) {\n      str += ',';\n      nsp = false;\n    }\n    str += obj.id;\n  }\n\n  // json data\n  if (null != obj.data) {\n    if (nsp) str += ',';\n    str += json.stringify(obj.data);\n  }\n\n  debug('encoded %j as %s', obj, str);\n  return str;\n}\n\n/**\n * Encode packet as 'buffer sequence' by removing blobs, and\n * deconstructing packet into object with placeholders and\n * a list of buffers.\n *\n * @param {Object} packet\n * @return {Buffer} encoded\n * @api private\n */\n\nfunction encodeAsBinary(obj, callback) {\n\n  function writeEncoding(bloblessData) {\n    var deconstruction = binary.deconstructPacket(bloblessData);\n    var pack = encodeAsString(deconstruction.packet);\n    var buffers = deconstruction.buffers;\n\n    buffers.unshift(pack); // add packet info to beginning of data list\n    callback(buffers); // write all the buffers\n  }\n\n  binary.removeBlobs(obj, writeEncoding);\n}\n\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n * @api public\n */\n\nfunction Decoder() {\n  this.reconstructor = null;\n}\n\n/**\n * Mix in `Emitter` with Decoder.\n */\n\nEmitter(Decoder.prototype);\n\n/**\n * Decodes an ecoded packet string into packet JSON.\n *\n * @param {String} obj - encoded packet\n * @return {Object} packet\n * @api public\n */\n\nDecoder.prototype.add = function(obj) {\n  var packet;\n  if ('string' == typeof obj) {\n    packet = decodeString(obj);\n    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json\n      this.reconstructor = new BinaryReconstructor(packet);\n\n      // no attachments, labeled binary but no binary data to follow\n      if (this.reconstructor.reconPack.attachments === 0) {\n        this.emit('decoded', packet);\n      }\n    } else { // non-binary full packet\n      this.emit('decoded', packet);\n    }\n  }\n  else if (isBuf(obj) || obj.base64) { // raw binary data\n    if (!this.reconstructor) {\n      throw new Error('got binary data when not reconstructing a packet');\n    } else {\n      packet = this.reconstructor.takeBinaryData(obj);\n      if (packet) { // received final buffer\n        this.reconstructor = null;\n        this.emit('decoded', packet);\n      }\n    }\n  }\n  else {\n    throw new Error('Unknown type: ' + obj);\n  }\n};\n\n/**\n * Decode a packet String (JSON data)\n *\n * @param {String} str\n * @return {Object} packet\n * @api private\n */\n\nfunction decodeString(str) {\n  var p = {};\n  var i = 0;\n\n  // look up type\n  p.type = Number(str.charAt(0));\n  if (null == exports.types[p.type]) return error();\n\n  // look up attachments if type binary\n  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {\n    var buf = '';\n    while (str.charAt(++i) != '-') {\n      buf += str.charAt(i);\n      if (i == str.length) break;\n    }\n    if (buf != Number(buf) || str.charAt(i) != '-') {\n      throw new Error('Illegal attachments');\n    }\n    p.attachments = Number(buf);\n  }\n\n  // look up namespace (if any)\n  if ('/' == str.charAt(i + 1)) {\n    p.nsp = '';\n    while (++i) {\n      var c = str.charAt(i);\n      if (',' == c) break;\n      p.nsp += c;\n      if (i == str.length) break;\n    }\n  } else {\n    p.nsp = '/';\n  }\n\n  // look up id\n  var next = str.charAt(i + 1);\n  if ('' !== next && Number(next) == next) {\n    p.id = '';\n    while (++i) {\n      var c = str.charAt(i);\n      if (null == c || Number(c) != c) {\n        --i;\n        break;\n      }\n      p.id += str.charAt(i);\n      if (i == str.length) break;\n    }\n    p.id = Number(p.id);\n  }\n\n  // look up json data\n  if (str.charAt(++i)) {\n    p = tryParse(p, str.substr(i));\n  }\n\n  debug('decoded %s as %j', str, p);\n  return p;\n}\n\nfunction tryParse(p, str) {\n  try {\n    p.data = json.parse(str);\n  } catch(e){\n    return error();\n  }\n  return p; \n};\n\n/**\n * Deallocates a parser's resources\n *\n * @api public\n */\n\nDecoder.prototype.destroy = function() {\n  if (this.reconstructor) {\n    this.reconstructor.finishedReconstruction();\n  }\n};\n\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n * @api private\n */\n\nfunction BinaryReconstructor(packet) {\n  this.reconPack = packet;\n  this.buffers = [];\n}\n\n/**\n * Method to be called when binary data received from connection\n * after a BINARY_EVENT packet.\n *\n * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n * @return {null | Object} returns null if more binary data is expected or\n *   a reconstructed packet object if all buffers have been received.\n * @api private\n */\n\nBinaryReconstructor.prototype.takeBinaryData = function(binData) {\n  this.buffers.push(binData);\n  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list\n    var packet = binary.reconstructPacket(this.reconPack, this.buffers);\n    this.finishedReconstruction();\n    return packet;\n  }\n  return null;\n};\n\n/**\n * Cleans up binary packet reconstruction variables.\n *\n * @api private\n */\n\nBinaryReconstructor.prototype.finishedReconstruction = function() {\n  this.reconPack = null;\n  this.buffers = [];\n};\n\nfunction error(data){\n  return {\n    type: exports.ERROR,\n    data: 'parser error'\n  };\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/socket.io-parser/index.js\n ** module id = 77\n ** module chunks = 0\n **/","\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  return ('WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  return JSON.stringify(v);\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage(){\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/socket.io-parser/~/debug/browser.js\n ** module id = 78\n ** module chunks = 0\n **/","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = Array.prototype.slice.call(arguments);\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    if ('function' === typeof exports.formatArgs) {\n      args = exports.formatArgs.apply(self, args);\n    }\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/socket.io-parser/~/debug/debug.js\n ** module id = 79\n ** module chunks = 0\n **/","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = '' + str;\n  if (str.length > 10000) return;\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/socket.io-parser/~/ms/index.js\n ** module id = 80\n ** module chunks = 0\n **/","/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */\n;(function () {\n  // Detect the `define` function exposed by asynchronous module loaders. The\n  // strict `define` check is necessary for compatibility with `r.js`.\n  var isLoader = typeof define === \"function\" && define.amd;\n\n  // A set of types used to distinguish objects from primitives.\n  var objectTypes = {\n    \"function\": true,\n    \"object\": true\n  };\n\n  // Detect the `exports` object exposed by CommonJS implementations.\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\n  // Use the `global` object exposed by Node (including Browserify via\n  // `insert-module-globals`), Narwhal, and Ringo as the default context,\n  // and the `window` object in browsers. Rhino exports a `global` function\n  // instead.\n  var root = objectTypes[typeof window] && window || this,\n      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == \"object\" && global;\n\n  if (freeGlobal && (freeGlobal[\"global\"] === freeGlobal || freeGlobal[\"window\"] === freeGlobal || freeGlobal[\"self\"] === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  // Public: Initializes JSON 3 using the given `context` object, attaching the\n  // `stringify` and `parse` functions to the specified `exports` object.\n  function runInContext(context, exports) {\n    context || (context = root[\"Object\"]());\n    exports || (exports = root[\"Object\"]());\n\n    // Native constructor aliases.\n    var Number = context[\"Number\"] || root[\"Number\"],\n        String = context[\"String\"] || root[\"String\"],\n        Object = context[\"Object\"] || root[\"Object\"],\n        Date = context[\"Date\"] || root[\"Date\"],\n        SyntaxError = context[\"SyntaxError\"] || root[\"SyntaxError\"],\n        TypeError = context[\"TypeError\"] || root[\"TypeError\"],\n        Math = context[\"Math\"] || root[\"Math\"],\n        nativeJSON = context[\"JSON\"] || root[\"JSON\"];\n\n    // Delegate to the native `stringify` and `parse` implementations.\n    if (typeof nativeJSON == \"object\" && nativeJSON) {\n      exports.stringify = nativeJSON.stringify;\n      exports.parse = nativeJSON.parse;\n    }\n\n    // Convenience aliases.\n    var objectProto = Object.prototype,\n        getClass = objectProto.toString,\n        isProperty, forEach, undef;\n\n    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\n    var isExtended = new Date(-3509827334573292);\n    try {\n      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\n      // results for certain dates in Opera >= 10.53.\n      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&\n        // Safari < 2.0.2 stores the internal millisecond time value correctly,\n        // but clips the values returned by the date methods to the range of\n        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\n        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\n    } catch (exception) {}\n\n    // Internal: Determines whether the native `JSON.stringify` and `parse`\n    // implementations are spec-compliant. Based on work by Ken Snyder.\n    function has(name) {\n      if (has[name] !== undef) {\n        // Return cached feature test result.\n        return has[name];\n      }\n      var isSupported;\n      if (name == \"bug-string-char-index\") {\n        // IE <= 7 doesn't support accessing string characters using square\n        // bracket notation. IE 8 only supports this for primitives.\n        isSupported = \"a\"[0] != \"a\";\n      } else if (name == \"json\") {\n        // Indicates whether both `JSON.stringify` and `JSON.parse` are\n        // supported.\n        isSupported = has(\"json-stringify\") && has(\"json-parse\");\n      } else {\n        var value, serialized = '{\"a\":[1,true,false,null,\"\\\\u0000\\\\b\\\\n\\\\f\\\\r\\\\t\"]}';\n        // Test `JSON.stringify`.\n        if (name == \"json-stringify\") {\n          var stringify = exports.stringify, stringifySupported = typeof stringify == \"function\" && isExtended;\n          if (stringifySupported) {\n            // A test function object with a custom `toJSON` method.\n            (value = function () {\n              return 1;\n            }).toJSON = value;\n            try {\n              stringifySupported =\n                // Firefox 3.1b1 and b2 serialize string, number, and boolean\n                // primitives as object literals.\n                stringify(0) === \"0\" &&\n                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\n                // literals.\n                stringify(new Number()) === \"0\" &&\n                stringify(new String()) == '\"\"' &&\n                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\n                // does not define a canonical JSON representation (this applies to\n                // objects with `toJSON` properties as well, *unless* they are nested\n                // within an object or array).\n                stringify(getClass) === undef &&\n                // IE 8 serializes `undefined` as `\"undefined\"`. Safari <= 5.1.7 and\n                // FF 3.1b3 pass this test.\n                stringify(undef) === undef &&\n                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\n                // respectively, if the value is omitted entirely.\n                stringify() === undef &&\n                // FF 3.1b1, 2 throw an error if the given value is not a number,\n                // string, array, object, Boolean, or `null` literal. This applies to\n                // objects with custom `toJSON` methods as well, unless they are nested\n                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\n                // methods entirely.\n                stringify(value) === \"1\" &&\n                stringify([value]) == \"[1]\" &&\n                // Prototype <= 1.6.1 serializes `[undefined]` as `\"[]\"` instead of\n                // `\"[null]\"`.\n                stringify([undef]) == \"[null]\" &&\n                // YUI 3.0.0b1 fails to serialize `null` literals.\n                stringify(null) == \"null\" &&\n                // FF 3.1b1, 2 halts serialization if an array contains a function:\n                // `[1, true, getClass, 1]` serializes as \"[1,true,],\". FF 3.1b3\n                // elides non-JSON values from objects and arrays, unless they\n                // define custom `toJSON` methods.\n                stringify([undef, getClass, null]) == \"[null,null,null]\" &&\n                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\n                // where character escape codes are expected (e.g., `\\b` => `\\u0008`).\n                stringify({ \"a\": [value, true, false, null, \"\\x00\\b\\n\\f\\r\\t\"] }) == serialized &&\n                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\n                stringify(null, value) === \"1\" &&\n                stringify([1, 2], null, 1) == \"[\\n 1,\\n 2\\n]\" &&\n                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\n                // serialize extended years.\n                stringify(new Date(-8.64e15)) == '\"-271821-04-20T00:00:00.000Z\"' &&\n                // The milliseconds are optional in ES 5, but required in 5.1.\n                stringify(new Date(8.64e15)) == '\"+275760-09-13T00:00:00.000Z\"' &&\n                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\n                // four-digit years instead of six-digit years. Credits: @Yaffle.\n                stringify(new Date(-621987552e5)) == '\"-000001-01-01T00:00:00.000Z\"' &&\n                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\n                // values less than 1000. Credits: @Yaffle.\n                stringify(new Date(-1)) == '\"1969-12-31T23:59:59.999Z\"';\n            } catch (exception) {\n              stringifySupported = false;\n            }\n          }\n          isSupported = stringifySupported;\n        }\n        // Test `JSON.parse`.\n        if (name == \"json-parse\") {\n          var parse = exports.parse;\n          if (typeof parse == \"function\") {\n            try {\n              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\n              // Conforming implementations should also coerce the initial argument to\n              // a string prior to parsing.\n              if (parse(\"0\") === 0 && !parse(false)) {\n                // Simple parsing test.\n                value = parse(serialized);\n                var parseSupported = value[\"a\"].length == 5 && value[\"a\"][0] === 1;\n                if (parseSupported) {\n                  try {\n                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\n                    parseSupported = !parse('\"\\t\"');\n                  } catch (exception) {}\n                  if (parseSupported) {\n                    try {\n                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading\n                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow\n                      // certain octal literals.\n                      parseSupported = parse(\"01\") !== 1;\n                    } catch (exception) {}\n                  }\n                  if (parseSupported) {\n                    try {\n                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal\n                      // points. These environments, along with FF 3.1b1 and 2,\n                      // also allow trailing commas in JSON objects and arrays.\n                      parseSupported = parse(\"1.\") !== 1;\n                    } catch (exception) {}\n                  }\n                }\n              }\n            } catch (exception) {\n              parseSupported = false;\n            }\n          }\n          isSupported = parseSupported;\n        }\n      }\n      return has[name] = !!isSupported;\n    }\n\n    if (!has(\"json\")) {\n      // Common `[[Class]]` name aliases.\n      var functionClass = \"[object Function]\",\n          dateClass = \"[object Date]\",\n          numberClass = \"[object Number]\",\n          stringClass = \"[object String]\",\n          arrayClass = \"[object Array]\",\n          booleanClass = \"[object Boolean]\";\n\n      // Detect incomplete support for accessing string characters by index.\n      var charIndexBuggy = has(\"bug-string-char-index\");\n\n      // Define additional utility methods if the `Date` methods are buggy.\n      if (!isExtended) {\n        var floor = Math.floor;\n        // A mapping between the months of the year and the number of days between\n        // January 1st and the first of the respective month.\n        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n        // Internal: Calculates the number of days between the Unix epoch and the\n        // first day of the given month.\n        var getDay = function (year, month) {\n          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\n        };\n      }\n\n      // Internal: Determines if a property is a direct property of the given\n      // object. Delegates to the native `Object#hasOwnProperty` method.\n      if (!(isProperty = objectProto.hasOwnProperty)) {\n        isProperty = function (property) {\n          var members = {}, constructor;\n          if ((members.__proto__ = null, members.__proto__ = {\n            // The *proto* property cannot be set multiple times in recent\n            // versions of Firefox and SeaMonkey.\n            \"toString\": 1\n          }, members).toString != getClass) {\n            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but\n            // supports the mutable *proto* property.\n            isProperty = function (property) {\n              // Capture and break the object's prototype chain (see section 8.6.2\n              // of the ES 5.1 spec). The parenthesized expression prevents an\n              // unsafe transformation by the Closure Compiler.\n              var original = this.__proto__, result = property in (this.__proto__ = null, this);\n              // Restore the original prototype chain.\n              this.__proto__ = original;\n              return result;\n            };\n          } else {\n            // Capture a reference to the top-level `Object` constructor.\n            constructor = members.constructor;\n            // Use the `constructor` property to simulate `Object#hasOwnProperty` in\n            // other environments.\n            isProperty = function (property) {\n              var parent = (this.constructor || constructor).prototype;\n              return property in this && !(property in parent && this[property] === parent[property]);\n            };\n          }\n          members = null;\n          return isProperty.call(this, property);\n        };\n      }\n\n      // Internal: Normalizes the `for...in` iteration algorithm across\n      // environments. Each enumerated key is yielded to a `callback` function.\n      forEach = function (object, callback) {\n        var size = 0, Properties, members, property;\n\n        // Tests for bugs in the current environment's `for...in` algorithm. The\n        // `valueOf` property inherits the non-enumerable flag from\n        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\n        (Properties = function () {\n          this.valueOf = 0;\n        }).prototype.valueOf = 0;\n\n        // Iterate over a new instance of the `Properties` class.\n        members = new Properties();\n        for (property in members) {\n          // Ignore all properties inherited from `Object.prototype`.\n          if (isProperty.call(members, property)) {\n            size++;\n          }\n        }\n        Properties = members = null;\n\n        // Normalize the iteration algorithm.\n        if (!size) {\n          // A list of non-enumerable properties inherited from `Object.prototype`.\n          members = [\"valueOf\", \"toString\", \"toLocaleString\", \"propertyIsEnumerable\", \"isPrototypeOf\", \"hasOwnProperty\", \"constructor\"];\n          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\n          // properties.\n          forEach = function (object, callback) {\n            var isFunction = getClass.call(object) == functionClass, property, length;\n            var hasProperty = !isFunction && typeof object.constructor != \"function\" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;\n            for (property in object) {\n              // Gecko <= 1.0 enumerates the `prototype` property of functions under\n              // certain conditions; IE does not.\n              if (!(isFunction && property == \"prototype\") && hasProperty.call(object, property)) {\n                callback(property);\n              }\n            }\n            // Manually invoke the callback for each non-enumerable property.\n            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));\n          };\n        } else if (size == 2) {\n          // Safari <= 2.0.4 enumerates shadowed properties twice.\n          forEach = function (object, callback) {\n            // Create a set of iterated properties.\n            var members = {}, isFunction = getClass.call(object) == functionClass, property;\n            for (property in object) {\n              // Store each property name to prevent double enumeration. The\n              // `prototype` property of functions is not enumerated due to cross-\n              // environment inconsistencies.\n              if (!(isFunction && property == \"prototype\") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {\n                callback(property);\n              }\n            }\n          };\n        } else {\n          // No bugs detected; use the standard `for...in` algorithm.\n          forEach = function (object, callback) {\n            var isFunction = getClass.call(object) == functionClass, property, isConstructor;\n            for (property in object) {\n              if (!(isFunction && property == \"prototype\") && isProperty.call(object, property) && !(isConstructor = property === \"constructor\")) {\n                callback(property);\n              }\n            }\n            // Manually invoke the callback for the `constructor` property due to\n            // cross-environment inconsistencies.\n            if (isConstructor || isProperty.call(object, (property = \"constructor\"))) {\n              callback(property);\n            }\n          };\n        }\n        return forEach(object, callback);\n      };\n\n      // Public: Serializes a JavaScript `value` as a JSON string. The optional\n      // `filter` argument may specify either a function that alters how object and\n      // array members are serialized, or an array of strings and numbers that\n      // indicates which properties should be serialized. The optional `width`\n      // argument may be either a string or number that specifies the indentation\n      // level of the output.\n      if (!has(\"json-stringify\")) {\n        // Internal: A map of control characters and their escaped equivalents.\n        var Escapes = {\n          92: \"\\\\\\\\\",\n          34: '\\\\\"',\n          8: \"\\\\b\",\n          12: \"\\\\f\",\n          10: \"\\\\n\",\n          13: \"\\\\r\",\n          9: \"\\\\t\"\n        };\n\n        // Internal: Converts `value` into a zero-padded string such that its\n        // length is at least equal to `width`. The `width` must be <= 6.\n        var leadingZeroes = \"000000\";\n        var toPaddedString = function (width, value) {\n          // The `|| 0` expression is necessary to work around a bug in\n          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== \"0\"`.\n          return (leadingZeroes + (value || 0)).slice(-width);\n        };\n\n        // Internal: Double-quotes a string `value`, replacing all ASCII control\n        // characters (characters with code unit values between 0 and 31) with\n        // their escaped equivalents. This is an implementation of the\n        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\n        var unicodePrefix = \"\\\\u00\";\n        var quote = function (value) {\n          var result = '\"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;\n          var symbols = useCharIndex && (charIndexBuggy ? value.split(\"\") : value);\n          for (; index < length; index++) {\n            var charCode = value.charCodeAt(index);\n            // If the character is a control character, append its Unicode or\n            // shorthand escape sequence; otherwise, append the character as-is.\n            switch (charCode) {\n              case 8: case 9: case 10: case 12: case 13: case 34: case 92:\n                result += Escapes[charCode];\n                break;\n              default:\n                if (charCode < 32) {\n                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));\n                  break;\n                }\n                result += useCharIndex ? symbols[index] : value.charAt(index);\n            }\n          }\n          return result + '\"';\n        };\n\n        // Internal: Recursively serializes an object. Implements the\n        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\n        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {\n          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\n          try {\n            // Necessary for host object support.\n            value = object[property];\n          } catch (exception) {}\n          if (typeof value == \"object\" && value) {\n            className = getClass.call(value);\n            if (className == dateClass && !isProperty.call(value, \"toJSON\")) {\n              if (value > -1 / 0 && value < 1 / 0) {\n                // Dates are serialized according to the `Date#toJSON` method\n                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\n                // for the ISO 8601 date time string format.\n                if (getDay) {\n                  // Manually compute the year, month, date, hours, minutes,\n                  // seconds, and milliseconds if the `getUTC*` methods are\n                  // buggy. Adapted from @Yaffle's `date-shim` project.\n                  date = floor(value / 864e5);\n                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);\n                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);\n                  date = 1 + date - getDay(year, month);\n                  // The `time` value specifies the time within the day (see ES\n                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\n                  // to compute `A modulo B`, as the `%` operator does not\n                  // correspond to the `modulo` operation for negative numbers.\n                  time = (value % 864e5 + 864e5) % 864e5;\n                  // The hours, minutes, seconds, and milliseconds are obtained by\n                  // decomposing the time within the day. See section 15.9.1.10.\n                  hours = floor(time / 36e5) % 24;\n                  minutes = floor(time / 6e4) % 60;\n                  seconds = floor(time / 1e3) % 60;\n                  milliseconds = time % 1e3;\n                } else {\n                  year = value.getUTCFullYear();\n                  month = value.getUTCMonth();\n                  date = value.getUTCDate();\n                  hours = value.getUTCHours();\n                  minutes = value.getUTCMinutes();\n                  seconds = value.getUTCSeconds();\n                  milliseconds = value.getUTCMilliseconds();\n                }\n                // Serialize extended years correctly.\n                value = (year <= 0 || year >= 1e4 ? (year < 0 ? \"-\" : \"+\") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +\n                  \"-\" + toPaddedString(2, month + 1) + \"-\" + toPaddedString(2, date) +\n                  // Months, dates, hours, minutes, and seconds should have two\n                  // digits; milliseconds should have three.\n                  \"T\" + toPaddedString(2, hours) + \":\" + toPaddedString(2, minutes) + \":\" + toPaddedString(2, seconds) +\n                  // Milliseconds are optional in ES 5.0, but required in 5.1.\n                  \".\" + toPaddedString(3, milliseconds) + \"Z\";\n              } else {\n                value = null;\n              }\n            } else if (typeof value.toJSON == \"function\" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, \"toJSON\"))) {\n              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\n              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\n              // ignores all `toJSON` methods on these objects unless they are\n              // defined directly on an instance.\n              value = value.toJSON(property);\n            }\n          }\n          if (callback) {\n            // If a replacement function was provided, call it to obtain the value\n            // for serialization.\n            value = callback.call(object, property, value);\n          }\n          if (value === null) {\n            return \"null\";\n          }\n          className = getClass.call(value);\n          if (className == booleanClass) {\n            // Booleans are represented literally.\n            return \"\" + value;\n          } else if (className == numberClass) {\n            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\n            // `\"null\"`.\n            return value > -1 / 0 && value < 1 / 0 ? \"\" + value : \"null\";\n          } else if (className == stringClass) {\n            // Strings are double-quoted and escaped.\n            return quote(\"\" + value);\n          }\n          // Recursively serialize objects and arrays.\n          if (typeof value == \"object\") {\n            // Check for cyclic structures. This is a linear search; performance\n            // is inversely proportional to the number of unique nested objects.\n            for (length = stack.length; length--;) {\n              if (stack[length] === value) {\n                // Cyclic structures cannot be serialized by `JSON.stringify`.\n                throw TypeError();\n              }\n            }\n            // Add the object to the stack of traversed objects.\n            stack.push(value);\n            results = [];\n            // Save the current indentation level and indent one additional level.\n            prefix = indentation;\n            indentation += whitespace;\n            if (className == arrayClass) {\n              // Recursively serialize array elements.\n              for (index = 0, length = value.length; index < length; index++) {\n                element = serialize(index, value, callback, properties, whitespace, indentation, stack);\n                results.push(element === undef ? \"null\" : element);\n              }\n              result = results.length ? (whitespace ? \"[\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"]\" : (\"[\" + results.join(\",\") + \"]\")) : \"[]\";\n            } else {\n              // Recursively serialize object members. Members are selected from\n              // either a user-specified list of property names, or the object\n              // itself.\n              forEach(properties || value, function (property) {\n                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\n                if (element !== undef) {\n                  // According to ES 5.1 section 15.12.3: \"If `gap` {whitespace}\n                  // is not the empty string, let `member` {quote(property) + \":\"}\n                  // be the concatenation of `member` and the `space` character.\"\n                  // The \"`space` character\" refers to the literal space\n                  // character, not the `space` {width} argument provided to\n                  // `JSON.stringify`.\n                  results.push(quote(property) + \":\" + (whitespace ? \" \" : \"\") + element);\n                }\n              });\n              result = results.length ? (whitespace ? \"{\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"}\" : (\"{\" + results.join(\",\") + \"}\")) : \"{}\";\n            }\n            // Remove the object from the traversed object stack.\n            stack.pop();\n            return result;\n          }\n        };\n\n        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\n        exports.stringify = function (source, filter, width) {\n          var whitespace, callback, properties, className;\n          if (objectTypes[typeof filter] && filter) {\n            if ((className = getClass.call(filter)) == functionClass) {\n              callback = filter;\n            } else if (className == arrayClass) {\n              // Convert the property names array into a makeshift set.\n              properties = {};\n              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));\n            }\n          }\n          if (width) {\n            if ((className = getClass.call(width)) == numberClass) {\n              // Convert the `width` to an integer and create a string containing\n              // `width` number of space characters.\n              if ((width -= width % 1) > 0) {\n                for (whitespace = \"\", width > 10 && (width = 10); whitespace.length < width; whitespace += \" \");\n              }\n            } else if (className == stringClass) {\n              whitespace = width.length <= 10 ? width : width.slice(0, 10);\n            }\n          }\n          // Opera <= 7.54u2 discards the values associated with empty string keys\n          // (`\"\"`) only if they are used directly within an object member list\n          // (e.g., `!(\"\" in { \"\": 1})`).\n          return serialize(\"\", (value = {}, value[\"\"] = source, value), callback, properties, whitespace, \"\", []);\n        };\n      }\n\n      // Public: Parses a JSON source string.\n      if (!has(\"json-parse\")) {\n        var fromCharCode = String.fromCharCode;\n\n        // Internal: A map of escaped control characters and their unescaped\n        // equivalents.\n        var Unescapes = {\n          92: \"\\\\\",\n          34: '\"',\n          47: \"/\",\n          98: \"\\b\",\n          116: \"\\t\",\n          110: \"\\n\",\n          102: \"\\f\",\n          114: \"\\r\"\n        };\n\n        // Internal: Stores the parser state.\n        var Index, Source;\n\n        // Internal: Resets the parser state and throws a `SyntaxError`.\n        var abort = function () {\n          Index = Source = null;\n          throw SyntaxError();\n        };\n\n        // Internal: Returns the next token, or `\"$\"` if the parser has reached\n        // the end of the source string. A token may be a string, number, `null`\n        // literal, or Boolean literal.\n        var lex = function () {\n          var source = Source, length = source.length, value, begin, position, isSigned, charCode;\n          while (Index < length) {\n            charCode = source.charCodeAt(Index);\n            switch (charCode) {\n              case 9: case 10: case 13: case 32:\n                // Skip whitespace tokens, including tabs, carriage returns, line\n                // feeds, and space characters.\n                Index++;\n                break;\n              case 123: case 125: case 91: case 93: case 58: case 44:\n                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at\n                // the current position.\n                value = charIndexBuggy ? source.charAt(Index) : source[Index];\n                Index++;\n                return value;\n              case 34:\n                // `\"` delimits a JSON string; advance to the next character and\n                // begin parsing the string. String tokens are prefixed with the\n                // sentinel `@` character to distinguish them from punctuators and\n                // end-of-string tokens.\n                for (value = \"@\", Index++; Index < length;) {\n                  charCode = source.charCodeAt(Index);\n                  if (charCode < 32) {\n                    // Unescaped ASCII control characters (those with a code unit\n                    // less than the space character) are not permitted.\n                    abort();\n                  } else if (charCode == 92) {\n                    // A reverse solidus (`\\`) marks the beginning of an escaped\n                    // control character (including `\"`, `\\`, and `/`) or Unicode\n                    // escape sequence.\n                    charCode = source.charCodeAt(++Index);\n                    switch (charCode) {\n                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:\n                        // Revive escaped control characters.\n                        value += Unescapes[charCode];\n                        Index++;\n                        break;\n                      case 117:\n                        // `\\u` marks the beginning of a Unicode escape sequence.\n                        // Advance to the first character and validate the\n                        // four-digit code point.\n                        begin = ++Index;\n                        for (position = Index + 4; Index < position; Index++) {\n                          charCode = source.charCodeAt(Index);\n                          // A valid sequence comprises four hexdigits (case-\n                          // insensitive) that form a single hexadecimal value.\n                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\n                            // Invalid Unicode escape sequence.\n                            abort();\n                          }\n                        }\n                        // Revive the escaped character.\n                        value += fromCharCode(\"0x\" + source.slice(begin, Index));\n                        break;\n                      default:\n                        // Invalid escape sequence.\n                        abort();\n                    }\n                  } else {\n                    if (charCode == 34) {\n                      // An unescaped double-quote character marks the end of the\n                      // string.\n                      break;\n                    }\n                    charCode = source.charCodeAt(Index);\n                    begin = Index;\n                    // Optimize for the common case where a string is valid.\n                    while (charCode >= 32 && charCode != 92 && charCode != 34) {\n                      charCode = source.charCodeAt(++Index);\n                    }\n                    // Append the string as-is.\n                    value += source.slice(begin, Index);\n                  }\n                }\n                if (source.charCodeAt(Index) == 34) {\n                  // Advance to the next character and return the revived string.\n                  Index++;\n                  return value;\n                }\n                // Unterminated string.\n                abort();\n              default:\n                // Parse numbers and literals.\n                begin = Index;\n                // Advance past the negative sign, if one is specified.\n                if (charCode == 45) {\n                  isSigned = true;\n                  charCode = source.charCodeAt(++Index);\n                }\n                // Parse an integer or floating-point value.\n                if (charCode >= 48 && charCode <= 57) {\n                  // Leading zeroes are interpreted as octal literals.\n                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {\n                    // Illegal octal literal.\n                    abort();\n                  }\n                  isSigned = false;\n                  // Parse the integer component.\n                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);\n                  // Floats cannot contain a leading decimal point; however, this\n                  // case is already accounted for by the parser.\n                  if (source.charCodeAt(Index) == 46) {\n                    position = ++Index;\n                    // Parse the decimal component.\n                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                    if (position == Index) {\n                      // Illegal trailing decimal.\n                      abort();\n                    }\n                    Index = position;\n                  }\n                  // Parse exponents. The `e` denoting the exponent is\n                  // case-insensitive.\n                  charCode = source.charCodeAt(Index);\n                  if (charCode == 101 || charCode == 69) {\n                    charCode = source.charCodeAt(++Index);\n                    // Skip past the sign following the exponent, if one is\n                    // specified.\n                    if (charCode == 43 || charCode == 45) {\n                      Index++;\n                    }\n                    // Parse the exponential component.\n                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                    if (position == Index) {\n                      // Illegal empty exponent.\n                      abort();\n                    }\n                    Index = position;\n                  }\n                  // Coerce the parsed value to a JavaScript number.\n                  return +source.slice(begin, Index);\n                }\n                // A negative sign may only precede numbers.\n                if (isSigned) {\n                  abort();\n                }\n                // `true`, `false`, and `null` literals.\n                if (source.slice(Index, Index + 4) == \"true\") {\n                  Index += 4;\n                  return true;\n                } else if (source.slice(Index, Index + 5) == \"false\") {\n                  Index += 5;\n                  return false;\n                } else if (source.slice(Index, Index + 4) == \"null\") {\n                  Index += 4;\n                  return null;\n                }\n                // Unrecognized token.\n                abort();\n            }\n          }\n          // Return the sentinel `$` character if the parser has reached the end\n          // of the source string.\n          return \"$\";\n        };\n\n        // Internal: Parses a JSON `value` token.\n        var get = function (value) {\n          var results, hasMembers;\n          if (value == \"$\") {\n            // Unexpected end of input.\n            abort();\n          }\n          if (typeof value == \"string\") {\n            if ((charIndexBuggy ? value.charAt(0) : value[0]) == \"@\") {\n              // Remove the sentinel `@` character.\n              return value.slice(1);\n            }\n            // Parse object and array literals.\n            if (value == \"[\") {\n              // Parses a JSON array, returning a new JavaScript array.\n              results = [];\n              for (;; hasMembers || (hasMembers = true)) {\n                value = lex();\n                // A closing square bracket marks the end of the array literal.\n                if (value == \"]\") {\n                  break;\n                }\n                // If the array literal contains elements, the current token\n                // should be a comma separating the previous element from the\n                // next.\n                if (hasMembers) {\n                  if (value == \",\") {\n                    value = lex();\n                    if (value == \"]\") {\n                      // Unexpected trailing `,` in array literal.\n                      abort();\n                    }\n                  } else {\n                    // A `,` must separate each array element.\n                    abort();\n                  }\n                }\n                // Elisions and leading commas are not permitted.\n                if (value == \",\") {\n                  abort();\n                }\n                results.push(get(value));\n              }\n              return results;\n            } else if (value == \"{\") {\n              // Parses a JSON object, returning a new JavaScript object.\n              results = {};\n              for (;; hasMembers || (hasMembers = true)) {\n                value = lex();\n                // A closing curly brace marks the end of the object literal.\n                if (value == \"}\") {\n                  break;\n                }\n                // If the object literal contains members, the current token\n                // should be a comma separator.\n                if (hasMembers) {\n                  if (value == \",\") {\n                    value = lex();\n                    if (value == \"}\") {\n                      // Unexpected trailing `,` in object literal.\n                      abort();\n                    }\n                  } else {\n                    // A `,` must separate each object member.\n                    abort();\n                  }\n                }\n                // Leading commas are not permitted, object property names must be\n                // double-quoted strings, and a `:` must separate each property\n                // name and value.\n                if (value == \",\" || typeof value != \"string\" || (charIndexBuggy ? value.charAt(0) : value[0]) != \"@\" || lex() != \":\") {\n                  abort();\n                }\n                results[value.slice(1)] = get(lex());\n              }\n              return results;\n            }\n            // Unexpected token encountered.\n            abort();\n          }\n          return value;\n        };\n\n        // Internal: Updates a traversed object member.\n        var update = function (source, property, callback) {\n          var element = walk(source, property, callback);\n          if (element === undef) {\n            delete source[property];\n          } else {\n            source[property] = element;\n          }\n        };\n\n        // Internal: Recursively traverses a parsed JSON object, invoking the\n        // `callback` function for each value. This is an implementation of the\n        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\n        var walk = function (source, property, callback) {\n          var value = source[property], length;\n          if (typeof value == \"object\" && value) {\n            // `forEach` can't be used to traverse an array in Opera <= 8.54\n            // because its `Object#hasOwnProperty` implementation returns `false`\n            // for array indices (e.g., `![1, 2, 3].hasOwnProperty(\"0\")`).\n            if (getClass.call(value) == arrayClass) {\n              for (length = value.length; length--;) {\n                update(value, length, callback);\n              }\n            } else {\n              forEach(value, function (property) {\n                update(value, property, callback);\n              });\n            }\n          }\n          return callback.call(source, property, value);\n        };\n\n        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\n        exports.parse = function (source, callback) {\n          var result, value;\n          Index = 0;\n          Source = \"\" + source;\n          result = get(lex());\n          // If a JSON string contains multiple tokens, it is invalid.\n          if (lex() != \"$\") {\n            abort();\n          }\n          // Reset the parser state.\n          Index = Source = null;\n          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[\"\"] = result, value), \"\", callback) : result;\n        };\n      }\n    }\n\n    exports[\"runInContext\"] = runInContext;\n    return exports;\n  }\n\n  if (freeExports && !isLoader) {\n    // Export for CommonJS environments.\n    runInContext(root, freeExports);\n  } else {\n    // Export for web browsers and JavaScript engines.\n    var nativeJSON = root.JSON,\n        previousJSON = root[\"JSON3\"],\n        isRestored = false;\n\n    var JSON3 = runInContext(root, (root[\"JSON3\"] = {\n      // Public: Restores the original value of the global `JSON` object and\n      // returns a reference to the `JSON3` object.\n      \"noConflict\": function () {\n        if (!isRestored) {\n          isRestored = true;\n          root.JSON = nativeJSON;\n          root[\"JSON3\"] = previousJSON;\n          nativeJSON = previousJSON = null;\n        }\n        return JSON3;\n      }\n    }));\n\n    root.JSON = {\n      \"parse\": JSON3.parse,\n      \"stringify\": JSON3.stringify\n    };\n  }\n\n  // Export for asynchronous module loaders.\n  if (isLoader) {\n    define(function () {\n      return JSON3;\n    });\n  }\n}).call(this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/json3/lib/json3.js\n ** module id = 81\n ** module chunks = 0\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 82\n ** module chunks = 0\n **/","module.exports = __webpack_amd_options__;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/amd-options.js\n ** module id = 83\n ** module chunks = 0\n **/","\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  var self = this;\n  this._callbacks = this._callbacks || {};\n\n  function on() {\n    self.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks[event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/socket.io-parser/~/component-emitter/index.js\n ** module id = 84\n ** module chunks = 0\n **/","/*global Blob,File*/\n\n/**\n * Module requirements\n */\n\nvar isArray = require('isarray');\nvar isBuf = require('./is-buffer');\n\n/**\n * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.\n * Anything with blobs or files should be fed through removeBlobs before coming\n * here.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @api public\n */\n\nexports.deconstructPacket = function(packet){\n  var buffers = [];\n  var packetData = packet.data;\n\n  function _deconstructPacket(data) {\n    if (!data) return data;\n\n    if (isBuf(data)) {\n      var placeholder = { _placeholder: true, num: buffers.length };\n      buffers.push(data);\n      return placeholder;\n    } else if (isArray(data)) {\n      var newData = new Array(data.length);\n      for (var i = 0; i < data.length; i++) {\n        newData[i] = _deconstructPacket(data[i]);\n      }\n      return newData;\n    } else if ('object' == typeof data && !(data instanceof Date)) {\n      var newData = {};\n      for (var key in data) {\n        newData[key] = _deconstructPacket(data[key]);\n      }\n      return newData;\n    }\n    return data;\n  }\n\n  var pack = packet;\n  pack.data = _deconstructPacket(packetData);\n  pack.attachments = buffers.length; // number of binary 'attachments'\n  return {packet: pack, buffers: buffers};\n};\n\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @api public\n */\n\nexports.reconstructPacket = function(packet, buffers) {\n  var curPlaceHolder = 0;\n\n  function _reconstructPacket(data) {\n    if (data && data._placeholder) {\n      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)\n      return buf;\n    } else if (isArray(data)) {\n      for (var i = 0; i < data.length; i++) {\n        data[i] = _reconstructPacket(data[i]);\n      }\n      return data;\n    } else if (data && 'object' == typeof data) {\n      for (var key in data) {\n        data[key] = _reconstructPacket(data[key]);\n      }\n      return data;\n    }\n    return data;\n  }\n\n  packet.data = _reconstructPacket(packet.data);\n  packet.attachments = undefined; // no longer useful\n  return packet;\n};\n\n/**\n * Asynchronously removes Blobs or Files from data via\n * FileReader's readAsArrayBuffer method. Used before encoding\n * data as msgpack. Calls callback with the blobless data.\n *\n * @param {Object} data\n * @param {Function} callback\n * @api private\n */\n\nexports.removeBlobs = function(data, callback) {\n  function _removeBlobs(obj, curKey, containingObject) {\n    if (!obj) return obj;\n\n    // convert any blob\n    if ((global.Blob && obj instanceof Blob) ||\n        (global.File && obj instanceof File)) {\n      pendingBlobs++;\n\n      // async filereader\n      var fileReader = new FileReader();\n      fileReader.onload = function() { // this.result == arraybuffer\n        if (containingObject) {\n          containingObject[curKey] = this.result;\n        }\n        else {\n          bloblessData = this.result;\n        }\n\n        // if nothing pending its callback time\n        if(! --pendingBlobs) {\n          callback(bloblessData);\n        }\n      };\n\n      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer\n    } else if (isArray(obj)) { // handle array\n      for (var i = 0; i < obj.length; i++) {\n        _removeBlobs(obj[i], i, obj);\n      }\n    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object\n      for (var key in obj) {\n        _removeBlobs(obj[key], key, obj);\n      }\n    }\n  }\n\n  var pendingBlobs = 0;\n  var bloblessData = data;\n  _removeBlobs(bloblessData);\n  if (!pendingBlobs) {\n    callback(bloblessData);\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/socket.io-parser/binary.js\n ** module id = 85\n ** module chunks = 0\n **/","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/socket.io-parser/~/isarray/index.js\n ** module id = 86\n ** module chunks = 0\n **/","\nmodule.exports = isBuf;\n\n/**\n * Returns true if obj is a buffer or an arraybuffer.\n *\n * @api private\n */\n\nfunction isBuf(obj) {\n  return (global.Buffer && global.Buffer.isBuffer(obj)) ||\n         (global.ArrayBuffer && obj instanceof ArrayBuffer);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/socket.io-parser/is-buffer.js\n ** module id = 87\n ** module chunks = 0\n **/","\n/**\n * Module dependencies.\n */\n\nvar eio = require('engine.io-client');\nvar Socket = require('./socket');\nvar Emitter = require('component-emitter');\nvar parser = require('socket.io-parser');\nvar on = require('./on');\nvar bind = require('component-bind');\nvar debug = require('debug')('socket.io-client:manager');\nvar indexOf = require('indexof');\nvar Backoff = require('backo2');\n\n/**\n * IE6+ hasOwnProperty\n */\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Module exports\n */\n\nmodule.exports = Manager;\n\n/**\n * `Manager` constructor.\n *\n * @param {String} engine instance or engine uri/opts\n * @param {Object} options\n * @api public\n */\n\nfunction Manager (uri, opts) {\n  if (!(this instanceof Manager)) return new Manager(uri, opts);\n  if (uri && ('object' === typeof uri)) {\n    opts = uri;\n    uri = undefined;\n  }\n  opts = opts || {};\n\n  opts.path = opts.path || '/socket.io';\n  this.nsps = {};\n  this.subs = [];\n  this.opts = opts;\n  this.reconnection(opts.reconnection !== false);\n  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n  this.reconnectionDelay(opts.reconnectionDelay || 1000);\n  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n  this.randomizationFactor(opts.randomizationFactor || 0.5);\n  this.backoff = new Backoff({\n    min: this.reconnectionDelay(),\n    max: this.reconnectionDelayMax(),\n    jitter: this.randomizationFactor()\n  });\n  this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n  this.readyState = 'closed';\n  this.uri = uri;\n  this.connecting = [];\n  this.lastPing = null;\n  this.encoding = false;\n  this.packetBuffer = [];\n  this.encoder = new parser.Encoder();\n  this.decoder = new parser.Decoder();\n  this.autoConnect = opts.autoConnect !== false;\n  if (this.autoConnect) this.open();\n}\n\n/**\n * Propagate given event to sockets and emit on `this`\n *\n * @api private\n */\n\nManager.prototype.emitAll = function () {\n  this.emit.apply(this, arguments);\n  for (var nsp in this.nsps) {\n    if (has.call(this.nsps, nsp)) {\n      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);\n    }\n  }\n};\n\n/**\n * Update `socket.id` of all sockets\n *\n * @api private\n */\n\nManager.prototype.updateSocketIds = function () {\n  for (var nsp in this.nsps) {\n    if (has.call(this.nsps, nsp)) {\n      this.nsps[nsp].id = this.engine.id;\n    }\n  }\n};\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Manager.prototype);\n\n/**\n * Sets the `reconnection` config.\n *\n * @param {Boolean} true/false if it should automatically reconnect\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnection = function (v) {\n  if (!arguments.length) return this._reconnection;\n  this._reconnection = !!v;\n  return this;\n};\n\n/**\n * Sets the reconnection attempts config.\n *\n * @param {Number} max reconnection attempts before giving up\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionAttempts = function (v) {\n  if (!arguments.length) return this._reconnectionAttempts;\n  this._reconnectionAttempts = v;\n  return this;\n};\n\n/**\n * Sets the delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelay = function (v) {\n  if (!arguments.length) return this._reconnectionDelay;\n  this._reconnectionDelay = v;\n  this.backoff && this.backoff.setMin(v);\n  return this;\n};\n\nManager.prototype.randomizationFactor = function (v) {\n  if (!arguments.length) return this._randomizationFactor;\n  this._randomizationFactor = v;\n  this.backoff && this.backoff.setJitter(v);\n  return this;\n};\n\n/**\n * Sets the maximum delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelayMax = function (v) {\n  if (!arguments.length) return this._reconnectionDelayMax;\n  this._reconnectionDelayMax = v;\n  this.backoff && this.backoff.setMax(v);\n  return this;\n};\n\n/**\n * Sets the connection timeout. `false` to disable\n *\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.timeout = function (v) {\n  if (!arguments.length) return this._timeout;\n  this._timeout = v;\n  return this;\n};\n\n/**\n * Starts trying to reconnect if reconnection is enabled and we have not\n * started reconnecting yet\n *\n * @api private\n */\n\nManager.prototype.maybeReconnectOnOpen = function () {\n  // Only try to reconnect if it's the first time we're connecting\n  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {\n    // keeps reconnection from firing twice for the same reconnection loop\n    this.reconnect();\n  }\n};\n\n/**\n * Sets the current transport `socket`.\n *\n * @param {Function} optional, callback\n * @return {Manager} self\n * @api public\n */\n\nManager.prototype.open =\nManager.prototype.connect = function (fn, opts) {\n  debug('readyState %s', this.readyState);\n  if (~this.readyState.indexOf('open')) return this;\n\n  debug('opening %s', this.uri);\n  this.engine = eio(this.uri, this.opts);\n  var socket = this.engine;\n  var self = this;\n  this.readyState = 'opening';\n  this.skipReconnect = false;\n\n  // emit `open`\n  var openSub = on(socket, 'open', function () {\n    self.onopen();\n    fn && fn();\n  });\n\n  // emit `connect_error`\n  var errorSub = on(socket, 'error', function (data) {\n    debug('connect_error');\n    self.cleanup();\n    self.readyState = 'closed';\n    self.emitAll('connect_error', data);\n    if (fn) {\n      var err = new Error('Connection error');\n      err.data = data;\n      fn(err);\n    } else {\n      // Only do this if there is no fn to handle the error\n      self.maybeReconnectOnOpen();\n    }\n  });\n\n  // emit `connect_timeout`\n  if (false !== this._timeout) {\n    var timeout = this._timeout;\n    debug('connect attempt will timeout after %d', timeout);\n\n    // set timer\n    var timer = setTimeout(function () {\n      debug('connect attempt timed out after %d', timeout);\n      openSub.destroy();\n      socket.close();\n      socket.emit('error', 'timeout');\n      self.emitAll('connect_timeout', timeout);\n    }, timeout);\n\n    this.subs.push({\n      destroy: function () {\n        clearTimeout(timer);\n      }\n    });\n  }\n\n  this.subs.push(openSub);\n  this.subs.push(errorSub);\n\n  return this;\n};\n\n/**\n * Called upon transport open.\n *\n * @api private\n */\n\nManager.prototype.onopen = function () {\n  debug('open');\n\n  // clear old subs\n  this.cleanup();\n\n  // mark as open\n  this.readyState = 'open';\n  this.emit('open');\n\n  // add new subs\n  var socket = this.engine;\n  this.subs.push(on(socket, 'data', bind(this, 'ondata')));\n  this.subs.push(on(socket, 'ping', bind(this, 'onping')));\n  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));\n  this.subs.push(on(socket, 'error', bind(this, 'onerror')));\n  this.subs.push(on(socket, 'close', bind(this, 'onclose')));\n  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));\n};\n\n/**\n * Called upon a ping.\n *\n * @api private\n */\n\nManager.prototype.onping = function () {\n  this.lastPing = new Date();\n  this.emitAll('ping');\n};\n\n/**\n * Called upon a packet.\n *\n * @api private\n */\n\nManager.prototype.onpong = function () {\n  this.emitAll('pong', new Date() - this.lastPing);\n};\n\n/**\n * Called with data.\n *\n * @api private\n */\n\nManager.prototype.ondata = function (data) {\n  this.decoder.add(data);\n};\n\n/**\n * Called when parser fully decodes a packet.\n *\n * @api private\n */\n\nManager.prototype.ondecoded = function (packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon socket error.\n *\n * @api private\n */\n\nManager.prototype.onerror = function (err) {\n  debug('error', err);\n  this.emitAll('error', err);\n};\n\n/**\n * Creates a new socket for the given `nsp`.\n *\n * @return {Socket}\n * @api public\n */\n\nManager.prototype.socket = function (nsp, opts) {\n  var socket = this.nsps[nsp];\n  if (!socket) {\n    socket = new Socket(this, nsp, opts);\n    this.nsps[nsp] = socket;\n    var self = this;\n    socket.on('connecting', onConnecting);\n    socket.on('connect', function () {\n      socket.id = self.engine.id;\n    });\n\n    if (this.autoConnect) {\n      // manually call here since connecting evnet is fired before listening\n      onConnecting();\n    }\n  }\n\n  function onConnecting () {\n    if (!~indexOf(self.connecting, socket)) {\n      self.connecting.push(socket);\n    }\n  }\n\n  return socket;\n};\n\n/**\n * Called upon a socket close.\n *\n * @param {Socket} socket\n */\n\nManager.prototype.destroy = function (socket) {\n  var index = indexOf(this.connecting, socket);\n  if (~index) this.connecting.splice(index, 1);\n  if (this.connecting.length) return;\n\n  this.close();\n};\n\n/**\n * Writes a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nManager.prototype.packet = function (packet) {\n  debug('writing packet %j', packet);\n  var self = this;\n  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;\n\n  if (!self.encoding) {\n    // encode, then write to engine with result\n    self.encoding = true;\n    this.encoder.encode(packet, function (encodedPackets) {\n      for (var i = 0; i < encodedPackets.length; i++) {\n        self.engine.write(encodedPackets[i], packet.options);\n      }\n      self.encoding = false;\n      self.processPacketQueue();\n    });\n  } else { // add packet to the queue\n    self.packetBuffer.push(packet);\n  }\n};\n\n/**\n * If packet buffer is non-empty, begins encoding the\n * next packet in line.\n *\n * @api private\n */\n\nManager.prototype.processPacketQueue = function () {\n  if (this.packetBuffer.length > 0 && !this.encoding) {\n    var pack = this.packetBuffer.shift();\n    this.packet(pack);\n  }\n};\n\n/**\n * Clean up transport subscriptions and packet buffer.\n *\n * @api private\n */\n\nManager.prototype.cleanup = function () {\n  debug('cleanup');\n\n  var subsLength = this.subs.length;\n  for (var i = 0; i < subsLength; i++) {\n    var sub = this.subs.shift();\n    sub.destroy();\n  }\n\n  this.packetBuffer = [];\n  this.encoding = false;\n  this.lastPing = null;\n\n  this.decoder.destroy();\n};\n\n/**\n * Close the current socket.\n *\n * @api private\n */\n\nManager.prototype.close =\nManager.prototype.disconnect = function () {\n  debug('disconnect');\n  this.skipReconnect = true;\n  this.reconnecting = false;\n  if ('opening' === this.readyState) {\n    // `onclose` will not fire because\n    // an open event never happened\n    this.cleanup();\n  }\n  this.backoff.reset();\n  this.readyState = 'closed';\n  if (this.engine) this.engine.close();\n};\n\n/**\n * Called upon engine close.\n *\n * @api private\n */\n\nManager.prototype.onclose = function (reason) {\n  debug('onclose');\n\n  this.cleanup();\n  this.backoff.reset();\n  this.readyState = 'closed';\n  this.emit('close', reason);\n\n  if (this._reconnection && !this.skipReconnect) {\n    this.reconnect();\n  }\n};\n\n/**\n * Attempt a reconnection.\n *\n * @api private\n */\n\nManager.prototype.reconnect = function () {\n  if (this.reconnecting || this.skipReconnect) return this;\n\n  var self = this;\n\n  if (this.backoff.attempts >= this._reconnectionAttempts) {\n    debug('reconnect failed');\n    this.backoff.reset();\n    this.emitAll('reconnect_failed');\n    this.reconnecting = false;\n  } else {\n    var delay = this.backoff.duration();\n    debug('will wait %dms before reconnect attempt', delay);\n\n    this.reconnecting = true;\n    var timer = setTimeout(function () {\n      if (self.skipReconnect) return;\n\n      debug('attempting reconnect');\n      self.emitAll('reconnect_attempt', self.backoff.attempts);\n      self.emitAll('reconnecting', self.backoff.attempts);\n\n      // check again for the case socket closed in above events\n      if (self.skipReconnect) return;\n\n      self.open(function (err) {\n        if (err) {\n          debug('reconnect attempt error');\n          self.reconnecting = false;\n          self.reconnect();\n          self.emitAll('reconnect_error', err.data);\n        } else {\n          debug('reconnect success');\n          self.onreconnect();\n        }\n      });\n    }, delay);\n\n    this.subs.push({\n      destroy: function () {\n        clearTimeout(timer);\n      }\n    });\n  }\n};\n\n/**\n * Called upon successful reconnect.\n *\n * @api private\n */\n\nManager.prototype.onreconnect = function () {\n  var attempt = this.backoff.attempts;\n  this.reconnecting = false;\n  this.backoff.reset();\n  this.updateSocketIds();\n  this.emitAll('reconnect', attempt);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/socket.io-client/lib/manager.js\n ** module id = 88\n ** module chunks = 0\n **/","\nmodule.exports = require('./lib/index');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/engine.io-client/index.js\n ** module id = 89\n ** module chunks = 0\n **/","\nmodule.exports = require('./socket');\n\n/**\n * Exports parser\n *\n * @api public\n *\n */\nmodule.exports.parser = require('engine.io-parser');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/engine.io-client/lib/index.js\n ** module id = 90\n ** module chunks = 0\n **/","/**\n * Module dependencies.\n */\n\nvar transports = require('./transports/index');\nvar Emitter = require('component-emitter');\nvar debug = require('debug')('engine.io-client:socket');\nvar index = require('indexof');\nvar parser = require('engine.io-parser');\nvar parseuri = require('parseuri');\nvar parsejson = require('parsejson');\nvar parseqs = require('parseqs');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Socket;\n\n/**\n * Socket constructor.\n *\n * @param {String|Object} uri or options\n * @param {Object} options\n * @api public\n */\n\nfunction Socket (uri, opts) {\n  if (!(this instanceof Socket)) return new Socket(uri, opts);\n\n  opts = opts || {};\n\n  if (uri && 'object' === typeof uri) {\n    opts = uri;\n    uri = null;\n  }\n\n  if (uri) {\n    uri = parseuri(uri);\n    opts.hostname = uri.host;\n    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';\n    opts.port = uri.port;\n    if (uri.query) opts.query = uri.query;\n  } else if (opts.host) {\n    opts.hostname = parseuri(opts.host).host;\n  }\n\n  this.secure = null != opts.secure ? opts.secure\n    : (global.location && 'https:' === location.protocol);\n\n  if (opts.hostname && !opts.port) {\n    // if no port is specified manually, use the protocol default\n    opts.port = this.secure ? '443' : '80';\n  }\n\n  this.agent = opts.agent || false;\n  this.hostname = opts.hostname ||\n    (global.location ? location.hostname : 'localhost');\n  this.port = opts.port || (global.location && location.port\n      ? location.port\n      : (this.secure ? 443 : 80));\n  this.query = opts.query || {};\n  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);\n  this.upgrade = false !== opts.upgrade;\n  this.path = (opts.path || '/engine.io').replace(/\\/$/, '') + '/';\n  this.forceJSONP = !!opts.forceJSONP;\n  this.jsonp = false !== opts.jsonp;\n  this.forceBase64 = !!opts.forceBase64;\n  this.enablesXDR = !!opts.enablesXDR;\n  this.timestampParam = opts.timestampParam || 't';\n  this.timestampRequests = opts.timestampRequests;\n  this.transports = opts.transports || ['polling', 'websocket'];\n  this.readyState = '';\n  this.writeBuffer = [];\n  this.prevBufferLen = 0;\n  this.policyPort = opts.policyPort || 843;\n  this.rememberUpgrade = opts.rememberUpgrade || false;\n  this.binaryType = null;\n  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;\n  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;\n\n  if (true === this.perMessageDeflate) this.perMessageDeflate = {};\n  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {\n    this.perMessageDeflate.threshold = 1024;\n  }\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx || null;\n  this.key = opts.key || null;\n  this.passphrase = opts.passphrase || null;\n  this.cert = opts.cert || null;\n  this.ca = opts.ca || null;\n  this.ciphers = opts.ciphers || null;\n  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? null : opts.rejectUnauthorized;\n  this.forceNode = !!opts.forceNode;\n\n  // other options for Node.js client\n  var freeGlobal = typeof global === 'object' && global;\n  if (freeGlobal.global === freeGlobal) {\n    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {\n      this.extraHeaders = opts.extraHeaders;\n    }\n\n    if (opts.localAddress) {\n      this.localAddress = opts.localAddress;\n    }\n  }\n\n  // set on handshake\n  this.id = null;\n  this.upgrades = null;\n  this.pingInterval = null;\n  this.pingTimeout = null;\n\n  // set on heartbeat\n  this.pingIntervalTimer = null;\n  this.pingTimeoutTimer = null;\n\n  this.open();\n}\n\nSocket.priorWebsocketSuccess = false;\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Socket.prototype);\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nSocket.protocol = parser.protocol; // this is an int\n\n/**\n * Expose deps for legacy compatibility\n * and standalone browser access.\n */\n\nSocket.Socket = Socket;\nSocket.Transport = require('./transport');\nSocket.transports = require('./transports/index');\nSocket.parser = require('engine.io-parser');\n\n/**\n * Creates transport of the given type.\n *\n * @param {String} transport name\n * @return {Transport}\n * @api private\n */\n\nSocket.prototype.createTransport = function (name) {\n  debug('creating transport \"%s\"', name);\n  var query = clone(this.query);\n\n  // append engine.io protocol identifier\n  query.EIO = parser.protocol;\n\n  // transport name\n  query.transport = name;\n\n  // session id if we already have one\n  if (this.id) query.sid = this.id;\n\n  var transport = new transports[name]({\n    agent: this.agent,\n    hostname: this.hostname,\n    port: this.port,\n    secure: this.secure,\n    path: this.path,\n    query: query,\n    forceJSONP: this.forceJSONP,\n    jsonp: this.jsonp,\n    forceBase64: this.forceBase64,\n    enablesXDR: this.enablesXDR,\n    timestampRequests: this.timestampRequests,\n    timestampParam: this.timestampParam,\n    policyPort: this.policyPort,\n    socket: this,\n    pfx: this.pfx,\n    key: this.key,\n    passphrase: this.passphrase,\n    cert: this.cert,\n    ca: this.ca,\n    ciphers: this.ciphers,\n    rejectUnauthorized: this.rejectUnauthorized,\n    perMessageDeflate: this.perMessageDeflate,\n    extraHeaders: this.extraHeaders,\n    forceNode: this.forceNode,\n    localAddress: this.localAddress\n  });\n\n  return transport;\n};\n\nfunction clone (obj) {\n  var o = {};\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      o[i] = obj[i];\n    }\n  }\n  return o;\n}\n\n/**\n * Initializes transport to use and starts probe.\n *\n * @api private\n */\nSocket.prototype.open = function () {\n  var transport;\n  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {\n    transport = 'websocket';\n  } else if (0 === this.transports.length) {\n    // Emit error on next tick so it can be listened to\n    var self = this;\n    setTimeout(function () {\n      self.emit('error', 'No transports available');\n    }, 0);\n    return;\n  } else {\n    transport = this.transports[0];\n  }\n  this.readyState = 'opening';\n\n  // Retry with the next transport if the transport is disabled (jsonp: false)\n  try {\n    transport = this.createTransport(transport);\n  } catch (e) {\n    this.transports.shift();\n    this.open();\n    return;\n  }\n\n  transport.open();\n  this.setTransport(transport);\n};\n\n/**\n * Sets the current transport. Disables the existing one (if any).\n *\n * @api private\n */\n\nSocket.prototype.setTransport = function (transport) {\n  debug('setting transport %s', transport.name);\n  var self = this;\n\n  if (this.transport) {\n    debug('clearing existing transport %s', this.transport.name);\n    this.transport.removeAllListeners();\n  }\n\n  // set up transport\n  this.transport = transport;\n\n  // set up transport listeners\n  transport\n  .on('drain', function () {\n    self.onDrain();\n  })\n  .on('packet', function (packet) {\n    self.onPacket(packet);\n  })\n  .on('error', function (e) {\n    self.onError(e);\n  })\n  .on('close', function () {\n    self.onClose('transport close');\n  });\n};\n\n/**\n * Probes a transport.\n *\n * @param {String} transport name\n * @api private\n */\n\nSocket.prototype.probe = function (name) {\n  debug('probing transport \"%s\"', name);\n  var transport = this.createTransport(name, { probe: 1 });\n  var failed = false;\n  var self = this;\n\n  Socket.priorWebsocketSuccess = false;\n\n  function onTransportOpen () {\n    if (self.onlyBinaryUpgrades) {\n      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;\n      failed = failed || upgradeLosesBinary;\n    }\n    if (failed) return;\n\n    debug('probe transport \"%s\" opened', name);\n    transport.send([{ type: 'ping', data: 'probe' }]);\n    transport.once('packet', function (msg) {\n      if (failed) return;\n      if ('pong' === msg.type && 'probe' === msg.data) {\n        debug('probe transport \"%s\" pong', name);\n        self.upgrading = true;\n        self.emit('upgrading', transport);\n        if (!transport) return;\n        Socket.priorWebsocketSuccess = 'websocket' === transport.name;\n\n        debug('pausing current transport \"%s\"', self.transport.name);\n        self.transport.pause(function () {\n          if (failed) return;\n          if ('closed' === self.readyState) return;\n          debug('changing transport and sending upgrade packet');\n\n          cleanup();\n\n          self.setTransport(transport);\n          transport.send([{ type: 'upgrade' }]);\n          self.emit('upgrade', transport);\n          transport = null;\n          self.upgrading = false;\n          self.flush();\n        });\n      } else {\n        debug('probe transport \"%s\" failed', name);\n        var err = new Error('probe error');\n        err.transport = transport.name;\n        self.emit('upgradeError', err);\n      }\n    });\n  }\n\n  function freezeTransport () {\n    if (failed) return;\n\n    // Any callback called by transport should be ignored since now\n    failed = true;\n\n    cleanup();\n\n    transport.close();\n    transport = null;\n  }\n\n  // Handle any error that happens while probing\n  function onerror (err) {\n    var error = new Error('probe error: ' + err);\n    error.transport = transport.name;\n\n    freezeTransport();\n\n    debug('probe transport \"%s\" failed because of error: %s', name, err);\n\n    self.emit('upgradeError', error);\n  }\n\n  function onTransportClose () {\n    onerror('transport closed');\n  }\n\n  // When the socket is closed while we're probing\n  function onclose () {\n    onerror('socket closed');\n  }\n\n  // When the socket is upgraded while we're probing\n  function onupgrade (to) {\n    if (transport && to.name !== transport.name) {\n      debug('\"%s\" works - aborting \"%s\"', to.name, transport.name);\n      freezeTransport();\n    }\n  }\n\n  // Remove all listeners on the transport and on self\n  function cleanup () {\n    transport.removeListener('open', onTransportOpen);\n    transport.removeListener('error', onerror);\n    transport.removeListener('close', onTransportClose);\n    self.removeListener('close', onclose);\n    self.removeListener('upgrading', onupgrade);\n  }\n\n  transport.once('open', onTransportOpen);\n  transport.once('error', onerror);\n  transport.once('close', onTransportClose);\n\n  this.once('close', onclose);\n  this.once('upgrading', onupgrade);\n\n  transport.open();\n};\n\n/**\n * Called when connection is deemed open.\n *\n * @api public\n */\n\nSocket.prototype.onOpen = function () {\n  debug('socket open');\n  this.readyState = 'open';\n  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;\n  this.emit('open');\n  this.flush();\n\n  // we check for `readyState` in case an `open`\n  // listener already closed the socket\n  if ('open' === this.readyState && this.upgrade && this.transport.pause) {\n    debug('starting upgrade probes');\n    for (var i = 0, l = this.upgrades.length; i < l; i++) {\n      this.probe(this.upgrades[i]);\n    }\n  }\n};\n\n/**\n * Handles a packet.\n *\n * @api private\n */\n\nSocket.prototype.onPacket = function (packet) {\n  if ('opening' === this.readyState || 'open' === this.readyState ||\n      'closing' === this.readyState) {\n    debug('socket receive: type \"%s\", data \"%s\"', packet.type, packet.data);\n\n    this.emit('packet', packet);\n\n    // Socket is live - any packet counts\n    this.emit('heartbeat');\n\n    switch (packet.type) {\n      case 'open':\n        this.onHandshake(parsejson(packet.data));\n        break;\n\n      case 'pong':\n        this.setPing();\n        this.emit('pong');\n        break;\n\n      case 'error':\n        var err = new Error('server error');\n        err.code = packet.data;\n        this.onError(err);\n        break;\n\n      case 'message':\n        this.emit('data', packet.data);\n        this.emit('message', packet.data);\n        break;\n    }\n  } else {\n    debug('packet received with socket readyState \"%s\"', this.readyState);\n  }\n};\n\n/**\n * Called upon handshake completion.\n *\n * @param {Object} handshake obj\n * @api private\n */\n\nSocket.prototype.onHandshake = function (data) {\n  this.emit('handshake', data);\n  this.id = data.sid;\n  this.transport.query.sid = data.sid;\n  this.upgrades = this.filterUpgrades(data.upgrades);\n  this.pingInterval = data.pingInterval;\n  this.pingTimeout = data.pingTimeout;\n  this.onOpen();\n  // In case open handler closes socket\n  if ('closed' === this.readyState) return;\n  this.setPing();\n\n  // Prolong liveness of socket on heartbeat\n  this.removeListener('heartbeat', this.onHeartbeat);\n  this.on('heartbeat', this.onHeartbeat);\n};\n\n/**\n * Resets ping timeout.\n *\n * @api private\n */\n\nSocket.prototype.onHeartbeat = function (timeout) {\n  clearTimeout(this.pingTimeoutTimer);\n  var self = this;\n  self.pingTimeoutTimer = setTimeout(function () {\n    if ('closed' === self.readyState) return;\n    self.onClose('ping timeout');\n  }, timeout || (self.pingInterval + self.pingTimeout));\n};\n\n/**\n * Pings server every `this.pingInterval` and expects response\n * within `this.pingTimeout` or closes connection.\n *\n * @api private\n */\n\nSocket.prototype.setPing = function () {\n  var self = this;\n  clearTimeout(self.pingIntervalTimer);\n  self.pingIntervalTimer = setTimeout(function () {\n    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);\n    self.ping();\n    self.onHeartbeat(self.pingTimeout);\n  }, self.pingInterval);\n};\n\n/**\n* Sends a ping packet.\n*\n* @api private\n*/\n\nSocket.prototype.ping = function () {\n  var self = this;\n  this.sendPacket('ping', function () {\n    self.emit('ping');\n  });\n};\n\n/**\n * Called on `drain` event\n *\n * @api private\n */\n\nSocket.prototype.onDrain = function () {\n  this.writeBuffer.splice(0, this.prevBufferLen);\n\n  // setting prevBufferLen = 0 is very important\n  // for example, when upgrading, upgrade packet is sent over,\n  // and a nonzero prevBufferLen could cause problems on `drain`\n  this.prevBufferLen = 0;\n\n  if (0 === this.writeBuffer.length) {\n    this.emit('drain');\n  } else {\n    this.flush();\n  }\n};\n\n/**\n * Flush write buffers.\n *\n * @api private\n */\n\nSocket.prototype.flush = function () {\n  if ('closed' !== this.readyState && this.transport.writable &&\n    !this.upgrading && this.writeBuffer.length) {\n    debug('flushing %d packets in socket', this.writeBuffer.length);\n    this.transport.send(this.writeBuffer);\n    // keep track of current length of writeBuffer\n    // splice writeBuffer and callbackBuffer on `drain`\n    this.prevBufferLen = this.writeBuffer.length;\n    this.emit('flush');\n  }\n};\n\n/**\n * Sends a message.\n *\n * @param {String} message.\n * @param {Function} callback function.\n * @param {Object} options.\n * @return {Socket} for chaining.\n * @api public\n */\n\nSocket.prototype.write =\nSocket.prototype.send = function (msg, options, fn) {\n  this.sendPacket('message', msg, options, fn);\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {String} packet type.\n * @param {String} data.\n * @param {Object} options.\n * @param {Function} callback function.\n * @api private\n */\n\nSocket.prototype.sendPacket = function (type, data, options, fn) {\n  if ('function' === typeof data) {\n    fn = data;\n    data = undefined;\n  }\n\n  if ('function' === typeof options) {\n    fn = options;\n    options = null;\n  }\n\n  if ('closing' === this.readyState || 'closed' === this.readyState) {\n    return;\n  }\n\n  options = options || {};\n  options.compress = false !== options.compress;\n\n  var packet = {\n    type: type,\n    data: data,\n    options: options\n  };\n  this.emit('packetCreate', packet);\n  this.writeBuffer.push(packet);\n  if (fn) this.once('flush', fn);\n  this.flush();\n};\n\n/**\n * Closes the connection.\n *\n * @api private\n */\n\nSocket.prototype.close = function () {\n  if ('opening' === this.readyState || 'open' === this.readyState) {\n    this.readyState = 'closing';\n\n    var self = this;\n\n    if (this.writeBuffer.length) {\n      this.once('drain', function () {\n        if (this.upgrading) {\n          waitForUpgrade();\n        } else {\n          close();\n        }\n      });\n    } else if (this.upgrading) {\n      waitForUpgrade();\n    } else {\n      close();\n    }\n  }\n\n  function close () {\n    self.onClose('forced close');\n    debug('socket closing - telling transport to close');\n    self.transport.close();\n  }\n\n  function cleanupAndClose () {\n    self.removeListener('upgrade', cleanupAndClose);\n    self.removeListener('upgradeError', cleanupAndClose);\n    close();\n  }\n\n  function waitForUpgrade () {\n    // wait for upgrade to finish since we can't send packets while pausing a transport\n    self.once('upgrade', cleanupAndClose);\n    self.once('upgradeError', cleanupAndClose);\n  }\n\n  return this;\n};\n\n/**\n * Called upon transport error\n *\n * @api private\n */\n\nSocket.prototype.onError = function (err) {\n  debug('socket error %j', err);\n  Socket.priorWebsocketSuccess = false;\n  this.emit('error', err);\n  this.onClose('transport error', err);\n};\n\n/**\n * Called upon transport close.\n *\n * @api private\n */\n\nSocket.prototype.onClose = function (reason, desc) {\n  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {\n    debug('socket close with reason: \"%s\"', reason);\n    var self = this;\n\n    // clear timers\n    clearTimeout(this.pingIntervalTimer);\n    clearTimeout(this.pingTimeoutTimer);\n\n    // stop event from firing again for transport\n    this.transport.removeAllListeners('close');\n\n    // ensure transport won't stay open\n    this.transport.close();\n\n    // ignore further transport communication\n    this.transport.removeAllListeners();\n\n    // set ready state\n    this.readyState = 'closed';\n\n    // clear session id\n    this.id = null;\n\n    // emit close event\n    this.emit('close', reason, desc);\n\n    // clean buffers after, so users can still\n    // grab the buffers on `close` event\n    self.writeBuffer = [];\n    self.prevBufferLen = 0;\n  }\n};\n\n/**\n * Filters upgrades, returning only those matching client transports.\n *\n * @param {Array} server upgrades\n * @api private\n *\n */\n\nSocket.prototype.filterUpgrades = function (upgrades) {\n  var filteredUpgrades = [];\n  for (var i = 0, j = upgrades.length; i < j; i++) {\n    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);\n  }\n  return filteredUpgrades;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/engine.io-client/lib/socket.js\n ** module id = 91\n ** module chunks = 0\n **/","/**\n * Module dependencies\n */\n\nvar XMLHttpRequest = require('xmlhttprequest-ssl');\nvar XHR = require('./polling-xhr');\nvar JSONP = require('./polling-jsonp');\nvar websocket = require('./websocket');\n\n/**\n * Export transports.\n */\n\nexports.polling = polling;\nexports.websocket = websocket;\n\n/**\n * Polling transport polymorphic constructor.\n * Decides on xhr vs jsonp based on feature detection.\n *\n * @api private\n */\n\nfunction polling (opts) {\n  var xhr;\n  var xd = false;\n  var xs = false;\n  var jsonp = false !== opts.jsonp;\n\n  if (global.location) {\n    var isSSL = 'https:' === location.protocol;\n    var port = location.port;\n\n    // some user agents have empty `location.port`\n    if (!port) {\n      port = isSSL ? 443 : 80;\n    }\n\n    xd = opts.hostname !== location.hostname || port !== opts.port;\n    xs = opts.secure !== isSSL;\n  }\n\n  opts.xdomain = xd;\n  opts.xscheme = xs;\n  xhr = new XMLHttpRequest(opts);\n\n  if ('open' in xhr && !opts.forceJSONP) {\n    return new XHR(opts);\n  } else {\n    if (!jsonp) throw new Error('JSONP disabled');\n    return new JSONP(opts);\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/engine.io-client/lib/transports/index.js\n ** module id = 92\n ** module chunks = 0\n **/","// browser shim for xmlhttprequest module\n\nvar hasCORS = require('has-cors');\n\nmodule.exports = function (opts) {\n  var xdomain = opts.xdomain;\n\n  // scheme must be same when usign XDomainRequest\n  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx\n  var xscheme = opts.xscheme;\n\n  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.\n  // https://github.com/Automattic/engine.io-client/pull/217\n  var enablesXDR = opts.enablesXDR;\n\n  // XMLHttpRequest can be disabled on IE\n  try {\n    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {\n      return new XMLHttpRequest();\n    }\n  } catch (e) { }\n\n  // Use XDomainRequest for IE8 if enablesXDR is true\n  // because loading bar keeps flashing when using jsonp-polling\n  // https://github.com/yujiosaka/socke.io-ie8-loading-example\n  try {\n    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {\n      return new XDomainRequest();\n    }\n  } catch (e) { }\n\n  if (!xdomain) {\n    try {\n      return new global[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');\n    } catch (e) { }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/engine.io-client/lib/xmlhttprequest.js\n ** module id = 93\n ** module chunks = 0\n **/","\n/**\n * Module exports.\n *\n * Logic borrowed from Modernizr:\n *\n *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js\n */\n\ntry {\n  module.exports = typeof XMLHttpRequest !== 'undefined' &&\n    'withCredentials' in new XMLHttpRequest();\n} catch (err) {\n  // if XMLHttp support is disabled in IE then it will throw\n  // when trying to create\n  module.exports = false;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/has-cors/index.js\n ** module id = 94\n ** module chunks = 0\n **/","/**\n * Module requirements.\n */\n\nvar XMLHttpRequest = require('xmlhttprequest-ssl');\nvar Polling = require('./polling');\nvar Emitter = require('component-emitter');\nvar inherit = require('component-inherit');\nvar debug = require('debug')('engine.io-client:polling-xhr');\n\n/**\n * Module exports.\n */\n\nmodule.exports = XHR;\nmodule.exports.Request = Request;\n\n/**\n * Empty function\n */\n\nfunction empty () {}\n\n/**\n * XHR Polling constructor.\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction XHR (opts) {\n  Polling.call(this, opts);\n  this.requestTimeout = opts.requestTimeout;\n\n  if (global.location) {\n    var isSSL = 'https:' === location.protocol;\n    var port = location.port;\n\n    // some user agents have empty `location.port`\n    if (!port) {\n      port = isSSL ? 443 : 80;\n    }\n\n    this.xd = opts.hostname !== global.location.hostname ||\n      port !== opts.port;\n    this.xs = opts.secure !== isSSL;\n  } else {\n    this.extraHeaders = opts.extraHeaders;\n  }\n}\n\n/**\n * Inherits from Polling.\n */\n\ninherit(XHR, Polling);\n\n/**\n * XHR supports binary\n */\n\nXHR.prototype.supportsBinary = true;\n\n/**\n * Creates a request.\n *\n * @param {String} method\n * @api private\n */\n\nXHR.prototype.request = function (opts) {\n  opts = opts || {};\n  opts.uri = this.uri();\n  opts.xd = this.xd;\n  opts.xs = this.xs;\n  opts.agent = this.agent || false;\n  opts.supportsBinary = this.supportsBinary;\n  opts.enablesXDR = this.enablesXDR;\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n  opts.requestTimeout = this.requestTimeout;\n\n  // other options for Node.js client\n  opts.extraHeaders = this.extraHeaders;\n\n  return new Request(opts);\n};\n\n/**\n * Sends data.\n *\n * @param {String} data to send.\n * @param {Function} called upon flush.\n * @api private\n */\n\nXHR.prototype.doWrite = function (data, fn) {\n  var isBinary = typeof data !== 'string' && data !== undefined;\n  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });\n  var self = this;\n  req.on('success', fn);\n  req.on('error', function (err) {\n    self.onError('xhr post error', err);\n  });\n  this.sendXhr = req;\n};\n\n/**\n * Starts a poll cycle.\n *\n * @api private\n */\n\nXHR.prototype.doPoll = function () {\n  debug('xhr poll');\n  var req = this.request();\n  var self = this;\n  req.on('data', function (data) {\n    self.onData(data);\n  });\n  req.on('error', function (err) {\n    self.onError('xhr poll error', err);\n  });\n  this.pollXhr = req;\n};\n\n/**\n * Request constructor\n *\n * @param {Object} options\n * @api public\n */\n\nfunction Request (opts) {\n  this.method = opts.method || 'GET';\n  this.uri = opts.uri;\n  this.xd = !!opts.xd;\n  this.xs = !!opts.xs;\n  this.async = false !== opts.async;\n  this.data = undefined !== opts.data ? opts.data : null;\n  this.agent = opts.agent;\n  this.isBinary = opts.isBinary;\n  this.supportsBinary = opts.supportsBinary;\n  this.enablesXDR = opts.enablesXDR;\n  this.requestTimeout = opts.requestTimeout;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx;\n  this.key = opts.key;\n  this.passphrase = opts.passphrase;\n  this.cert = opts.cert;\n  this.ca = opts.ca;\n  this.ciphers = opts.ciphers;\n  this.rejectUnauthorized = opts.rejectUnauthorized;\n\n  // other options for Node.js client\n  this.extraHeaders = opts.extraHeaders;\n\n  this.create();\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Request.prototype);\n\n/**\n * Creates the XHR object and sends the request.\n *\n * @api private\n */\n\nRequest.prototype.create = function () {\n  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n\n  var xhr = this.xhr = new XMLHttpRequest(opts);\n  var self = this;\n\n  try {\n    debug('xhr open %s: %s', this.method, this.uri);\n    xhr.open(this.method, this.uri, this.async);\n    try {\n      if (this.extraHeaders) {\n        xhr.setDisableHeaderCheck(true);\n        for (var i in this.extraHeaders) {\n          if (this.extraHeaders.hasOwnProperty(i)) {\n            xhr.setRequestHeader(i, this.extraHeaders[i]);\n          }\n        }\n      }\n    } catch (e) {}\n    if (this.supportsBinary) {\n      // This has to be done after open because Firefox is stupid\n      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension\n      xhr.responseType = 'arraybuffer';\n    }\n\n    if ('POST' === this.method) {\n      try {\n        if (this.isBinary) {\n          xhr.setRequestHeader('Content-type', 'application/octet-stream');\n        } else {\n          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\n        }\n      } catch (e) {}\n    }\n\n    try {\n      xhr.setRequestHeader('Accept', '*/*');\n    } catch (e) {}\n\n    // ie6 check\n    if ('withCredentials' in xhr) {\n      xhr.withCredentials = true;\n    }\n\n    if (this.requestTimeout) {\n      xhr.timeout = this.requestTimeout;\n    }\n\n    if (this.hasXDR()) {\n      xhr.onload = function () {\n        self.onLoad();\n      };\n      xhr.onerror = function () {\n        self.onError(xhr.responseText);\n      };\n    } else {\n      xhr.onreadystatechange = function () {\n        if (4 !== xhr.readyState) return;\n        if (200 === xhr.status || 1223 === xhr.status) {\n          self.onLoad();\n        } else {\n          // make sure the `error` event handler that's user-set\n          // does not throw in the same tick and gets caught here\n          setTimeout(function () {\n            self.onError(xhr.status);\n          }, 0);\n        }\n      };\n    }\n\n    debug('xhr data %s', this.data);\n    xhr.send(this.data);\n  } catch (e) {\n    // Need to defer since .create() is called directly fhrom the constructor\n    // and thus the 'error' event can only be only bound *after* this exception\n    // occurs.  Therefore, also, we cannot throw here at all.\n    setTimeout(function () {\n      self.onError(e);\n    }, 0);\n    return;\n  }\n\n  if (global.document) {\n    this.index = Request.requestsCount++;\n    Request.requests[this.index] = this;\n  }\n};\n\n/**\n * Called upon successful response.\n *\n * @api private\n */\n\nRequest.prototype.onSuccess = function () {\n  this.emit('success');\n  this.cleanup();\n};\n\n/**\n * Called if we have data.\n *\n * @api private\n */\n\nRequest.prototype.onData = function (data) {\n  this.emit('data', data);\n  this.onSuccess();\n};\n\n/**\n * Called upon error.\n *\n * @api private\n */\n\nRequest.prototype.onError = function (err) {\n  this.emit('error', err);\n  this.cleanup(true);\n};\n\n/**\n * Cleans up house.\n *\n * @api private\n */\n\nRequest.prototype.cleanup = function (fromError) {\n  if ('undefined' === typeof this.xhr || null === this.xhr) {\n    return;\n  }\n  // xmlhttprequest\n  if (this.hasXDR()) {\n    this.xhr.onload = this.xhr.onerror = empty;\n  } else {\n    this.xhr.onreadystatechange = empty;\n  }\n\n  if (fromError) {\n    try {\n      this.xhr.abort();\n    } catch (e) {}\n  }\n\n  if (global.document) {\n    delete Request.requests[this.index];\n  }\n\n  this.xhr = null;\n};\n\n/**\n * Called upon load.\n *\n * @api private\n */\n\nRequest.prototype.onLoad = function () {\n  var data;\n  try {\n    var contentType;\n    try {\n      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];\n    } catch (e) {}\n    if (contentType === 'application/octet-stream') {\n      data = this.xhr.response || this.xhr.responseText;\n    } else {\n      if (!this.supportsBinary) {\n        data = this.xhr.responseText;\n      } else {\n        try {\n          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));\n        } catch (e) {\n          var ui8Arr = new Uint8Array(this.xhr.response);\n          var dataArray = [];\n          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {\n            dataArray.push(ui8Arr[idx]);\n          }\n\n          data = String.fromCharCode.apply(null, dataArray);\n        }\n      }\n    }\n  } catch (e) {\n    this.onError(e);\n  }\n  if (null != data) {\n    this.onData(data);\n  }\n};\n\n/**\n * Check if it has XDomainRequest.\n *\n * @api private\n */\n\nRequest.prototype.hasXDR = function () {\n  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;\n};\n\n/**\n * Aborts the request.\n *\n * @api public\n */\n\nRequest.prototype.abort = function () {\n  this.cleanup();\n};\n\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\n\nRequest.requestsCount = 0;\nRequest.requests = {};\n\nif (global.document) {\n  if (global.attachEvent) {\n    global.attachEvent('onunload', unloadHandler);\n  } else if (global.addEventListener) {\n    global.addEventListener('beforeunload', unloadHandler, false);\n  }\n}\n\nfunction unloadHandler () {\n  for (var i in Request.requests) {\n    if (Request.requests.hasOwnProperty(i)) {\n      Request.requests[i].abort();\n    }\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/engine.io-client/lib/transports/polling-xhr.js\n ** module id = 95\n ** module chunks = 0\n **/","/**\n * Module dependencies.\n */\n\nvar Transport = require('../transport');\nvar parseqs = require('parseqs');\nvar parser = require('engine.io-parser');\nvar inherit = require('component-inherit');\nvar yeast = require('yeast');\nvar debug = require('debug')('engine.io-client:polling');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Polling;\n\n/**\n * Is XHR2 supported?\n */\n\nvar hasXHR2 = (function () {\n  var XMLHttpRequest = require('xmlhttprequest-ssl');\n  var xhr = new XMLHttpRequest({ xdomain: false });\n  return null != xhr.responseType;\n})();\n\n/**\n * Polling interface.\n *\n * @param {Object} opts\n * @api private\n */\n\nfunction Polling (opts) {\n  var forceBase64 = (opts && opts.forceBase64);\n  if (!hasXHR2 || forceBase64) {\n    this.supportsBinary = false;\n  }\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(Polling, Transport);\n\n/**\n * Transport name.\n */\n\nPolling.prototype.name = 'polling';\n\n/**\n * Opens the socket (triggers polling). We write a PING message to determine\n * when the transport is open.\n *\n * @api private\n */\n\nPolling.prototype.doOpen = function () {\n  this.poll();\n};\n\n/**\n * Pauses polling.\n *\n * @param {Function} callback upon buffers are flushed and transport is paused\n * @api private\n */\n\nPolling.prototype.pause = function (onPause) {\n  var self = this;\n\n  this.readyState = 'pausing';\n\n  function pause () {\n    debug('paused');\n    self.readyState = 'paused';\n    onPause();\n  }\n\n  if (this.polling || !this.writable) {\n    var total = 0;\n\n    if (this.polling) {\n      debug('we are currently polling - waiting to pause');\n      total++;\n      this.once('pollComplete', function () {\n        debug('pre-pause polling complete');\n        --total || pause();\n      });\n    }\n\n    if (!this.writable) {\n      debug('we are currently writing - waiting to pause');\n      total++;\n      this.once('drain', function () {\n        debug('pre-pause writing complete');\n        --total || pause();\n      });\n    }\n  } else {\n    pause();\n  }\n};\n\n/**\n * Starts polling cycle.\n *\n * @api public\n */\n\nPolling.prototype.poll = function () {\n  debug('polling');\n  this.polling = true;\n  this.doPoll();\n  this.emit('poll');\n};\n\n/**\n * Overloads onData to detect payloads.\n *\n * @api private\n */\n\nPolling.prototype.onData = function (data) {\n  var self = this;\n  debug('polling got data %s', data);\n  var callback = function (packet, index, total) {\n    // if its the first message we consider the transport open\n    if ('opening' === self.readyState) {\n      self.onOpen();\n    }\n\n    // if its a close packet, we close the ongoing requests\n    if ('close' === packet.type) {\n      self.onClose();\n      return false;\n    }\n\n    // otherwise bypass onData and handle the message\n    self.onPacket(packet);\n  };\n\n  // decode payload\n  parser.decodePayload(data, this.socket.binaryType, callback);\n\n  // if an event did not trigger closing\n  if ('closed' !== this.readyState) {\n    // if we got data we're not polling\n    this.polling = false;\n    this.emit('pollComplete');\n\n    if ('open' === this.readyState) {\n      this.poll();\n    } else {\n      debug('ignoring poll - transport state \"%s\"', this.readyState);\n    }\n  }\n};\n\n/**\n * For polling, send a close packet.\n *\n * @api private\n */\n\nPolling.prototype.doClose = function () {\n  var self = this;\n\n  function close () {\n    debug('writing close packet');\n    self.write([{ type: 'close' }]);\n  }\n\n  if ('open' === this.readyState) {\n    debug('transport open - closing');\n    close();\n  } else {\n    // in case we're trying to close while\n    // handshaking is in progress (GH-164)\n    debug('transport not open - deferring close');\n    this.once('open', close);\n  }\n};\n\n/**\n * Writes a packets payload.\n *\n * @param {Array} data packets\n * @param {Function} drain callback\n * @api private\n */\n\nPolling.prototype.write = function (packets) {\n  var self = this;\n  this.writable = false;\n  var callbackfn = function () {\n    self.writable = true;\n    self.emit('drain');\n  };\n\n  parser.encodePayload(packets, this.supportsBinary, function (data) {\n    self.doWrite(data, callbackfn);\n  });\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nPolling.prototype.uri = function () {\n  var query = this.query || {};\n  var schema = this.secure ? 'https' : 'http';\n  var port = '';\n\n  // cache busting is forced\n  if (false !== this.timestampRequests) {\n    query[this.timestampParam] = yeast();\n  }\n\n  if (!this.supportsBinary && !query.sid) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  // avoid port if default for schema\n  if (this.port && (('https' === schema && Number(this.port) !== 443) ||\n     ('http' === schema && Number(this.port) !== 80))) {\n    port = ':' + this.port;\n  }\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  var ipv6 = this.hostname.indexOf(':') !== -1;\n  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/engine.io-client/lib/transports/polling.js\n ** module id = 96\n ** module chunks = 0\n **/","/**\n * Module dependencies.\n */\n\nvar parser = require('engine.io-parser');\nvar Emitter = require('component-emitter');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Transport;\n\n/**\n * Transport abstract constructor.\n *\n * @param {Object} options.\n * @api private\n */\n\nfunction Transport (opts) {\n  this.path = opts.path;\n  this.hostname = opts.hostname;\n  this.port = opts.port;\n  this.secure = opts.secure;\n  this.query = opts.query;\n  this.timestampParam = opts.timestampParam;\n  this.timestampRequests = opts.timestampRequests;\n  this.readyState = '';\n  this.agent = opts.agent || false;\n  this.socket = opts.socket;\n  this.enablesXDR = opts.enablesXDR;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx;\n  this.key = opts.key;\n  this.passphrase = opts.passphrase;\n  this.cert = opts.cert;\n  this.ca = opts.ca;\n  this.ciphers = opts.ciphers;\n  this.rejectUnauthorized = opts.rejectUnauthorized;\n  this.forceNode = opts.forceNode;\n\n  // other options for Node.js client\n  this.extraHeaders = opts.extraHeaders;\n  this.localAddress = opts.localAddress;\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Transport.prototype);\n\n/**\n * Emits an error.\n *\n * @param {String} str\n * @return {Transport} for chaining\n * @api public\n */\n\nTransport.prototype.onError = function (msg, desc) {\n  var err = new Error(msg);\n  err.type = 'TransportError';\n  err.description = desc;\n  this.emit('error', err);\n  return this;\n};\n\n/**\n * Opens the transport.\n *\n * @api public\n */\n\nTransport.prototype.open = function () {\n  if ('closed' === this.readyState || '' === this.readyState) {\n    this.readyState = 'opening';\n    this.doOpen();\n  }\n\n  return this;\n};\n\n/**\n * Closes the transport.\n *\n * @api private\n */\n\nTransport.prototype.close = function () {\n  if ('opening' === this.readyState || 'open' === this.readyState) {\n    this.doClose();\n    this.onClose();\n  }\n\n  return this;\n};\n\n/**\n * Sends multiple packets.\n *\n * @param {Array} packets\n * @api private\n */\n\nTransport.prototype.send = function (packets) {\n  if ('open' === this.readyState) {\n    this.write(packets);\n  } else {\n    throw new Error('Transport not open');\n  }\n};\n\n/**\n * Called upon open\n *\n * @api private\n */\n\nTransport.prototype.onOpen = function () {\n  this.readyState = 'open';\n  this.writable = true;\n  this.emit('open');\n};\n\n/**\n * Called with data.\n *\n * @param {String} data\n * @api private\n */\n\nTransport.prototype.onData = function (data) {\n  var packet = parser.decodePacket(data, this.socket.binaryType);\n  this.onPacket(packet);\n};\n\n/**\n * Called with a decoded packet.\n */\n\nTransport.prototype.onPacket = function (packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon close.\n *\n * @api private\n */\n\nTransport.prototype.onClose = function () {\n  this.readyState = 'closed';\n  this.emit('close');\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/engine.io-client/lib/transport.js\n ** module id = 97\n ** module chunks = 0\n **/","/**\n * Module dependencies.\n */\n\nvar keys = require('./keys');\nvar hasBinary = require('has-binary');\nvar sliceBuffer = require('arraybuffer.slice');\nvar after = require('after');\nvar utf8 = require('wtf-8');\n\nvar base64encoder;\nif (global && global.ArrayBuffer) {\n  base64encoder = require('base64-arraybuffer');\n}\n\n/**\n * Check if we are running an android browser. That requires us to use\n * ArrayBuffer with polling transports...\n *\n * http://ghinda.net/jpeg-blob-ajax-android/\n */\n\nvar isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\n\n/**\n * Check if we are running in PhantomJS.\n * Uploading a Blob with PhantomJS does not work correctly, as reported here:\n * https://github.com/ariya/phantomjs/issues/11395\n * @type boolean\n */\nvar isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);\n\n/**\n * When true, avoids using Blobs to encode payloads.\n * @type boolean\n */\nvar dontSendBlobs = isAndroid || isPhantomJS;\n\n/**\n * Current protocol version.\n */\n\nexports.protocol = 3;\n\n/**\n * Packet types.\n */\n\nvar packets = exports.packets = {\n    open:     0    // non-ws\n  , close:    1    // non-ws\n  , ping:     2\n  , pong:     3\n  , message:  4\n  , upgrade:  5\n  , noop:     6\n};\n\nvar packetslist = keys(packets);\n\n/**\n * Premade error packet.\n */\n\nvar err = { type: 'error', data: 'parser error' };\n\n/**\n * Create a blob api even for blob builder when vendor prefixes exist\n */\n\nvar Blob = require('blob');\n\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */\n\nexports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {\n  if ('function' == typeof supportsBinary) {\n    callback = supportsBinary;\n    supportsBinary = false;\n  }\n\n  if ('function' == typeof utf8encode) {\n    callback = utf8encode;\n    utf8encode = null;\n  }\n\n  var data = (packet.data === undefined)\n    ? undefined\n    : packet.data.buffer || packet.data;\n\n  if (global.ArrayBuffer && data instanceof ArrayBuffer) {\n    return encodeArrayBuffer(packet, supportsBinary, callback);\n  } else if (Blob && data instanceof global.Blob) {\n    return encodeBlob(packet, supportsBinary, callback);\n  }\n\n  // might be an object with { base64: true, data: dataAsBase64String }\n  if (data && data.base64) {\n    return encodeBase64Object(packet, callback);\n  }\n\n  // Sending data as a utf-8 string\n  var encoded = packets[packet.type];\n\n  // data fragment is optional\n  if (undefined !== packet.data) {\n    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);\n  }\n\n  return callback('' + encoded);\n\n};\n\nfunction encodeBase64Object(packet, callback) {\n  // packet data is an object { base64: true, data: dataAsBase64String }\n  var message = 'b' + exports.packets[packet.type] + packet.data.data;\n  return callback(message);\n}\n\n/**\n * Encode packet helpers for binary types\n */\n\nfunction encodeArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var data = packet.data;\n  var contentArray = new Uint8Array(data);\n  var resultBuffer = new Uint8Array(1 + data.byteLength);\n\n  resultBuffer[0] = packets[packet.type];\n  for (var i = 0; i < contentArray.length; i++) {\n    resultBuffer[i+1] = contentArray[i];\n  }\n\n  return callback(resultBuffer.buffer);\n}\n\nfunction encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var fr = new FileReader();\n  fr.onload = function() {\n    packet.data = fr.result;\n    exports.encodePacket(packet, supportsBinary, true, callback);\n  };\n  return fr.readAsArrayBuffer(packet.data);\n}\n\nfunction encodeBlob(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  if (dontSendBlobs) {\n    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);\n  }\n\n  var length = new Uint8Array(1);\n  length[0] = packets[packet.type];\n  var blob = new Blob([length.buffer, packet.data]);\n\n  return callback(blob);\n}\n\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */\n\nexports.encodeBase64Packet = function(packet, callback) {\n  var message = 'b' + exports.packets[packet.type];\n  if (Blob && packet.data instanceof global.Blob) {\n    var fr = new FileReader();\n    fr.onload = function() {\n      var b64 = fr.result.split(',')[1];\n      callback(message + b64);\n    };\n    return fr.readAsDataURL(packet.data);\n  }\n\n  var b64data;\n  try {\n    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));\n  } catch (e) {\n    // iPhone Safari doesn't let you apply with typed arrays\n    var typed = new Uint8Array(packet.data);\n    var basic = new Array(typed.length);\n    for (var i = 0; i < typed.length; i++) {\n      basic[i] = typed[i];\n    }\n    b64data = String.fromCharCode.apply(null, basic);\n  }\n  message += global.btoa(b64data);\n  return callback(message);\n};\n\n/**\n * Decodes a packet. Changes format to Blob if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */\n\nexports.decodePacket = function (data, binaryType, utf8decode) {\n  if (data === undefined) {\n    return err;\n  }\n  // String data\n  if (typeof data == 'string') {\n    if (data.charAt(0) == 'b') {\n      return exports.decodeBase64Packet(data.substr(1), binaryType);\n    }\n\n    if (utf8decode) {\n      data = tryDecode(data);\n      if (data === false) {\n        return err;\n      }\n    }\n    var type = data.charAt(0);\n\n    if (Number(type) != type || !packetslist[type]) {\n      return err;\n    }\n\n    if (data.length > 1) {\n      return { type: packetslist[type], data: data.substring(1) };\n    } else {\n      return { type: packetslist[type] };\n    }\n  }\n\n  var asArray = new Uint8Array(data);\n  var type = asArray[0];\n  var rest = sliceBuffer(data, 1);\n  if (Blob && binaryType === 'blob') {\n    rest = new Blob([rest]);\n  }\n  return { type: packetslist[type], data: rest };\n};\n\nfunction tryDecode(data) {\n  try {\n    data = utf8.decode(data);\n  } catch (e) {\n    return false;\n  }\n  return data;\n}\n\n/**\n * Decodes a packet encoded in a base64 string\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */\n\nexports.decodeBase64Packet = function(msg, binaryType) {\n  var type = packetslist[msg.charAt(0)];\n  if (!base64encoder) {\n    return { type: type, data: { base64: true, data: msg.substr(1) } };\n  }\n\n  var data = base64encoder.decode(msg.substr(1));\n\n  if (binaryType === 'blob' && Blob) {\n    data = new Blob([data]);\n  }\n\n  return { type: type, data: data };\n};\n\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */\n\nexports.encodePayload = function (packets, supportsBinary, callback) {\n  if (typeof supportsBinary == 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n\n  var isBinary = hasBinary(packets);\n\n  if (supportsBinary && isBinary) {\n    if (Blob && !dontSendBlobs) {\n      return exports.encodePayloadAsBlob(packets, callback);\n    }\n\n    return exports.encodePayloadAsArrayBuffer(packets, callback);\n  }\n\n  if (!packets.length) {\n    return callback('0:');\n  }\n\n  function setLengthHeader(message) {\n    return message.length + ':' + message;\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {\n      doneCallback(null, setLengthHeader(message));\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(results.join(''));\n  });\n};\n\n/**\n * Async array map using after\n */\n\nfunction map(ary, each, done) {\n  var result = new Array(ary.length);\n  var next = after(ary.length, done);\n\n  var eachWithIndex = function(i, el, cb) {\n    each(el, function(error, msg) {\n      result[i] = msg;\n      cb(error, result);\n    });\n  };\n\n  for (var i = 0; i < ary.length; i++) {\n    eachWithIndex(i, ary[i], next);\n  }\n}\n\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */\n\nexports.decodePayload = function (data, binaryType, callback) {\n  if (typeof data != 'string') {\n    return exports.decodePayloadAsBinary(data, binaryType, callback);\n  }\n\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var packet;\n  if (data == '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n  var length = ''\n    , n, msg;\n\n  for (var i = 0, l = data.length; i < l; i++) {\n    var chr = data.charAt(i);\n\n    if (':' != chr) {\n      length += chr;\n    } else {\n      if ('' == length || (length != (n = Number(length)))) {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      msg = data.substr(i + 1, n);\n\n      if (length != msg.length) {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      if (msg.length) {\n        packet = exports.decodePacket(msg, binaryType, true);\n\n        if (err.type == packet.type && err.data == packet.data) {\n          // parser error in individual packet - ignoring payload\n          return callback(err, 0, 1);\n        }\n\n        var ret = callback(packet, i + n, l);\n        if (false === ret) return;\n      }\n\n      // advance cursor\n      i += n;\n      length = '';\n    }\n  }\n\n  if (length != '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n};\n\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {ArrayBuffer} encoded payload\n * @api private\n */\n\nexports.encodePayloadAsArrayBuffer = function(packets, callback) {\n  if (!packets.length) {\n    return callback(new ArrayBuffer(0));\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(data) {\n      return doneCallback(null, data);\n    });\n  }\n\n  map(packets, encodeOne, function(err, encodedPackets) {\n    var totalLength = encodedPackets.reduce(function(acc, p) {\n      var len;\n      if (typeof p === 'string'){\n        len = p.length;\n      } else {\n        len = p.byteLength;\n      }\n      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2\n    }, 0);\n\n    var resultArray = new Uint8Array(totalLength);\n\n    var bufferIndex = 0;\n    encodedPackets.forEach(function(p) {\n      var isString = typeof p === 'string';\n      var ab = p;\n      if (isString) {\n        var view = new Uint8Array(p.length);\n        for (var i = 0; i < p.length; i++) {\n          view[i] = p.charCodeAt(i);\n        }\n        ab = view.buffer;\n      }\n\n      if (isString) { // not true binary\n        resultArray[bufferIndex++] = 0;\n      } else { // true binary\n        resultArray[bufferIndex++] = 1;\n      }\n\n      var lenStr = ab.byteLength.toString();\n      for (var i = 0; i < lenStr.length; i++) {\n        resultArray[bufferIndex++] = parseInt(lenStr[i]);\n      }\n      resultArray[bufferIndex++] = 255;\n\n      var view = new Uint8Array(ab);\n      for (var i = 0; i < view.length; i++) {\n        resultArray[bufferIndex++] = view[i];\n      }\n    });\n\n    return callback(resultArray.buffer);\n  });\n};\n\n/**\n * Encode as Blob\n */\n\nexports.encodePayloadAsBlob = function(packets, callback) {\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(encoded) {\n      var binaryIdentifier = new Uint8Array(1);\n      binaryIdentifier[0] = 1;\n      if (typeof encoded === 'string') {\n        var view = new Uint8Array(encoded.length);\n        for (var i = 0; i < encoded.length; i++) {\n          view[i] = encoded.charCodeAt(i);\n        }\n        encoded = view.buffer;\n        binaryIdentifier[0] = 0;\n      }\n\n      var len = (encoded instanceof ArrayBuffer)\n        ? encoded.byteLength\n        : encoded.size;\n\n      var lenStr = len.toString();\n      var lengthAry = new Uint8Array(lenStr.length + 1);\n      for (var i = 0; i < lenStr.length; i++) {\n        lengthAry[i] = parseInt(lenStr[i]);\n      }\n      lengthAry[lenStr.length] = 255;\n\n      if (Blob) {\n        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);\n        doneCallback(null, blob);\n      }\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(new Blob(results));\n  });\n};\n\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n *\n * @param {ArrayBuffer} data, callback method\n * @api public\n */\n\nexports.decodePayloadAsBinary = function (data, binaryType, callback) {\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var bufferTail = data;\n  var buffers = [];\n\n  var numberTooLong = false;\n  while (bufferTail.byteLength > 0) {\n    var tailArray = new Uint8Array(bufferTail);\n    var isString = tailArray[0] === 0;\n    var msgLength = '';\n\n    for (var i = 1; ; i++) {\n      if (tailArray[i] == 255) break;\n\n      if (msgLength.length > 310) {\n        numberTooLong = true;\n        break;\n      }\n\n      msgLength += tailArray[i];\n    }\n\n    if(numberTooLong) return callback(err, 0, 1);\n\n    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);\n    msgLength = parseInt(msgLength);\n\n    var msg = sliceBuffer(bufferTail, 0, msgLength);\n    if (isString) {\n      try {\n        msg = String.fromCharCode.apply(null, new Uint8Array(msg));\n      } catch (e) {\n        // iPhone Safari doesn't let you apply to typed arrays\n        var typed = new Uint8Array(msg);\n        msg = '';\n        for (var i = 0; i < typed.length; i++) {\n          msg += String.fromCharCode(typed[i]);\n        }\n      }\n    }\n\n    buffers.push(msg);\n    bufferTail = sliceBuffer(bufferTail, msgLength);\n  }\n\n  var total = buffers.length;\n  buffers.forEach(function(buffer, i) {\n    callback(exports.decodePacket(buffer, binaryType, true), i, total);\n  });\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/engine.io-parser/lib/browser.js\n ** module id = 98\n ** module chunks = 0\n **/","\n/**\n * Gets the keys for an object.\n *\n * @return {Array} keys\n * @api private\n */\n\nmodule.exports = Object.keys || function keys (obj){\n  var arr = [];\n  var has = Object.prototype.hasOwnProperty;\n\n  for (var i in obj) {\n    if (has.call(obj, i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/engine.io-parser/lib/keys.js\n ** module id = 99\n ** module chunks = 0\n **/","\n/*\n * Module requirements.\n */\n\nvar isArray = require('isarray');\n\n/**\n * Module exports.\n */\n\nmodule.exports = hasBinary;\n\n/**\n * Checks for binary data.\n *\n * Right now only Buffer and ArrayBuffer are supported..\n *\n * @param {Object} anything\n * @api public\n */\n\nfunction hasBinary(data) {\n\n  function _hasBinary(obj) {\n    if (!obj) return false;\n\n    if ( (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||\n         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||\n         (global.Blob && obj instanceof Blob) ||\n         (global.File && obj instanceof File)\n        ) {\n      return true;\n    }\n\n    if (isArray(obj)) {\n      for (var i = 0; i < obj.length; i++) {\n          if (_hasBinary(obj[i])) {\n              return true;\n          }\n      }\n    } else if (obj && 'object' == typeof obj) {\n      // see: https://github.com/Automattic/has-binary/pull/4\n      if (obj.toJSON && 'function' == typeof obj.toJSON) {\n        obj = obj.toJSON();\n      }\n\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return _hasBinary(data);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/has-binary/index.js\n ** module id = 100\n ** module chunks = 0\n **/","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/has-binary/~/isarray/index.js\n ** module id = 101\n ** module chunks = 0\n **/","/**\n * An abstraction for slicing an arraybuffer even when\n * ArrayBuffer.prototype.slice is not supported\n *\n * @api public\n */\n\nmodule.exports = function(arraybuffer, start, end) {\n  var bytes = arraybuffer.byteLength;\n  start = start || 0;\n  end = end || bytes;\n\n  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }\n\n  if (start < 0) { start += bytes; }\n  if (end < 0) { end += bytes; }\n  if (end > bytes) { end = bytes; }\n\n  if (start >= bytes || start >= end || bytes === 0) {\n    return new ArrayBuffer(0);\n  }\n\n  var abv = new Uint8Array(arraybuffer);\n  var result = new Uint8Array(end - start);\n  for (var i = start, ii = 0; i < end; i++, ii++) {\n    result[ii] = abv[i];\n  }\n  return result.buffer;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/arraybuffer.slice/index.js\n ** module id = 102\n ** module chunks = 0\n **/","module.exports = after\n\nfunction after(count, callback, err_cb) {\n    var bail = false\n    err_cb = err_cb || noop\n    proxy.count = count\n\n    return (count === 0) ? callback() : proxy\n\n    function proxy(err, result) {\n        if (proxy.count <= 0) {\n            throw new Error('after called too many times')\n        }\n        --proxy.count\n\n        // after first error, rest are passed to err_cb\n        if (err) {\n            bail = true\n            callback(err)\n            // future error callbacks will go to error handler\n            callback = err_cb\n        } else if (proxy.count === 0 && !bail) {\n            callback(null, result)\n        }\n    }\n}\n\nfunction noop() {}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/after/index.js\n ** module id = 103\n ** module chunks = 0\n **/","/*! https://mths.be/wtf8 v1.0.0 by @mathias */\n;(function(root) {\n\n\t// Detect free variables `exports`\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code,\n\t// and use it as `root`\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar stringFromCharCode = String.fromCharCode;\n\n\t// Taken from https://mths.be/punycode\n\tfunction ucs2decode(string) {\n\t\tvar output = [];\n\t\tvar counter = 0;\n\t\tvar length = string.length;\n\t\tvar value;\n\t\tvar extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t// Taken from https://mths.be/punycode\n\tfunction ucs2encode(array) {\n\t\tvar length = array.length;\n\t\tvar index = -1;\n\t\tvar value;\n\t\tvar output = '';\n\t\twhile (++index < length) {\n\t\t\tvalue = array[index];\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t}\n\t\treturn output;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tfunction createByte(codePoint, shift) {\n\t\treturn stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);\n\t}\n\n\tfunction encodeCodePoint(codePoint) {\n\t\tif ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence\n\t\t\treturn stringFromCharCode(codePoint);\n\t\t}\n\t\tvar symbol = '';\n\t\tif ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);\n\t\t}\n\t\telse if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);\n\t\t\tsymbol += createByte(codePoint, 6);\n\t\t}\n\t\telse if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);\n\t\t\tsymbol += createByte(codePoint, 12);\n\t\t\tsymbol += createByte(codePoint, 6);\n\t\t}\n\t\tsymbol += stringFromCharCode((codePoint & 0x3F) | 0x80);\n\t\treturn symbol;\n\t}\n\n\tfunction wtf8encode(string) {\n\t\tvar codePoints = ucs2decode(string);\n\t\tvar length = codePoints.length;\n\t\tvar index = -1;\n\t\tvar codePoint;\n\t\tvar byteString = '';\n\t\twhile (++index < length) {\n\t\t\tcodePoint = codePoints[index];\n\t\t\tbyteString += encodeCodePoint(codePoint);\n\t\t}\n\t\treturn byteString;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tfunction readContinuationByte() {\n\t\tif (byteIndex >= byteCount) {\n\t\t\tthrow Error('Invalid byte index');\n\t\t}\n\n\t\tvar continuationByte = byteArray[byteIndex] & 0xFF;\n\t\tbyteIndex++;\n\n\t\tif ((continuationByte & 0xC0) == 0x80) {\n\t\t\treturn continuationByte & 0x3F;\n\t\t}\n\n\t\t// If we end up here, it’s not a continuation byte.\n\t\tthrow Error('Invalid continuation byte');\n\t}\n\n\tfunction decodeSymbol() {\n\t\tvar byte1;\n\t\tvar byte2;\n\t\tvar byte3;\n\t\tvar byte4;\n\t\tvar codePoint;\n\n\t\tif (byteIndex > byteCount) {\n\t\t\tthrow Error('Invalid byte index');\n\t\t}\n\n\t\tif (byteIndex == byteCount) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Read the first byte.\n\t\tbyte1 = byteArray[byteIndex] & 0xFF;\n\t\tbyteIndex++;\n\n\t\t// 1-byte sequence (no continuation bytes)\n\t\tif ((byte1 & 0x80) == 0) {\n\t\t\treturn byte1;\n\t\t}\n\n\t\t// 2-byte sequence\n\t\tif ((byte1 & 0xE0) == 0xC0) {\n\t\t\tvar byte2 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x1F) << 6) | byte2;\n\t\t\tif (codePoint >= 0x80) {\n\t\t\t\treturn codePoint;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t}\n\t\t}\n\n\t\t// 3-byte sequence (may include unpaired surrogates)\n\t\tif ((byte1 & 0xF0) == 0xE0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tbyte3 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;\n\t\t\tif (codePoint >= 0x0800) {\n\t\t\t\treturn codePoint;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t}\n\t\t}\n\n\t\t// 4-byte sequence\n\t\tif ((byte1 & 0xF8) == 0xF0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tbyte3 = readContinuationByte();\n\t\t\tbyte4 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |\n\t\t\t\t(byte3 << 0x06) | byte4;\n\t\t\tif (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n\t\t\t\treturn codePoint;\n\t\t\t}\n\t\t}\n\n\t\tthrow Error('Invalid WTF-8 detected');\n\t}\n\n\tvar byteArray;\n\tvar byteCount;\n\tvar byteIndex;\n\tfunction wtf8decode(byteString) {\n\t\tbyteArray = ucs2decode(byteString);\n\t\tbyteCount = byteArray.length;\n\t\tbyteIndex = 0;\n\t\tvar codePoints = [];\n\t\tvar tmp;\n\t\twhile ((tmp = decodeSymbol()) !== false) {\n\t\t\tcodePoints.push(tmp);\n\t\t}\n\t\treturn ucs2encode(codePoints);\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar wtf8 = {\n\t\t'version': '1.0.0',\n\t\t'encode': wtf8encode,\n\t\t'decode': wtf8decode\n\t};\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine(function() {\n\t\t\treturn wtf8;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = wtf8;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tvar object = {};\n\t\t\tvar hasOwnProperty = object.hasOwnProperty;\n\t\t\tfor (var key in wtf8) {\n\t\t\t\thasOwnProperty.call(wtf8, key) && (freeExports[key] = wtf8[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.wtf8 = wtf8;\n\t}\n\n}(this));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/wtf-8/wtf-8.js\n ** module id = 104\n ** module chunks = 0\n **/","/*\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n(function(){\n  \"use strict\";\n\n  var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n  // Use a lookup table to find the index.\n  var lookup = new Uint8Array(256);\n  for (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n  }\n\n  exports.encode = function(arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer),\n    i, len = bytes.length, base64 = \"\";\n\n    for (i = 0; i < len; i+=3) {\n      base64 += chars[bytes[i] >> 2];\n      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n      base64 += chars[bytes[i + 2] & 63];\n    }\n\n    if ((len % 3) === 2) {\n      base64 = base64.substring(0, base64.length - 1) + \"=\";\n    } else if (len % 3 === 1) {\n      base64 = base64.substring(0, base64.length - 2) + \"==\";\n    }\n\n    return base64;\n  };\n\n  exports.decode =  function(base64) {\n    var bufferLength = base64.length * 0.75,\n    len = base64.length, i, p = 0,\n    encoded1, encoded2, encoded3, encoded4;\n\n    if (base64[base64.length - 1] === \"=\") {\n      bufferLength--;\n      if (base64[base64.length - 2] === \"=\") {\n        bufferLength--;\n      }\n    }\n\n    var arraybuffer = new ArrayBuffer(bufferLength),\n    bytes = new Uint8Array(arraybuffer);\n\n    for (i = 0; i < len; i+=4) {\n      encoded1 = lookup[base64.charCodeAt(i)];\n      encoded2 = lookup[base64.charCodeAt(i+1)];\n      encoded3 = lookup[base64.charCodeAt(i+2)];\n      encoded4 = lookup[base64.charCodeAt(i+3)];\n\n      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n\n    return arraybuffer;\n  };\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/base64-arraybuffer/lib/base64-arraybuffer.js\n ** module id = 105\n ** module chunks = 0\n **/","/**\n * Create a blob builder even when vendor prefixes exist\n */\n\nvar BlobBuilder = global.BlobBuilder\n  || global.WebKitBlobBuilder\n  || global.MSBlobBuilder\n  || global.MozBlobBuilder;\n\n/**\n * Check if Blob constructor is supported\n */\n\nvar blobSupported = (function() {\n  try {\n    var a = new Blob(['hi']);\n    return a.size === 2;\n  } catch(e) {\n    return false;\n  }\n})();\n\n/**\n * Check if Blob constructor supports ArrayBufferViews\n * Fails in Safari 6, so we need to map to ArrayBuffers there.\n */\n\nvar blobSupportsArrayBufferView = blobSupported && (function() {\n  try {\n    var b = new Blob([new Uint8Array([1,2])]);\n    return b.size === 2;\n  } catch(e) {\n    return false;\n  }\n})();\n\n/**\n * Check if BlobBuilder is supported\n */\n\nvar blobBuilderSupported = BlobBuilder\n  && BlobBuilder.prototype.append\n  && BlobBuilder.prototype.getBlob;\n\n/**\n * Helper function that maps ArrayBufferViews to ArrayBuffers\n * Used by BlobBuilder constructor and old browsers that didn't\n * support it in the Blob constructor.\n */\n\nfunction mapArrayBufferViews(ary) {\n  for (var i = 0; i < ary.length; i++) {\n    var chunk = ary[i];\n    if (chunk.buffer instanceof ArrayBuffer) {\n      var buf = chunk.buffer;\n\n      // if this is a subarray, make a copy so we only\n      // include the subarray region from the underlying buffer\n      if (chunk.byteLength !== buf.byteLength) {\n        var copy = new Uint8Array(chunk.byteLength);\n        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));\n        buf = copy.buffer;\n      }\n\n      ary[i] = buf;\n    }\n  }\n}\n\nfunction BlobBuilderConstructor(ary, options) {\n  options = options || {};\n\n  var bb = new BlobBuilder();\n  mapArrayBufferViews(ary);\n\n  for (var i = 0; i < ary.length; i++) {\n    bb.append(ary[i]);\n  }\n\n  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();\n};\n\nfunction BlobConstructor(ary, options) {\n  mapArrayBufferViews(ary);\n  return new Blob(ary, options || {});\n};\n\nmodule.exports = (function() {\n  if (blobSupported) {\n    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;\n  } else if (blobBuilderSupported) {\n    return BlobBuilderConstructor;\n  } else {\n    return undefined;\n  }\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/blob/index.js\n ** module id = 106\n ** module chunks = 0\n **/","/**\r\n * Compiles a querystring\r\n * Returns string representation of the object\r\n *\r\n * @param {Object}\r\n * @api private\r\n */\r\n\r\nexports.encode = function (obj) {\r\n  var str = '';\r\n\r\n  for (var i in obj) {\r\n    if (obj.hasOwnProperty(i)) {\r\n      if (str.length) str += '&';\r\n      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\r\n    }\r\n  }\r\n\r\n  return str;\r\n};\r\n\r\n/**\r\n * Parses a simple querystring into an object\r\n *\r\n * @param {String} qs\r\n * @api private\r\n */\r\n\r\nexports.decode = function(qs){\r\n  var qry = {};\r\n  var pairs = qs.split('&');\r\n  for (var i = 0, l = pairs.length; i < l; i++) {\r\n    var pair = pairs[i].split('=');\r\n    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\r\n  }\r\n  return qry;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/parseqs/index.js\n ** module id = 107\n ** module chunks = 0\n **/","\nmodule.exports = function(a, b){\n  var fn = function(){};\n  fn.prototype = b.prototype;\n  a.prototype = new fn;\n  a.prototype.constructor = a;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/component-inherit/index.js\n ** module id = 108\n ** module chunks = 0\n **/","'use strict';\n\nvar alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')\n  , length = 64\n  , map = {}\n  , seed = 0\n  , i = 0\n  , prev;\n\n/**\n * Return a string representing the specified number.\n *\n * @param {Number} num The number to convert.\n * @returns {String} The string representation of the number.\n * @api public\n */\nfunction encode(num) {\n  var encoded = '';\n\n  do {\n    encoded = alphabet[num % length] + encoded;\n    num = Math.floor(num / length);\n  } while (num > 0);\n\n  return encoded;\n}\n\n/**\n * Return the integer value specified by the given string.\n *\n * @param {String} str The string to convert.\n * @returns {Number} The integer value represented by the string.\n * @api public\n */\nfunction decode(str) {\n  var decoded = 0;\n\n  for (i = 0; i < str.length; i++) {\n    decoded = decoded * length + map[str.charAt(i)];\n  }\n\n  return decoded;\n}\n\n/**\n * Yeast: A tiny growing id generator.\n *\n * @returns {String} A unique id.\n * @api public\n */\nfunction yeast() {\n  var now = encode(+new Date());\n\n  if (now !== prev) return seed = 0, prev = now;\n  return now +'.'+ encode(seed++);\n}\n\n//\n// Map each character to its index.\n//\nfor (; i < length; i++) map[alphabet[i]] = i;\n\n//\n// Expose the `yeast`, `encode` and `decode` functions.\n//\nyeast.encode = encode;\nyeast.decode = decode;\nmodule.exports = yeast;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/yeast/index.js\n ** module id = 109\n ** module chunks = 0\n **/","\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && 'WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    return exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (typeof process !== 'undefined' && 'env' in process) {\n    return process.env.DEBUG;\n  }\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage(){\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/engine.io-client/~/debug/browser.js\n ** module id = 110\n ** module chunks = 0\n **/","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug.debug = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting\n    args = exports.formatArgs.apply(self, args);\n\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/[\\\\^$+?.()|[\\]{}]/g, '\\\\$&').replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/engine.io-client/~/debug/debug.js\n ** module id = 111\n ** module chunks = 0\n **/","/**\n * Helpers.\n */\n\nvar s = 1000\nvar m = s * 60\nvar h = m * 60\nvar d = h * 24\nvar y = d * 365.25\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {}\n  var type = typeof val\n  if (type === 'string' && val.length > 0) {\n    return parse(val)\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ?\n\t\t\tfmtLong(val) :\n\t\t\tfmtShort(val)\n  }\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))\n}\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str)\n  if (str.length > 10000) {\n    return\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)\n  if (!match) {\n    return\n  }\n  var n = parseFloat(match[1])\n  var type = (match[2] || 'ms').toLowerCase()\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n\n    default:\n      return undefined\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd'\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h'\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm'\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's'\n  }\n  return ms + 'ms'\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms'\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's'\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/engine.io-client/~/ms/index.js\n ** module id = 112\n ** module chunks = 0\n **/","\n/**\n * Module requirements.\n */\n\nvar Polling = require('./polling');\nvar inherit = require('component-inherit');\n\n/**\n * Module exports.\n */\n\nmodule.exports = JSONPPolling;\n\n/**\n * Cached regular expressions.\n */\n\nvar rNewline = /\\n/g;\nvar rEscapedNewline = /\\\\n/g;\n\n/**\n * Global JSONP callbacks.\n */\n\nvar callbacks;\n\n/**\n * Noop.\n */\n\nfunction empty () { }\n\n/**\n * JSONP Polling constructor.\n *\n * @param {Object} opts.\n * @api public\n */\n\nfunction JSONPPolling (opts) {\n  Polling.call(this, opts);\n\n  this.query = this.query || {};\n\n  // define global callbacks array if not present\n  // we do this here (lazily) to avoid unneeded global pollution\n  if (!callbacks) {\n    // we need to consider multiple engines in the same page\n    if (!global.___eio) global.___eio = [];\n    callbacks = global.___eio;\n  }\n\n  // callback identifier\n  this.index = callbacks.length;\n\n  // add callback to jsonp global\n  var self = this;\n  callbacks.push(function (msg) {\n    self.onData(msg);\n  });\n\n  // append to query string\n  this.query.j = this.index;\n\n  // prevent spurious errors from being emitted when the window is unloaded\n  if (global.document && global.addEventListener) {\n    global.addEventListener('beforeunload', function () {\n      if (self.script) self.script.onerror = empty;\n    }, false);\n  }\n}\n\n/**\n * Inherits from Polling.\n */\n\ninherit(JSONPPolling, Polling);\n\n/*\n * JSONP only supports binary as base64 encoded strings\n */\n\nJSONPPolling.prototype.supportsBinary = false;\n\n/**\n * Closes the socket.\n *\n * @api private\n */\n\nJSONPPolling.prototype.doClose = function () {\n  if (this.script) {\n    this.script.parentNode.removeChild(this.script);\n    this.script = null;\n  }\n\n  if (this.form) {\n    this.form.parentNode.removeChild(this.form);\n    this.form = null;\n    this.iframe = null;\n  }\n\n  Polling.prototype.doClose.call(this);\n};\n\n/**\n * Starts a poll cycle.\n *\n * @api private\n */\n\nJSONPPolling.prototype.doPoll = function () {\n  var self = this;\n  var script = document.createElement('script');\n\n  if (this.script) {\n    this.script.parentNode.removeChild(this.script);\n    this.script = null;\n  }\n\n  script.async = true;\n  script.src = this.uri();\n  script.onerror = function (e) {\n    self.onError('jsonp poll error', e);\n  };\n\n  var insertAt = document.getElementsByTagName('script')[0];\n  if (insertAt) {\n    insertAt.parentNode.insertBefore(script, insertAt);\n  } else {\n    (document.head || document.body).appendChild(script);\n  }\n  this.script = script;\n\n  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);\n\n  if (isUAgecko) {\n    setTimeout(function () {\n      var iframe = document.createElement('iframe');\n      document.body.appendChild(iframe);\n      document.body.removeChild(iframe);\n    }, 100);\n  }\n};\n\n/**\n * Writes with a hidden iframe.\n *\n * @param {String} data to send\n * @param {Function} called upon flush.\n * @api private\n */\n\nJSONPPolling.prototype.doWrite = function (data, fn) {\n  var self = this;\n\n  if (!this.form) {\n    var form = document.createElement('form');\n    var area = document.createElement('textarea');\n    var id = this.iframeId = 'eio_iframe_' + this.index;\n    var iframe;\n\n    form.className = 'socketio';\n    form.style.position = 'absolute';\n    form.style.top = '-1000px';\n    form.style.left = '-1000px';\n    form.target = id;\n    form.method = 'POST';\n    form.setAttribute('accept-charset', 'utf-8');\n    area.name = 'd';\n    form.appendChild(area);\n    document.body.appendChild(form);\n\n    this.form = form;\n    this.area = area;\n  }\n\n  this.form.action = this.uri();\n\n  function complete () {\n    initIframe();\n    fn();\n  }\n\n  function initIframe () {\n    if (self.iframe) {\n      try {\n        self.form.removeChild(self.iframe);\n      } catch (e) {\n        self.onError('jsonp polling iframe removal error', e);\n      }\n    }\n\n    try {\n      // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n      var html = '<iframe src=\"javascript:0\" name=\"' + self.iframeId + '\">';\n      iframe = document.createElement(html);\n    } catch (e) {\n      iframe = document.createElement('iframe');\n      iframe.name = self.iframeId;\n      iframe.src = 'javascript:0';\n    }\n\n    iframe.id = self.iframeId;\n\n    self.form.appendChild(iframe);\n    self.iframe = iframe;\n  }\n\n  initIframe();\n\n  // escape \\n to prevent it from being converted into \\r\\n by some UAs\n  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side\n  data = data.replace(rEscapedNewline, '\\\\\\n');\n  this.area.value = data.replace(rNewline, '\\\\n');\n\n  try {\n    this.form.submit();\n  } catch (e) {}\n\n  if (this.iframe.attachEvent) {\n    this.iframe.onreadystatechange = function () {\n      if (self.iframe.readyState === 'complete') {\n        complete();\n      }\n    };\n  } else {\n    this.iframe.onload = complete;\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/engine.io-client/lib/transports/polling-jsonp.js\n ** module id = 113\n ** module chunks = 0\n **/","/**\n * Module dependencies.\n */\n\nvar Transport = require('../transport');\nvar parser = require('engine.io-parser');\nvar parseqs = require('parseqs');\nvar inherit = require('component-inherit');\nvar yeast = require('yeast');\nvar debug = require('debug')('engine.io-client:websocket');\nvar BrowserWebSocket = global.WebSocket || global.MozWebSocket;\nvar NodeWebSocket;\nif (typeof window === 'undefined') {\n  try {\n    NodeWebSocket = require('ws');\n  } catch (e) { }\n}\n\n/**\n * Get either the `WebSocket` or `MozWebSocket` globals\n * in the browser or try to resolve WebSocket-compatible\n * interface exposed by `ws` for Node-like environment.\n */\n\nvar WebSocket = BrowserWebSocket;\nif (!WebSocket && typeof window === 'undefined') {\n  WebSocket = NodeWebSocket;\n}\n\n/**\n * Module exports.\n */\n\nmodule.exports = WS;\n\n/**\n * WebSocket transport constructor.\n *\n * @api {Object} connection options\n * @api public\n */\n\nfunction WS (opts) {\n  var forceBase64 = (opts && opts.forceBase64);\n  if (forceBase64) {\n    this.supportsBinary = false;\n  }\n  this.perMessageDeflate = opts.perMessageDeflate;\n  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;\n  if (!this.usingBrowserWebSocket) {\n    WebSocket = NodeWebSocket;\n  }\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(WS, Transport);\n\n/**\n * Transport name.\n *\n * @api public\n */\n\nWS.prototype.name = 'websocket';\n\n/*\n * WebSockets support binary\n */\n\nWS.prototype.supportsBinary = true;\n\n/**\n * Opens socket.\n *\n * @api private\n */\n\nWS.prototype.doOpen = function () {\n  if (!this.check()) {\n    // let probe timeout\n    return;\n  }\n\n  var uri = this.uri();\n  var protocols = void (0);\n  var opts = {\n    agent: this.agent,\n    perMessageDeflate: this.perMessageDeflate\n  };\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n  if (this.extraHeaders) {\n    opts.headers = this.extraHeaders;\n  }\n  if (this.localAddress) {\n    opts.localAddress = this.localAddress;\n  }\n\n  try {\n    this.ws = this.usingBrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);\n  } catch (err) {\n    return this.emit('error', err);\n  }\n\n  if (this.ws.binaryType === undefined) {\n    this.supportsBinary = false;\n  }\n\n  if (this.ws.supports && this.ws.supports.binary) {\n    this.supportsBinary = true;\n    this.ws.binaryType = 'nodebuffer';\n  } else {\n    this.ws.binaryType = 'arraybuffer';\n  }\n\n  this.addEventListeners();\n};\n\n/**\n * Adds event listeners to the socket\n *\n * @api private\n */\n\nWS.prototype.addEventListeners = function () {\n  var self = this;\n\n  this.ws.onopen = function () {\n    self.onOpen();\n  };\n  this.ws.onclose = function () {\n    self.onClose();\n  };\n  this.ws.onmessage = function (ev) {\n    self.onData(ev.data);\n  };\n  this.ws.onerror = function (e) {\n    self.onError('websocket error', e);\n  };\n};\n\n/**\n * Writes data to socket.\n *\n * @param {Array} array of packets.\n * @api private\n */\n\nWS.prototype.write = function (packets) {\n  var self = this;\n  this.writable = false;\n\n  // encodePacket efficient as it uses WS framing\n  // no need for encodePayload\n  var total = packets.length;\n  for (var i = 0, l = total; i < l; i++) {\n    (function (packet) {\n      parser.encodePacket(packet, self.supportsBinary, function (data) {\n        if (!self.usingBrowserWebSocket) {\n          // always create a new object (GH-437)\n          var opts = {};\n          if (packet.options) {\n            opts.compress = packet.options.compress;\n          }\n\n          if (self.perMessageDeflate) {\n            var len = 'string' === typeof data ? global.Buffer.byteLength(data) : data.length;\n            if (len < self.perMessageDeflate.threshold) {\n              opts.compress = false;\n            }\n          }\n        }\n\n        // Sometimes the websocket has already been closed but the browser didn't\n        // have a chance of informing us about it yet, in that case send will\n        // throw an error\n        try {\n          if (self.usingBrowserWebSocket) {\n            // TypeError is thrown when passing the second argument on Safari\n            self.ws.send(data);\n          } else {\n            self.ws.send(data, opts);\n          }\n        } catch (e) {\n          debug('websocket closed before onclose event');\n        }\n\n        --total || done();\n      });\n    })(packets[i]);\n  }\n\n  function done () {\n    self.emit('flush');\n\n    // fake drain\n    // defer to next tick to allow Socket to clear writeBuffer\n    setTimeout(function () {\n      self.writable = true;\n      self.emit('drain');\n    }, 0);\n  }\n};\n\n/**\n * Called upon close\n *\n * @api private\n */\n\nWS.prototype.onClose = function () {\n  Transport.prototype.onClose.call(this);\n};\n\n/**\n * Closes socket.\n *\n * @api private\n */\n\nWS.prototype.doClose = function () {\n  if (typeof this.ws !== 'undefined') {\n    this.ws.close();\n  }\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nWS.prototype.uri = function () {\n  var query = this.query || {};\n  var schema = this.secure ? 'wss' : 'ws';\n  var port = '';\n\n  // avoid port if default for schema\n  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||\n    ('ws' === schema && Number(this.port) !== 80))) {\n    port = ':' + this.port;\n  }\n\n  // append timestamp to URI\n  if (this.timestampRequests) {\n    query[this.timestampParam] = yeast();\n  }\n\n  // communicate binary support capabilities\n  if (!this.supportsBinary) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  var ipv6 = this.hostname.indexOf(':') !== -1;\n  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n};\n\n/**\n * Feature detection for WebSocket.\n *\n * @return {Boolean} whether this transport is available.\n * @api public\n */\n\nWS.prototype.check = function () {\n  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/engine.io-client/lib/transports/websocket.js\n ** module id = 114\n ** module chunks = 0\n **/","\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/indexof/index.js\n ** module id = 116\n ** module chunks = 0\n **/","/**\r\n * JSON parse.\r\n *\r\n * @see Based on jQuery#parseJSON (MIT) and JSON2\r\n * @api private\r\n */\r\n\r\nvar rvalidchars = /^[\\],:{}\\s]*$/;\r\nvar rvalidescape = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;\r\nvar rvalidtokens = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\r\nvar rvalidbraces = /(?:^|:|,)(?:\\s*\\[)+/g;\r\nvar rtrimLeft = /^\\s+/;\r\nvar rtrimRight = /\\s+$/;\r\n\r\nmodule.exports = function parsejson(data) {\r\n  if ('string' != typeof data || !data) {\r\n    return null;\r\n  }\r\n\r\n  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');\r\n\r\n  // Attempt to parse using the native JSON parser first\r\n  if (global.JSON && JSON.parse) {\r\n    return JSON.parse(data);\r\n  }\r\n\r\n  if (rvalidchars.test(data.replace(rvalidescape, '@')\r\n      .replace(rvalidtokens, ']')\r\n      .replace(rvalidbraces, ''))) {\r\n    return (new Function('return ' + data))();\r\n  }\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/parsejson/index.js\n ** module id = 117\n ** module chunks = 0\n **/","\n/**\n * Module dependencies.\n */\n\nvar parser = require('socket.io-parser');\nvar Emitter = require('component-emitter');\nvar toArray = require('to-array');\nvar on = require('./on');\nvar bind = require('component-bind');\nvar debug = require('debug')('socket.io-client:socket');\nvar hasBin = require('has-binary');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = Socket;\n\n/**\n * Internal events (blacklisted).\n * These events can't be emitted by the user.\n *\n * @api private\n */\n\nvar events = {\n  connect: 1,\n  connect_error: 1,\n  connect_timeout: 1,\n  connecting: 1,\n  disconnect: 1,\n  error: 1,\n  reconnect: 1,\n  reconnect_attempt: 1,\n  reconnect_failed: 1,\n  reconnect_error: 1,\n  reconnecting: 1,\n  ping: 1,\n  pong: 1\n};\n\n/**\n * Shortcut to `Emitter#emit`.\n */\n\nvar emit = Emitter.prototype.emit;\n\n/**\n * `Socket` constructor.\n *\n * @api public\n */\n\nfunction Socket (io, nsp, opts) {\n  this.io = io;\n  this.nsp = nsp;\n  this.json = this; // compat\n  this.ids = 0;\n  this.acks = {};\n  this.receiveBuffer = [];\n  this.sendBuffer = [];\n  this.connected = false;\n  this.disconnected = true;\n  if (opts && opts.query) {\n    this.query = opts.query;\n  }\n  if (this.io.autoConnect) this.open();\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Socket.prototype);\n\n/**\n * Subscribe to open, close and packet events\n *\n * @api private\n */\n\nSocket.prototype.subEvents = function () {\n  if (this.subs) return;\n\n  var io = this.io;\n  this.subs = [\n    on(io, 'open', bind(this, 'onopen')),\n    on(io, 'packet', bind(this, 'onpacket')),\n    on(io, 'close', bind(this, 'onclose'))\n  ];\n};\n\n/**\n * \"Opens\" the socket.\n *\n * @api public\n */\n\nSocket.prototype.open =\nSocket.prototype.connect = function () {\n  if (this.connected) return this;\n\n  this.subEvents();\n  this.io.open(); // ensure open\n  if ('open' === this.io.readyState) this.onopen();\n  this.emit('connecting');\n  return this;\n};\n\n/**\n * Sends a `message` event.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.send = function () {\n  var args = toArray(arguments);\n  args.unshift('message');\n  this.emit.apply(this, args);\n  return this;\n};\n\n/**\n * Override `emit`.\n * If the event is in `events`, it's emitted normally.\n *\n * @param {String} event name\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.emit = function (ev) {\n  if (events.hasOwnProperty(ev)) {\n    emit.apply(this, arguments);\n    return this;\n  }\n\n  var args = toArray(arguments);\n  var parserType = parser.EVENT; // default\n  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary\n  var packet = { type: parserType, data: args };\n\n  packet.options = {};\n  packet.options.compress = !this.flags || false !== this.flags.compress;\n\n  // event ack callback\n  if ('function' === typeof args[args.length - 1]) {\n    debug('emitting packet with ack id %d', this.ids);\n    this.acks[this.ids] = args.pop();\n    packet.id = this.ids++;\n  }\n\n  if (this.connected) {\n    this.packet(packet);\n  } else {\n    this.sendBuffer.push(packet);\n  }\n\n  delete this.flags;\n\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.packet = function (packet) {\n  packet.nsp = this.nsp;\n  this.io.packet(packet);\n};\n\n/**\n * Called upon engine `open`.\n *\n * @api private\n */\n\nSocket.prototype.onopen = function () {\n  debug('transport is open - connecting');\n\n  // write connect packet if necessary\n  if ('/' !== this.nsp) {\n    if (this.query) {\n      this.packet({type: parser.CONNECT, query: this.query});\n    } else {\n      this.packet({type: parser.CONNECT});\n    }\n  }\n};\n\n/**\n * Called upon engine `close`.\n *\n * @param {String} reason\n * @api private\n */\n\nSocket.prototype.onclose = function (reason) {\n  debug('close (%s)', reason);\n  this.connected = false;\n  this.disconnected = true;\n  delete this.id;\n  this.emit('disconnect', reason);\n};\n\n/**\n * Called with socket packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onpacket = function (packet) {\n  if (packet.nsp !== this.nsp) return;\n\n  switch (packet.type) {\n    case parser.CONNECT:\n      this.onconnect();\n      break;\n\n    case parser.EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.BINARY_EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.ACK:\n      this.onack(packet);\n      break;\n\n    case parser.BINARY_ACK:\n      this.onack(packet);\n      break;\n\n    case parser.DISCONNECT:\n      this.ondisconnect();\n      break;\n\n    case parser.ERROR:\n      this.emit('error', packet.data);\n      break;\n  }\n};\n\n/**\n * Called upon a server event.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onevent = function (packet) {\n  var args = packet.data || [];\n  debug('emitting event %j', args);\n\n  if (null != packet.id) {\n    debug('attaching ack callback to event');\n    args.push(this.ack(packet.id));\n  }\n\n  if (this.connected) {\n    emit.apply(this, args);\n  } else {\n    this.receiveBuffer.push(args);\n  }\n};\n\n/**\n * Produces an ack callback to emit with an event.\n *\n * @api private\n */\n\nSocket.prototype.ack = function (id) {\n  var self = this;\n  var sent = false;\n  return function () {\n    // prevent double callbacks\n    if (sent) return;\n    sent = true;\n    var args = toArray(arguments);\n    debug('sending ack %j', args);\n\n    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;\n    self.packet({\n      type: type,\n      id: id,\n      data: args\n    });\n  };\n};\n\n/**\n * Called upon a server acknowlegement.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onack = function (packet) {\n  var ack = this.acks[packet.id];\n  if ('function' === typeof ack) {\n    debug('calling ack %s with %j', packet.id, packet.data);\n    ack.apply(this, packet.data);\n    delete this.acks[packet.id];\n  } else {\n    debug('bad ack %s', packet.id);\n  }\n};\n\n/**\n * Called upon server connect.\n *\n * @api private\n */\n\nSocket.prototype.onconnect = function () {\n  this.connected = true;\n  this.disconnected = false;\n  this.emit('connect');\n  this.emitBuffered();\n};\n\n/**\n * Emit buffered events (received and emitted).\n *\n * @api private\n */\n\nSocket.prototype.emitBuffered = function () {\n  var i;\n  for (i = 0; i < this.receiveBuffer.length; i++) {\n    emit.apply(this, this.receiveBuffer[i]);\n  }\n  this.receiveBuffer = [];\n\n  for (i = 0; i < this.sendBuffer.length; i++) {\n    this.packet(this.sendBuffer[i]);\n  }\n  this.sendBuffer = [];\n};\n\n/**\n * Called upon server disconnect.\n *\n * @api private\n */\n\nSocket.prototype.ondisconnect = function () {\n  debug('server disconnect (%s)', this.nsp);\n  this.destroy();\n  this.onclose('io server disconnect');\n};\n\n/**\n * Called upon forced client/server side disconnections,\n * this method ensures the manager stops tracking us and\n * that reconnections don't get triggered for this.\n *\n * @api private.\n */\n\nSocket.prototype.destroy = function () {\n  if (this.subs) {\n    // clean subscriptions to avoid reconnections\n    for (var i = 0; i < this.subs.length; i++) {\n      this.subs[i].destroy();\n    }\n    this.subs = null;\n  }\n\n  this.io.destroy(this);\n};\n\n/**\n * Disconnects the socket manually.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.close =\nSocket.prototype.disconnect = function () {\n  if (this.connected) {\n    debug('performing disconnect (%s)', this.nsp);\n    this.packet({ type: parser.DISCONNECT });\n  }\n\n  // remove socket from pool\n  this.destroy();\n\n  if (this.connected) {\n    // fire events\n    this.onclose('io client disconnect');\n  }\n  return this;\n};\n\n/**\n * Sets the compress flag.\n *\n * @param {Boolean} if `true`, compresses the sending data\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.compress = function (compress) {\n  this.flags = this.flags || {};\n  this.flags.compress = compress;\n  return this;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/socket.io-client/lib/socket.js\n ** module id = 118\n ** module chunks = 0\n **/","module.exports = toArray\n\nfunction toArray(list, index) {\n    var array = []\n\n    index = index || 0\n\n    for (var i = index || 0; i < list.length; i++) {\n        array[i - index] = list[i]\n    }\n\n    return array\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/to-array/index.js\n ** module id = 119\n ** module chunks = 0\n **/","\n/**\n * Module exports.\n */\n\nmodule.exports = on;\n\n/**\n * Helper for subscriptions.\n *\n * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`\n * @param {String} event name\n * @param {Function} callback\n * @api public\n */\n\nfunction on (obj, ev, fn) {\n  obj.on(ev, fn);\n  return {\n    destroy: function () {\n      obj.removeListener(ev, fn);\n    }\n  };\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/socket.io-client/lib/on.js\n ** module id = 120\n ** module chunks = 0\n **/","/**\n * Slice reference.\n */\n\nvar slice = [].slice;\n\n/**\n * Bind `obj` to `fn`.\n *\n * @param {Object} obj\n * @param {Function|String} fn or string\n * @return {Function}\n * @api public\n */\n\nmodule.exports = function(obj, fn){\n  if ('string' == typeof fn) fn = obj[fn];\n  if ('function' != typeof fn) throw new Error('bind() requires a function');\n  var args = slice.call(arguments, 2);\n  return function(){\n    return fn.apply(obj, args.concat(slice.call(arguments)));\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/component-bind/index.js\n ** module id = 121\n ** module chunks = 0\n **/","\n/**\n * Expose `Backoff`.\n */\n\nmodule.exports = Backoff;\n\n/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction Backoff(opts) {\n  opts = opts || {};\n  this.ms = opts.min || 100;\n  this.max = opts.max || 10000;\n  this.factor = opts.factor || 2;\n  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n  this.attempts = 0;\n}\n\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\n\nBackoff.prototype.duration = function(){\n  var ms = this.ms * Math.pow(this.factor, this.attempts++);\n  if (this.jitter) {\n    var rand =  Math.random();\n    var deviation = Math.floor(rand * this.jitter * ms);\n    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;\n  }\n  return Math.min(ms, this.max) | 0;\n};\n\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\n\nBackoff.prototype.reset = function(){\n  this.attempts = 0;\n};\n\n/**\n * Set the minimum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMin = function(min){\n  this.ms = min;\n};\n\n/**\n * Set the maximum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMax = function(max){\n  this.max = max;\n};\n\n/**\n * Set the jitter\n *\n * @api public\n */\n\nBackoff.prototype.setJitter = function(jitter){\n  this.jitter = jitter;\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/backo2/index.js\n ** module id = 122\n ** module chunks = 0\n **/"],"sourceRoot":""}